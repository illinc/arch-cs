\chapter{Программирование сопроцессора}
\setlablabel{fpu}

\purpose{познакомиться с~работой сопроцессора и~его командами.}


\begin{tasks}

\item%
\footnote{Использованы материалы: П.\,Закляков. Представление чисел в~памяти ЭВМ. Ошибка «Циклическая дыра».
Системный Администратор, № 10 (119) 2012 г.;
В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
с~плавающей точкой
}%
Разработайте программу на языке C++, выполняющую вычисления  над вещественными числами одинарной точности (тип float).

Проверьте, что программа действительно работает с~операндами одинарной точности, а~не приводит к~типу float окончательный результат.

% Учтите, что числовой литерал 1 имеет тип int
\begin{variants}[varfloat]
Найти разность $a-b$ для различных значений  $a, b$:
$a=123456789; b=123456788$,

$a=123456788; b=123456787$
\next
Найти значение выражения
$\dfrac{(a+b)^2 - (a^2 + 2ab)}{b^2}$

для различных значений $a, b$ (пример Лавренова):

$a=95; b=1$, 

$a=95; b=0,1$
\next
Не используя умножение, найти суммы

$S_1 = \sum\limits_{i=0}^{N-1} \frac{1}{N}$
~~и~~%
$S_2 = \sum\limits_{i=0}^{2N-1} \frac{1}{N}$

для различных $N$: $10^2, 10^4, 10^6, 10^7, 10^8, 10^9$
\end{variants}

Сравните полученный результат с~теоретическим.
Объясните результат.

Измените тип операндов на double.
Объясните результат.

\item\labellocal{task:inline} 
Составьте программу calc для вычисления выражения с~использованием сопроцессора в~соответствии со своим
вариантом. 

% Вычисление оформите в~виде ассемблерной вставки в~консольном
% приложении на C++. %Основные команды сопроцессора приведены в~Приложении 1.



\item \bonus{+2 балла}
\labellocal{task:func} 
Оформите вычисления из задания~\reflocal{task:inline} как функцию на ассемблере (вещественную от вещественного аргумента~$x$).

\end{tasks}
\section{Дополнительные бонусные и~штрафные баллы}

$-2$ балла за \emph{каждое} использование команды \lstinline!finit!.

Инициализация процессора, в~том числе и~модуля FPU, выполняется операционной системой в~процессе загрузки.


$-2$ балла за потерю точности из-за округления промежуточных расчётов в~заданиях~\reflocal{task:inline} и~\reflocal{task:func}.

$-4$ балла за включение в~отчёт заведомо недостоверных цифр (более 2 недостоверных десятичных знаков в~округлённом результате).

$+1$ балл за поясняющие текущее содержимое стека FPU комментарии.


% \clearpage
\section{Варианты заданий для программы calc\footnote{Использованы: лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной
}  }
\begingroup

\renewcommand\varlocalcountername{\lablabel:var}
\newcounter{\varlocalcountername}
\setcounter{\varlocalcountername}{0}

% \small
\renewcommand\arraystretch{1.4}
% \setlength\extrarulesep{1ex}
% \extrarowheight=2em
\renewcommand{\tabularxcolumn}[1]{m{#1}} 

\noindent\begin{longtabu} to \textwidth {|l<{\refstepcounter{\varlocalcountername}\arabic{\varlocalcountername}}|L|L|L|}
\hline
\multicolumn{1}{|c|}{\thead{{ПК}}}&\thead{МП-30}&\thead{МП-34}&\thead{МП-35}\\\hline
&$\dfrac{1.2+x}{x^2}$ &                    $1.5x^2-3x-1$&                           $\dfrac{\sin(x-1)}{2x}$\\\hline
&$\dfrac{\cos(x)}{\sin(x)+2}$&               $\dfrac{\sin(1.9x)}{x-1.5}$&                    $\sin(x)\cdot\cos(0.9x)$\\\hline
&$\sin(2x)+\cos(3x)$&                 $\sqrt{0.99x} + x^2$&                          $\sin(0.27x)-\cos(x)$\\\hline
&$\ln2\cdot (\sin(1.2x))$&                $\sqrt{3.45x^2+0.1}$&                        $\dfrac{\cos(x)}{\sin(x)+2}$\\\hline
&$1.5+3.88(x^2 -1)$&                 $\cos^3(x)+\tg(x)$&                        $\sin(0.9x)+\cos(x)$\\\hline
&$\dfrac{\cos(x)}{\sin(2x)+1.5}$&            $\sin^2(\frac{x}{2} + 1)$&                        $x(x^2+3x-5)$\\\hline
&$\cos(x+0.9x^2)$&                    $3.4x^2 + 1.5$&                          $\sin(1.5x)+\frac{1}{x}$\\\hline
&$\cos(x-0.8)+ x$&                   $(\frac{x}{2} + 1.5)(x+1)$&                     $\sin((\cos(x)+1.3))$\\\hline
&$\sqrt{\sin(2x) + x}$&                    $\dfrac{x^2+4}{\sin(2x)}$&                       $\sqrt{\dfrac{x-1.2}{2x}}$\\\hline
&$2x^2 +x-5$&                        $\sqrt{|x-\ln2|}$&                             $\dfrac{x \tg(x)}{2}$\\\hline
&$(x+1)(2x-1)$&                     $3x^2+2x-1$&                             $|3x^3-2.5|$\\\hline
&$\sin(2x)\cdot\cos(x)$&                  $(2x+0.5)(3x-2)$&                       $\dfrac{7+x}{2x+1}$\\\hline
&$\sin(2.27x)-\cos(x)$&               $\sin(1.88x+1)\cdot\cos(x)$&                   $\cos(x+ \ln2 )$\\\hline
&$\dfrac{\cos(x)}{\sin(2x+1)}$&                $\sqrt{x^3-5} +x$&                          $\cos(x-0.8)+ x^2$\\\hline
&$\sin(0.99x)+\cos(x)$&               $\dfrac{\sin^2(x)}{1+\tg(x)}$&                    $1.1x+0.5x^2$\\\hline
&$\sin(2.5x)-\cos(x^2)$&               $\cos^2(x)+\tg(1.5x)$&                     $\cos(x)\cdot(1+3x^2 )$\\\hline
&$\sin(1.5x)+\cos(x)$&                $2\sqrt{x+1}$&                              $\dfrac{\sin(1.5x)}{\cos(1.5x)}$\\\hline
&$\sin((\cos(x)+1.3))$&               $\dfrac{\sin(x)+1}{2}$&                         $1+2x-3x^2$\\\hline
&$\sin(t+1), %\text{где}~ 
x=2.123t$&               $(x+3)^2 -\sin^2(x)$&                      $|\tg(\frac{x}{2})+1|$\\\hline
&$\cos(x)+\sin(2x)$&                  $\cos(2.1x)-\sin(x)$&                     $\dfrac{\sin(0.5x)}{x^2}$\\\hline
&$0.9x^2 +0.7$&                      $\dfrac{\sin^2(x)}{1+\tg^3(x)}$&                   $\cos^2(x) + \tg(2x)$\\\hline
&$0.5\sin(0.5x+2)$&                  $\dfrac{x}{3x^2-x+1}$&                          $x^2-x+8.7$\\\hline
&$\dfrac{\sin(x)}{\cos(x)+1.1}$&             $x^2(2-3x)$&                             $\dfrac{1}{2.5+x^2}$\\\hline
&$\cos((0.7+x)x)$&                   $|\cos(2x+0.9)|$&                        $\sin(x)\cdot(2.5x^2+3)$\\\hline
&$|\cos(2+x^2)|$&                     $\cos(x-0.8)+ x^2$&                       $\sin(x)+2\cos(x)$\\\hline
&$|1.5x| + x^2$&                     $1.1x+0.5x^2$&                           $\sin(\frac{x}{2.1})-\cos(2x)$\\\hline

\end{longtabu}
\endgroup

\section{Математический сопроцессор\footnote{Использованы: %http://devotes.narod.ru/Books/3/
Зубков С.\,В. Assembler для DOS, Windows и~UNIX
}  
}
Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой (начиная с~i486DX "--- интегрирован в~процессор).

FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.


% \section{Регистры сопроцессора}
% 
% Восемь 80-разрядных регистров, образующих стек (кольцевой буфер).

FPU предоставляет восемь регистров для хранения данных и~пять вспомогательных регистров.
При обращении к~ним в~GAS надо указывать тот же префикс, что и~для регистров основного процессора (CPU).

\begin{illustration}
\includegraphics[width=\approvedImageWidth]{fpu_reg}
\caption{Регистры FPU}
\labellocal{ris:fpu_reg}
\end{illustration}

Регистры данных (R0--R7) не адресуются по именам, как регистры основного процессора. Вместо этого эти восемь регистров рассматриваются как стек, вершина которого называется st(0), а~более глубокие элементы "--- st(1), st(2) и~так далее до st(7). Если, например, в~какой-то момент времени регистр R5 называется st(0), то после записи в~этот стек числа оно будет записано в~регистр R4, который станет называться st(0), R5 станет называться st(1) и~т.\,д.

Для вычислений хотя бы один операнд должен быть загружен в~стек сопроцессора.

% http://stackoverflow.com/questions/612507/what-are-the-applications-benefits-of-an-80-bit-extended-precision-data-type
Значения в~сопроцессоре представлены в 80-битном формате (с~двойной расширенной точностью соответственно IEEE 754-1985).
Старший бит "--- знак,
порядок занимает 15 бит, %(как для чисел четверной точности соответственно IEEE 754-2008 https://en.wikipedia.org/wiki/Extended_precision ??? не нашла в 2008)
мантисса "--- 64 бита, причём мантисса включает целую часть (рис.~\reflocal{ris:fpu_digits}).

\begin{illustration}
\includegraphics[width=\linewidth]{X86_Extended_Floating_Point_Format_ru}
\caption{Внутренний 80-битный формат сопроцессора}
\labellocal{ris:fpu_digits}
\end{illustration}

Регистры сопроцессора могут содержать следующие значения:
\begin{itemize}
\item  вещественные числа "--- порядок не равен 0 и~не состоит из всех единиц, %то есть не равен 0x7FFF
целая часть мантиссы равна 1; %, корректно представимые
\item денормализованные вещественные числа "--- порядок и~целая часть мантиссы равны 0, но мантисса не равна нулю;
\item нули ($+0.0$ и~$-0.0$, в~соответствии со знаковым битом) "--- порядок и~мантисса равны нулю;
\item бесконечности ($+\infty$ и~$-\infty$, в~соответствии со знаковым битом) "--- порядок состоит из всех единиц, целая часть мантиссы "--- единица, дробная часть равна нулю;
\item нечисла двух типов:
\begin{itemize}
\item сигнальные нечисла (при  появлении такого значения в~стеке генерируется исключение недействительной операции);
\item тихие нечисла (не генерируют исключения, но результат вычислений с~операндом-нечислом "--- тоже нечисло):
\begin{itemize}
\item вещественная неопределённость (знаковый бит не имеет значения) "--- порядок состоит из всех единиц, целая часть и~старший бит дробной части "--- единицы, остальные нули;
\item другие тихие нечисла "--- порядок состоит из всех единиц, целая часть и~старший бит дробной части "--- единицы, остальные "--- не все нули;
\end{itemize}
\end{itemize}
\item недопустимые значения.
\end{itemize}
Начиная с~80387 некоторые ранее недопустимые значения стали нечислами различного типа, и~наоборот "--- многие недопустимые для современных сопроцессоров значения были корректными нечислами в~ранних дискретных моделях.

Регистр состояний SW содержит слово состояния FPU.
Регистр управления CW содержит управляющие биты и~маски.

Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.

Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.

\subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
% 
Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти:
\begin{lstlisting}[style=lstsmall]
const double a = 12;
double x = 1, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "faddl %[A]\n"  // st(0) = %[SRC] + %[A]
    "fstpl %[DST]\n"// %[DST] = %[SRC] + %[A], стек пуст
    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = x + a
\end{lstlisting}

В~списке  перезаписываемых регистров GCC не позволяет описывать элементы стека сопроцессора.
Это, как правило, не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).


\section{Набор инструкций x87}
% http://www.studfiles.ru/preview/4034449/

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы:

Все мнемонические обозначения начинаются с~символа f (Float).

Вторая буква мнемонического обозначения определяет тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item i "--- целое двоичное число;

\item b "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы "--- вещественное число.
\end{itemize}

Последняя буква p в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная pp "---  из стека извлекаются оба операнда). 

\subsection{Сброс сопроцессора}

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Команда finit восстанавливает значения по умолчанию в~регистрах CW, SW, TW, а~начиная с~80387 "--- FIP и~FDP. Управляющий регистр инициализируется значением 037Fh (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на 0, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Регистр состояния обнуляется (ТОР = 0, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~регистре TW. Регистры FIP и~FDP обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.



\subsection{Загрузка данных в~стек сопроцессора}
\index{Команды!FPU!загрузки}

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций f*ld.
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение st(0).

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры

\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-fld-list.tex}

\endgroup

Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
double x = 5.7, y;
int i = 10;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fldz\n"        // st(0) = 0, st(1) = %[SRC]
    "fld1\n"        // st(0) = 1, st(1) = 0, st(2) = %[SRC]
    "fild %[I]\n"   // st(0) = %[I], st(1) = 1, st(2) = 0, st(3) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = %[I],   st(0) = 1, st(1) = 0, st(2) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = 1,      st(0) = 0, st(1) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = 0,      st(0) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = %[SRC], стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [I]"m"(i)
    :"cc"
);
\end{lstlisting}


\subsection{Выгрузка и~пересылка данных% из~стека сопроцессора
}
\index{Команды!FPU!выгрузки}
\index{Команды!FPU!пересылки}


\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-fst-list.tex}

\endgroup

\subsection{%Арифметические 
Основные арифметические команды\footnote{Использованы: Александр Фролов, Григорий Фролов Аппаратное обеспечение персонального компьютера}  
}
\index{Команды!FPU!арифметические}
Основные арифметические команды сопроцессора выполняют бинарные арифметические операции.
Хотя бы один операнд должен быть %в~стеке сопроцессора.
в~вершине стека сопроцессора~$st(0)$.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.
Приёмник должен быть в~стеке сопроцессора, но не обязательно на его вершине. %, таким образом, .

Сопроцессор использует шесть основных типов арифметических команд (XXX "--- операция): 
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-arcommon-list.tex}

\endgroup

Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
Так, для операции add это команды:
\begin{itemize}[wide=\parindent]
\item \lstinline!fadd!	(синоним \lstinline!faddp!,
эквивалент \lstinline!faddp %st(0), %st(1)!)

"--- st(1) := st(0) + st(1) и~выталкивание  st(0) из стека, так что после этой операции результат оказывается в~st(0);
\item \lstinline!fadd src!	"--- st(0) := st(0) + вещественное src;
\item \lstinline!fiadd src!	"--- st(0) := st(0) + целое src;
\item \lstinline!fadd %st(i), %st(0)!	"--- st(0) := st(0) + st(i);
\item \lstinline!fadd %st(0), %st(i)!	"--- st(i) := st(i) + st(0);
\item \lstinline!faddp %st(0), %st(i)!	"--- st(i) := st(i) + st(0) и~выталкивание  st(0) из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{itemize}

\warning{ 
Внимание!

Ассемблер Unix исторически использовал для некоторых команд FPU \emph{в~некоторых ситуациях} обратное расположение операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel и~большинстве учебников.
}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
всегда, в~том числе
в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
% в~таком случае 
для двух регистров
вычисляет $st(0) - st(i)$ независимо от того, какой из этих регистров является приёмником (в~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры). 
Обратное вычитание~\lstinline!fsubr! вычисляет $st(i) - st(0)$.


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub[p] %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.

Такое поведение в~случае сочетания синтаксиса AT\&T и~платформы x86 в~некоторых источниках описывается как баг GCC, но из соображений совместимости с~имеющимся кодом меняться не будет.
Из-за него, кроме всего прочего, в~GCC для всех основных арифметических команд доступна <<нелегальная>> седьмая форма записи, например, \lstinline!fsubp %st(i), %st(0)!.
Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)! (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
Подобную некорректную форму лучше не использовать.

Поведение Intel и~GAS совпадает в~тех случаях, когда приёмником является~$st(0)$, в~том числе в~ситуациях, когда источник находится в~памяти.

Также поведение Intel и~GAS полностью совпадает для симметричных операций "--- сложения и~умножения.

\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-ar-list.tex}

\endgroup


Пример использования (так как используется GAS, \lstinline!fdivr! рассчитывает %прямое деление 
$st(1)/st(0)$, после чего источник $st(0)$ выталкивается из стека):
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 0.01;
double x = 5, y;
int i = 10;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fldpi\n"       // st(0) = pi, st(1) = %[SRC]
    "fld1\n"        // st(0) = 1, st(1) = pi, st(2) = %[SRC]
    "fildl %[I]\n"  // st(0) = %[I], st(1) = 1, st(2) = pi, st(3) = %[SRC]
    "fdivr\n"       // st(0) = 1/%[I], st(1) = pi, st(2) = %[SRC]
    "fldl  %[A]\n"  // st(0) = %[A], st(1) = 1/%[I], st(2) = pi, st(3) = %[SRC]
    "fmulp %%st(0), %%st(2)\n"  // st(0) = 1/%[I], st(1) = pi*%[A], st(2) = %[SRC]
    "faddp\n"       // st(0) = 1/%[I] + pi*%[A], st(1) = %[SRC]
    "faddp\n"       // st(0) = 1/%[I] + pi*%[A] + %[SRC]
    "fstpl %[DST]\n"// %[DST] = 1/%[I] + pi*%[A] + %[SRC], стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a), [I]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}

\subsection{Дополнительные арифметические и~трансцендентные команды\footnote{Использованы: %http://devotes.narod.ru/Books/3/
Зубков С.\,В. Assembler для DOS, Windows и~UNIX
} }
Дополнительные арифметические и~трансцендентные команды работают с~вершиной стека st(0) и,~при необходимости, с~st(1). Они не имеют аргументов и~соответствующих пяти форм.

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
% Если операнд выходит за эти пределы, флаг С2 устанавливается в 1, значение st(0) и~стек не изменяются. 

Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице ниже.
\index{Команды!FPU!трансцендентные}
\index{Команды!FPU!дополнительные}
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-arex-list.tex}

\endgroup


Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fsincos\n"     // st(0) = cos(%[SRC]), st(1) = sin(%[SRC])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[SRC]), st(1) = sin(%[SRC])
    "fadd\n"        // st(0) = %[A]*cos(%[SRC]) + sin(%[SRC])
    "fstpl %[DST]\n"// %[DST] = %[A]*cos(%[SRC]) + sin(%[SRC]) стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}

\section{Сравнение вещественных чисел}


\begingroup

\subsection{Флаги сопроцессора}
\colorlet{csControl}{green!50}
\colorlet{csExceptionStatus}{green!7!yellow!7!white}
\colorlet{csSystem}{blue!20!red!10}
\index{Флаги!сопроцессора}

Математический сопроцессор имеет собственный регистр флагов "--- слово состояния \Reg{SW}.
Команды сравнения оригинального FPU 8087 (fcom, fcomp, fcompp, ftst) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (fucom, fucomp, fucompp), не генерирующее исключений при сравнении некоторых нечисел, сохраняют результат сравнения в~биты C3, C0 и,~в~случае несравнимости операндов, в~бит~C2 слова состояния.


\begin{table}[!ht]
\caption{Слово состояния FPU}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{\Reg{SW}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}2 	&ZE 	& Деление на нуль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}\Reg{eflags}, f(n)stsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{csMarker}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{csMarker}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{csMarker}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{csSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{csSystem}12 	& 	&&\cellcolor{csMarker}4 	&\cellcolor{csMarker}AF 	&\cellcolor{csMarker}Auxiliary Carry Flag\\
\rowcolor{csSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{csMarker}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{csExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\end{table}

% \pagebreak[3]
Для анализа результата сравнения вещественных чисел в~ранних (отдельных) моделях сопроцессора было необходимо вручную перенести его в~регистр флагов \Reg{eflags} основного процессора.  
\pagebreak[3]

Это выполнялось в~два этапа:
\begin{itemize}
\item слово состояния \Reg{SW} выгружалось в~регистр \Reg{AX} командами fstsw (проверяет на наличие отложенных необработанных исключений) или~fnstsw (также данные команды могут выгрузить \Reg{SW}  в~память);
\item старший байт \Reg{AX} загружался в~младший байт регистра флагов \Reg{flags} командой sahf.
\end{itemize}
\pagebreak[3]
%слово состояния \Reg{SW} могло быть выгружено в~память или регистр \Reg{AX} командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки \Reg{SW} в~регистр \Reg{AX} его старший байт загружал

После этого флаги C3 и~C0 помещались в~биты ZF и~CF, а~бит C2 "--- в~бит~PF. 
В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.

Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (fcomi, fcomip, fucomi, fucomip), которые напрямую устанавливают флаги ZF, CF, PF в~\Reg{eflags}.
Эти команды не изменяют биты C0,  C3 регистра \Reg{SW}.
% и~не дублируют туда результат сравнения.


Таким образом, после выполнения команды сравнения (%и~%пары команд 
% \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% или при использовании совместимых с~ними 
при использовании совместимых с~ранними моделями 
команд %f*com[p[p]]
без суффикса~\lstinline!i! 
необходимы также \lstinline!fstsw %ax! + \lstinline!sahf!)
результат  можно 
анализировать как результат сравнения беззнаковых целых чисел.
% 

\subsection{Команды сравнения\footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается
}
\index{Команды!сравнения!вещественных чисел}
\index{Команды!FPU!сравнения}

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

Все команды сравнения вещественных чисел сравнивают вершину стека $st(0)$ с~другим операндом (источником $src$).

\subsubsection{Команды, устанавливающие флаги сопроцессора}

Команды сравнения, унаследованные от ранних (дискретных) моделей сопроцессора, выставляют по результатам сравнения биты C0, C2, C3 слова состояния сопроцессора (рис.~\reflocal{fig:fcom}).
Бит~C3 взводится в~случае равенства операндов, бит~C0 "---  в~случае $st(0) < src$.
% ; бит C2 в~этих случаях равен $0$. 
Если операнды несравнимы, взводится бит~C2, а~также оба бита C0 и~C3.

К командам, помещающим результат в~слово состояния сопроцессора, относятся:
\begin{description}
\item[fcom] %Семейство команд сравнения.
Источник может быть указан явно (\lstinline!fcom %st(i)!, \lstinline!fcom mem!) или не указан (\lstinline!fcom!, находится в~$st(1)$). Источник в~памяти может иметь одинарную~или двойную точность.

Команда может иметь формы \lstinline!fcom [src]! (из стека ничего не выталкивается), \lstinline!fcomp [src]! (из стека выталкивается $st(0)$), \lstinline!fcompp! (из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$).

\item[fucom] Семейство команд, аналогичное \lstinline!fcom!. Отличается тем, что при сравнении тихих нечисел не генерируется исключений. 
% Сравнение чисел выполняется аналогично

\item[ficom] Источник "--- целое число (16 или 32 бита), находится в~памяти и~должен быть указан явно (\lstinline!ficom mem!).
Команда может иметь формы \lstinline!ficom src! (из стека ничего не выталкивается) и~\lstinline!ficomp src! (из стека выталкивается $st(0)$).
Если $st(0)$ "--- нечисло, генерируется исключение и~выставляются флаги, как для несравнимых значений.

\item[ftst] Источник равен нулю. Действие аналогично \lstinline!fcom!.

\end{description}

\begin{illustration}

$\left.
\begin{tabular}{l@{}l}
$src$ "--- st(i) или в~памяти & 
$\left\{\begin{tabular}{@{}r@{}}
\termin{fcom[p[p]]} \farg{[src]}\\
\termin{fucom[p[p]]} \farg{[src]}
\end{tabular}\right.$\\
$src$ "--- целое в~памяти & \termin{ficom[p]} \farg{src}\\
$src = 0$ & \termin{ftst}
\end{tabular}
\right\}$
% 
\begin{tabular}{c|@{~}c@{~}c@{~}c}
Условие & C3 & C0 &C2\\\hline
$st(0)>src$ & 0 & 0 & 0 \\
$st(0)<src$ & 0 & 1 & 0 \\
$st(0)=src$ & 1 & 0 & 0 \\
несравнимы& 1 & 1 & 1
\end{tabular}

{
\termin{f[n]stsw + sahf:} C3, C0, C2 $\to$ ZF, CF, PF.
\centering

}

\caption{Команды, выставляющие флаги сопроцессора (\Reg{SW})}
\labellocal{fig:fcom}
\end{illustration}

Так как условные команды, в~частности, команды условной пересылки регистров сопроцессора fcmovXXX, используют флаги \Reg{eflags}, а~не слово состояния сопроцессора,
% 
после выполнения команд сравнения этой группы необходимо перенести результат сравнения в~\Reg{eflags} парой команд \lstinline!fstsw %ax! + \lstinline!sahf!.

После этого значение C3 помещается в~аналогичный ему по смыслу флаг нуля ZF ($st(0) - src = 0$), C0 "--- в~флаг переноса~CF ($st(0) - src < 0$),
то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
Бит несравнимости C2 попадает на место флага чётности~PF. 


\subsubsection{Команды, устанавливающие флаги CPU}

Современные процессоры включают два семейства команд сравнения, напрямую выставляющие флаги ZF, CF, PF (рис.~\reflocal{fig:fcomi}):
\begin{description}
\item[fcomi] %Семейство команд сравнения.
Источник должен находиться в~стеке сопроцессора, при этом и~источник, и~приёмник $st(0)$ должны быть указаны явно (\lstinline!fcomi %st(i), %st(0)!).

Команда может иметь формы \lstinline!fcomi %st(i), %st(0)! (из стека ничего не выталкивается) и~\lstinline!fcomip %st(i), %st(0)! (из стека выталкивается $st(0)$).

\item[fucomi] Отличается от \lstinline!fcomi! тем, что при сравнении тихих нечисел не генерируется исключений. 
\end{description}


\begin{illustration}

\begin{tabular}{r}
\termin{fcomi[p]} \farg{src, \%st(0)}\\
\termin{fucomi[p]} \farg{src, \%st(0)}\\
% $src$ "--- st(i)\hfill \strut сравнивают вершину стека с операндом-источником, который может быть регистром или операндом в памяти (коротким или длинным вещественным).
\end{tabular}
% 
% 
\begin{tabular}{c|c@{~}c@{~}c|c@{~}c@{~}c}
Условие & ZF & CF &PF	&OF& SF & AF \\\hline
$st(0)>src$ & 0 & 0 & 0 &\multirow{4}{*}{0} &\multirow{4}{*}{0}  &\multirow{4}{*}{0} \\
$st(0)<src$ & 0 & 1 & 0 &&&\\
$st(0)=src$ & 1 & 0 & 0 &&&\\
несравнимы& 1 & 1 & 1&&&
\end{tabular}
\caption{Команды, выставляющие флаги основного процессора (\Reg{eflags})}
\labellocal{fig:fcomi}
\end{illustration}



Неиспользуемые три флага состояния \Reg{eflags} сбрасываются в~$0$; биты C0, C2,  C3 слова состояния сопроцессора не изменяются.

\endgroup


\section{Вопросы}


\begin{enumerate}

\item Какие регистры используются в~сопроцессоре для хранения операндов?

\item Какие команды используются для выполнения арифметических операций над вещественными числами?

\item Какие команды используются для выполнения тригонометрических операций?
\item Какие команды используются для сравнения вещественных чисел?
\item Какие флаги регистра \Reg{eflags} содержат результат сравнения вещественных чисел?

\end{enumerate}


\section{Справочные материалы}

% \subsection{Статьи}
\begingroup
\lstset{keywordstyle=}


\begin{enumerate}

\item Список основных команд архитектур x86 и x86-64 "---
\lstinline!Команды архитектур x86 и x86-64.htm!


\end{enumerate}
\endgroup
