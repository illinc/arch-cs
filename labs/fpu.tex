\chapter{Программирование сопроцессора}
\setlablabel{fpu}

\purpose{познакомиться с~работой сопроцессора и~его командами.}


\begin{tasks}

\item%
\footnote{Использованы материалы: П.\,Закляков. Представление чисел в~памяти ЭВМ. Ошибка «Циклическая дыра».
Системный Администратор, № 10 (119) 2012 г.;
В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
с~плавающей точкой
}%
Разработайте программу на языке C++, выполняющую вычисления  над вещественными числами одинарной точности (тип float).

Проверьте, что программа действительно работает с~операндами одинарной точности, а~не приводит к~типу float окончательный результат.

% Учтите, что числовой литерал 1 имеет тип int
\begin{variants}[varfloat]
Найти разность $a-b$ для различных значений  $a, b$:
$a=123456789; b=123456788$,

$a=123456788; b=123456787$
\next
Найти значение выражения
$\dfrac{(a+b)^2 - (a^2 + 2ab)}{b^2}$

для различных значений $a, b$ (пример Лавренова):

$a=95; b=1$, 

$a=95; b=0,1$
\next
Не используя умножение, найти суммы

$S_1 = \sum\limits_{i=0}^{N-1} \frac{1}{N}$
~~и~~%
$S_2 = \sum\limits_{i=0}^{2N-1} \frac{1}{N}$

для различных $N$: $10^2, 10^4, 10^6, 10^7, 10^8, 10^9$
\end{variants}

Сравните полученный результат с~теоретическим.
Объясните результат.

Измените тип операндов на double.
Объясните результат.

\item\labellocal{task:inline} 
Составьте программу calc для вычисления выражения с~использованием сопроцессора в~соответствии со своим
вариантом. 

% Вычисление оформите в~виде ассемблерной вставки в~консольном
% приложении на C++. %Основные команды сопроцессора приведены в~Приложении 1.



\item \bonus{+2 балла}
\labellocal{task:func} 
Оформите вычисления из задания~\reflocal{task:inline} как функцию на ассемблере (вещественную от вещественного аргумента~$x$).

\end{tasks}
\section{Дополнительные бонусные и~штрафные баллы}

$-2$ балла за \emph{каждое} использование команды \lstinline!finit!.

Инициализация процессора, в~том числе и~модуля FPU, выполняется операционной системой в~процессе загрузки.


$-2$ балла за потерю точности из-за округления промежуточных расчётов в~заданиях~\reflocal{task:inline} и~\reflocal{task:func}.

$-4$ балла за включение в~отчёт заведомо недостоверных цифр (более 2 недостоверных десятичных знаков в~округлённом результате).

$+1$ балл за поясняющие текущее содержимое стека FPU комментарии.


% \clearpage
\section{Варианты заданий для программы calc\footnote{Использованы: лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной
}  }
\begingroup

\renewcommand\varlocalcountername{\lablabel:var}
\newcounter{\varlocalcountername}
\setcounter{\varlocalcountername}{0}

% \small
\renewcommand\arraystretch{1.4}
% \setlength\extrarulesep{1ex}
% \extrarowheight=2em
\renewcommand{\tabularxcolumn}[1]{m{#1}} 

\noindent\begin{longtabu} to \textwidth {|l<{\refstepcounter{\varlocalcountername}\arabic{\varlocalcountername}}|L|L|L|}
\hline
\multicolumn{1}{|c|}{\thead{{ПК}}}&\thead{МП-30}&\thead{МП-34}&\thead{МП-35}\\\hline
&$\dfrac{1.2+x}{x^2}$ &                    $1.5x^2-3x-1$&                           $\dfrac{\sin(x-1)}{2x}$\\\hline
&$\dfrac{\cos(x)}{\sin(x)+2}$&               $\dfrac{\sin(1.9x)}{x-1.5}$&                    $\sin(x)\cdot\cos(0.9x)$\\\hline
&$\sin(2x)+\cos(3x)$&                 $\sqrt{0.99x} + x^2$&                          $\sin(0.27x)-\cos(x)$\\\hline
&$\ln2\cdot (\sin(1.2x))$&                $\sqrt{3.45x^2+0.1}$&                        $\dfrac{\cos(x)}{\sin(x)+2}$\\\hline
&$1.5+3.88(x^2 -1)$&                 $\cos^3(x)+\tg(x)$&                        $\sin(0.9x)+\cos(x)$\\\hline
&$\dfrac{\cos(x)}{\sin(2x)+1.5}$&            $\sin^2(\frac{x}{2} + 1)$&                        $x(x^2+3x-5)$\\\hline
&$\cos(x+0.9x^2)$&                    $3.4x^2 + 1.5$&                          $\sin(1.5x)+\frac{1}{x}$\\\hline
&$\cos(x-0.8)+ x$&                   $(\frac{x}{2} + 1.5)(x+1)$&                     $\sin((\cos(x)+1.3))$\\\hline
&$\sqrt{\sin(2x) + x}$&                    $\dfrac{x^2+4}{\sin(2x)}$&                       $\sqrt{\dfrac{x-1.2}{2x}}$\\\hline
&$2x^2 +x-5$&                        $\sqrt{|x-\ln2|}$&                             $\dfrac{x \tg(x)}{2}$\\\hline
&$(x+1)(2x-1)$&                     $3x^2+2x-1$&                             $|3x^3-2.5|$\\\hline
&$\sin(2x)\cdot\cos(x)$&                  $(2x+0.5)(3x-2)$&                       $\dfrac{7+x}{2x+1}$\\\hline
&$\sin(2.27x)-\cos(x)$&               $\sin(1.88x+1)\cdot\cos(x)$&                   $\cos(x+ \ln2 )$\\\hline
&$\dfrac{\cos(x)}{\sin(2x+1)}$&                $\sqrt{x^3-5} +x$&                          $\cos(x-0.8)+ x^2$\\\hline
&$\sin(0.99x)+\cos(x)$&               $\dfrac{\sin^2(x)}{1+\tg(x)}$&                    $1.1x+0.5x^2$\\\hline
&$\sin(2.5x)-\cos(x^2)$&               $\cos^2(x)+\tg(1.5x)$&                     $\cos(x)\cdot(1+3x^2 )$\\\hline
&$\sin(1.5x)+\cos(x)$&                $2\sqrt{x+1}$&                              $\dfrac{\sin(1.5x)}{\cos(1.5x)}$\\\hline
&$\sin((\cos(x)+1.3))$&               $\dfrac{\sin(x)+1}{2}$&                         $1+2x-3x^2$\\\hline
&$\sin(t+1), %\text{где}~ 
x=2.123t$&               $(x+3)^2 -\sin^2(x)$&                      $|\tg(\frac{x}{2})+1|$\\\hline
&$\cos(x)+\sin(2x)$&                  $\cos(2.1x)-\sin(x)$&                     $\dfrac{\sin(0.5x)}{x^2}$\\\hline
&$0.9x^2 +0.7$&                      $\dfrac{\sin^2(x)}{1+\tg^3(x)}$&                   $\cos^2(x) + \tg(2x)$\\\hline
&$0.5\sin(0.5x+2)$&                  $\dfrac{x}{3x^2-x+1}$&                          $x^2-x+8.7$\\\hline
&$\dfrac{\sin(x)}{\cos(x)+1.1}$&             $x^2(2-3x)$&                             $\dfrac{1}{2.5+x^2}$\\\hline
&$\cos((0.7+x)x)$&                   $|\cos(2x+0.9)|$&                        $\sin(x)\cdot(2.5x^2+3)$\\\hline
&$|\cos(2+x^2)|$&                     $\cos(x-0.8)+ x^2$&                       $\sin(x)+2\cos(x)$\\\hline
&$|1.5x| + x^2$&                     $1.1x+0.5x^2$&                           $\sin(\frac{x}{2.1})-\cos(2x)$\\\hline

\end{longtabu}
\endgroup

\section{Математический сопроцессор\footnote{Использованы: %http://devotes.narod.ru/Books/3/
Зубков С.\,В. Assembler для DOS, Windows и~UNIX
}  
}
Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой (начиная с~i486DX "--- интегрирован в~процессор).

FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.


% \section{Регистры сопроцессора}
% 
% Восемь 80-разрядных регистров, образующих стек (кольцевой буфер).

FPU предоставляет восемь регистров для хранения данных и~пять вспомогательных регистров.
При обращении к~ним в~GAS надо указывать тот же префикс, что и~для регистров основного процессора (CPU).

\begin{illustration}
\includegraphics[width=\approvedImageWidth]{fpu_reg}
\caption{Регистры FPU}
\labellocal{ris:fpu_reg}
\end{illustration}

Регистры данных (R0--R7) не адресуются по именам, как регистры основного процессора. Вместо этого эти восемь регистров рассматриваются как стек, вершина которого называется st(0), а~более глубокие элементы "--- st(1), st(2) и~так далее до st(7). если, например, в~какой-то момент времени регистр R5 называется st(0), то после записи в~этот стек числа оно будет записано в~регистр R4, который станет называться st(0), R5 станет называться st(1) и~т.\,д.

Для вычислений хотя бы один операнд должен быть загружен в~стек сопроцессора.


Регистр состояний SR содержит слово состояния FPU.
Регистр управления CR содержит управляющие биты и~маски.

Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.

Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.

\subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
% 
Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти:
\begin{lstlisting}[style=lstsmall]
const double a = 12;
double x = 1, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "faddl %[A]\n"  // st(0) = %[SRC] + %[A]
    "fstpl %[DST]\n"// %[DST] = %[SRC] + %[A], стек пуст
    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = x + a
\end{lstlisting}

В~списке  перезаписываемых регистров GCC не позволяет описывать элементы стека сопроцессора.
Это, как правило, не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).


\section{Набор инструкций x87}
% http://www.studfiles.ru/preview/4034449/

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы:

Все мнемонические обозначения начинаются с~символа F (Float).

Вторая буква мнемонического обозначения определяет тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item i "--- целое двоичное число;

\item b "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы "--- вещественное число.
\end{itemize}

Последняя буква p в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная pp "---  из стека извлекаются оба операнда). 

\subsection{Сброс сопроцессора}

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Команда finit восстанавливает значения по умолчанию в~регистрах CR, SR, TW, а~начиная с~80387 "--- FIP и~FDP. Управляющий регистр инициализируется значением 037Fh (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на 0, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Регистр состояния обнуляется (ТОР = 0, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~регистре TW. Регистры FIP и~FDP обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.



\subsection{Загрузка данных в~стек сопроцессора}

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций f*ld.
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение st(0).

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры

\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-fld-list.tex}

\endgroup

Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
double x = 5.7, y;
int i = 10;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fldz\n"        // st(0) = 0, st(1) = %[SRC]
    "fld1\n"        // st(0) = 1, st(1) = 0, st(2) = %[SRC]
    "fild %[I]\n"   // st(0) = %[I], st(1) = 1, st(2) = 0, st(3) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = %[I],   st(0) = 1, st(1) = 0, st(2) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = 1,      st(0) = 0, st(1) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = 0,      st(0) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = %[SRC], стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [I]"m"(i)
    :"cc"
);
\end{lstlisting}


\subsection{Выгрузка и~пересылка данных% из~стека сопроцессора
}


\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-fst-list.tex}

\endgroup

\subsection{%Арифметические 
Основные арифметические команды\footnote{Использованы: Александр Фролов, Григорий Фролов Аппаратное обеспечение персонального компьютера}  
}
Основные арифметические команды сопроцессора выполняют бинарные арифметические операции.
Хотя бы один операнд должен быть в~стеке сопроцессора.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.

Сопроцессор использует шесть основных типов арифметических команд (XXX "--- операция): 
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-arcommon-list.tex}

\endgroup

Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
Так, для операции add это команды:
\begin{itemize}[wide=\parindent]
\item \lstinline!fadd!	(синоним \lstinline!faddp!)"--- st(1) := st(0) + st(1) и~выталкивание  st(0) из стека, так что после этой операции результат оказывается в~st(0);
\item \lstinline!fadd src!	"--- st(0) := st(0) + вещественное src;
\item \lstinline!fiadd src!	"--- st(0) := st(0) + целое src;
\item \lstinline!fadd %st(i), %st(0)!	"--- st(0) := st(0) + st(i);
\item \lstinline!fadd %st(0), %st(i)!	"--- st(i) := st(i) + st(0);
\item \lstinline!faddp %st(0), %st(i)!	"--- st(i) := st(i) + st(0) и~выталкивание  st(0) из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{itemize}

\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-ar-list.tex}

\endgroup


Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 0.01;
double x = 5, y;
int i = 10;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fldpi\n"       // st(0) = pi, st(1) = %[SRC]
    "fld1\n"        // st(0) = 1, st(1) = pi, st(2) = %[SRC]
    "fildl %[I]\n"  // st(0) = %[I], st(1) = 1, st(2) = pi, st(3) = %[SRC]
    "fdivr\n"       // st(0) = 1/%[I], st(1) = pi, st(2) = %[SRC]
    "fldl  %[A]\n"  // st(0) = %[A], st(1) = 1/%[I], st(2) = pi, st(3) = %[SRC]
    "fmulp %%st(0), %%st(2)\n"  // st(0) = 1/%[I], st(1) = pi*%[A], st(2) = %[SRC]
    "faddp\n"       // st(0) = 1/%[I] + pi*%[A], st(1) = %[SRC]
    "faddp\n"       // st(0) = 1/%[I] + pi*%[A] + %[SRC]
    "fstpl %[DST]\n"// %[DST] = 1/%[I] + pi*%[A] + %[SRC], стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a), [I]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}

\subsection{Дополнительные арифметические и~трансцендентные команды\footnote{Использованы: %http://devotes.narod.ru/Books/3/
Зубков С.\,В. Assembler для DOS, Windows и~UNIX
} }
Дополнительные арифметические и~трансцендентные команды работают с~вершиной стека st(0) и,~при необходимости, с~st(1). Они не имеют аргументов и~соответствующих пяти форм.

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
% Если операнд выходит за эти пределы, флаг С2 устанавливается в 1, значение st(0) и~стек не изменяются. 

Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице ниже.
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-arex-list.tex}

\endgroup


Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fsincos\n"     // st(0) = cos(%[SRC]), st(1) = sin(%[SRC])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[SRC]), st(1) = sin(%[SRC])
    "fadd\n"        // st(0) = %[A]*cos(%[SRC]) + sin(%[SRC])
    "fstpl %[DST]\n"// %[DST] = %[A]*cos(%[SRC]) + sin(%[SRC]) стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}







