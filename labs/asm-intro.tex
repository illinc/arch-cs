
\section{Особенности GNU Assembler%
\footnote{Использованы материалы:
GCC-Inline-Assembly-HOWTO,
Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А.
Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
X86 Assembly/GAS Syntax
}
}

Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% 
% Синтаксис AT&T немного 
отличается от синтаксиса Intel, который используется, например, MASM. 
%
Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.

\paragraph{Порядок операндов}
% В~отличие от синтаксиса Intel, 
Инструкция GAS обычно имеет вид  
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.
Например, команда \lstinline!movb $0x05, %al! помещает значение 5 в~регистр \lstinline!AL!.

\paragraph{Суффикс мнемоники}

Размер операндов маркируется суффиксом, например, \lstinline!movl %edx, %eax!.

\noindent\begin{tabularx}{\linewidth}{|l|L|L|}
\hline
\thead{Суффикс} & \thead{Целые} & \thead{Вещественные} \\\hline
    b & byte (8 bit) &\\\hline
    s & short (16 bit integer) & single (32-bit floating point) \\\hline
    w & word (16 bit) &\\\hline
    l & long (32 bit integer) & double (64-bit floating point) \\\hline
    q & quad (64 bit) &\\\hline
    t & & ten bytes (80-bit floating point) \\\hline
\end{tabularx}
% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  размер может быть определён по регистровому операнду.
Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
% По умолчанию принимается 32-bit.

\paragraph{Префиксы}
Имена \emph{регистров} начинаются с~префикса \lstinline!%! (\lstinline!%eax!, \lstinline!%dl!).

\emph{Константы} отмечаются префиксом \lstinline!$!, например,
\lstinline!addl $5, %eax!
(добавить константу 5 к регистру \EAX).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!). Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
\lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

\paragraph{Вычисление адреса}

Вычисление адреса с~одновременным разыменованием
$$
*\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
$$
в~соответствии с~синтаксисом~AT\&T имеет вид
{
\lstset{language=}
% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
\begin{lstlisting}
displacement(base, offset, scalar multiplier)
\end{lstlisting} 
где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).

В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
\begin{lstlisting}
[base + displacement + offset * scalar multiplier]
\end{lstlisting} 


\section{Адресация операндов}

Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
% Данные могут адресоваться различными способами.
Для них доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).

Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды;

Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n! (значение глобальной переменной $n$).

\item \termin{Регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;

Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!.

\item \termin{Косвенно-регистровая (косвенная)} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).

%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров.

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}


В~языке ассемблера конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
$$
*\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
$$
где $base$ и~$\mathit{offset}$ "--- регистры (32-разрядные для соответствующей платформы), $displacement$ "--- целое число (смещение), $scalar\,multiplier$ "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется $scalar\,multiplier = 1$, вместо остальных пропущенных параметров  используется~$0$).

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS имеет вид
\begin{lstlisting}
displacement(base, offset, scalar multiplier)
\end{lstlisting} 
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.

}

Например, следующая команда использует все четыре параметра и~загружает в~\EAX{} значение  
$*\big(\mathReg{EBP} - 4 + (\mathReg{EDX} \cdot 4)\big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dst! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда \lstinline!lea src, dst! загружает в~приёмник адрес источника, что компенсирует разыменование, то есть
\begin{lstlisting}
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~\EAX{} значение  
$\mathReg{EBP} - 4 + (\mathReg{EDX} \cdot 4)$.
Команда вычисления адреса~\lstinline!lea! часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем команда беззнакового умножения~\lstinline!mul!:
\begin{lstlisting}
leal    8(,%eax,4), %eax    // EAX := EAX*4 + 8   
leal    (%eax,%eax,2), %eax // EAX := EAX*2 + EAX = EAX*3
\end{lstlisting} 


Чаще используются сокращённые варианты адресации, когда указывается только часть параметров.

Если используется только параметр~$base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает значение \lstinline!*ECX! в~регистр \EDX.
\begin{lstlisting}
movl    (%ecx), %edx
\end{lstlisting} 

С~параметрами~$base$ и~$displacement$ получим $*\big(base + displacement\big)$, что соответствует обращению к~полю структуры ($base$ "--- адрес структуры, константа~$displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса \lstinline!EBP - 4!)
в~регистр \EAX.
\begin{lstlisting}
movl    -4(%ebp), %eax
\end{lstlisting} 

Адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
% он может быть масштабным коэффициентом ($scalar\,multiplier$)
к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(base + \mathit{offset} \cdot scalar\,multiplier\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! обычно равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~\ECX, а~индекс "--- в~\ESI, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Запись~$M[i]$ в~\EAX:
\begin{lstlisting}
movl    (%ecx, %esi, 4), %eax
\end{lstlisting} 


При передаче параметров функции через стек обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека \lstinline!%esp!.

На вершине стека, то есть по адресу \lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше \lstinline!%esp!, то есть первый параметр равен \lstinline!4(%esp)!.
% \begin{lstlisting}[numbers=none]
% 4(%esp)   // *(ESP+4)
% \end{lstlisting} 

Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее. 

% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 
\section{Основные команды}
В~таблице приведены некоторые команды x86-совместимых процессоров.

Если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что src и~dest могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.

\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/instr-list.tex}

\endgroup

