\chapter{Программирование ветвящихся и~циклических алгоритмов}
\setlablabel{jmp}
\purpose{
ознакомиться с~командами условного и~безусловного перехода; 
научиться использовать их~для реализации  ветвящихся и~циклических алгоритмов.
}


\begin{tasks}

\item Вычислите для заданных целых $x, y$
\begin{variants}[if-else-int]
$f(x) = \left\{\begin{array}{ll}
 x/2, & x\%2 = 0 \\
3x+1, & x\%2 \neq 0 \\
\end{array}\right.$
\next
$f(x,y) = \left\{\begin{array}{ll}
x & x + y < 4 \\
y+2, & x+y \geqslant 4 \\
\end{array}\right.$
\next
$f(x,y) = \left\{\begin{array}{ll}
y/x &  y\%x = 0 \\
y\cdot x, & y\%x \neq 0 \\
\end{array}\right.$
\end{variants}

\item
Вычислите для заданного вещественного $x$
\input{labs/if-else-variants.tex}

\item 
\labellocal{progression}
Задайте с~клавиатуры~$N$ и~напечатайте первые $N$ членов последовательности (целой).

% Последовательности:
\begin{variants}[varint]
Числа Фибоначчи:
$\varphi_0 = \varphi_1 = 1, \varphi_{i+1} = \varphi_{i} + \varphi_{i-1}$
\next
Арифметическая прогрессия
$a_0 = 0, a_{i+1} = a_i + x$, ~~$x$ ввести с~клавиатуры
\end{variants}

\item \bonus{+2 балла)} 
Найдите с~заданной точностью~$\varepsilon$ сумму ряда (если это возможно).
Если ряд расходится, выведите сообщение об этом.

\begin{variantsThree}[varfloat]{МП-30}{МП-34}{МП-35}
$$S = \sum\limits_{i=1}^\infty (-1)^i \frac{1}{i}$$ 
&	$$S = \sum\limits_{i=2}^\infty (-1)^i \frac{i+1}{i^3 - 1}$$ 
&	$$S = \sum\limits_{i=1}^\infty e^{-i}$$
\next
	$$S = \sum\limits_{i=0}^\infty (-1)^i \frac{1}{2^i}$$
&	$$S = \sum\limits_{i=1}^\infty (-1)^i \frac{1}{i^2}$$
&	$$S = \sum\limits_{i=1}^\infty (-1)^i \frac{1}{\sqrt{i}}$$ 
\next
$$S = \sum\limits_{i=1}^\infty  \frac{1}{i}$$ 
&	$$S = \sum\limits_{i=2}^\infty  \frac{i-1}{i^3 + 1}$$ 
&	$$S = \sum\limits_{i=1}^\infty (-1)^i e^{-i}$$
\next
	$$S = \sum\limits_{i=0}^\infty  \frac{1}{2^i}$$
&	$$S = \sum\limits_{i=1}^\infty \frac{1}{i^2}$$
&	$$S = \sum\limits_{i=1}^\infty \frac{1}{\sqrt{i}}$$
\next
	$$S = \sum\limits_{i=0}^\infty (-1)^{2i} \frac{1}{2^i}$$
&	$$S = \sum\limits_{i=1}^\infty \frac{\sin(i)}{i}$$
&	$$S = \sum\limits_{i=1}^\infty \frac{\sin(i)}{i^2}$$ 
\end{variantsThree}

\item \termin{Бонус (+2 балла):} Реализуйте умножение двух целых чисел без знака ($x\cdot y$) «в~столбик» (то есть не как сумму $\underbrace{x+\ldots+x}_{\text{$y$ раз}}$), не используя mul/imul и~команды сопроцессора.

\end{tasks}
\section{Дополнительные бонусные и~штрафные баллы}

$-2$ балла за \emph{каждое} использование команд \lstinline!loop*!, \lstinline!jcx*! или  \lstinline!jecx*!.
% http://mar.ugatu.su/assets/files/Arc/lab/asm.pdf
% На  современных  процессорах  организация  цикла  с  помощью  команд  DEC/ JNZ/JZ предпочтительна с 
% точки  зрения  производительности;  в  сумме  они  будут  работать  в  два  раза  быстрее,  нежели  одна 
% инструкция  LOOP.

Хотя команды  \lstinline!loop*! занимают меньше места, чем комбинация команды \lstinline!dec! с~условным переходом \lstinline!jz/jnz!, но последняя выполняется вдвое быстрее, чем \lstinline!loop*!.
% 
Кроме того, организация цикла при помощи явной модификации счётчика и~условных переходов более гибка и,~в~частности, позволяет организовать вложенный цикл.


% \input{flags}


\section{Условные и~безусловные переходы\footnote{Использованы: 
http://asmworld.ru/spravochnik-komand/jcond/,
http://unixwiz.net/techtips/x86-jumps.html
}}
\index{Флаги!проверка}

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода.

Безусловный переход 
\begin{lstlisting}
  jmp label
\end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу label.

Команды условного перехода
\begin{lstlisting}
  jXXX label
\end{lstlisting}
передают адресу label при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).
Если условие не выполнено,  \lstinline!jXXX! не делает ничего,  и~выполняется команда, следующая за \lstinline!jXXX! по тексту программы.

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

В~следующей таблице приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.
\index{Команды!передачи управления}

\begingroup
\small
\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
\providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}


% \singlespacing

\LTXtable{\textwidth}{labs/jmp-list.tex}

\endgroup

Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop, loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если \lstinline!%cx/%ecx! равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop метка! эквивалентна  командам \lstinline!dec %ecx; jz метка!, при этом loop не меняет флаги eflags. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только \lstinline!%cx/%ecx!, но и~флаг нуля ZF (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).
 
Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода\footnote{Optimizing subroutines in assembly 
language.
An optimization guide for x86 platforms. 
By Agner Fog. Technical University of Denmark. }.

\subsection{Условная пересылка}
\index{Флаги!проверка}
\index{Команды!условной пересылки}

Для каждой команды условного перехода jXXX существует команда условной пересылки cmovXXX src, dst, выполняющая присваивание $dst = src$, если соответствующее условие верно.

Команды условной пересылки не полностью аналогичны mov: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

\subsection{Установка байта по условию}
\index{Флаги!проверка}
\index{Команды!установки байта}

Для каждой команды условного перехода jXXX существует команда установки байта по условию setXXX dst, выполняющая присваивание $dst = 1$, если соответствующее условие верно, и~$dst = 0$ иначе.

% \section{Установка флагов}












\section{Программирование нелинейных алгоритмов}

\subsection{Условие с~операторами в~одной ветви}

Пусть необходимо заменить значение целой знаковой переменной $x$ нулём, если   оно отрицательно.
$$x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$$

Построим схему алгоритма (рис.~\reflocal{ris:if}, а) для решения этой задачи.

В~отличие от операторов  \lstinline!if! большинства языков высокого уровня,
ветвь, где должны выполняться операторы, лучше сделать ветвью «нет» (обход части программы).

Построим по данной схеме программу. Каждому  блоку процесса здесь будет соответствовать линейный фрагмент кода; блок решения завершится условным переходом по метке; точка соединения двух потоков соответствует метке  (рис.~\reflocal{ris:if}, б).


\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\coordinate[right=  of is_positive] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);

\node[block,on chain=alg_start, join={node[right]{нет}}] (is_positive_no_op) {$x = 0$};
\coordinate[below = of is_positive_no_op] (to_end);

\path[blockarrow] (is_positive_yes) |- (to_end);
\node[terminator, on chain=alg_start, below = of to_end, join/.style=blockarrow] (end) {Конец}; % Удаляет линию вообще
\path[blockarrow] (is_positive_no_op) -- (end);


\coordinate[right=  of is_positive_yes] (asm_coord);

% \node[asm] at (start-|asm_coord) {
%   \begin{lstlisting}
%   int x;
%   asm
%   (
%       "movl $12, %[X]\n"
%       :[X]"=rm"(x)
%   );
%   \end{lstlisting}
%   };

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = -6;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge end_check\n"
\end{lstlisting}
};
\node[asm] at (is_positive_no_op-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[X]\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  : [X]"+rm"(x)
  : : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};

\end{tikzpicture}
}

\caption{Алгоритм и~реализация ветвления}
\labellocal{ris:if}
\end{illustration}

% Данную задачу можно также решить с~помощью команд условной пересылки:
Для более быстрой реализации подобных ветвлений (присваивания по условию) начиная с~Pentium Pro добавлены команды  условной пересылки:
\begin{lstlisting}[style=lstsmall]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "cmovngel %[Zero], %[X]\n"
  : [X]"+r"(x)
  : [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Так как источником для команды cmovXXX не может быть константа, вводится входной параметр \lstinline![Zero]!, расположенный в~памяти или регистре и~равный нулю.

\subsection{Условие с~операторами в~двух ветвях}

Пусть в~зависимости от условия необходимо выполнить один из двух операторов:
$$y(x) = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$$

% Построим схему алгоритма (рис.~\reflocal{ris:if-else}, а) для решения этой задачи, выстроим блоки линейно вдоль одной вертикали (рис.~\reflocal{ris:if-else}, б) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\reflocal{ris:if-else}, в).
% 
% Потоки, выходящие за пределы основной линии "--- условные и~безусловные  переходы, точки входа таких потоков-переходов в~основной вертикальный поток "--- метки.


Построим схему алгоритма (рис.~\reflocal{ris:if-else}, а) для решения этой задачи и~затем выстроим блоки линейно вдоль одной вертикали (рис.~\reflocal{ris:if-else}, б).


\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\tikzset{every join/.style=blockarrow}

\coordinate[right= of is_positive, on chain=if_yes] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);
\node[block,on chain=if_yes] (yes_op) {$y = 1$};

\coordinate[left=  of is_positive, on chain=if_no] (is_positive_no);
\path[blockline] (is_positive) -- node[auto] {нет} (is_positive_no);
\node[block,on chain=if_no] (no_op) {$y = 0$};

\coordinate[below = of yes_op] (to_end_y);

\coordinate[on chain=alg_end, join/.style={}] (to_end) at (to_end_y-|start);
\path[blockline] (yes_op) |- (to_end);
\path[blockline] (no_op) |- (to_end);

\node[terminator, on chain=alg_end, below = of to_end] (end) {Конец};
% \path[blockarrow] (to_end) -- (end);



\tikzset{every join/.style=blockline}


\coordinate[right= 6em of yes_op] (squeeze_coord);

\node[terminator,on chain=squeeze_start] (start2) at (start-|squeeze_coord) {Начало};

\node[decision,on chain=squeeze_start] (is_positive2) {$x\geqslant0$};

\node[block,   on chain=squeeze_start, join={node[right]{нет}}] (no_op2) {$y = 0$};
\coordinate[on chain=squeeze_start] (to_end_no2);


\coordinate[right= of is_positive2] (is_positive_yes2);
\path[blockline] (is_positive2) -- node[auto] {да} (is_positive_yes2);
\tikzset{every join/.style=nodraw}
\coordinate[on chain=squeeze_start] (non-used);

\coordinate[on chain=squeeze_start, join/.style={}] (to_yes2);
\node[block,   on chain=squeeze_start, join/.style={}] (yes_op2) {$y = 1$};
\tikzset{every join/.style=blockline}

\coordinate[on chain=squeeze_start] (to_end_yes2);
% \coordinate[on chain=squeeze_start] (non-used2);

\node[terminator, on chain=squeeze_start, join/.style={}] (end2) {Конец};

\path[blockarrow] (is_positive_yes2) |- (to_yes2) -- (yes_op2);

\coordinate[left=of yes_op2] (from_no_to_end2);
\path[blockline] (to_end_no2) -| (from_no_to_end2);
\path[blockarrow] (from_no_to_end2) |- (to_end_yes2);
\path[blockarrow] (to_end_yes2) -- (end2);



\coordinate[right=  of is_positive_yes2] (asm_coord);

\node[asm] at (start2-|asm_coord) {
\begin{lstlisting}
int x = -6, y;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive2-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge setting_1\n"
\end{lstlisting}
};

\node[asm] at (to_yes2-|asm_coord) {
\begin{lstlisting}
"setting_1:\n"
\end{lstlisting}
};

\node[asm] at (yes_op2-|asm_coord) {
\begin{lstlisting}
  "movl $1, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (no_op2-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (to_end_no2-|asm_coord) {
\begin{lstlisting}
  "jmp end_check\n"
\end{lstlisting}
};

\node[asm] at (to_end_yes2-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end2.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  :[Y]"=rm"(y)
  :[X]"rm" (x)  
  : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (end2|-lettersline) {б)};
\node at (asm-end|-lettersline) {в)};


\end{tikzpicture}
}

\caption{Алгоритм и~реализация ветвления}
\labellocal{ris:if-else}
\end{illustration}

Сопоставим каждому блоку одну или несколько команд ассемблера.
В~этом случае излом потока (отход от базовой вертикали без ветвления) будет соответствовать безусловному переходу, блок решения включает условный переход, а~точки входа боковых потоков-переходов в~основной вертикальный поток соответствуют меткам (рис.~\reflocal{ris:if-else}, в).
\pagebreak[3]


Данную задачу также можно  решить с~помощью команд условной пересылки.
Для подобного задания такая реализация будет компактнее и~быстрее. 

\begin{lstlisting}
int x = 10, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $1, %[Y]\n"
  "cmovll %[Zero], %[Y]\n"
  : [Y]"+r"(y)
  : [X]"rm"(x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Здесь параметр \lstinline![Y]! объявлен как выходной с~начальным значением, хотя, казалось бы, его исходное значение нам не требуется.
Это сделано, чтобы компилятор не совместил его с~входным параметром  \lstinline![Zero]! (совмещение с~входным параметром \lstinline![X]! не повредит выполнению, так как значение \lstinline![X]! используется только для сравнения с~литералом \lstinline!$0!, до первого присваивания \lstinline![Y]!).
Если %не указать \lstinline![Y]! в~списке входных и~он 
\lstinline![Y]! будет совмещён с~\lstinline![Zero]!, мы всегда получим на выходе $y=1$.

\pagebreak[3]

Для данных значений ($y$ равен либо нулю, либо единице) задачу можно  решить и~с~помощью команды условной установки байта.
\begin{lstlisting}
int x = -7, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $0, %[Y]\n"
  "setgeb %[Y]\n"
  :[Y]"=m"(y)
  :[X]"rm"(x)
  : "cc"
);
\end{lstlisting}
Здесь мы записываем ноль в~четырёхбайтовую переменную  \lstinline![Y]!, находящуюся в~памяти, а~затем устанавливаем по условию её младший байт (так как платформа x86 использует  порядок байтов Intel, адрес младшего байта \lstinline![Y]! совпадает с~адресом \lstinline![Y]!).
Оба возможных значения $y$ неотрицательны, поэтому дополнение нулями является корректным расширением и~для знаковой, и~для беззнаковой их~интерпретации.

Также можно было установить по условию регистр  \Reg{AL} и~специальными командами расширить его вначале до \Reg{AX}, а~затем до~\Reg{EAX}.

При использовании для $y$ однобайтового типа \lstinline!char! вместо четырёхбайтового \lstinline!int! расширение не будет нужным.

\pagebreak[3]

% \subsection{Цикл с~предусловием}
\subsection{Цикл}

Пусть необходимо найти сумму двоичных цифр беззнакового числа $x$.


% Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\reflocal{ris:if-else}, а), реализован цикл с~предусловием) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\reflocal{ris:if-else}, б).

Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\reflocal{ris:while}, а), реализован цикл с~предусловием). 
При соединении блоков немного отступим от требований ЕСПД 
(стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости)
и~отделим точку, где боковой поток случая $CF\neq 0$ входит в~основную вертикаль, от~точки, где поток отходит от вертикали, чтобы перейти назад к~началу итерации.
Расположение этих точек выберем так, чтобы поток основной вертикали на каждом её участке шёл в~естественном направлении "--- сверху вниз (это не только позволяет не~рисовать стрелку для обозначения направления, но и~соответствует выполнению %программы 
кода, не включающего команд передачи управления).



\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\tikzstyle{asm}	= [text width=16em,text badly ragged, anchor=west]

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[block,on chain=alg_start] (init) {$count = 0$};

\coordinate[on chain=alg_start] (to_shift);
\tikzset{every join/.style=blockarrow}
\node[decision,on chain=alg_start] (is_zero) {$x=0$};
\tikzset{every join/.style=blockline}
\node[block,on chain=alg_start, join={node[right]{нет}}] (shift) {
$CF = x \& 1$

$x = (x>>1)$
};

\node[decision,on chain=alg_start] (is_last_bit) {$CF=1$};
\node[block,on chain=alg_start, join={node[right]{да}}] (inc) {$count = count+1$};
\coordinate[on chain=alg_start] (from_no_to_next_iter);
\coordinate[on chain=alg_start] (to_next_iter);
\tikzset{every join/.style=blockarrow}
\coordinate[left = of current bounding box] (to_next_iter_middle);
\path[blockarrow] (to_next_iter) -| (to_next_iter_middle) |- (to_shift);

\tikzset{every join/.style=nodraw}
% \coordinate[on chain=alg_start] (non-used);
\coordinate[on chain=alg_start] (to_end);
\node[terminator, on chain=alg_start] (end) {Конец};


\coordinate[right= of is_last_bit] (is_no_last_bit);
\path[blockarrow] (is_last_bit) -- node[auto] {нет} (is_no_last_bit) |- (from_no_to_next_iter);



\coordinate[right= of is_zero-|is_no_last_bit] (is_zero_yes);
\path[blockarrow] (is_zero) -- node[auto] {да} (is_zero_yes) |- (to_end) -- (end);



\coordinate[right=  of current bounding box] (asm_coord);

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = 7, count;
asm
(
\end{lstlisting}
};

\node[asm] at (to_shift-|asm_coord) {
\begin{lstlisting}
"begin_iteration:\n"
\end{lstlisting}
};
\node[asm] at (init-|asm_coord) {
\begin{lstlisting}
  "xorl %[Count], %[Count]\n"
\end{lstlisting}
};
\node[asm] at (shift-|asm_coord) {
\begin{lstlisting}
  "shrl $1, %[X]\n"
\end{lstlisting}
};
\node[asm] at (is_zero-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "je end_loop\n"
\end{lstlisting}
};
\node[asm] at (is_last_bit-|asm_coord) {
\begin{lstlisting}
  "jnc end_iteration\n"
\end{lstlisting}
};
\node[asm] at (inc-|asm_coord) {
\begin{lstlisting}
  "incl %[Count]\n"
\end{lstlisting}
};

\node[asm] at (from_no_to_next_iter-|asm_coord) {
\begin{lstlisting}
"end_iteration:\n"
  "jmp begin_iteration\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_loop:\n"
\end{lstlisting}
};

\node[asm] at (end-|asm_coord) (asm-end) {
\begin{lstlisting}
:[Count]"=rm"(count),[X]"+rm"(x)
: : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};


\end{tikzpicture}
}

\caption{Алгоритм и~реализация цикла}
\labellocal{ris:while}
\end{illustration}

Теперь сопоставим каждому блоку одну или несколько команд ассемблера.
Отход потока от базовой вертикали будет соответствовать команде перехода, точки входа боковых потоков в~основной вертикальный  "--- меткам 
(рис.~\reflocal{ris:while}, б).

Цикл с~постусловием будет отличаться только на этапе построения схемы алгоритма.

Цикл с~параметром, как и~в~C/C++, можно реализовать как цикл с~предусловием.




\section{Вопросы}


\begin{enumerate}

\item Какие вы знаете флаги?
\item Какие вы знаете команды передачи управления?
\item Какие вы знаете команды условной пересылки?

\item Как, согласно ЕСПД, изображается блок «терминатор»?
\item Как, согласно ЕСПД, изображается блок «процесс»?
\item Как, согласно ЕСПД, изображается блок «решение»?


\end{enumerate}

\section{Справочные материалы}

% \subsection{Статьи}
\begingroup
\lstset{keywordstyle=}


\begin{enumerate}

{
\item ГОСТ 19.701-90 Схемы алгоритмов, программ, данных и~систем. Обозначения условные и~правила выполнения (часть единой системы программной документации "--- ЕСПД)
 "--- \lstinline!ГОСТ 19.701-90 Схемы алгоритмов, программ, данных и систем.pdf!
 \sloppy
 
 }


\item Список основных команд архитектур x86 и x86-64 "---
\lstinline!Команды архитектур x86 и x86-64.htm!


\item
Черновик стандарта C++ 
% (C++14 standard plus minor editorial changes) 
(C++14 с~незначительными редакторскими правками)
"---
November 2014 working draft.
\lstinline!n4296.pdf!


\end{enumerate}
\endgroup