\chapter{Представление данных в~ЭВМ}
\setlablabel{digits}
\purpose{изучить форматы представления целых чисел и~символьной информации в~ЭВМ.
\footnote{Использованы: %лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной (использованы материалы и~программы R.Hyde); 
программа  gbase  (C) 1999 Damian Kramer, Roger Dunce; таблица ASCII, оформленная Victor Eijkhout.
}}


\begin{tasks}


\item \bonus{+2 балла за платформу}  
При подготовке к~работе соберите и~запустите программу (программы) из заданий \reflocal{task:prog:start}--\reflocal{task:prog:end}, используя платформу и/или компилятор, отличные от доступных на ВЦ.  Результаты измерений с~пояснениями внести в~конспект (дополнить таблицы результатов заданий \reflocal{task:prog:start}--\reflocal{task:prog:end}).

\item 
\labellocal{task:intcode}
% \addcontentsline{toc}{subsection}{Задание}%
% Изучите, как интерпретируется один и~тот же код% (рассмотрите два 16-битных кода)
% , если он рассматривается различными способами:
% \\
% а) как десятичное число без знака;\\
% б) как десятичное число со знаком; \\
% в) как шестнадцатеричное число.
% % ;\\
% % г) как двоичное число.
Изучите, как интерпретируется одна и~та же область памяти, если она рассматривается как знаковое или беззнаковое число, а~также как одно и~то же число записывается в~различных системах счисления.

Необходимо сравнить:\\
а) беззнаковую интерпретацию переменной в~шестнадцатеричной форме;\\
б) беззнаковую интерпретацию в~десятичной форме; \\
в) знаковую интерпретацию в~десятичной форме.


Для этого
определите и~запишите в~отчёт 
% \begin{itemize}
% \item 
% двоичное (16 бит) и~шестнадцатеричное представления десятичного числа $-12\,345$, а~также беззнаковую интерпретацию этого представления в~десятичном виде;
% 
% \item 
двоичное (16 бит) и~шестнадцатеричное представления десятичного числа $-34$, а~также беззнаковую интерпретацию этого представления в~десятичном виде.

Для получения различных интерпретаций одного и~того же кода 
можно написать программу на C++, где на один и тот же участок памяти ссылаются знаковая и~беззнаковая переменная одного размера (используя объединения или оператор  \lstinline!reinterpret_cast!).
% и,~используя различные форматы вывода,
% напечатать значения обеих переменных.
Шестнадцатеричное и~десятичное представление в~этом случае можно получить, используя различные форматы вывода.
% 
Шестнадцатеричный формат вывода не предусматривает знака, то есть шестнадцатеричное представление знаковой переменной будет соответствовать её беззнаковой интерпретации.


Также
возможно 
использовать конвертер,  в~частности, \url{http://calc.penjee.com/} (доступ в~Сеть есть на терминале Galaxy) или  gbase. % (или аналогичный)

% \item двоичное (16 бит) и~шестнадцатеричное представления десятичного числа $65\,502$.
% , а~также знаковую интерпретацию этого представления в~десятичном виде;

% \end{itemize}


% В~программе \programname{gbase} изучите, как одно и~то же число будет представлено (для представления используется 16 бит) в
% виде 
% \\
% а) десятичного числа без знака;\\
% б) десятичного числа со знаком; \\
% в) шестнадцатеричного числа;\\
% г) двоичного числа.

\item 
Найдите и~выпишите в~отчёт минимальное и~максимальное 16-битное число со
знаком и~без знака в~формах представления (а), (б), (в) и~%(г) 
в~двоичной форме
(4~числа, каждое из которых представлено в~4 формах).


\item 
\labellocal{task:bitwise}
\labellocal{task:prog:start}
Разработайте программу на языке C++, выполняющую над беззнаковыми целыми числами следующие операции (результат должен печататься в~десятичной и~шестнадцатеричной формах): 
\begin{itemize}
\item бинарные
AND (конъюнкция), OR (дизъюнкция), XOR (сложение по модулю два); 
\item унарные NOT (отрицание),
\\
NEG (дополнение до двух, $x + NEG(x) = 2^{\text{разрядность }x}$);
\item SHL (логический сдвиг влево), SHR (логический сдвиг вправо).
% 
% \item \bonus{+2 балла} ROL (циклический сдвиг влево) и~ROR (циклический сдвиг вправо). 
\end{itemize}

\item
Измените в~программе из~задания~\reflocal{task:bitwise} тип переменных на знаковый. 
Объясните изменение (или неизменность) результата.

\item\bonus{+2 балла} 

\noindent 
Придумайте и~запишите в~отчёте:
\begin{itemize}
\item маску (т.е. второй операнд бинарной побитовой операции) для преобразования кодов ASCII
цифр '0'...'9' в~их двоичные эквиваленты (однобайтовые числа 0...9) с~помощью операции AND.
При этом ASCII-код нуля (шестнадцатеричное число \lstinline!0x30!, что также иногда записывается как $30_{16}$, однако наиболее предпочтительное и~самодокументирующееся представление ASCII-кода нуля "--- \lstinline!'0'!) должно быть преобразовано в~однобайтовое число 00,  ASCII-код единицы (\lstinline!'1'!, шестнадцатеричное число \lstinline!0x31! или $31_{16}$)
 "--- в~01, и~т.\,д.;
\item необходимую операцию и~маску для преобразования однобайтовых чисел 0...9 в~их коды ASCII;
\item маску, которая преобразовывает строчные английские буквы в~прописные и~наоборот с~помощью операции XOR.
\end{itemize}
Коды ASCII приведены в~разделе~\reflocal{sec:ascii}.



\item\bonus{+1 балл} 
Разработайте программу на языке C++ (или дополните программу из~задания~\reflocal{task:bitwise}), которая расширяет шестнадцатибитное представление числа до
32-битового, рассматривая числа как
\begin{itemize}
\item знаковые (signed);
\item беззнаковые (unsigned).
\end{itemize}
\descrcomment{Расширение числа происходит, в~частности, при присваивании
% : \lstinline!int i; short s = -1; i = s;!
"--- если размер приёмника больше размера источника.
}


\item
\labellocal{task:platforms}
\labellocal{task:char}
Определите и~выпишите в~отчёт, как хранятся в~памяти компьютера: % на различных платформах

\begin{itemize}
\item %Определите и~выпишите в~отчёт, как хранятся в~памяти компьютера 
целое
число 0x12345678; по результату исследования определите порядок следования байтов в~словах  для вашего процессора:
\begin{itemize}
\item Little-Endian (от младшего к старшему, порядок Intel);
\item Big-Endian (от старшего к младшему, порядок Motorola);
\end{itemize}


\item строки \lstinline!"abcd"! и~\lstinline!"абвг"! (массив из \lstinline!char!);

\item «широкие» строки \lstinline!L"abcd"! и~\lstinline!L"абвг"! (массив из \lstinline!wchar_t!).
\end{itemize}

% В~отчёт необходимо включить шестнадцатеричный дамп области памяти, где хранятся символы строк и~значение числа.

\item
\bonus{+1 балл} 

Напишите программу, демонстрирующую переполнение целых чисел со знаком и~без знака. Для этого опишите целое число со знаком и~инициализируйте его максимально возможным для данного типа значением, результат распечатайте %в~двоичном и~
в~шестнадцатеричном виде. Затем прибавьте к~этому
числу единицу, результат распечатайте %в~двоичном и~
также в~шестнадцатеричном виде. 
Выполните аналогичные действия для беззнаковой переменной.
Выпишите в~отчёт распечатанные значения переменной,
% (в~двоичном и~в~шестнадцатеричном виде), письменно
поясните полученные результаты.

% Пояснения. 1) Для вывода значения целой переменной в~десятичной или шестнадцатеричной
% системах счисления используются манипуляторы \lstinline!dec! (используется по умолчанию) или \lstinline!hex!.
% Пример: \lstinline!cout << hex << i << endl;!
% 
% 2) 
% Для задания шестнадцатеричной константы перед числом указывается \lstinline!0x! или \lstinline!0X!.


\item
\labellocal{task:prog:end}
{
При помощи оператора \lstinline!sizeof! выясните, сколько байтов занимают %на различных платформах (аналогично заданию \reflocal{task:platforms})
переменные следующих типов: \lstinline!char, bool, wchar_t, short, int, long, long long, float, double, long double, size_t, ptrdiff_t, void*!. Результаты оформите в~отчёте в~виде таблицы, указывая для каждого типа его назначение.\sloppy

}

Для выполнения единообразных действий над переменными различных типов используются макросы препроцессора C или шаблоны C++.

% \noindent\begin{tabularx}{1\linewidth}{}

Проверьте, соответствуют ли размеры типов современному стандарту C++.
% (файл n4296.pdf "--- свободно распространяемый черновик актуального сейчас ISO International Standard ISO/IEC 14882:2014(E) "--- Programming Language C++).

\item
Запустите программу (программы) из заданий \reflocal{task:prog:start}--\reflocal{task:prog:end} на двух других платформах, доступных на ВЦ "--- 32- и~64-разрядной версиях Microsoft Windows и~повторите измерения.

% Платформы, для которых необходимо провести измерения:
% По результатам 
Для каждого из заданий 
% Оформите таблицу, где приведены результаты измерений на платформах:
дополните таблицу результатами новых измерений.
% на платформах:
Платформы, для которых необходимо провести измерения:
\begin{itemize}
\item \stdOs{} \stdDist{}, архитектура \stdArch{} (компилятор \stdCompiler{}, среда любая);
\item 32-разрядная версия Microsoft Windows (ВЦ, среда Microsoft Visual Studio);
\item 64-разрядная версия Microsoft Windows (терминал Skylab, среда Microsoft Visual Studio, %для проекта необходимо назначить 64-битную конфигурацию
64-битная конфигурация).
\end{itemize}



Результаты однотипных измерений, выполненных на различных платформах, должны быть сгруппированы в~таблицу или последовательно описаны в~одном разделе. 
% Различия платформ должны 




\end{tasks}
\section{Дополнительные бонусные и~штрафные баллы}

$+2$ балла "--- корректная автоматизация с~помощью макросов препроцессора C или шаблонов C++.

$-4$ балла "--- неудобочитаемый отчёт.


\emph{Пример неудобочитаемого фрагмента отчёта:}

{
\footnotesize
Задание \reflocal{task:bitwise}.

\includegraphics[width=0.5\linewidth,keepaspectratio]{bad-report}

}

\emph{Возможная альтернатива:}

{
\footnotesize
Задание \reflocal{task:bitwise}.
Разработайте программу на языке C++, выполняющую над беззнаковыми целыми числами следующие операции (результат должен печататься в~десятичной и~шестнадцатеричной формах): 
% \begin{itemize}
% \item бинарные
% \end{itemize}
% AND (конъюнкция)

\lstinline!11 & 14 = 10 (0xB & 0xE = 0xA)!

}

\section{Рекомендации}

% Пояснение. Используйте 
Для просмотра содержимого памяти используйте
возможности отладчика
% (окна Memory и~Watches, рис.~\ref{ris:codeblocks-digits-debugmemory}) 
или отладочную печать.
% 
Для перенаправления стандартного вывода в~файл "--- возможности оболочки (\lstinline!>!).

Скопировать вывод программы из терминала в~отчёт можно, используя буфер обмена primary. 
Для этого необходимо выделить мышью необходимый текст в~терминале и~затем щёлкнуть средней кнопкой мыши в~том месте редактора, где планируется вставка.
% Внимание!
После закрытия текста-источника содержимое буфера primary теряется, поэтому вставку желательно проводить непосредственно после выделения фрагмента вывода в терминале.

% \begin{illustration}
% \includegraphics[width=\linewidth]{digits-debugmemory}
% 
% \caption{Отладочные окна Memory и~Watches в~Code::Blocks}
% \labellocal{ris:digits-debugmemory}
% \end{illustration}




\section{Создание 64-битной конфигурации Microsoft Visual Studio\footnote{Использована лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной}}

% 64-разрядная версия Microsoft Windows доступна в~терминале Skylab (домен SIPC).

Для создания 64-битной конфигурации Microsoft Visual Studio
запустите Microsoft Visual Studio  в~терминале Skylab (домен SIPC)
и~выполните следующие три шага
(рис.~\reflocal{ris:win64conf}):
\begin{illustration}
\includegraphics[width=\linewidth]{il-lab1-ris2}

\caption{Создание 64-битной конфигурации для проекта в~Microsoft Visual Studio}
\labellocal{ris:win64conf}
\end{illustration}



Шаг 1. Запустить менеджер конфигураций (рис.~\reflocal{ris:win64conf}, а).

Шаг 2. В~менеджере конфигураций выбрать поддержку новой платформы (рис.~\reflocal{ris:win64conf}, б).

Шаг 3. Выбрать 64-битную платформу (x64), а~в~качестве основы выбрать настройки от 32-битной версии (рис.~\reflocal{ris:win64conf}, в). Те настройки, которые влияют на режим сборки, среда Microsoft Visual Studio
скорректирует сама.

\section{Базовые типы C++\footnote{Использован черновик стандарта C++14, разделы basic.types, basic.fundamental и~expr.sizeof}}

Базовые типы C++ описаны в~разделе Fundamental types (basic.fundamental) стандарта C++.
Раздел Types (basic.types) описывает общие характеристики хранения данных в~памяти.

% В~данном разделе также дана ссылка на раздел 5.2.4.2.1 стандарта C, где описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов.

% \subsection{Целые типы и~указатели}
\subsection{Целые типы}
% \subsection{Требования стандарта к~целым типам}

Существует пять стандартных \termin{знаковых целых типов}:  
\begin{itemize}
\item \lstinline!signed char!, 
\item \lstinline!signed short int! (синонимы: \lstinline!short, signed short!),  
\item \lstinline!signed int! (синонимы: \lstinline!int, signed!),
\item \lstinline!signed long int! (синонимы: \lstinline!long, signed long!),  
\item \lstinline!signed long long int! (синонимы: \lstinline!long long, signed long long!)
\end{itemize}
% компилятор может поддерживать и~д
и~пять соответствующих \termin{беззнаковых целых типов} (каждый из них имеет тот же размер и~те же требования к~выравниванию, что и~соответствующий знаковый):
\begin{itemize}
\item \lstinline!unsigned char!, 
\item \lstinline!unsigned short int! (синонимы: \lstinline!unsigned short!),  
\item \lstinline!unsigned int! (синонимы: \lstinline!unsigned!),
\item \lstinline!unsigned long int! (синонимы: \lstinline!unsigned long!),  
\item \lstinline!unsigned long long int! (синонимы: \lstinline!unsigned long long!).
\end{itemize}
Тип \lstinline!char!, в~зависимости от реализации, может быть знаковым или беззнаковым.
Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! имеют один размер и~одинаковые требования к~выравниванию.


Стандарт C++ не содержит явных значений разрядности типов.

Согласно стандарту,
% размер типа \lstinline!char! "--- минимально возможный размер какого-то объекта в~памяти, кроме того, размер любого объекта кратен размеру~\lstinline!char!;
% также в~разделе Sizeof указано, что 
\lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! занимают 1~байт.
При этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! \emph{однобайтовый,} но \emph{не однооктетный,}
то есть занимает не~8~бит.
% 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта

% Оператор \lstinline!sizeof! возвращает, сколько раз \lstinline!char! укладывается в~аргументе. 
Таким образом, всякий объект любого типа (обозначим его \lstinline!T!) может быть скопирован в~массив \lstinline!char [sizeof(T)]!.

В~ряду целых типов каждый следующий тип имеет размер (и~диапазон значений)  не меньше предыдущего:
$$
\begin{array}{c}
\mathlst{sizeof(char)} \leqslant \mathlst{sizeof(short)} \leqslant \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
\leqslant \mathlst{sizeof(long long)}
\end{array}
$$
Размеры стандартных целых типов C++ также должны соответствовать ограничениям раздела 5.2.4.2.1 стандарта C.
В~этом разделе описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов (при этом указанные значения не обязательно должны быть граничными).
% $$
% \begin{array}{lcl}
% \mathlst{sizeof(char)} \geqslant 
% \mathlst{sizeof(short)} \leqslant 
% \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
% \leqslant \mathlst{sizeof(long long)}
% \end{array}
% $$
Анализ этих значений приводит к~следующим выводам о~минимально допустимой разрядности стандартных типов:\\
\strut\hfill
\begin{tabular}{l|l}
Тип & Разрядность, бит (не менее) \\\hline
 \lstinline!char! & 8 \\
 \lstinline!short! & 16 \\
 \lstinline!int! & 16 \\
 \lstinline!long! & 32 \\
 \lstinline!long long! & 64 \\
\end{tabular}
\hfill\strut\bigskip




Тип \lstinline!int! должен соответствовать «естественной» разрядности архитектуры.
% ; расплывчатость этой формулировки приводит к тому, что практически на 64-битной платформе тип \lstinline!int! чаще всего 32-разряден.

% \subsubsection{интерпретация}
%  и~называются ещё \termin{узкими (narrow)}

% Размер типа \lstinline!char! 

Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! называются ещё \termin{узкими (narrow) символьными типами}, так как 
% хранящееся в~переменных так
они могут быть интерпретированы не только как числа, но и~как символы; соответственно
их размер должен быть таким, чтобы хранить представление любого символа из \termin{базового набора.}

Единственное отличие %типа \lstinline!char! 
узких символьных типов
от других целых (кроме размера) "--- то, что операторы ввода/вывода в~поток для них перегружены так, что отображают не значение переменной, а~символ, код которого равен этому значению.
Все арифметические операции для \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! выполняются точно так же, как и для любого другого целого типа.


Для  типа \lstinline!unsigned char!
каждой возможной  комбинации разрядов должно соответствовать отдельное число. 
Для других типов это не обязательно.

Для представления \termin{расширенного набора  символов} введён специальный тип \lstinline!wchar_t!, имеющий такой же размер, знаковость и~требования к~выравниванию, что и~один из~целых типов.


Тип \lstinline!bool! может хранить только два значения "--- \lstinline!true! и~\lstinline!false!.

\subsubsection{Практическая реализация}

\warning{Всё, что явно не прописано в~стандарте C++, может быть реализовано по-разному на различных платформах.

% Соответственно, в
Всё, написанное  в~этом разделе и~в~аналогичных разделах ниже, описывает в~основном платформу x86 и~наиболее популярные компиляторы.
На других программно/аппаратных платформах (в~частности, при использовании экзотического компилятора) эти закономерности могут быть нарушены.
}

Для представления беззнаковых чисел используется натуральный двоичный код;
знаковые представляются дополнительным кодом (таблица~\ref{tab:naturalbincode}).
Таким образом, для всех целых типов, в~частности, для \lstinline!unsigned char!, каждой возможной  комбинации разрядов  соответствует отдельное число.

\begingroup
%  \scriptsize
% \renewcommand{\arraystretch}{1.05}
\newcolumntype{Y}{>{$}R<{$}}
\renewcommand\theadlong[1]{\multicolumn{1}{@{}R@{}}{{\bfseries\small #1\par
\vspace*{-1\baselineskip}
\strut
}}}

\begin{table}

\caption{Натуральный двоичный и~дополнительный коды}
\label{tab:naturalbincode}

% \noindent
\begin{tabularx}{1\linewidth}{YYYY@{\hspace{4em}}}
\theadlong{Тетрада}& \theadlong{16-ричный код} & \theadlong{Беззнаковое представление}
& \theadlong{Дополнительный код (доп. до 2)} 
	\\\hline

0000 & 0	& 0 &	0  			\\%\hline
0001 & 1	& 1 &	+1 			\\%\hline
0010 & 2	& 2 &	+2 			\\%\hline
0011 & 3	& 3 &	+3 			\\\hline
0100 & 4	& 4 &	+4 			\\%\hline
0101 & 5	& 5 &	+5 			\\%\hline
0110 & 6	& 6 &	+6 			\\%\hline
0111 & 7	& 7 &	+7 			\\\hline
1000 & 8	& 8 &	-8 		\\%\hline
1001 & 9	& 9 &	-7 			\\%\hline
1010 & A	& 10 &	-6 			\\%\hline
1011 & B	& 11 &	-5 			\\\hline
1100 & C	& 12 &	-4 			\\%\hline
1101 & D	& 13 &	-3 			\\%\hline
1110 & E	& 14 &	-2 			\\%\hline
1111 & F	& 15 &	-1 			\\\hline


\end{tabularx}
\end{table}

Как видно из таблицы~\ref{tab:naturalbincode}, минимальное беззнаковое четырёхбитное число "--- ноль ($0b0000$),
максимальное "--- $2^4 - 1 = 15$ ($0b1111$).
Минимальное знаковое четырёхбитное число "---  $-2^3 = -8$  ($0b1000$),
максимальное "--- $2^3 - 1 = +7$ ($0b0111$).

Для знаковых и~беззнаковых типов по-разному реализованы некоторые арифметические и~битовые операции, в~частности, умножение (\lstinline!*!), деление (\lstinline!/, %!), битовые сдвиги (\lstinline!<<,>>!), расширение при присваивании (если приёмник больше источника).

\paragraph{char, wchar\_t%
\footnote{Использованы материалы forum.ishodniki.ru}%
}

% % Соответственно,
% Для большинства программно/аппаратных платформ 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта, занимает один байт
% (при этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! однобайтовый, но не однооктетный).
% % , как минимально  размер любого типа кратен \lstinline!char!.
% % , хотя есть и~исключения (как правило, платформы, где байт не восьмибитен).

Тип \lstinline!char! "--- восьмибитный и~знаковый.
При этом  \lstinline!char! и~\lstinline!signed char! не являются синонимами, хотя вычисления с~их использованием компилируются в~одинаковые конструкции.
% 
Именно, при перегрузке  \lstinline!f(char)! и~\lstinline!f(signed char)! считаются разными функциями и~их имена декорируются по-разному (для сравнения, \lstinline!f(int)! и~\lstinline!f(signed int)! не различаются и~декорируются одинаково).


Базовым набором символов является ASCII.
% Изначально стоит текущая для всего локаль "C" в котрой мало что известно, по сути это просто US ASCII как правило. не Linux
% 
При интерпретации переменной типа \lstinline!char! как символа
значение этой переменной трактуется как ASCII-код.
% , если оно лежит в~пре
% от 0 до 127 интерпретируется
Таким образом, 64, 0x40 и '@' "--- это разные формы записи одного и того же числа (ASCII-код символа «собака» равен шестидесяти четырём).

Символы не из ASCII, в~частности, русские буквы, в~зависимости от реализации, могут быть представлены 
одной переменной типа  \lstinline!char! (кодировки koi8, cp1251, cp866; в~этом случае с учётом знаковости \lstinline!char! коды русских букв "--- 128--255 "--- трактуются как отрицательные, то есть \lstinline!'ы' < 0 < 's'!)
или цепочкой из нескольких 
% переменными типа  
\lstinline!char!'ов (кодировка UTF-8; в~этом случае можно описать строку из русских букв как \lstinline!char []!, но невозможно описать одну такую букву как \lstinline!char!).
% Представление одного символа несколькими  переменными не очень удобно

% http://forum.ishodniki.ru/index.php/topic,19509.msg80866.html?PHPSESSID=0231dfe0510c43d48470048b3716466b#msg80866

Понятие расширенного набора  символов и~тип  \lstinline!wchar_t! возникли с~появлением Unicode.
Широкий символьный тип \lstinline!wchar_t! может содержать любое количество байтов.
% С появлением юникода появился и тип "широких" символов wchar_t. Вот уж сколько в нем байтов или char-ов совершенно неизвестно. Но про него известны 2 хорошие вещи которые как правило создатели компиляторов и API закладывают в него :
% - Он используется как правило для преставления какой либо Unicode кодировки.
% - У него фиксированная длина символов. Это достаточно важно. Как известно символы в юникоде представленны абстрактным кодовым пространством (UCS).  А в реальных устройствах эти абстрактные ккоды кодируются различными "юникодными" кодировками (UTF). Причем на разные символы у этих юникодных кодировок может быть переменное число байт. Так вот прелесть wchar_t в том, что в нем обычно используются такие юникодные кодировки или их части в которых каждый логический символ занимает ровно один wchar_t.
Как правило,  при хранении символьной информации в~\lstinline!wchar_t! используются такие юникодные кодировки или их части, в~которых каждый логический символ занимает ровно один \lstinline!wchar_t! (UTF-32, или, если поддерживается только часть набора символов Unicode "--- UTF-16).
Расширенный набор символов, соответственно "--- та часть набора символов Unicode, которая поддерживается и~может быть записана одним \lstinline!wchar_t!.

Литералы, соответствующие широким строкам и~символам, предваряются префиксом \lstinline!L!.
Для ввода/вывода широких символов и~строк используются те же операторы, что и~для узких, но другие потоки (\lstinline!wcin/wcout!). Поток \lstinline!cout! при выводе  \lstinline!wchar_t! отображает число, при выводе \lstinline!wchar_t*! "--- адрес в~шестнадцатеричном виде. 


% http://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c
% char is always a byte , but it's not always an
% octet. A byte is the smallest addressable unit of
% memory (in most definitions), an octet is 8-bit
% unit of mem

\paragraph{int, short, long, long long}


% Нечёткость требований к~размеру стандартных типов формулировки приводит к тому, что практически 
Тип \lstinline!int! на 16-разрядных платформах занимал 16 бит, на 32-разрядных "--- 32 бита.
На 64-битной платформе \lstinline!int! чаще всего 32-разряден.

Тип \lstinline!short! 16-разряден на 16-, 32- и~64-разрядных платформах.

Тип \lstinline!long! на 16- и~32-разрядных платформах занимал 32 бита.
На 64-битной платформе "--- 64.

Тип \lstinline!long long!, если поддерживается, 64-разряден.

\subsection{Вещественные типы}

Существует три стандартных \termin{вещественных типа}:  
\begin{itemize}
\item \lstinline!float!, 
\item \lstinline!double!,  
\item \lstinline!long double!.
\end{itemize}
тип \lstinline!double! обеспечивает не меньшую точность, чем \lstinline!float!,
\lstinline!long double! "---  не меньшую точность, чем \lstinline!double!.

Множество значений типа \lstinline!float! является подмножеством множества  значений типа  \lstinline!double!;
множество значений типа \lstinline!double! является подмножеством множества  значений типа  \lstinline!long double!:
$$
\mathlst{float} \subseteq \mathlst{double} \subseteq \mathlst{long double}
$$

\subsubsection{Практическая реализация%
\footnote{Использованы материалы: 
В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
с~плавающей точкой;
текст стандарта IEEE Std 754™-2008
}%
}


Вещественные числа, согласно стандарту двоичной арифметики с~плавающей точкой IEEE 754,
представляются в~виде знака, экспоненты (порядка) и~мантиссы
(рис.~\reflocal{ris:ieee754_1}).


% Это представление основано на двоичной экспоненциальной форме вещественного числа $F$, то есть:
Число $F$ представляется в~двоичной экспоненциальной форме "--- в~виде произведения трёх компонент:
\begin{itemize}
\item знак ($+1$ или $-1$);
\item двойка в~некоторой степени~$\epsilon$, называемой \emph{порядком}, или экспонентой; %(порядок "--- зна);
% (для записи очень маленьких чисел порядок должен быть отрицательным);
\item \emph{мантиссы $\mu$} "--- двоичной дроби $1 \leqslant \mu <2$, то есть $\mu = 1,\beta_1\beta_2\beta_3\ldots\beta_n$, где $\beta_i$ "--- двоичный разряд.
\end{itemize}
$$
F = (-1)^{\sigma} \cdot 2^{\epsilon} \cdot \mu
% \big( 1,\beta_1\beta_2\beta_3\ldots\beta_n \big)
$$
В~такой форме можно представить любое конечное число, кроме нуля.

Старший бит (S) "--- бит знака, если $S=0$ "--- число положительное, если $S=1$ "--- число отрицательное.
Следующие $b$ бит отводятся под  порядок, смещённый на $2^{b-1} - 1$ (то есть 
знаковое значение порядка представляется не дополнительным кодом, а~кодом с~избытком:
% для отр
порядок~$0$ представляется числом $2^{b-1} - 1$,
% отрицательные порядки представляются малыми беззнаковыми числами
порядок~$-2^{b-1}+1$ "--- нулём%
).
% S - бит знака, если S=0 - положительное число; S=1 - отрицательное число
% E - смещенная экспонента двоичного числа;
% exp2 = E - (2(b-1) - 1) - экспонента двоичного нормализованного числа с плавающей точкой
% (2(b-1) -1) - заданное смещение экспоненты (в 32-битном ieee754 оно равно +127 см.выше)
Оставшиеся $n$ бит кодируют $M$ остаток мантиссы двоичного нормализованного числа с плавающей точкой (мантиссу без ведущей единицы).

Таким образом, значение вещественного числа (рис.~\reflocal{ris:ieee754_1}) для всех комбинаций битов, кроме исключительных (таблица~\ref{tab:ieee754-singular})   вычисляется по формуле:
\begin{illustration}
\includegraphics[width=\approvedImageWidth]{ieee754_1}
\caption{Представление числа в формате IEEE 754}
\labellocal{ris:ieee754_1}
\end{illustration}
$$
F = (-1)^S \cdot 2^{E - 2^{b-1} + 1} \cdot \left( 1 + \dfrac{M}{2^n}\right)
$$

\begin{table}

\caption{Исключительные значения представления IEEE 754}
\label{tab:ieee754-singular}
\begin{tabular}%{l>{$}l<{$}}
{ll}
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+0} & $+0$\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-0} & $-0$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754den} & денормализованные числа \\
\\\hline
\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+inf} & $+\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-inf} & $-\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754nan} & $NaN$ (нечисла) \\
\end{tabular}
\end{table}

% Денормализованные числа. Это числа, мантиссы которых лежат в диапазоне 0.1 <= M <1.

Денормализованные числа находятся ближе к нулю, чем наименьшие по модулю нормализованные. 
% Их мантиссы (при минимально возможном по)
% 
% Денормализованные числа как бы разбивают минимальный разряд нормализованного числа на некоторое подмножество. Сделано так потому, что в технической практике чаще встречаются величины близкие к нулю. 

Стандарт %двоичной арифметики с~плавающей точкой
IEEE 754-2008 описывает
%  \begin{itemize}
% \item 
три двоичных вещественных формата разрядностью 32, 64, и 128 бита. %;
% \item два двоично-десятичных формата "--- 64 и~128 бита.
% \end{itemize}
% 
Более старый вариант этого стандарта    IEEE 754-1985 определяет также формат с~двойной расширенной точностью (double-extended precision) $\geqslant$ 79 бит. % (обычно используют 80 бит).

\begin{illustration}
\includegraphics[width=\wideImageWidth]{ieee754_32}\\
a)\\

\includegraphics[width=\wideImageWidth]{ieee754_64}\\
б)
\caption{Формат чисел а) одинарной (single-precision, 32 бита)  и~б) двойной точности (double-precision, 64 бита)}
\labellocal{ris:ieee754_32}
\end{illustration}




Модуль операций с~плавающей запятой процессоров семейства x86 (floating point unit, FPU) %— часть процессора для выполнения широкого спектра математических операций над вещественными числами.
поддерживает три типа вещественных чисел 
\begin{itemize}
\item  одинарной точности (32 бита), 
\item  двойной точности (64 бита), 
\item  с~двойной расширенной точностью (80 бит, внутренний формат FPU "--- 15 разрядов отводится под порядок,  64 под мантиссу), отводится под экпоненту).
\end{itemize}
Типу \lstinline!float! соответствует число одинарной точности, 
типу \lstinline!double! "--- двойной.

{
Типу \lstinline!long double! чаще всего соответствует 10-байтовое число расширенной точности. % при этом они могут требовать выравнивания
Размер выделяемой под переменную \lstinline!long double! памяти при этом %может превышать реальный размер числа и, 
в~зависимости от флагов компиляции (\verb!-m96bit-long-double! и~\verb!-m128bit-long-double! в~GCC), может быть равен 12 или 16 байт. 
Используются только первые 80 бит (10 байт), остальное "--- неиспользуемая память (заполнение). 
% -m96bit-long-double
% -m128bit-long-double
% These switches control the size of long double type. The i386 application binary interface specifies the size to be 96 bits, so -m96bit-long-double is the default in 32 bit mode.
% Modern architectures (Pentium and newer) would prefer long double to be aligned to an 8 or 16 byte boundary.
% \sloppy

}

В~Microsoft Visual Studio типу \lstinline!long double!  соответствуют числа двойной точности (64 бита), хотя \lstinline!long double! не считается синонимом \lstinline!double!.


\subsection{Специальные типы}

Множество значений типа  \lstinline!void! пусто.
Он используется для описания функций, которые не возвращают значения.

% Любое выражение может быть приведено к~типу 
% \lstinline!void!.

\section{Преобразование типов\footnote{Использована статья 
Е.\,Сагалаевой «Приведение типов в C++»
% «Приведение типов»% (\url{http://habrahabr.ru/post/106294/})
}}
В~С++ есть четыре оператора явного преобразования (приведения) типов: \lstinline!const_cast!, \lstinline!static_cast!, \lstinline!dynamic_cast! и~\lstinline!reinterpret_cast!. 
Кроме того, для совместимости поддерживается приведение в~стиле C.

\begin{description}

\item[const\_cast] убирает (или добавляет, но это редко используется) так называемые cv-спецификаторы (cv qualifiers), то есть const и volatile. volatile встречается не очень часто, так что  \lstinline!const_cast! более известен как приведение типов, предназначенное для убирания const. Если приведение типов не удалось, выдается ошибка на этапе компиляции.
При использовании остальных приведений типов cv-спецификаторы останутся как были.
\begin{lstlisting}[style=lstsmall]
int i;
const int * pi = &i;
// *pi имеет тип const int,
// но pi указывает на int, который константным не является
int* j = const_cast<int *> (pi);
\end{lstlisting}

% http://rsdn.ru/article/cpp/static_cast.xml
\item[static\_cast]
% Синтаксис:
% TYPE static_cast<TYPE> (object);
преобразует выражения одного статического типа в объекты и значения другого статического типа. 
% Самый популярный вид преобразования.
Может быть использован везде, где допустимо неявное преобразование типов (в~частности, преобразования чисел вроде \lstinline!int i = 1.3;! или указателя произвольного типа в~нетипизированный \lstinline!void *up = &i;!), а~также для преобразования:
\begin{itemize}
\item    любого типа к типу void (допустимое, но обычно ненужное на практике преобразование);
\item указателя \lstinline!void *! в~указатель произвольного типа;
\item    базового класса к ссылке на производный класс (допустимо, но опасно, если объект на самом деле не того производного класса; в~этих случаях часто лучше использовать  \lstinline!dynamic_cast!);
\item указателя на базовый класс  в~указатель на производный класс (аналогично, надёжнее использовать \lstinline!dynamic_cast!, если это возможно);
% \item    инверсия некоторых стандартных преобразований, в~частности:
% \begin{itemize}
\item    интегральных типов в перечисляемые%;
% \item    (возможно cv-квалифицированный) Base * в (с не меньшей cv-квалификацией) Derived *
% \item    (возможно cv-квалифицированный) T Base:: * в (с не меньшей cv-квалификацией) T Derived:: *
% \item    (возможно cv-квалифицированный) void * в любой T *
% \end{itemize}
.
\end{itemize}
Если приведение типов не удалось, выдается ошибка на этапе компиляции.

\item[dynamic\_cast]
"--- безопасное приведение по иерархии наследования, в том числе виртуального.
Используется для преобразования
\begin{itemize}
\item указателя на базовый класс  в~указатель на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class *>(base_class_ptr_expr)
\end{lstlisting}
если приведение невозможно, будет возвращён NULL;

\item    базового класса к ссылке на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class &>(base_class_ref_expr)
\end{lstlisting}
если приведение невозможно, 
% Работа со ссылками происходит аналогично, но в случае ошибки во время выполнения 
будет выброшено исключение \lstinline!bad_cast!.
\end{itemize}
% Используется RTTI (Runtime Type Information), чтобы привести один указатель на объект класса к другому указателю на объект класса. 
Для корректного преобразования классы должны быть полиморфными, то есть в базовом классе должна быть хотя бы одна виртуальная функция. Если это условие не соблюдено, ошибка возникнет на этапе компиляции.
 Если приведение невозможно, это станет ясно только на этапе выполнения программы.

\item[reinterpret\_cast]
"--- приведение без проверок. Не может быть приведено одно значение к другому значению. Обычно используется, чтобы привести указатель к указателю, указатель к целому, целое к указателю. Умеет также работать со ссылками.

Возможные варианты использования
\begin{lstlisting}[style=lstsmall]
reinterpret_cast<whatever *>(some *)
reinterpret_cast<integer_expression>(some *)
reinterpret_cast<whatever *>(integer_expression)
\end{lstlisting}
Например, допустимо:
\begin{lstlisting}[style=lstsmall]
double x = 1;
int i = -1;
char *pc = reinterpret_cast<char *>(&x);

// refu -- ссылка на то же место в памяти, где расположена переменная i,
// но интерпретируется этот фрагмент памяти уже как unsigned
unsigned &refu = reinterpret_cast<unsigned &>(i);

// pu указывает на то же место в памяти, где расположена переменная i (аналогично)
unsigned *pu = reinterpret_cast<unsigned *>(&i);

// u -- новая переменная, инициализированная текущим значением i в беззнаковой интерпретации (0xFFFFFFFF)
unsigned u = reinterpret_cast<unsigned &>(i);

// lox ссылается на первые (в x86 -- младшие) 4 байта x и интерпретирует их как беззнаковое целое
unsigned &lox = reinterpret_cast<unsigned &>(x);
unsigned &hix = *(&lox + 4);
\end{lstlisting}
% используя пару разнотипных переменных 
% 
Но нельзя выполнить
\begin{lstlisting}[style=lstsmall]
int i;
unsigned u = reinterpret_cast<unsigned>(i);
\end{lstlisting}

\item[Приведение в~стиле C](C-style cast) "--- самое медленное преобразование, так как  последовательно перебираются следующие вызовы:
\begin{enumerate}
\item    \lstinline!const_cast!
\item    \lstinline!static_cast!
\item    \lstinline!static_cast + const_cast!
\item    \lstinline!reinterpret_cast!
\item    \lstinline!reinterpret_cast + const_cast!
\end{enumerate}
Допустимо во всех случаях, но не рекомендуется из-за внешнего вида.

Примеры:
\begin{lstlisting}[style=lstsmall]
double x = 1;
int i = -1;
char *pc = (char *)(&x);
unsigned &refu = (unsigned &)i;
unsigned *pu = (unsigned *)&i;
unsigned u = (unsigned)i;
\end{lstlisting}


\end{description}

\section{Литералы C++}

\subsection{Целые}

Целочисленные литералы начинаются с~цифры или знака ($+$ или $-$) и~не содержат десятичной запятой и~показателя степени. 

Для тех чисел, которые соответствуют кодам ASCII для печатных и~некоторых управляющих символов, 
%  которые можно каким-то образом задать , 
есть альтернативная форма записи "--- соответствующий символ в~одинарных кавычках, например
\lstinline!'\0'! равен 0, \lstinline!'\t'! "--- 9, \lstinline!'2'! "--- 50, \lstinline!'R'! "--- 82, \lstinline!'r'! "--- 114. 

\subsubsection{Префиксы системы счисления}
Целочисленные литералы могут предваряться префиксом, обозначающим систему счисления:
\begin{description}
\item[0x, 0X] "--- шестнадцатеричная;
\item[0] (ведущий ноль) "--- восьмеричная;
\item[0b, 0B] "--- двоичная;
\end{description}
по умолчанию (без префикса) используется десятичная система.
% 
Так, одно и~то же число может быть записано как \lstinline!13, 015, 0xD! и~\lstinline!0b1101!. 

\subsubsection{Суффиксы знаковости и~размера}

Целый литерал без суффикса имеет тип \lstinline!int! (если значение выходит за пределы \lstinline!int!, то "--- минимальный знаковый тип, в~который литерал помещается).

Для указания беззнакового типа литерала (без суффикса размера это тип \lstinline!unsigned!) используется суффикс \lstinline!u! или \lstinline!U!. 

Для указания размера используются следующие суффиксы:
\begin{description}
\item[l, L] "---  \lstinline!long!;
\item[ll, LL] "---  \lstinline!long long!.
\end{description}
Так, \lstinline!2ul! "--- беззнаковое число типа \lstinline!unsigned long! (возможна также запись \lstinline!2lu!).

Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Вещественные}
Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные точки (.) и/или показатели степени: \lstinline!34.56, 0.12, 1.! (вещественное число 1), \lstinline!1e4! ($10^4$), \lstinline!5e-4! ($5\cdot10^{-4}$), \lstinline!2.12e+2! ($2,12\cdot10^2 = 212$).

Вещественный литерал без суффикса имеет тип \lstinline!double! (если значение выходит за пределы \lstinline!double!, то "--- \lstinline!long double!).
Для указания размера используются следующие суффиксы:
\begin{description}
\item[f, F] "---  \lstinline!float!;
\item[l, L] "---  \lstinline!long double!.
\end{description}
Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Строки}

Строковые литералы заключаются в~двойные кавычки.
Перед «широкими» строками ставится префикс \lstinline!L!.


\section{Исследование структуры объектов}


\subsection{Обозреватель памяти (Memory~dump)}

Исследовать структуру объекта и~его представление в~памяти во время отладки можно с~помощью  обозревателя памяти.

% Окно отладчика «Memory~dump» доступно во время отладки и~отображает содержимое памяти.
В~среде Code::Blocks окно просмотра содержимого фрагмента памяти  «Memory~dump»  (рис.~\reflocal{ris:cb-memory}) доступно во время отладки.
Его можно скрыть или вернуть, используя меню $Debug \to Debugging~windows \to Memory~dump$.

\begin{illustration}
\includegraphics[width=\linewidth]{cb-memory}

\caption{Отладочное окно Memory~dump в~Code::Blocks}
\labellocal{ris:cb-memory}
\end{illustration}

Начало фрагмента может быть литералом (конкретным адресом в~памяти), адресом переменной (\lstinline!&x!), регистром, в~котором содержится адрес или~выражением C++ (результатом выражения должен быть указатель).
% Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.

Содержимое памяти отображается как последовательность байтов. 
Каждый байт представлен как беззнаковое целое (в~виде двух шестнадцатеричных цифр) и~как ASCII-символ (справа).
Байты разбиты на строки по 16; слева перед строкой показан адрес первого байта в~строке в~шестнадцатеричном виде.

% Просмотр памяти по адресу переменной с~помощью отладчика позволяет получит ту же информацию, что и~отладочная печать байтов "--- 


\subsection{Отладочная печать}

В~некоторых случаях использование окон отладчика по какой-то причине неудобно, в~частности, иногда необходимо сформировать файл протокола, содержащий шестнадцатеричные представления множества объектов.

Язык C++ предоставляет множество средств для исследования структуры объектов во~время выполнения программы.


%  the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or

\subsubsection{Идентификация типа\footnote{Использован черновик стандарта C++14, раздел expr.typeid}}

Для получения информации о~типе объекта во время исполнения программы (run-time type identification "--- RTTI) в~C++ используется оператор \lstinline!typeid!.
Оператор \lstinline!typeid! принимает в~качестве параметра имя типа или переменной и~возвращает \lstinline!const std::type_info!.

Класс \lstinline!std::type_info! включает метод \lstinline!name()!, возвращающий строку, характеризующую тип (не имя типа и~не формат вывода).
В~частности, \lstinline!typeid(int).name()! вернёт  \lstinline!"i"!, \lstinline!typeid(double).name()! "---  \lstinline!"d"!, а~\lstinline!typeid(long double).name()! "---  \lstinline!"e"!.
Составные типы характеризуются длинными многокомпонентными строками.

\subsubsection{Размер объекта\footnote{Использован черновик стандарта C++14, раздел expr.sizeof}}

Размер выделяемой под объект памяти можно узнать, используя оператор \lstinline!sizeof!.
% 
Согласно стандарту C++,  оператор \lstinline!sizeof! возвращает количество байтов, используемое для представления операнда.

\lstinline!sizeof(char), sizeof(signed char)! и~\lstinline!sizeof(unsigned char)! равны~1, для остальных стандартных типов определяется реализацией.

\subsubsection{Адреса и~указатели}

% Указатель "--- объект (переменная), хранящая адрес другого объекта. 

С~точки зрения языка высокого уровня, указатели, хранящие адреса объектов различных типов, сами имеют разные типы.
Это сделано для защиты от ошибок, чтобы не попытаться рассмотреть в~памяти то, чего там нет (и~не получить очень странное значение, например, нечаянно прочитав часть вещественного числа как целое) или не испортить соседние переменные, записывая объект большого размера в~область, зарезервированную под меньший.

С точки зрения более низкого уровня, адреса объектов различных типов ничем не различаются, и~программист сам должен помнить размер, структуру и~назначение каждого объекта в~памяти.
Все адреса имеет один размер, соответствующий разрядности платформы, и,~теоретически, любой адрес может быть преобразован к~любому типу указателя.

% На практике не любое преобразование указатель-указатель имеет смысл.
Так как размер любого типа кратен размеру  \lstinline!char!, адрес любого объекта~\lstinline!x! может быть преобразован в~указатель типа \lstinline!char *!.
Таким образом мы получим доступ к~байтам, составляющим объект, как к~массиву \lstinline!char!'ов; размер этого массива "--- количество байтов~в~\lstinline!x! "--- равен \lstinline!sizeof(x)!.


Язык C++ позволяет преобразовать указатели на разные типы только с~помощью самого наглого и~не портируемого оператора преобразования "--- \lstinline!reinterpret_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
\end{lstlisting}
В~программировании на высоком уровне не рекомендуется использование \lstinline!reinterpret_cast! вообще и~преобразование типов указателей в~частности, так как это небезопасно.
% Низкоуровневое программирование небезопасно само по себе.

\subsubsection{Вывод в~поток}

Для формирования файла-протокола можно воспользоваться потоками вывода.
Ассоциировав в~программе какой-либо файл с~потоком типа \lstinline!fstream!, мы получим возможность записи протокола непосредственно в~этот файл.
Выводя протокол в~стандартный поток вывода (\lstinline!cout!), мы сможем наблюдать протокол в~консоли или сохранить его в~файл, используя перенаправление стандартного потока вывода в~командном интерпретаторе (в~частности, \lstinline!bash!):
\begin{lstlisting}[language=Bash]
$ program > /tmp/log.txt
\end{lstlisting}
(данная команда запускает программу \lstinline!program! и~направляет её стандартный вывод не в~консоль, а~в~файл \lstinline!/tmp/log.txt!).
Второй способ более универсален, поэтому во всех примерах будем рассматривать стандартный поток вывода.

Используемые для вывода в~поток перегруженные операторы \lstinline!<<! и~\lstinline!>>! реализованы для разных типов по-разному.
% 
Типы \lstinline!char, signed char! и~\lstinline!unsigned char! отображаются в~потоке как символы, код которых равен значениям переменных.
Вывести значение такой переменной как число можно, преобразовав её в~другой целый тип, в~частности, \lstinline!int! или \lstinline!unsigned!, для чего можно использовать \lstinline!static_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
cout << static_cast<int>(*p);
\end{lstlisting}
или
\begin{lstlisting}
unsigned char *p = reinterpret_cast<unsigned char *>(&x);
cout << static_cast<unsigned>(*p);
\end{lstlisting}
оба эти листинга выводят в~поток \lstinline!cout! первый байт объекта~\lstinline!x!,
первый "--- как знаковое число, второй "--- как беззнаковое.

Прочие целые типы %по умолчанию
отображаются как значение в~десятичной, восьмеричной или шестнадцатеричной системе счисления.
Используемую систему счисления можно  изменить, используя манипуляторы \lstinline!hex, oct, dec! или \lstinline!setbase()!.
Манипуляторы \lstinline!hex, oct! и~\lstinline!dec! меняют вывод целых чисел (но не \lstinline!char!) на  шестнадцатеричный, восьмеричный и~десятичный соответственно.
Манипулятор \lstinline!setbase (int base)! позволяет задать основание; фактически можно выбрать только 8, 10 и~16.
Теми же манипуляторами можно задать систему счисления для ввода чисел.

Знак отображается только в~десятичной форме вывода; восьмеричная и~шестнадцатеричная формы при выводе знаковых чисел представляют собой двоичное представление числа, приведённое к~соответствующей системе счисления.
Так, число $-1$ (так как в~литерале не указан суффикс типа, число имеет тип \lstinline!int!) в~восьмеричной и~шестнадцатеричной формах соответственно выглядит как
\lstinline!37777777777! и~\lstinline!ffffffff!.

Регистр шестнадцатеричных цифр \lstinline!A..F! (а~также символа \lstinline!E! в~экспоненциальной форме вывода вещественных чисел) задаётся манипуляторами \lstinline!uppercase! и~\lstinline!lowercase!.

Манипулятор \lstinline!setfill(int ch)! 	устанавливает символ заполнения равным \lstinline!ch!.
В~частности, \lstinline!setfill('0')! указывает, что числа нужно дополнять до ширины, указанной манипулятором \lstinline!setw()! не пробелами, а~ведущими нулями.

Действие манипуляторов \lstinline!hex, oct, dec, setbase()!, \lstinline!uppercase!, \lstinline!lowercase! и~\lstinline!setfill()! не прекращается после вывода/ввода одного числа и~длится до
% задания нового основания или символа заполнения 
изменения
другим аналогичным манипулятором.

Ширина вывода устанавливается манипулятором \lstinline!setw(int w)! только для следующего выводимого значения.
Если выводимое значение не помещается в~\lstinline!w! знакомест, оно выводится целиком.

Таким образом, строка
\begin{lstlisting}[style=lstsmall]
cout << hex << setfill('0')
    << setw(4) << 10 << " " << 20 << " "
    << setw(3) << " " << setw(8) << 30 << " "
    << setw(2) << 257 << endl;
\end{lstlisting}
поместит в~поток \lstinline!cout!
\begin{lstlisting}[style=lstsmall]
000a 14 00 0000001e 101
\end{lstlisting}
манипулятор \lstinline!hex! действует на все целые числа;
\lstinline!setfill('0')! "--- на все выводимые данные, для которых ширина поля вывода превышает ширину данных (включая пробел, для которого установлена ширина поля вывода в~3 знакоместа);
манипулятор \lstinline!setw(4)! действует только на число 10 (\lstinline!0xA!), \lstinline!setw(3)! "--- только на выводимый после него пробел, \lstinline!setw(8)! "--- только на число 30 (\lstinline!0x1E!); \lstinline!setw(2)! не влияет на вывод числа 257 (\lstinline!0x101!), так как для его вывода нужно три знакоместа.

Порядок использования манипуляторов не важен.

Таким образом, вывести в~поток \lstinline!cout! первый байт по адресу \lstinline!p! в~том, виде, который использован в~окне Memory dump (две шестнадцатеричные цифры с~ведущим нулём), можно следующим образом: 
\begin{lstlisting}
unsigned char *p;
cout << hex << setfill('0') << setw(2) << static_cast<unsigned>(*p);
\end{lstlisting}
используется тип~\lstinline!unsigned char!, чтобы расширение до \lstinline!unsigned! гарантированно было беззнаковым, и~выводимое значение поместилось в~два знакоместа.

Адрес следующего элемента (с~учётом того, что \lstinline!p! "--- указатель на однобайтовый тип "--- следующего байта) равен \lstinline!p+1! и~так далее.
Соответственно, зная адрес начала переменной, можно вывести в~поток все составляющие её байты, сымитировав функциональность  окна Memory dump.

Зная размер переменной (\lstinline!sizeof(x)!), можно вывести на экран её побайтовое представление.
Оно может не совпадать с~шестнадцатеричным представлением из-за порядка байтов в~словах.
В~шестнадцатеричном представлении цифры выводятся по-арабски, от старшей к~младшей;
побайтовый вывод показывает реальный порядок байтов в~памяти (на платформе x86 "--- от младшего к~старшему), при этом  цифры каждого байта выводятся  от старшей к~младшей.

\subsubsection{Шаблоны C++}
% Для автоматизации отладочной печати можно воспользоваться  шаблонами. 
% Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.

Для автоматизации отладочной печати лучше реализовать её в~виде отдельной функции, чтобы упростить внесение изменений.
Назовём эту функцию  \lstinline!MemoryDump()!.
Пусть  \lstinline!MemoryDump()! получает в~качестве аргумента исследуемый объект \lstinline!x!, печатает данные о~нём в~стандартном потоке вывода и~возвращает ничего (\lstinline!void!).

Чтобы избежать приведения типа аргумента и,~соответственно, искажения данных о~нём,
необходима отдельная реализация \lstinline!MemoryDump()! для каждого возможного типа аргумента; 
при этом текст реализаций \lstinline!MemoryDump()! для различных типов аргументов будет полностью совпадать.
Для этого идеально подходит механизм \termin{шаблонов (templates).}
Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.
Так как нам нужно варьировать только тип аргумента, у~шаблона будет один параметр "--- имя типа аргумента функции:
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T ...x)
{
...
}
\end{lstlisting}

Для доступа к~памяти, где реально находится объект, необходимо передать этой функций указатель или ссылку на него.
С~точки зрения низкого уровня указатель и~ссылка "--- одно и~то же; на уровне C++ передача по ссылке позволит использовать те же синтаксические конструкции, что и~для исследования локальной переменной.
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T &x)
...
\end{lstlisting}
Так как планируется не изменение, а~только печать аргумента, правила хорошего тона требуют для него спецификатора \lstinline!const! (соответственно, используемый в~тексте \lstinline!MemoryDump()! указатель \lstinline!p! тоже должен быть константным):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(const T &x)
{
    const unsigned char *p 
        = reinterpret_cast<const unsigned char *>(&x);

    cout << "Type: " << typeid(x).name() << " Value: " << x << endl
	 << "Size: " << sizeof(x) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < sizeof(x); ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Эта функция позволяет вывести в~стандартный поток вывода байты любой переменной в~том порядке, в~котором они лежат в~памяти.
В~частности, результатом следующего кода:
\begin{lstlisting}[style=lstsmall]
int i = 1;
double d = 1;
long double ld = 1;

MemoryDump(i);
MemoryDump(d);
MemoryDump(ld);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: i Value: 1
Size: 4
Dump: 01 00 00 00 

Type: d Value: 1
Size: 8
Dump: 00 00 00 00 00 00 F0 3F 

Type: e Value: 1
Size: 12
Dump: 00 00 00 00 00 00 00 80 FF 3F 00 00 
\end{lstlisting}
Для каждого такого вызова компилятор формирует отдельную функцию "---  реализацию шаблона \lstinline!MemoryDump()! для конкретного типа аргумента.  
Такие реализации перегружают друг друга и~имеют одно имя для C++; с~точки зрения линкера разные реализации имеют разные имена, так как по-разному декорируются.

При вызове шаблонной функции  \lstinline!MemoryDump()! конкретная вызываемая реализация определяется типом передаваемого фактического параметра.
Указывать реализацию явно (например, \lstinline!MemoryDump<int>(i)!) здесь не только не нужно, но и~вредно "--- если указанный тип реализации не совпадёт с~настоящим типом передаваемого параметра, результат будет некорректен.

Для указателя данная функция выведет размер и~представление в~памяти самой переменной-указателя, а~не тот фрагмент памяти, куда он указывает.
Если необходимо напечатать именно память, на которую указывает аргумент, необходимо модифицировать функцию (\lstinline!CellCount! "--- количество ячеек типа \lstinline!T! по адресу \lstinline!px!):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void PointerMemoryDump(T *px, int CellCount)
{
    const unsigned char *p
        = reinterpret_cast<const unsigned char *>(px);

    size_t BytesCount = sizeof(*px)*CellCount;

    cout << "Type: " << typeid(px).name() << " Value: " << px << endl
	 << "Size: " << sizeof(px) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < BytesCount; ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Тогда результатом кода:
\begin{lstlisting}[style=lstsmall]
char *s = "abcdef";

MemoryDump(s);
PointerMemoryDump(s,8);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: Pc Value: abcdef
Size: 4
Dump: 08 96 04 08 

Type: Pc Value: abcdef
Size: 4
Dump: 61 62 63 64 65 66 00 54
\end{lstlisting}
% \section{Порядок выполнения лабораторной работы}
% Выполните задания, оформите отчёт и~покажите работу преподавателю.

% \section{Требования}
% \begin{enumerate}
% \item При подготовке к~работе (дома) студент должен подготовить конспект, содержащий: название
% работы, выполненные теоретически задания \reflocal{task:intcode}--\reflocal{task:char} и~тексты программы (или набора программ) для заданий \reflocal{task:prog:start}--\reflocal{task:prog:end}.
% 
% \item При выполнении работы оформите отчёт. %, дополнив конспект ответами на вопросы, которые
% указаны в~тексте соответствующих заданий (синим цветом). 
% Также проверьте, соответствуют ли
% ваши теоретические результаты практическим результатам для заданий \reflocal{task:intcode}--\reflocal{task:char}.
% % Объясните   расхождения
% 
% Объясните совпадения и~различия результатов на разных платформах.
% \end{enumerate}

\input{labs/c-macro}

\section{Вопросы}
\begin{enumerate}
\item Как представляется символьная информация в~компьютере в~кодах ASCII, расширениях ASCII и~различных кодировках Unicode?
\item Как хранятся русские буквы в~«классических» и~«широких» строках?
\item Как представляются целые числа со знаком и~без знака?
\item Как перевести число в~дополнительный код?
\item Как выполняются логические операции и~сдвиги над строкой битов?
\item Что такое расширение чисел со знаком и~без знака? Для чего нужны операции расширения?
\item Для чего нужно знать %, какой 
порядок следования байтов на вашем компьютере?
% \item Уметь пользоваться окнами Watch и~Memory в~отладчике используемой вами IDE.
\end{enumerate}





\section{Справочные материалы}

\subsection{Тексты}
\begingroup
\lstset{keywordstyle=}


\begin{enumerate}

\item Черновик стандарта C
% (latest publically available version of the C11 standard) 
(последняя общедоступная версия C11)
"---
\lstinline!n1570.pdf!

\item
Черновик стандарта C++ 
% (C++14 standard plus minor editorial changes) 
(C++14 с~незначительными редакторскими правками)
"---
November 2014 working draft.
\lstinline!n4296.pdf!

\item IEEE 754 "--- стандарт двоичной арифметики
с плавающей точкой
"---
IEEE Std 754™-2008
(Revision of 
IEEE Std 754-1985)
IEEE Standard for Floating-Point 
Arithmetic.
\lstinline!IEEE754_FP2008.pdf!



\end{enumerate}
\endgroup

\subsection{Коды ASCII}
\labellocal{sec:ascii}
\bigskip

\input{labs/ascii}
