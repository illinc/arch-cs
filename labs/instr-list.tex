\begin{longtable}{|l|L|}
\hline
\thead{Команда} & \thead{Действие}  %& \thead{Флаги} 
\\\hline

mov src, dest & Копирует src в~dest.

% Операнды src и~dest могут быть переменными в~памяти (но не оба одновременно) 
% или регистрами,
% src "--- ещё и~константой.
Операнд src может быть константой, переменной в~памяти или регистром;
dest "--- переменной в~памяти или регистром
% & 
\\\hline

lea src, dest & Вычисляет адрес src и~записывает его в~dest (load effective address).

dest может быть только регистром
% & 
\\\hline
\multicolumn{2}{|c|}{\textbf{Работа со стеком}}\\\hline
push arg& Помещает $arg$ в~стек (уменьшает указатель стека)
\\\hline
pop arg & Выталкивает значение из стека в~$arg$ (увеличивает указатель стека)
\\\hline
\multicolumn{2}{|c|}{\textbf{Передача управления}}\\\hline
call proc
 & Помещает в~стек адрес следующей инструкции (адрес возврата) и~переходит по адресу proc
\\\hline
ret [val] & Снимает со стека адрес возврата и~помещает его в~указатель команд.

Если указан параметр val, снимает со стека ещё val байтов.
\\\hline
\multicolumn{2}{|c|}{\textbf{Арифметические операции}}\\\hline
inc arg & \lstinline!++!$arg$ (выполняется быстрее add)
\\\hline
dec arg & \lstinline!--!$arg$ (выполняется быстрее sub)
\\\hline
add src, dest & $dest := dest + src$
% & 
\\\hline
adc src, dest & $dest := dest + src + carry flag$
% & 
\\\hline
sub src, dest & $dest := dest - src$
% & 
\\\hline
sbb src, dest & $dest := dest - (src + carry flag)$
% & 
\\\hline
mul arg & Беззнаковое умножение. %регистра A на arg. 
В~зависимости от размера arg:

4 байта: $EDX:EAX := EAX*arg$

2 байта: $DX:AX := AX*arg$

1 байт: $AX := AL*arg$

arg "--- регистр или переменная в~памяти
% & 
\\\hline
imul arg & Знаковое умножение, аналогично mul
\\\hline
imul src, dest & Знаковое умножение $dest := dest*src$
\\\hline
imul aux, src, dest & Знаковое умножение $dest := aux*src$, aux "--- константа
\\\hline

div arg & Беззнаковое деление с~остатком.
В~зависимости от размера arg:

4 байта: $\left\{\begin{array}{l}
EAX := (EDX:EAX)/arg \\
EDX := (EDX:EAX)\%arg \\
\end{array}\right.$

2 байта: $\left\{\begin{array}{l}AX := (DX:AX)/arg\\ DX := (DX:AX)\%arg\end{array}\right.$

1 байт: $\left\{\begin{array}{l}AL := AX/arg\\ AH := AX\%arg\end{array}\right.$

arg "--- регистр или переменная в~памяти
\\\hline
idiv arg & Знаковое деление с~остатком, аналогично div
\\\hline
cdq & Знаковое расширение регистра \EAX{}  в~пару регистров \EDX:\EAX{} (convert double-word to quad-word)
\\\hline
cwd & Знаковое расширение регистра \lstinline!AX!  в~пару регистров \lstinline!DX:AX!

(convert word to double-word)
\\\hline
cbw & Знаковое расширение регистра \lstinline!AL!  до \lstinline!AX!
% 
(convert byte to word)
\\\hline
cwde & Знаковое расширение регистра \lstinline!AX!  до \lstinline!EAX!
\\\hline
% neg arg
% 
% Arithmetically negates the argument (i.e. two's complement negation).



\multicolumn{2}{|c|}{\textbf{Битовые операции}}\\\hline
not arg & Побитовая инверсия\hfill \lstinline!arg := ~arg!
\\\hline
and src, dest & Побитовое «и»\hfill \lstinline!dest := dest & src!
\\\hline
or src, dest & Побитовое «или» \hfill\lstinline!dest := dest | src!
\\\hline
xor src, dest & Побитовое «исключающее или» \hfill \lstinline!dest := dest ^ src!
\\\hline
shr src, dest & Беззнаковый сдвиг вправо\hfill \lstinline!dest := (unsigned)dest >> src! 

Освободившиеся старшие разряды заполняются нулями, младшие теряются, кроме последнего, который попадает в~\lstinline!carry flag!

Эквивалентно беззнаковому делению на $2^{src}$ (остаток не вычисляется).
\\\hline
sar src, dest & Знаковый (арифметический) сдвиг вправо\hfill \lstinline!dest := (signed)dest >> src! 

Освободившиеся старшие разряды заполняются знаковым битом, младшие теряются, кроме последнего, который попадает в~\lstinline!carry flag!

Эквивалентно знаковому делению на $2^{src}$ (остаток не вычисляется).
\\\hline
\adjustbox{valign=t}{\begin{tabular}{@{}l@{}}
shl src, dest 
\\
sal src, dest
\end{tabular}}
& Сдвиг влево (shl и~sal "--- синонимы) \hfill \lstinline!dest := dest << src! 

Освободившиеся младшие разряды заполняются нулями, старшие теряются, кроме последнего, который попадает в~\lstinline!carry flag!.

Эквивалентно умножению на $2^{src}$ (если результат умножения помещается в~dest%. Если не помещается, старшая часть теряется
)
\\\hline
% 
% 
% shl src, dest  &\multirow{ 2}{0.7\linewidth}{ Сдвиг влево (shl и~sal "--- синонимы) \hfill \lstinline!dest := dest << src! 
% % 
% Освободившиеся младшие разряды заполняются нулями, старшие теряются, кроме последнего, который попадает в~\lstinline!carry flag!}
% \\
% sal src, dest&\\\hline




\end{longtable}




