\section{Точка входа на ассемблере и~использование stdlib}

Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.

Минимальная программа с~использованием стандартной библиотеки stdlib:
\begin{lstlisting}
.globl main // точка входа (stdlib)
main:
     xorl %eax, %eax // EAX ^= EAX, то есть EAX = 0
     ret // return EAX
\end{lstlisting}
Команда ret, в~отличие от оператора return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах всегда подразумевается в~регистре \lstinline!%eax!, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр \lstinline!%eax! (в~данном случае это делается при помощи побитового исключающего «или»).

Эквивалент данной программы на С++  выглядит следующим образом:
\begin{lstlisting}
int main()
{
    return 0;
}
\end{lstlisting}

Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции \lstinline!printf! библиотеки stdlib
\begin{lstlisting}
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на ассемблере выглядит следующим образом:
\begin{lstlisting}
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    movl $0, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются. 

Параметры функции \lstinline!printf! в~соответствии с~соглашением cdecl передаются через стек (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).


Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению cdecl эти параметры передаются в~обратном порядке (то есть на вершине стека оказывается первый):
\begin{lstlisting}
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  movl $0, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~\lstinline!%esp!, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности, \lstinline!%eax!) меняется.


