\chapter{Использование массивов}
\setlablabel{array}
\purpose{
ознакомиться с~расположением элементов массива в~памяти компьютера; 
научиться обрабатывать массивы, используя ассемблер.
}

% \section{Варианты заданий}
\begin{tasks}


\item
Cоздайте, используя язык высокого уровня, массив целых чисел.

Изучите расположение элементов массива (используя возможности языка высокого уровня или IDE). %, а~также общий размер массива.
\begin{enumerate}
\item Каков размер элемента (в байтах)?
\item Насколько отличаются адреса соседних элементов массива (в байтах)? 
\item Одинаково или различно это расстояние для разных элементов массива?
\item Каков общий размер массива (в байтах)?
\item Как получить адрес элемента массива, зная его номер и~адрес начала массива?
\end{enumerate}

\item Обработайте массив целых чисел (выделение памяти и~заполнение массива может быть выполнено на языке высокого уровня).

\begin{variants}[varmain]
Найти минимальный элемент массива
\next
Найти максимальный элемент массива
\next
Найти сумму элементов массива
\end{variants}


\item
\labellocal{task:keyval:debug}
Cоздайте, используя язык высокого уровня, массив структур, содержащих целый ключ и~вещественное значение. % или набор значений.
% \begin{variants}[vardebug]
% Структура содержит ключ и~одно вещественное число.
% \next
% Структура содержит ключ и~комплексное число $(re,im)$.
% \end{variants}

Определите размер массива и~расположение элементов (используя возможности языка высокого уровня или IDE).
\begin{enumerate}
\item Каков размер структуры (в байтах)?
\item Каковы размеры полей структуры (в байтах)?
\item Насколько отличаются адреса соседних полей структуры (в байтах)? 
% \item Одинаково или различно это расстояние для разных полей?
\item Каков общий размер массива (в байтах)?
% \item Как получить адрес элемента массива, зная его номер и~адрес начала массива?
\item Как получить адрес поля элемента массива, зная номер элемента, адрес начала массива и~имя поля?
\end{enumerate}

% Поменяйте местами поля структуры. Изменилось ли что-нибудь?

% \item \bonus{+2 балла}  
% создайте две функции, выполняющие одинаковые действия над двумя массивами структур, содержащих целый ключ и~%одно или несколько вещественных значений
% вещественное значение (10-байтного расширенного типа)
% % из раздела \reflocal{task:keyval:debug}
% (например, подсчёт суммы значений для нечётных ключей).
% % 
% Функции должны различаться только типом аргумента-массива, массивы "--- только порядком полей в~структурах-элементах.
% 
% Сравните ассемблерный код и~время выполнения функций.


\item 
% \bonus{(+1 балл)}  
\labellocal{task:align:asm}
Cоздайте, используя язык высокого уровня, массив структур, содержащих целый ключ и~одно однобайтовое символьное значение. 
\begin{enumerate}
\item Каков размер структуры (в байтах)?
\item Каковы размеры полей структуры (в байтах)?
\item Насколько отличаются адреса соседних полей структуры (в байтах)? 
\item Почему поля располагаются в~памяти именно так?
\item Как получить адрес поля элемента массива, зная номер элемента, адрес начала массива и~имя поля?
\end{enumerate}



\item 
\bonus{+2 балла}  
\labellocal{task:keyval:asm}
Создайте массив структур, содержащих целый ключ и~вещественное значение или набор значений.
Опишите ассемблерную функцию, обрабатывающую этот массив (реализация варианта в~виде вставки, а~не функции, принесёт не более $+1$ балла вместо $+2$).
Адрес и~длина массива должны передаваться в~функцию как параметры.

\begin{variants}[varbonus]
Структура содержит ключ и~одно вещественное число.

Функция получает эталонное значение ключа E и~нормирует соответствующие ключу значения.
После обработки сумма всех значений с~ключом, равным E, должна быть равна 1.
\next
Структура содержит ключ и~комплексное число $(re,im)$.

Изменить ключ каждой структуры на номер квадранта, где располагается число (или на 0, если число лежит на одной из осей).
Вернуть количество точек I квадранта.
\end{variants}

\item 
\bonus{+2 балла} 
Опишите ассемблерную вставку либо функцию, инициализирующую массив заданной длины $N$ первыми  $N$ элементами последовательности из задания~\ref{lab:jmp:progression} лабораторной работы \ref{lab:jmp}.

\end{tasks}

\section{Дополнительные бонусные и~штрафные баллы}

$-2$ балла за \emph{каждое} использование команд \lstinline!loop*!, \lstinline!jcx*! или  \lstinline!jecx*!.
% % http://mar.ugatu.su/assets/files/Arc/lab/asm.pdf
% % На  современных  процессорах  организация  цикла  с  помощью  команд  DEC/ JNZ/JZ предпочтительна с 
% % точки  зрения  производительности;  в  сумме  они  будут  работать  в  два  раза  быстрее,  нежели  одна 
% % инструкция  LOOP.
% 
% Хотя команды  \lstinline!loop*! занимают меньше места, чем комбинация команды \lstinline!dec! с~условным переходом \lstinline!jz/jnz!, но последняя выполняется вдвое быстрее, чем \lstinline!loop*!.
% % 
% Кроме того, организация цикла при помощи явной модификации счётчика и~условных переходов более гибка и,~в~частности, позволяет организовать вложенный цикл.

$-4$ балла за \emph{каждую} утечку памяти (то есть выделенный, но не освобождённый блок динамической памяти).


% $+1$ балл за достаточные комментарии и~хорошее оформление кода


% 
% \section{Адресация}
% 
% Эффективный адрес (32-разрядный) образуется путём суммирования трёх компонентов: базы, индекса и смещения (Base, Index, Displacement), причём возможно умножение индекса на масштаб (Scale):
% $$
% \text{Адрес} = Base + Scale \cdot Index + Displacement
% $$
% где  база и~индекс "--- регистры, $\alpha$ и~$\beta$ "--- числа, $\alpha = 2^{A}$ (и~не более $8$)

\section{Одномерные массивы}
\index{Массивы!одномерные}

Массив "---  структура данных в~виде набора однородных компонентов (элементов массива), расположенных в памяти непосредственно друг за другом. 
Элемент с~наименьшим индексом располагается по младшему адресу.
% 
Доступ к~отдельным элементам массива осуществляется с помощью индексации, то есть через ссылку на массив с~указанием номера (индекса) нужного элемента. 


В~языке C++ наименьший индекс массива всегда равен $0$, а~имя массива %фактически 
является константным указателем на его начало.
Таким образом, адрес $i$-го элемента массива $M$ равен $M + i\cdot size$, где~$size$ "--- размер одного элемента и,~в~случае, когда длина массива не равна нулю, может быть определён как \lstinline!sizeof(M[0])!.
% Если массив содержит элементы простых типов 
Для большинства простых типов
(\lstinline!char, bool, short, int, long, long long, float, double, size_t, ptrdiff_t, void*!)
этот размер как на 32-, так и~на 64-битной платформе равен~$1, 2, 4$ или~$8$.

Соответственно, в~ассемблере для получения элемента массива (если элементы массива имеют размер~$1, 2, 4$ или~$8$) будут использованы три из~четырёх компонент эффективного адреса \lstinline!displacement(base, index, multiplier)! "---  база (адрес начала массива~$M$), индекс и~масштаб (размер~элемента).
\index{Адресация!косвенная}

В~частности, адрес $i$-го элемента массива  $M$ из~чисел типа \lstinline!int! на 32-разрядных и~многих 64-разрядных платформах равен $M + i\cdot 4$, и~элемент будет записан как~\lstinline!(M, i, 4)!. При этом база~$M$ и~индекс~$i$ должны быть 32-разрядны (на соответствующей платформе) и~располагаться в~регистрах:
\begin{lstlisting}
const int N = 8;
int M[N], i = 0;
asm
(
"movl $0, (%[M], %[I], 4)\n"
:[I]"+r"(i)
:[M]"r"(M)
:"memory"
);
\end{lstlisting}
Так как мы модифицируем во вставке элементы массива (а~не сами параметры \lstinline![I]! и~\lstinline![M]!), необходимо указать в~списке перезаписываемых элементов специальное значение \lstinline!"memory"!.

В~приведённом выше коде на тип~\lstinline!int! у~элементов~массива указывают как суффикс~\lstinline!l! у~команды, так и~масштаб~\lstinline!4! при вычислении адреса.
Обе характеристики важны: попытка опустить суффикс команды приведёт к~ошибке, так как ни один из операндов~команды~\lstinline!mov! здесь не является регистром и,~следовательно, не имеет определённого размера. %, по которому можно было бы понять разрядность команды

Также %обе характеристики 
суффикс и~вычисление адреса
должны соответствовать друг другу: хотя  команды~\lstinline!movw $0, (%[M], %[I], 4)! и~\lstinline!movl $0, (%[M], %[I], 2)! синтаксически корректны и~не вызовут ошибок компиляции\footnote{Ошибка возможна при использовании здесь суффикса~\lstinline!s! вместо~\lstinline!w!, хотя в~целом они оба для команд CPU равноправны и~обозначают 16-битное целое, так как существует отдельная команда~\lstinline!movs! с~поведением, отличным от~\lstinline!mov!},  обе они при обработке массива из элементов типа~\lstinline!int! некорректны по смыслу.
Команда~\lstinline!movw $0, (%[M], %[I], 4)! запишет по адресу~$M[i]$ 16-битный ноль, который инициализирует только младшие два байта из четырёх%, зарезервированных за~$M[i]$
; таким образом, значение элемента~$M[i]$ останется неопределённым. % и,~фактически, элемент  
Команда~\lstinline!movl $0, (%[M], %[I], 2)! перезапишет не~$M[i]$, а~либо элемент~$M[i/2]$ (для чётного~$i$), либо два старших байта 
% половину 
одного элемента и~два младших следующего  (для нечётного~$i$).

Избавиться от явного указания суффикса и~масштаба можно, используя модификаторы параметров:
\begin{lstlisting}
const int N = 8;
short M[N];
int i = 3;
asm
(
"mov%z[el_type] $0, (%[M], %[I], %c[el_size])\n"
:[I]"+r"(i)
:[M]"r"(M), [el_size]"i"(sizeof(M[0])), [el_type]"m"(M[0])
: "memory"
);
\end{lstlisting}
Такой код будет компилироваться и~выполняться корректно для любого типа элементов массива~$M$, причём для типа~\lstinline!short! выбирается тот из синонимичных суффиксов, который не вызовет неоднозначности с~командой~\lstinline!movs!.
К~сожалению, это потребовало введения двух новых входных параметров: константа~\lstinline![el_size]! для масштаба~\lstinline!sizeof(M[0])! и~\lstinline![el_type]!, равный~\lstinline!M[0]!, для определения суффикса размера (так как ни один из ранее использованных параметров
"--- ни указатель~$M$, ни индекс~$i$ "---
в~общем случаем не совпадает~по размеру с~элементом массива%: $M$ "--- указатель, индекс~$i$ "--- \lstinline!size_t!, то есть их размер определяется платформой и~компилятором, а~не типом элемента
).

Масштаб, равный~$1$, может быть опущен.
Таким образом, если размер элемента равен~$1$, то адрес $i$-го элемента массива  $M$ равен $M + i$ и~сам элемент может быть записан и~как~\lstinline!(M, i, 1)!, и~как~\lstinline!(M, i)!.

Если размер~$size$ элемента отличен от~$1, 2, 4$ или~$8$, он не может быть масштабом при вычислении адреса; таким образом, смещение $i$-го элемента относительно начала массива%, равное $i\cdot size$, 
$$
\mathit{offset} = i\cdot size % без \mathit{} между ff дырка
$$
необходимо вычислить отдельно и~затем получить элемент как~\lstinline!(M, offset)!.
% Смещение 
Так как элементы массива, как правило, обрабатываются в~цикле, это можно сделать последовательным сложением % начального адреса
с~$size$ на каждой итерации.

\section{Многомерные массивы}
\index{Массивы!многомерные}

Если массивы с~одним индексом естественно отображаются на~одномерное адресное пространство памяти, 
то о~расположении элементов двумерного массива необходимо условиться дополнительно.

В~большинстве ЯВУ элементы статических многомерных массивов располагаются в~памяти так, что при движении от начала массива по возрастанию адресов быстрее всего меняется последний индекс. После того, как последний индекс достигнет максимального значения, увеличивается предпоследний и~так далее.

В~частности, статические двумерные массивы (матрицы) развёрнуты в~одномерный по строкам "--- сначала идёт вся нулевая строка, затем вся первая и~так далее, то есть в~массиве
\index{Массивы!матрицы}
\begin{lstlisting}
const int I = 8, J = 8;
int M[I][J];
\end{lstlisting}
адрес элемента~$M[i][j]$ равен~$M+(i\cdot J +j)\cdot size$, где $size = $\lstinline$sizeof(M[0][0])$.

При обработке всех элементов матрицы можно рассматривать её как одномерный длины~$I\cdot J$, так как все её элементы однородны и~расположены в~памяти непосредственно друг за другом. 
В~этом случае %эффективный 
индекс элемента~$M[i][j]$ в~этом массиве $index = i\cdot J +j$.
Обратное преобразование (расщепление при необходимости эффективного индекса на номера строки и~столбца) выглядит следующим образом: 
$$
\left\{
\begin{array}{l}
i = index / J\\
j = index \Mod J
\end{array}
\right.
$$
и~может быть выполнено одной командой беззнакового деления.

Динамические массивы, \index{Массивы!динамические}
память под которые выделяется из кучи с~помощью оператора new[] или функций *alloc() и~освобождается delete[]/free(), могут быть только одномерными.
При необходимости размещения в~куче многомерного массива программист вручную либо разворачивает его в~длинный одномерный, либо размещает в~древоподобной структуре данных из нескольких небольших одномерных массивов.
Способ обращения к~элементу в~таком случае зависит от способа организации данных.





\section{Вопросы}
\begin{enumerate}
\item Как располагаются в~памяти элементы массива?
\item Как найти размер массива, зная размер элемента и~их количество?
\item Что такое выравнивание полей структуры?
\item Зачем нужно выравнивание данных?

\end{enumerate}



