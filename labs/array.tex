\chapter{Использование массивов}
\setlablabel{array}
\purpose{
ознакомиться с~расположением элементов массива в~памяти компьютера; 
научиться обрабатывать массивы, используя ассемблер.
}

% \section{Варианты заданий}
\begin{tasks}


\item
Cоздайте, используя язык высокого уровня, массив целых чисел.

Изучите расположение элементов массива (используя возможности языка высокого уровня или IDE). %, а~также общий размер массива.
\begin{enumerate}
\item Каков размер элемента (в байтах)?
\item Насколько отличаются адреса соседних элементов массива (в байтах)? 
\item Одинаково или различно это расстояние для разных элементов массива?
\item Каков общий размер массива (в байтах)?
\item Как получить адрес элемента массива, зная его номер и~адрес начала массива?
\end{enumerate}

\item Обработайте массив целых чисел (выделение памяти и~заполнение массива может быть выполнено на языке высокого уровня).

\begin{variants}[varmain]
Найти минимальный элемент массива
\next
Найти максимальный элемент массива
\next
Найти сумму элементов массива
\end{variants}


\item
\labellocal{task:keyval:debug}
Cоздайте, используя язык высокого уровня, массив структур, содержащих целый ключ и~вещественное значение. % или набор значений.
% \begin{variants}[vardebug]
% Структура содержит ключ и~одно вещественное число.
% \next
% Структура содержит ключ и~комплексное число $(re,im)$.
% \end{variants}

Определите размер массива и~расположение элементов (используя возможности языка высокого уровня или IDE).
\begin{enumerate}
\item Каков размер структуры (в байтах)?
\item Каковы размеры полей структуры (в байтах)?
\item Насколько отличаются адреса соседних полей структуры (в байтах)? 
% \item Одинаково или различно это расстояние для разных полей?
\item Каков общий размер массива (в байтах)?
% \item Как получить адрес элемента массива, зная его номер и~адрес начала массива?
\item Как получить адрес поля элемента массива, зная номер элемента, адрес начала массива и~имя поля?
\end{enumerate}

% Поменяйте местами поля структуры. Изменилось ли что-нибудь?

% \item \bonus{+2 балла}  
% создайте две функции, выполняющие одинаковые действия над двумя массивами структур, содержащих целый ключ и~%одно или несколько вещественных значений
% вещественное значение (10-байтного расширенного типа)
% % из раздела \reflocal{task:keyval:debug}
% (например, подсчёт суммы значений для нечётных ключей).
% % 
% Функции должны различаться только типом аргумента-массива, массивы "--- только порядком полей в~структурах-элементах.
% 
% Сравните ассемблерный код и~время выполнения функций.


\item 
% \bonus{(+1 балл)}  
\labellocal{task:align:asm}
Cоздайте, используя язык высокого уровня, массив структур, содержащих целый ключ и~одно однобайтовое символьное значение. 
\begin{enumerate}
\item Каков размер структуры (в байтах)?
\item Каковы размеры полей структуры (в байтах)?
\item Насколько отличаются адреса соседних полей структуры (в байтах)? 
\item Почему поля располагаются в~памяти именно так?
\item Как получить адрес поля элемента массива, зная номер элемента, адрес начала массива и~имя поля?
\end{enumerate}



\item 
\bonus{+2 балла}  
\labellocal{task:keyval:asm}
Создайте массив структур, содержащих целый ключ и~вещественное значение или набор значений.
Опишите ассемблерную функцию, обрабатывающую этот массив (реализация варианта в~виде вставки, а~не функции, принесёт не более $+1$ балла вместо $+2$).
Адрес и~длина массива должны передаваться в~функцию как параметры.

\begin{variants}[varbonus]
Структура содержит ключ и~одно вещественное число.

Функция получает эталонное значение ключа E и~нормирует соответствующие ключу значения.
После обработки сумма всех значений с~ключом, равным E, должна быть равна 1.
\next
Структура содержит ключ и~комплексное число $(re,im)$.

Изменить ключ каждой структуры на номер квадранта, где располагается число (или на 0, если число лежит на одной из осей).
Вернуть количество точек I квадранта.
\end{variants}

\item 
\bonus{+2 балла} 
Опишите ассемблерную вставку либо функцию, инициализирующую массив заданной длины $N$ первыми  $N$ элементами последовательности из задания~\ref{lab:jmp:progression} лабораторной работы \ref{lab:jmp}.

\end{tasks}

\section{Дополнительные бонусные и~штрафные баллы}

$-2$ балла за \emph{каждое} использование команд \lstinline!loop*!, \lstinline!jcx*! или  \lstinline!jecx*!.
% % http://mar.ugatu.su/assets/files/Arc/lab/asm.pdf
% % На  современных  процессорах  организация  цикла  с  помощью  команд  DEC/ JNZ/JZ предпочтительна с 
% % точки  зрения  производительности;  в  сумме  они  будут  работать  в  два  раза  быстрее,  нежели  одна 
% % инструкция  LOOP.
% 
% Хотя команды  \lstinline!loop*! занимают меньше места, чем комбинация команды \lstinline!dec! с~условным переходом \lstinline!jz/jnz!, но последняя выполняется вдвое быстрее, чем \lstinline!loop*!.
% % 
% Кроме того, организация цикла при помощи явной модификации счётчика и~условных переходов более гибка и,~в~частности, позволяет организовать вложенный цикл.

$-4$ балла за \emph{каждую} утечку памяти (то есть выделенный, но не освобождённый блок динамической памяти).


% $+1$ балл за достаточные комментарии и~хорошее оформление кода


% 
% \section{Адресация}
% 
% Эффективный адрес (32-разрядный) образуется путём суммирования трёх компонентов: базы, индекса и смещения (Base, Index, Displacement), причём возможно умножение индекса на масштаб (Scale):
% $$
% \text{Адрес} = Base + Scale \cdot Index + Displacement
% $$
% где  база и~индекс "--- регистры, $\alpha$ и~$\beta$ "--- числа, $\alpha = 2^{A}$ (и~не более $8$)


% \section{Доступ к~элементам массивов в~памяти}
% \section{Временн\'{ы}е характеристики памяти}
\section{Выравнивание данных}


Хотя оперативная память "--- устройство с~произвольным доступом, то есть возможно читать значения по любым адресам в~любом порядке, время доступа различается в~зависимости от расположения данных.
% 
Конкретные особенности временн\'{ы}х характеристик обращения к~оперативной памяти зависят от особенностей процессора и~чипсета.


Тем не менее, есть несколько общих правил, позволяющих не потерять в~производительности слишком сильно.

\begin{enumerate}

\item Выравнивание.
Фактически процессор не работает с~данными, взятыми напрямую из оперативной памяти.
При чтении данные поступают в~сверхоперативную память (кэш); изменения вначале фиксируются в~кэше, затем попадают в~оперативную память.
Обмен между памятью и~кэшем производится пакетами, длина которых %различна для разного аппаратного обеспечения, но 
составляет от~$32$ до~$128$ байт.
% и~всегда составляет круглое (равное~$2^r$) количество байт. 
Начало пакета кратно его длине.
% 
Таким образом, если элемент попадает на границу таких блоков-пакетов, для его загрузки потребуется два запроса к~памяти.

% читаются и~записываются в~оперативную память

Чтобы избежать таких ситуаций, достаточно (хотя и~не всегда необходимо), чтобы граница между элементами в~памяти была кратна определённому числу.

% \cite{nezumi-memory} Техника оптимизации программ. Эффективное использование памяти
\noindent\begin{tabularx}{\linewidth}{|l@{~}L|L@{~}l|}
\hline
\multicolumn{2}{|c|}{\thead{Размер данных}} & \multicolumn{2}{c|}{\thead{Граница}} \\\hline
1 байт &(8 бит) & Произвольная  &\\\hline
2 байта &(16 бит) & Кратная 2 байтам  &\\\hline
4 байта &(32 бита) & Кратная 4 байтам  &\phantom{4 байта} \\\hline
8 байт &(64 бита) & Кратная 8 байтам  &\\\hline
10 байт &(80 бит) & Кратная 16 байтам  &\\\hline
16 байт &(128 бит) & Кратная 16 байтам  &\\\hline
\end{tabularx}
% \bigskip

По умолчанию в~C++ размер простых типов (кроме $long~double$) соответствует этим значениям.
Десятибайтовый тип $long~double$ может иметь размер ($sizeof$) как 16, так и~12 байт; в~последнем случае он выравнивается на 4~байта (а~компилятор MS~VC полагает $long~double = double$, таким образом и~размер, и~величина выравнивания там равны~8).


\item Обход %большого количества 
последовательно расположенных элементов в~порядке возрастания адресов выполняется быстрее, чем в~обратном.

\end{enumerate}


\section{Структуры и~объекты}

Структуры и~объекты в~C++ сочетают в~себе несколько в~общем случае разнородных компонент (полей), расположенных в~определённом порядке.
Доступ к~отдельным полям структуры на ЯВУ осуществляется по имени.
При обработке на языке ассемблера придётся использовать смещение поля относительно начала структуры, которое будет зависеть не только от состава структуры, но и~от компилятора и~его настроек. 

Обычно поля следуют в~порядке объявления и~начало поля %типа $T$ 
кратно некоторой величине, значение которой для конкретного поля/типа, а~также текущей версии и~настроек в~GCC можно получить с~помощью оператора \lstinline!__alignof__! (синтаксис аналогичен \lstinline$sizeof$).
При этом между началом одного поля и~концом предыдущего может образоваться промежуток, также промежуток может образоваться после последнего элемента структуры.
Соответственно, размер структуры может быть больше суммы размеров её полей; также размер структуры может меняться от перестановки полей между собой.
% При описании структур и~

% неверно
% По умолчанию на x86 максимальное значение кратности выравнивания (часто называемое просто выравниванием) равно~4. 
% В~этом случае данные размера 4~байта и~более выравниваются на~4~байта, то есть адрес начала такой переменной или поля будет кратен~4.
% Двухбайтовые данные выравниваются на~2, однобайтовые "--- на~1~байт.

{
% Уменьшить
Изменить
максимальную кратность выравнивания (часто называемую просто выравниванием) в~GCC можно с~помощью флага компиляции~\lstinline$-fpack-struct[=n]$.
Также GCC для совместимости с~компиляторами MS Windows поддерживает набор директив препроцессора \lstinline$#pragma pack$, позволяющих задать различную кратность выравнивания для различных определений типов:
\sloppy

}

% https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Structure-Packing-Pragmas.html
\begin{itemize}
\item \lstinline$#pragma pack(n)$ %simply sets the new alignment.
просто устанавливает новое значение выравнивания;

\item \lstinline$#pragma pack()$ %sets the alignment to the one that was in effect when compilation started (see also command-line option -fpack-struct[=n] see Code Gen Options).
возвращает выравнивание по умолчанию (возможно, заданное~\lstinline$-fpack-struct[=n]$);

\item \lstinline$#pragma pack(push[,n])$ %pushes the current alignment setting on an internal stack and then optionally sets the new alignment.
сохраняет текущее выравнивание во внутреннем стеке и,~при заданном~$n$, устанавливает новое значение

\item \lstinline$#pragma pack(pop)$ %restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and finalized by a single #pragma pack(pop). 
восстанавливает выравнивание из вершины внутреннего стека (и~удаляет эту запись оттуда).
\end{itemize}
Не рекомендуется 
уменьшать кратность выравнивания, 
%изменять настройки выравнивания%(особенно директивой \lstinline$#pragma pack$, %позволяющей получить несовместимый результат без изменения описания
% приводящей к~несовместимости одинаково описанных структур)
% , 
так как это может замедлить работу программы или даже нарушить её работоспособность.
При необходимости записи структуры в~файл для избавления от дыр неопределённого размера лучше воспользоваться покомпонентной записью.

Для придания размеру дыр определённости необходимо по возможности описывать поля структуры в~таком порядке (и,~возможно, добавить ещё несколько неиспользуемых полей), чтобы границы между полями независимо от настроек выравнивания совпадали с~рекомендуемыми значениями.

\section{Одномерные массивы}
\index{Массивы!одномерные}

Массив "---  структура данных в~виде набора однородных компонент (элементов массива), расположенных в памяти непосредственно друг за другом (независимо от настроек выравнивания). 
Элемент с~наименьшим индексом располагается по младшему адресу.
% 
Доступ к~отдельным элементам массива осуществляется с помощью индексации, то есть через ссылку на массив с~указанием номера (индекса) нужного элемента. 


В~языке C++ наименьший индекс массива всегда равен $0$, а~имя массива %фактически 
является константным указателем на его начало.
Таким образом, адрес $i$-го элемента массива $M$ равен $M + i\cdot size$, где~$size$ "--- размер одного элемента и,~в~случае, когда длина массива не равна нулю, может быть определён как \lstinline!sizeof(M[0])!.
% Если массив содержит элементы простых типов 
Для большинства простых типов
(\lstinline!char, bool, short, int, long, long long, float, double, size_t, ptrdiff_t, void*!)
этот размер как на 32-, так и~на 64-битной платформе равен~$1, 2, 4$ или~$8$.

Соответственно, в~ассемблере для получения элемента массива (если элементы массива имеют размер~$1, 2, 4$ или~$8$) будут использованы три из~четырёх компонент эффективного адреса \lstinline!displacement(base, index, multiplier)! "---  база (адрес начала массива~$M$), индекс и~масштаб (размер~элемента).
\index{Адресация!косвенная}

В~частности, адрес $i$-го элемента массива  $M$ из~чисел типа \lstinline!int! на 32-разрядных и~многих 64-разрядных платформах равен $M + i\cdot 4$, и~элемент будет записан как~\lstinline!(M, i, 4)!. При этом база~$M$ и~индекс~$i$ должны быть 32-разрядны (на соответствующей платформе) и~располагаться в~регистрах:
\begin{lstlisting}
const int N = 8;
int M[N], i = 0;
asm
(
"movl $0, (%[M], %[I], 4)\n"
:[I]"+r"(i)
:[M]"r"(M)
:"memory"
);
\end{lstlisting}
Так как мы модифицируем во вставке элементы массива (а~не сами параметры \lstinline![I]! и~\lstinline![M]!), необходимо указать в~списке перезаписываемых элементов специальное значение \lstinline!"memory"!.

В~приведённом выше коде на тип~\lstinline!int! у~элементов~массива указывают как суффикс~\lstinline!l! у~команды, так и~масштаб~\lstinline!4! при вычислении адреса.
Обе характеристики важны: попытка опустить суффикс команды приведёт к~ошибке, так как ни один из операндов~команды~\lstinline!mov! здесь не является регистром и,~следовательно, не имеет определённого размера. %, по которому можно было бы понять разрядность команды

Также %обе характеристики 
суффикс и~вычисление адреса
должны соответствовать друг другу: хотя  команды~\lstinline!movw $0, (%[M], %[I], 4)! и~\lstinline!movl $0, (%[M], %[I], 2)! синтаксически корректны и~не вызовут ошибок компиляции\footnote{Ошибка возможна при использовании здесь суффикса~\lstinline!s! вместо~\lstinline!w!, хотя в~целом они оба для команд CPU равноправны и~обозначают 16-битное целое, так как существует отдельная команда~\lstinline!movs! с~поведением, отличным от~\lstinline!mov!},  обе они при обработке массива из элементов типа~\lstinline!int! некорректны по смыслу.
Команда~\lstinline!movw $0, (%[M], %[I], 4)! запишет по адресу~$M[i]$ 16-битный ноль, который инициализирует только младшие два байта из четырёх%, зарезервированных за~$M[i]$
; таким образом, значение элемента~$M[i]$ останется неопределённым. % и,~фактически, элемент  
Команда~\lstinline!movl $0, (%[M], %[I], 2)! перезапишет не~$M[i]$, а~либо элемент~$M[i/2]$ (для чётного~$i$), либо два старших байта 
% половину 
одного элемента и~два младших следующего  (для нечётного~$i$).

Избавиться от явного указания суффикса и~масштаба можно, используя модификаторы параметров:
\begin{lstlisting}
const int N = 8;
short M[N];
int i = 3;
asm
(
"mov%z[el_type] $0, (%[M], %[I], %c[el_size])\n"
:[I]"+r"(i)
:[M]"r"(M), [el_size]"i"(sizeof(M[0])), [el_type]"m"(M[0])
: "memory"
);
\end{lstlisting}
Такой код будет компилироваться и~выполняться корректно для любого типа элементов массива~$M$, причём для типа~\lstinline!short! выбирается тот из синонимичных суффиксов, который не вызовет неоднозначности с~командой~\lstinline!movs!.
К~сожалению, это потребовало введения двух новых входных параметров: константа~\lstinline![el_size]! для масштаба~\lstinline!sizeof(M[0])! и~\lstinline![el_type]!, равный~\lstinline!M[0]!, для определения суффикса размера (так как ни один из ранее использованных параметров
"--- ни указатель~$M$, ни индекс~$i$ "---
в~общем случаем не совпадает~по размеру с~элементом массива%: $M$ "--- указатель, индекс~$i$ "--- \lstinline!size_t!, то есть их размер определяется платформой и~компилятором, а~не типом элемента
).

Масштаб, равный~$1$, может быть опущен.
Таким образом, если размер элемента равен~$1$, то адрес $i$-го элемента массива  $M$ равен $M + i$ и~сам элемент может быть записан и~как~\lstinline!(M, i, 1)!, и~как~\lstinline!(M, i)!.

Если размер~$size$ элемента отличен от~$1, 2, 4$ или~$8$, он не может быть масштабом при вычислении адреса; таким образом, смещение $i$-го элемента относительно начала массива%, равное $i\cdot size$, 
$$
\mathit{offset} = i\cdot size % без \mathit{} между ff дырка
$$
необходимо вычислить отдельно и~затем получить элемент как~\lstinline!(M, offset)!.
% Смещение 
Так как элементы массива, как правило, обрабатываются в~цикле, это можно сделать последовательным сложением % начального адреса
с~$size$ на каждой итерации.

\section{Многомерные массивы}
\index{Массивы!многомерные}

Если массивы с~одним индексом естественно отображаются на~одномерное адресное пространство памяти, 
то о~расположении элементов двумерного массива необходимо условиться дополнительно.

В~большинстве ЯВУ элементы статических многомерных массивов располагаются в~памяти так, что при движении от начала массива по возрастанию адресов быстрее всего меняется последний индекс. После того, как последний индекс достигнет максимального значения, увеличивается предпоследний и~так далее.

В~частности, статические двумерные массивы (матрицы) развёрнуты в~одномерный по строкам "--- сначала идёт вся нулевая строка, затем вся первая и~так далее, то есть в~массиве
\index{Массивы!матрицы}
\begin{lstlisting}
const int I = 8, J = 8;
int M[I][J];
\end{lstlisting}
адрес элемента~$M[i][j]$ равен~$M+(i\cdot J +j)\cdot size$, где $size = $\lstinline$sizeof(M[0][0])$.

При обработке всех элементов матрицы можно рассматривать её как одномерный длины~$I\cdot J$, так как все её элементы однородны и~расположены в~памяти непосредственно друг за другом. 
В~этом случае %эффективный 
индекс элемента~$M[i][j]$ в~этом массиве $index = i\cdot J +j$.
Обратное преобразование (расщепление при необходимости эффективного индекса на номера строки и~столбца) выглядит следующим образом: 
$$
\left\{
\begin{array}{l}
i = index / J\\
j = index \Mod J
\end{array}
\right.
$$
и~может быть выполнено одной командой беззнакового деления.

Динамические массивы, \index{Массивы!динамические}
память под которые выделяется из кучи с~помощью оператора new[] или функций *alloc() и~освобождается delete[]/free(), могут быть только одномерными.
При необходимости размещения в~куче многомерного массива программист вручную либо разворачивает его в~длинный одномерный, либо размещает в~древоподобной структуре данных из нескольких небольших одномерных массивов.
Способ обращения к~элементу в~таком случае зависит от способа организации данных.





\section{Вопросы}
\begin{enumerate}
\item Как располагаются в~памяти элементы массива?
\item Как найти размер массива, зная размер элемента и~их количество?
\item Что такое выравнивание полей структуры?
\item Зачем нужно выравнивание данных?

\end{enumerate}



