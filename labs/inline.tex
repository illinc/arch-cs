\chapter{Использование ассемблерных вставок в~программах на C++}
\setlablabel{inline}
\purpose{научиться вставлять в~программы на языке высокого уровня ассемблерные фрагменты.
}


\begin{tasks}

% \item  Выполните программу с~примером, печатающим строку производителя процессора.


\item\footnote{Использованы: лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной
}  

Разработайте и~выполните программу, в~которой реализуйте при помощи ассемблерной вставки
\bigskip
% \begin{itemize}
% \item для ПК 1, 5, 9, 13, 17, 21, 25: сложение целых чисел без знака;
% \itemдля ПК 2, 6, 10, 14, 18, 22, 26: сложение целых чисел со знаком;
% \itemдля ПК 3, 7, 11, 15, 19, 23: вычитание целых чисел без знака;
% \itemдля ПК 4, 8, 12, 16, 20, 24: вычитание целых чисел со знаком.
% \end{itemize}

\begin{variants}

Сложение целых чисел без знака
\next

Сложение целых чисел со знаком
\next

Вычитание целых чисел без знака
\next

Вычитание целых чисел со знаком
\next

Увеличение целого числа на 1 (инкремент)
\end{variants}


После команды сложения/вычитания проанализируйте соответствующий флаг состояния
процессора, и, в~зависимости от его значения, выведите результат и~строку «Результат верный»
(если не было переполнения) или «Результат неверный» (при переполнении).


\item %\bonus{+2 балла}
\labellocal{task:yx}
Реализовать задание лабораторной работы \ref{lab:func} (см.\,раздел \ref{lab:func:tasks}, задание~\ref{lab:func:var}) как ассемблерную вставку в~программу на C++.

\item \bonus{+2 балла}
Реализовать задание \reflocal{task:yx}, не используя в~тексте вставки конкретных имён регистров.

\end{tasks}



\section{Ассемблерные вставки в~код C++}

Для вставки одной или нескольких инструкций ассемблера используется ключевое слово \lstinline!asm!.
% 
% В~разделе 
%  [dcl.asm]
%  стандарта C++ сказано
% «An asm declaration has the form
% asm-definition:
% \lstinline!asm ( string-literal ) ;!
% The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
% is used to pass information through the implementation to an assembler. — end note ]»

Стандарт C++ описывает %синтаксис ассемблерной вставки как
использование  \lstinline!asm! следующим образом:
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}
% содержимое круглых скобок 
конкретный вид \lstinline!string-literal! 
при этом не регламентируется.
% \lstinline!asm("assembly code");!
% 
Обычно такие вставки используются для передачи кода непосредственно ассемблеру.


% Так как ассемблерный код  не стандартизирован, синтаксис 
% Синтаксис 
Содержимое
таких вставок зависит как от архитектуры целевого аппаратного обеспечения (набор команд, регистров и~т.\,д.), так и~от компилятора (мнемоники команд, порядок операндов, синтаксис и~т.\,д.).

Используемая операционная система определяет {только} обращения \emph{непосредственно к~интерфейсам операционной системы} (системные вызовы Linux и~BSD, функции API Windows~т.\,п.).
% Если не использовать напрямую интерфейсы операционной системы, 
% а~вызывать, например, функции стандартной библиотеки С/С++, методы Qt или функции, описанные в~C/C++ части проекта, ассемблерная вставка будет работать под любой операционной системой, где есть нужный компилятор (и~Qt).
% http://www.linux.org.ru/forum/development/11701125
% вставка будет собираться и~работать под любой  операционной системой. 
Вычисления, а~также обращение к~стандартной библиотеке С или к~кроссплатформенным библиотекам типа Qt описываются одинаково под любой операционной системой.

\section{Синтаксис ассемблерных вставок в~GCC}

Ассемблерная вставка в~программу, собираемую компилятором GCC, может быть описана с~использованием двух ключевых слов: \lstinline!asm!  либо \lstinline!__asm__!. Эти формы равнозначны и~используют одинаковый синтаксис. Форма \lstinline!__asm__! применяется, когда стандартное ключевое слово \lstinline!asm! конфликтует с~чем-либо в~программе.
Например:
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX := ECX
\end{lstlisting}
или
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX := BH (байт)
\end{lstlisting}
Если во вставке необходимо использовать более одной инструкции, то каждая строка помещается в~кавычки. В~конце строки помещается суффикс \lstinline!\n! для разделения инструкций (если желательно иметь красивый выходной файл, можно использовать суффикс  \lstinline!\n\t!, если форматирование выходного файла безразлично "--- суффикс \lstinline";").
% \lstinline!\n\t!, чтобы сформированный компилятором ассемблерный файл был корректно отформатирован.
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movl %ecx, $label(%edx,%ebx,$4)\n"
     "movb %ah, (%ebx)");
\end{lstlisting}
Внутри ассемблерной вставки можно обращаться по именам к~регистрам, а~также к~глобальным %и~статическим (то есть имеющим фиксированный адрес) 
переменным программы:
\begin{lstlisting}
int n = 12;

int main(){
    asm ("incl n");
    cout << n <<endl;
    return 0;
}
\end{lstlisting}
% Параметры функций 
Локальные переменные функций размещаются компилятором в~стеке (причём не всегда в~порядке объявления), поэтому к~ним необходимо обращаться, используя \emph{расширенный ассемблер GCC,} а~именно \termin{параметры вставок.}
Необходимо также учитывать, что в~регистрах, используемых во вставке, ранее компилятором могла быть размещена какая-либо регистровая переменная.
В~этом случае компилятор не определяет автоматически, что регистр изменён, что может привести к~краху программы.

% Вставка "--- не функция.

\subsection{Передача параметров в~ассемблерную вставку}

% http://www.ibm.com/developerworks/ru/library/l-linux_kernel_15/index.html
Синтаксис  вставки (расширенный) в~GCC может иметь две формы.

Первая выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}

% Ключевое слово const используется в~случае, когда выходные параметры зависят только от входных, что позволяет, в~частности, вынести блок за тело цикла при оптимизации.
% Один из случаев, когда const нельзя использовать "--- когда один из входных параметров интерпретируется как указатель. Значение по данному адресу может измениться, даже если сам адрес неизменен.

Ключевое слово volatile  
используется для того, чтобы указать компилятору, что вставляемый ассемблерный код может обладать побочными эффектами, поэтому попытки оптимизации могут привести к логическим ошибкам.
% В~частности, если необходимо не менять вставку местами с~дрк
% запрещает компилятору оптимизировать блок и~указывает вставить его как есть.

Вторая форма расширенной ассемблерной вставки имеет вид
\begin{lstlisting}[style=lstsmall]
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  

Ключевое слово goto указывает, что ассемблерный код может делать переходы на метки, перечисленные в~соответствующем разделе.

Обращение к~параметру-метке предваряется префиксом \lstinline!%l! (от \emph{label}), за которым идёт порядковый номер метки в~списке всех параметров; псевдоним для метки указать нельзя.
В~частности, данный код переходит к~метке \lstinline!carry:! (и~функция возвращает~1), если в~числе~p1 взведён бит с~номером~p2 (младший бит имеет нулевой номер).
\begin{lstlisting}[style=lstsmall]
asm goto (
    "btl %[BitIdx], %[Val]\n\t"
    "jc %l2"
    :: [Val]"r" (p1), [BitIdx]"r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда BT  копирует бит, номер которого передается вторым параметром, в~флаг CF.

% http://sysbin.com/files/lowlevel/gcc_inline_assembly.htm

Параметры указываются как \lstinline!%0!, \lstinline!%1! и~т.\,д. или как \lstinline!%[Value]!, где Value "--- определённое в~разделе %выходных 
параметров имя.
% Примечание:е
Если в коде указаны параметры, которые, как и регистры, начинаются с префикса \lstinline'%', то регистры указываются с префиксом \lstinline'%%', например, \lstinline!%%eax!.

Общее количество параметров ограничено: $input + output + goto \leqslant 30$.


\subsubsection{Выходные параметры}

Раздел выходных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

% https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands
Описание выходного параметра
в~общем случае имеет вид:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cvariablename)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда.
Область определения такого псевдонима "--- вся ассемблерная вставка.
Псевдоним может быть любым допустимым идентификатором C++.
Два разных операнда не могут использовать один псевдоним.

Псевдоним выходного параметра может быть указан как ограничение расположения входного.
В этом случае параметр с~данным псевдонимом является входным и~выходным одновременно (как правило, это изменяемая во вставке переменная).

Если псевдоним не определён, используются номер операнда, начиная с~нуля: \lstinline!%0! для первого, \lstinline!%1! для второго и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для выходного параметра начинается с~символа \lstinline!=! (если значение параметра перезаписывается) %, после которого 
или \lstinline!+! (если значение параметра используется как для чтения, так и~для записи).

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

При выборе регистра для размещения выходного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++ (lvalue), куда будет записано значение выходного параметра (обычно имя переменной).

Если для выходного параметра указано размещение в~регистре и~имя соответствующей переменной, это не значит, что переменная обязательно будет размещена в~регистре.
Возможно, в~регистре будет сформировано выходное значение, которое затем будет скопировано в~локальную стековую переменную.

\end{description}
Например, данный фрагмент записывает константу 12 в~переменную \lstinline!x_var!:
\begin{lstlisting}[style=lstsmall]
int x_var;
asm
(
    "movl $12, %[X]\n"
    :[X]"=rm"(x_var)
);
\end{lstlisting}

\subsubsection{Входные параметры}

Раздел входных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

Описание входного параметра в~общем случае:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cexpression)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда, аналогично псевдонимам выходных параметров.

Если псевдоним не определён, используются номер операнда, начиная со следующего за последним выходным параметром.
Если есть два выходных параметра, то первый входной будет обозначен \lstinline!%2! и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для входного параметра не может начинаться ни с~\lstinline!=!, ни с~\lstinline!+!.

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

Если входной параметр должен располагаться там же, где один из выходных,
расположение также может быть указано цифрой или псевдонимом данного выходного параметра.

При выборе регистра для размещения входного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++, откуда берётся значение входного параметра (также может быть именем переменной).

\end{description}

Например, конструкция:
\begin{lstlisting}[style=lstsmall]
asm ("movl %0, %%eax"::"i"(1) : "%eax");
\end{lstlisting}
превратится после компиляции %в~ассемблерном коде 
в:
\begin{lstlisting}[style=lstsmall]
movl $1, %eax
\end{lstlisting}

Данный фрагмент эквивалентен \lstinline!foo += bar!:
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
);
\end{lstlisting}
причём, если переменная foo не располагается в~регистре изначально, её значение будет скопировано в~регистр, а~после добавления bar результат будет скопирован обратно в~foo.

\subsection{Модификация входных параметров}

Модифицировать входные параметры, не являющиеся одновременно и~выходными, \termin{нельзя}.

Если возникает необходимость изменить значение, переданное как входной параметр, оно должно быть описано ещё и~как выходной.
В~следующем фрагменте \lstinline!%0! является входным и~выходным одновременно (точнее, входной параметр \lstinline!%1! располагается там же, где и~выходной \lstinline!%0!).
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
); // foo += bar
\end{lstlisting}
Аналогичные вычисления с~использованием именованных параметров (\lstinline![S]! здесь "--- и~входной и~выходной параметр) выглядят следующим образом.
% \begin{lstlisting}[style=lstsmall]
% asm("addl %[A], %[X]\n"
%     : [X]"=r"(foo)
%     :"[X]"(foo), [A]"g" (bar)
%     :"cc"
% ); // foo += bar
% \end{lstlisting}
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
\subsubsection{Перезаписываемые элементы%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\#Clobbers}%,
% {https://ru.wikipedia.org/wiki/GCC\_Inline_Assembly#.C2.ABmemory.C2.BB\_.D0.B2\_clobber\_list}
}
}

Код в~ассемблерной вставке может прямо или косвенно изменять значения не только выходных параметров, но и прочих регистров.
Эти регистры перечисляются в~списке перезаписываемых (clobber) регистров.

В~частности, команда умножения в~своей классической форме (\lstinline!%eax = %eax*src!) записывает старшую часть произведения в~\lstinline"%edx".
\begin{lstlisting}[style=lstsmall]
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}

Если во вставке явно модифицируется какой-либо регистр (что не рекомендуется; в~случае, если нужен регистр для хранения временного значения, лучше объявить фиктивный входной параметр, как описано в~следующем подразделе), его также необходимо указать в~списке перезаписываемых элементов.
% \hyperref[sss:inline:tmpreg]{qq}
\pagebreak[3]

\begin{lstlisting}
asm ("movl %0, %%eax"    
  ::"i"(1)  
  : "%eax");	// movl $1, %eax
\end{lstlisting}
\pagebreak[3]

Неуказание таких регистров в~списке перезаписываемых, скорее всего, приведёт к~тому, что компилятор поместит один из параметров вставки или переменных ЯВУ в~этот же регистр и,~соответственно, к~непредсказуемому значению в~нём. 

Специальные аргументы для списка перезаписываемых регистров:
\begin{description}
\item["cc"]
показывает, что код изменяет регистр флагов.

Флаги изменяют все арифметические инструкции.


\begin{lstlisting}[style=lstsmall]
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}



\item["memory"]
показывает, что код меняет значение в~памяти (не считая явно указанных выходных параметров) "--- например, интерпретирует какой-либо из параметров как указатель.

\begin{lstlisting}[style=lstsmall]
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}


% Помимо простого указания компилятору, что ассемблерная вставка изменяет содержимое памяти, она ещё служит директивой Memory Barrier для компилятора. Это означает, что те операции обращений в память, которые стоят выше по коду, в результирующем машинном коде будут выполняться до тех, которые стоят ниже ассемблерной вставки. В случае многопоточной среды, когда от этого напрямую зависит риск возникновения race condition, это обстоятельство является существенным.

% Кроме указания компилятору на изменение памяти,
% барьер компилятора

При указании \lstinline!"memory"! в~списке перезаписываемых элементов все операции работы с~памятью, которые были в~программе до ассемблерной вставки, выполнятся до неё, а~те, что стоят в~программе после "--- будут после.
В~противном случае компилятор может поменять местами как операторы C++, так и~ассемблерные вставки.
\end{description}


\subsubsection{Временные регистры%
\footnote{Использованы материалы:
{http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}
}
}

% \labellocal{sss::tmpreg}
% \label{sss:inline:tmpreg}

Использовать под временные данные фиксированные регистры и~указывать их в~списке  перезаписываемых не вполне корректно.

Более правильным будет ввести фиктивный выходной параметр (\lstinline!=r! или \lstinline!=&r!), так как это даст компилятору больше свободы при оптимизации.


% Так, в~программе 
% \begin{lstlisting}[style=lstsmall]
% int main()
% {
%     int a=77, b;
%     asm("movl %0, %%eax"::"d"(a));
%     asm("movl %%eax, %0":"=d"(b));
%     cout << b;
%     return 0;
% }
% \end{lstlisting}
% первая вставка записывает значение локальной переменной \lstinline!a! через регистр \EDX{} (\lstinline!"d"!) в~регистр \EAX;
% вторая "--- содержимое регистра \EAX{} записывает через регистр \EDX{} в~переменную \lstinline!b! (\lstinline!"=d"(b)!).
% То есть если вставки сохранят порядок после компиляции (что не гарантируется), программа копирует содержимое локальной переменной \lstinline!a! (77) в~локальную переменную \lstinline!b!, и~последующий оператор вывода выведет 77. 

Пересылка через временный регистр:
\begin{lstlisting}[style=lstsmall]
int src = 1, dst, tmp;
asm
(
    "movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);
\end{lstlisting}

\subsubsection{%Типы размещения параметров% 
Ограничения на расположение операнда%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Constraints.html\#Constraints}
}
}

% https://gcc.gnu.org/ml/gcc/1999-10n/msg00488.html
% Типы параметров:
Некоторые общие ограничения (типы размещения параметров):
\begin{description}
\item[r] "--- регистр; %- register
\item[m] "--- память; %- memory effective address
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); %- immediate value, 0..0xffffffff
\item[g] "--- память, регистр общего назначения или непосредственное значение (обычно этот тип эквивалентен \lstinline"rim"); %- general effective address
\item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
\end{description}

% But there are some i386-specific ones described in the processor-specific
% part of the manual and in more detail in GCC's i386.h:
Некоторые ограничения (типы), специфичные для i386 (определены в~файле i386.h GCC)
\begin{description}
\item[q] "--- регистр, который можно адресовать по байтам младшего слова (EAX, EBX, ECX, EDX); %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров  EDX:EAX;
\item[a, b, c, d, S, D] "--- регистры eax, ebx, ecx, edx, esi, edi соответственно;

\item[I..P] "--- машинно-зависимые ограничения для констант:
% \end{description}
% 
% Ограничения для констант:
% \begin{description}
% \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% %     ("i" would allow an address known only at link time)
\begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% \item[K] "--- Signed 8-bit integer constant. ?  255
% \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (сдвиги, которые может выполнить lea);
\item[N] "--- непосредственное значение в~диапазоне 0..255 (беззнаковое однобайтовое).
% \item[O] "--- непосредственное значение в~диапазоне 0..32
\end{description}
\end{description}




% \pagebreak[4]

\section{Вопросы}
\begin{enumerate}
% \item Знаковой или беззнаковой является операция инкремента?
\item Каким ключевым словом открывается ассемблерная вставка?

\item Как из ассемблерной вставки обратиться к~локальным переменным?

\item Какие вы знаете ограничения на размещение параметров ассемблерных вставок?

\end{enumerate}



\section{Справочные материалы}
\begingroup
\lstset{keywordstyle=}

\begin{enumerate}

% \item
% Расширения файлов GCC "---
% C\'{e}dric Musso. Development with GNU/Linux.
% \lstinline!GCC and File Extensions - Development with GNU_Linux - labor-liber.html!

\item
Черновик стандарта C++ 
% (C++14 standard plus minor editorial changes) 
(C++14 с~незначительными редакторскими правками)
"---
November 2014 working draft.
\lstinline!n4296.pdf!

\end{enumerate}
\endgroup





