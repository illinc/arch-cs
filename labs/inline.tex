\chapter{Использование ассемблерных вставок в~программах на C++}
\setlablabel{inline}
\purpose{научиться вставлять в~программы на языке высокого уровня ассемблерные фрагменты.
}


\begin{tasks}

% \item  Выполните программу с~примером, печатающим строку производителя процессора.


\item\footnote{Использованы: лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной
}  

Разработайте и~выполните программу, в~которой реализуйте при помощи ассемблерной вставки
\bigskip
% \begin{itemize}
% \item для ПК 1, 5, 9, 13, 17, 21, 25: сложение целых чисел без знака;
% \itemдля ПК 2, 6, 10, 14, 18, 22, 26: сложение целых чисел со знаком;
% \itemдля ПК 3, 7, 11, 15, 19, 23: вычитание целых чисел без знака;
% \itemдля ПК 4, 8, 12, 16, 20, 24: вычитание целых чисел со знаком.
% \end{itemize}

\begin{variants}

Сложение целых чисел без знака
\next

Сложение целых чисел со знаком
\next

Вычитание целых чисел без знака
\next

Вычитание целых чисел со знаком
\next

Увеличение целого числа на 1 (инкремент)
\end{variants}


После команды сложения/вычитания проанализируйте соответствующий флаг состояния
процессора, и, в~зависимости от его значения, выведите результат и~строку «Результат верный»
(если не было переполнения) или «Результат неверный» (при переполнении).


\item %\bonus{+2 балла}
\labellocal{task:yx}
Реализовать задание лабораторной работы \ref{lab:func} (см.\,раздел \ref{lab:func:tasks}, задание~\ref{lab:func:var}) как ассемблерную вставку в~программу на C++.

\item \bonus{+2 балла}
Реализовать задание \reflocal{task:yx}, не используя в~тексте вставки конкретных имён регистров.

\end{tasks}



\section{Ассемблерные вставки в~код C++}

Для вставки одной или нескольких инструкций ассемблера используется ключевое слово \lstinline!asm!.
% 
% В~разделе 
%  [dcl.asm]
%  стандарта C++ сказано
% «An asm declaration has the form
% asm-definition:
% \lstinline!asm ( string-literal ) ;!
% The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
% is used to pass information through the implementation to an assembler. — end note ]»

Стандарт C++ описывает %синтаксис ассемблерной вставки как
использование  \lstinline!asm! следующим образом:
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}
% содержимое круглых скобок 
конкретный вид \lstinline!string-literal! 
при этом не регламентируется.
% \lstinline!asm("assembly code");!
% 
Обычно такие вставки используются для передачи кода непосредственно ассемблеру.


% Так как ассемблерный код  не стандартизирован, синтаксис 
% Синтаксис 
Содержимое
таких вставок зависит как от архитектуры целевого аппаратного обеспечения (набор команд, регистров и~т.\,д.), так и~от компилятора (мнемоники команд, порядок операндов, синтаксис и~т.\,д.).

Используемая операционная система определяет {только} обращения \emph{непосредственно к~интерфейсам операционной системы} (системные вызовы Linux и~BSD, функции API Windows~т.\,п.).
% Если не использовать напрямую интерфейсы операционной системы, 
% а~вызывать, например, функции стандартной библиотеки С/С++, методы Qt или функции, описанные в~C/C++ части проекта, ассемблерная вставка будет работать под любой операционной системой, где есть нужный компилятор (и~Qt).
% http://www.linux.org.ru/forum/development/11701125
% вставка будет собираться и~работать под любой  операционной системой. 
Вычисления, а~также обращение к~стандартной библиотеке С или к~кроссплатформенным библиотекам типа Qt описываются одинаково под любой операционной системой.

\section{Синтаксис ассемблерных вставок в~GCC}

Ассемблерная вставка в~программу, собираемую компилятором GCC, может быть описана с~использованием двух ключевых слов: \lstinline!asm!  либо \lstinline!__asm__!. Эти формы равнозначны и~используют одинаковый синтаксис. Форма \lstinline!__asm__! применяется, когда стандартное ключевое слово \lstinline!asm! конфликтует с~чем-либо в~программе.

\subsection{Базовая форма}
Базовая форма ассемблерной вставки выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    );
\end{lstlisting}
Ключевое слово volatile для базовой формы не оказывает никакого эффекта, так как такая вставка не оптимизируется компилятором никогда.

Например:
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX := ECX
\end{lstlisting}
или
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX := BH (байт)
\end{lstlisting}
Если код во вставке содержит более одной строки, то каждая строка помещается в~кавычки. 
Тем не менее, этого недостаточно для разделения инструкций.

\subsubsection{Разделение инструкций}

% Несколько 
При компиляции соседние строки ассемблерной вставки склеиваются, как склеиваются части любой строковой константы "--- точно так же, как в~объявлении вида
\begin{lstlisting}
    char *s = "abcd"
        "ABCD";
\end{lstlisting}
которое задаёт строку \lstinline!"abcdABCD"!, не разделённую посередине никаким символом.
То есть вставка
\begin{lstlisting}
asm ("movl %eax, %ebx"
     "movl $56, %esi");
\end{lstlisting}
На самом деле выглядит как
\begin{lstlisting}
asm ("movl %eax, %ebxmovl $56, %esi");
\end{lstlisting}
и~вызывает логичное сообщение о некорректном имени регистра «ebxmovl».

Таким образом, если во вставке необходимо использовать более одной инструкции, то  
в~конце каждой строки необходимо поместить суффикс \lstinline!\n! для разделения инструкций (если желательно иметь красивый выходной файл, можно использовать суффикс  \lstinline!\n\t!, если форматирование выходного файла безразлично "--- можно использовать вместо  \lstinline!\n! разделитель \lstinline";").
% \lstinline!\n\t!, чтобы сформированный компилятором ассемблерный файл был корректно отформатирован.
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movl %ecx, $label(%edx,%ebx,$4)\n"
     "movb %ah, (%ebx)");
\end{lstlisting}

\subsubsection{Доступные в~базовой форме вставки имена}

Внутри ассемблерной вставки можно обращаться по именам к~регистрам, а~также к~глобальным %и~статическим (то есть имеющим фиксированный адрес) <- не получается 
переменным программы:
\begin{lstlisting}
int n = 12;

int main(){
    asm ("incl n");
    cout << n <<endl;
    return 0;
}
\end{lstlisting}
% Параметры функций 
Локальные переменные функций размещаются компилятором в~стеке (причём не всегда в~порядке объявления), поэтому к~ним необходимо обращаться, используя \emph{расширенный ассемблер GCC,} а~именно \termin{параметры вставок.}
Необходимо также учитывать, что в~регистрах, используемых во вставке, ранее компилятором могла быть размещена какая-либо регистровая переменная.
В~этом случае компилятор не определяет автоматически, что регистр изменён, что может привести к~краху программы.

\warning{
На практике описанную выше базовую форму ассемблерных вставок \mbox{(без параметров)} не стоит использовать \emph{никогда}.

Только расширенная форма даёт возможность корректного взаимодействия с~программой на ЯВУ.
}
% Вставка "--- не функция.

% \subsection{Передача параметров в~ассемблерную вставку}
\subsection{Расширенная форма} %http://www.gamedev.ru/code/articles/gcc_inline_asm?page=3

% http://www.ibm.com/developerworks/ru/library/l-linux_kernel_15/index.html
Синтаксис  вставки (расширенный) в~GCC может иметь две формы.

Первая выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}

% Ключевое слово const используется в~случае, когда выходные параметры зависят только от входных, что позволяет, в~частности, вынести блок за тело цикла при оптимизации.
% Один из случаев, когда const нельзя использовать "--- когда один из входных параметров интерпретируется как указатель. Значение по данному адресу может измениться, даже если сам адрес неизменен.

Ключевое слово volatile  
используется для того, чтобы указать компилятору, что вставляемый ассемблерный код может обладать побочными эффектами, поэтому попытки оптимизации могут привести к логическим ошибкам.
% В~частности, если необходимо не менять вставку местами с~дрк
% запрещает компилятору оптимизировать блок и~указывает вставить его как есть.

Вторая форма расширенной ассемблерной вставки имеет вид
\begin{lstlisting}[style=lstsmall]
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  

Ключевое слово goto указывает, что ассемблерный код может делать переходы на метки, перечисленные в~соответствующем разделе.

Обращение к~параметру-метке предваряется префиксом \lstinline!%l! (от \emph{label}), за которым идёт порядковый номер метки в~списке всех параметров; псевдоним для метки указать нельзя.
В~частности, данный код переходит к~метке \lstinline!carry:! (и~функция возвращает~1), если в~числе~$p1$ взведён бит с~номером~$p2$ (младший бит имеет нулевой номер).
\begin{lstlisting}[style=lstsmall]
asm goto (
    "btl %[BitIdx], %[Val]\n\t"
    "jc %l2"
    :: [Val]"r" (p1), [BitIdx]"r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда BT  копирует бит, номер которого передается вторым параметром, в~флаг CF.

% http://sysbin.com/files/lowlevel/gcc_inline_assembly.htm

Параметры указываются как \lstinline!%0!, \lstinline!%1! и~т.\,д. или как \lstinline!%[Value]!, где Value "--- определённый в~разделе %выходных 
параметров псевдоним (если параметр соответствует какой-либо переменной ЯВУ, то псевдоним может как совпадать, так и~не совпадать с~именем этой переменной).
% Примечание:е
Если в коде указаны параметры, которые, как и регистры, начинаются с префикса \lstinline'%', то регистры указываются с префиксом \lstinline'%%', например, \lstinline!%%eax!.

Общее количество параметров ограничено: $input + output + goto \leqslant 30$.


\subsubsection{Выходные параметры}

Раздел выходных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

% https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands
Описание выходного параметра
в~общем случае имеет вид:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cvariablename)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда.
Область определения такого псевдонима "--- вся ассемблерная вставка.
Псевдоним может быть любым допустимым идентификатором C++.
Два разных операнда не могут использовать один псевдоним.

Псевдоним выходного параметра может быть указан как ограничение расположения входного.
В этом случае параметр с~данным псевдонимом является входным и~выходным одновременно (как правило, это изменяемая во вставке переменная).

Если псевдоним не определён, используются номер операнда, начиная с~нуля: \lstinline!%0! для первого, \lstinline!%1! для второго и~т.\,д.
% \begin{lstlisting}[style=lstsmall]
% int x;
% asm
% (
%     "movl $12, %[x]\n"
%     :[x]"=rm"(x)
% );
% \end{lstlisting}

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для выходного параметра начинается с~символа \lstinline!=! (если значение параметра перезаписывается) %, после которого 
или \lstinline!+! (если значение параметра используется как для чтения, так и~для записи).

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

При выборе регистра для размещения выходного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++ (lvalue), куда будет записано значение выходного параметра (обычно имя переменной).

Если для выходного параметра указано размещение в~регистре и~имя соответствующей переменной, это не значит, что переменная обязательно будет размещена в~регистре.
Возможно, в~регистре будет сформировано выходное значение, которое затем будет скопировано в~локальную стековую переменную.

\end{description}
Например, данный фрагмент записывает константу 12 в~переменную~$x$:
\begin{lstlisting}[style=lstsmall]
int x;
asm
(
    "movl $12, %[x]\n"
    :[x]"=rm"(x)
);
\end{lstlisting}
начальное значение параметра \lstinline![x]! не определено.

Следующий фрагмент кода удваивает~$x$:
\begin{lstlisting}[style=lstsmall]
asm
(
    "addl %[x], %[x]\n"
    :[x]"+r"(x)
);
\end{lstlisting}
Символ  \lstinline!+! в~строке расположения указывает на то, что данный параметр является не чисто выходным, а~модифицируемым.
Начальное значение параметра \lstinline![x]! берётся из~выражения-приёмника, в~данном случае "--- переменной~$x$.
% Если бы ограничение расположения начиналось бы с~\lstinline!=!, начальное значение параметра было бы не определено.

\subsubsection{Входные параметры}

Раздел входных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

Описание входного параметра в~общем случае:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cexpression)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда, аналогично псевдонимам выходных параметров.

Если псевдоним не определён, используются номер операнда, начиная со следующего за последним выходным параметром.
Если есть два выходных параметра, то первый входной будет обозначен \lstinline!%2! и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для входного параметра не может начинаться ни с~\lstinline!=!, ни с~\lstinline!+!.

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

Если входной параметр должен располагаться там же, где один из выходных,
расположение также может быть указано цифрой или псевдонимом данного выходного параметра.

При выборе регистра для размещения входного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++, откуда берётся значение входного параметра (также может быть именем переменной).

\end{description}

Например, конструкция:
\begin{lstlisting}[style=lstsmall]
asm ("movl %0, %%eax"::"i"(1) : "%eax");
\end{lstlisting}
превратится после компиляции %в~ассемблерном коде 
в:
\begin{lstlisting}[style=lstsmall]
movl $1, %eax
\end{lstlisting}

Данный фрагмент эквивалентен \lstinline!foo += bar!:
\begin{lstlisting}[style=lstsmall]
int foo = 6, bar = 12;
asm ("addl %[bar], %[foo]"
    : [foo]"+r"(foo)
    : [bar]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
причём, если переменная foo не располагается в~регистре изначально, её значение будет скопировано в~регистр, а~после добавления bar результат будет скопирован обратно в~foo.


\subsubsection{Перезаписываемые элементы%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\#Clobbers}%,
% {https://ru.wikipedia.org/wiki/GCC\_Inline_Assembly#.C2.ABmemory.C2.BB\_.D0.B2\_clobber\_list}
}
}

Код в~ассемблерной вставке может прямо или косвенно изменять значения не только выходных параметров, но и прочих регистров.
Эти регистры перечисляются в~списке перезаписываемых (clobber) регистров.

В~частности, команда умножения в~своей классической форме (\lstinline!%eax = %eax*src!) записывает старшую часть произведения в~\lstinline"%edx".
\begin{lstlisting}[style=lstsmall]
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}

Если во вставке явно модифицируется какой-либо регистр (что не рекомендуется; в~случае, если нужен регистр для хранения временного значения, лучше объявить фиктивный входной параметр, как описано в~следующем подразделе), его также необходимо указать в~списке перезаписываемых элементов.
% \hyperref[sss:inline:tmpreg]{qq}
% \pagebreak[3]
% 
\begin{lstlisting}
asm ("movl %[One], %%eax"    
  ::[One]"i"(1)  
  : "%eax");	// movl $1, %eax
\end{lstlisting}
\pagebreak[3]

Неуказание таких регистров в~списке перезаписываемых, скорее всего, приведёт к~тому, что компилятор поместит один из параметров вставки или переменных ЯВУ в~этот же регистр и,~соответственно, к~непредсказуемому значению в~нём. 

Специальные аргументы для списка перезаписываемых регистров:
\begin{description}
\item["cc"]
показывает, что код изменяет регистр флагов.

Флаги изменяют все арифметические инструкции.


\begin{lstlisting}[style=lstsmall]
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}



\item["memory"]
показывает, что код меняет значение в~памяти (не считая явно указанных выходных параметров) "--- например, интерпретирует какой-либо из параметров как указатель.

\begin{lstlisting}[style=lstsmall]
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}


% Помимо простого указания компилятору, что ассемблерная вставка изменяет содержимое памяти, она ещё служит директивой Memory Barrier для компилятора. Это означает, что те операции обращений в память, которые стоят выше по коду, в результирующем машинном коде будут выполняться до тех, которые стоят ниже ассемблерной вставки. В случае многопоточной среды, когда от этого напрямую зависит риск возникновения race condition, это обстоятельство является существенным.

% Кроме указания компилятору на изменение памяти,
% барьер компилятора

При указании \lstinline!"memory"! в~списке перезаписываемых элементов все операции работы с~памятью, которые были в~программе до ассемблерной вставки, выполнятся до неё, а~те, что стоят в~программе после "--- будут после.
В~противном случае компилятор может поменять местами как операторы C++, так и~ассемблерные вставки.
\end{description}


\subsection{Практическое использование параметров}


\subsubsection{Временные регистры%
\footnote{Использованы материалы:
{http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}
}
}

% \labellocal{sss::tmpreg}
% \label{sss:inline:tmpreg}

Использовать под временные данные фиксированные регистры и~указывать их в~списке  перезаписываемых не вполне корректно.

Более правильным будет ввести фиктивный выходной параметр, размещаемый в~регистре (\lstinline!=r! или \lstinline!=&r!, либо более конкретное ограничение "--- подробнее указано в~разделе \reflocal{sec:Constraints}), так как это даст компилятору больше свободы при оптимизации.

В~тексте вставки можно использовать данный параметр для хранения произвольных временных данных.

% Так, в~программе 
% \begin{lstlisting}[style=lstsmall]
% int main()
% {
%     int a=77, b;
%     asm("movl %0, %%eax"::"d"(a));
%     asm("movl %%eax, %0":"=d"(b));
%     cout << b;
%     return 0;
% }
% \end{lstlisting}
% первая вставка записывает значение локальной переменной \lstinline!a! через регистр \EDX{} (\lstinline!"d"!) в~регистр \EAX;
% вторая "--- содержимое регистра \EAX{} записывает через регистр \EDX{} в~переменную \lstinline!b! (\lstinline!"=d"(b)!).
% То есть если вставки сохранят порядок после компиляции (что не гарантируется), программа копирует содержимое локальной переменной \lstinline!a! (77) в~локальную переменную \lstinline!b!, и~последующий оператор вывода выведет 77. 

Пересылка через временный регистр:
\begin{lstlisting}[style=lstsmall]
int src = 1, dst, tmp;
asm
(
    "movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);
\end{lstlisting}


\subsubsection{Модификация входных параметров}

Модифицировать входные параметры, не являющиеся одновременно и~выходными, \termin{нельзя}.

Если возникает необходимость изменить значение, переданное как входной параметр, оно должно быть описано ещё и~как выходной.


Рассмотрим код, который увеличивает переменную $foo$ на значение переменной $bar$.
В~данном случае $bar$ может быть только входным параметром, а~$foo$ "--- модифицируемым, то есть  одновременно и~входным, и~выходным.

В~следующем фрагменте неименованный параметр \lstinline!%0! является входным и~выходным одновременно (точнее, входной параметр \lstinline!%1! располагается там же, где и~выходной \lstinline!%0!).
Это определяется ограничением размещения входного параметра \lstinline!%1! "--- %вместо  ограничений 
там указан номер параметра \lstinline!%0!.
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
); // foo += bar
\end{lstlisting}
Аналогичные вычисления с~использованием именованных параметров (\lstinline![S]! здесь "--- %и~входной и~выходной параметр
выходной параметр в~регистре, и~в~том же регистре расположен неименованный входной параметр) выглядят следующим образом.
% \begin{lstlisting}[style=lstsmall]
% asm("addl %[A], %[X]\n"
%     : [X]"=r"(foo)
%     :"[X]"(foo), [A]"g" (bar)
%     :"cc"
% ); // foo += bar
% \end{lstlisting}
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
% Используя \lstinline![S]! как приёмник сложения, мы фактически модифицируем неименованный выходной параметр \lstinline!%1!
Мы используем  неименованный выходной параметр \lstinline!%1!, чтобы задать начальное значение входному~\lstinline![S]!.
В данном случае (входной параметр инициализируется исходным значением $foo$ "--- приёмника совмещённого с~ним выходного параметра~\lstinline![S]!) можно было и~не вводить дополнительный входной параметр, а~заменить описание% %ограничение расположения
~\lstinline![S]! на~\lstinline![S]"+r" (foo)!.


Описание параметра как выходного и~входного одновременно (точнее, однорасположенной пары параметров <<выходной-входной>>), в~частности, делает параметр сохраняющим предсказуемое значение на всём протяжении вставки.
Если такой параметр размещается в~регистре, никакой другой параметр данной вставки не будет помещён в~этот регистр.

Отличие такого описания параметра от выходного с~начальным значением (расположение которого начинается с~\lstinline!+!) "--- то, что источник начального значения  может отличаться от исходного значения назначения.
Так, следующий фрагмент кода устанавливает начальное значение параметра-регистра \lstinline![S]! нулём, а~значение этого регистра после завершения вставки записывается в~переменную~$foo$:
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}
% Если для инициализации выходного параметра не требуется значение, отличное от~исходного значения его приёмника,

Также для входного параметра, расположенного на месте выходного, можно задать отдельный псевдоним. %, так как %, в~отличие от 
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : [S_initial_value]"[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}


\subsubsection{Конфликт выходных и~входных долгоживущих параметров}

При размещении параметров в~регистрах компилятор считает, что входные параметры используются в~начале вставки, а~выходные "--- в~конце, \emph{после} использования всех входных.
Соответственно, <<только входные>> параметры часто располагаются в~тех же регистрах, что и~<<только выходные>>, чтобы освободить максимальное количество регистров для других переменных.

Это может привести к~конфликту, если какой-либо входной параметр используется в~конце вставки, после присваивания хотя бы одного из выходных параметров.
При размещении этих двух параметров в~одном регистре присваивание уничтожит оригинальное значение входного параметра.

В частности, данный фрагмент (вычисляющий $y = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$) в~случае размещения входного параметра \lstinline![Zero]! и~выходного \lstinline![y]! в~одном регистре работает некорректно ($y$ всегда равен $1$, так как инициализация выходного параметра  \lstinline![y]! единицей выполняется до чтения  входного параметра \lstinline![Zero]!, и~в~момент условного присваивания \lstinline!cmovll %[Zero], %[y]! регистр, где расположены оба этих параметра, равен $1$).
\begin{lstlisting}[style=lstsmall]
int x = 10, y;
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
); // y = 1 независимо от x
\end{lstlisting}
Это можно исправить, объявив \lstinline![y]! выходным параметром с~начальным значением (\lstinline!+! вместо \lstinline!=! в~расположении), хотя нам и~не требуется исходное значение переменной~$y$.
Такое ограничение не позволит компилятору совместить  какой-либо входной параметр с~\lstinline![y]!.
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"+r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
% 
Другой способ "--- явно указать, какой входной параметр следует расположить на месте выходного~\lstinline![y]!.
Здесь мы можем совместить с~\lstinline![y]! входной \lstinline![x]!, так как последнее чтение~\lstinline![x]! (сравнение \lstinline![x]! с~нулём) выполняется до инициализации~\lstinline![y]!:
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"[y]" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Оба этих способа позволяют разрешить конфликт и~получить корректное значение~$y$.
% $y = \left\{\begin{array}{ll}
% 1, & x \geqslant 0 \\
% 0, & x < 0 \\
% \end{array}\right.$

\subsection{%Типы размещения параметров% 
Ограничения на расположение операнда%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Constraints.html\#Constraints}
}
}
\labellocal{sec:Constraints}

% https://gcc.gnu.org/ml/gcc/1999-10n/msg00488.html
% Типы параметров:
Некоторые общие ограничения (типы размещения параметров):
\begin{description}
\item[r] "--- регистр; %- register
\item[m] "--- память; %- memory effective address
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); %- immediate value, 0..0xffffffff
\item[g] "--- память, регистр общего назначения или непосредственное значение (обычно этот тип эквивалентен \lstinline"rim"); %- general effective address
\item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
\end{description}

% But there are some i386-specific ones described in the processor-specific
% part of the manual and in more detail in GCC's i386.h:
Некоторые ограничения (типы), специфичные для i386 (определены в~файле i386.h GCC)
\begin{description}
\item[q] "--- регистр, который можно адресовать по байтам младшего слова (EAX, EBX, ECX, EDX); %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров  EDX:EAX;
\item[a, b, c, d, S, D] "--- регистры eax, ebx, ecx, edx, esi, edi соответственно;

\item[I..P] "--- машинно-зависимые ограничения для констант:
% \end{description}
% 
% Ограничения для констант:
% \begin{description}
% \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% %     ("i" would allow an address known only at link time)
\begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% \item[K] "--- Signed 8-bit integer constant. ?  255
% \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (сдвиги, которые может выполнить lea);
\item[N] "--- непосредственное значение в~диапазоне 0..255 (беззнаковое однобайтовое).
% \item[O] "--- непосредственное значение в~диапазоне 0..32
\end{description}
\end{description}




% \pagebreak[4]

\section{Вопросы}
\begin{enumerate}
% \item Знаковой или беззнаковой является операция инкремента?
\item Каким ключевым словом открывается ассемблерная вставка?

\item Как из ассемблерной вставки обратиться к~локальным переменным?

\item Какие вы знаете ограничения на размещение параметров ассемблерных вставок?

\end{enumerate}



\section{Справочные материалы}
\begingroup
\lstset{keywordstyle=}

\begin{enumerate}

% \item
% Расширения файлов GCC "---
% C\'{e}dric Musso. Development with GNU/Linux.
% \lstinline!GCC and File Extensions - Development with GNU_Linux - labor-liber.html!

\item
Черновик стандарта C++ 
% (C++14 standard plus minor editorial changes) 
(C++14 с~незначительными редакторскими правками)
"---
November 2014 working draft.
\lstinline!n4296.pdf!


\item Список основных команд архитектур x86 и x86-64 "---
\lstinline!Команды архитектур x86 и x86-64.htm!


\end{enumerate}
\endgroup





