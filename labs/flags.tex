
\section{Флаги\footnote{Использованы: 
Александр Семенко
http://sasm.narod.ru/apps/eflags/main.htm,
http://sasm.narod.ru/apps/eflags/app\_a.htm,
http://www.club155.ru/x86internalreg-eflags
}}

Флаги состояния отображают результаты целочисленных арифметических операций (add, sub, mul и~пр.), этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра eflags.

\paragraph{CF	
(бит 0)} Флаг переноса (Carry Flag = CF). Устанавливается, если арифметическая операция приводит к~переносу или заёму в/из старшего (выходящего за пределы операнда, воображаемого) разряда, таким образом, этот флаг показывает условие переполнения при выполнении арифметических операций. Также этот флаг используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит. 
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число бит, иначе "--- сбрасывается.

\paragraph{AF	
(бит 4)} Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)} Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное / отрицательное).

\paragraph{OF	
(бит 11)} Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита, или имеется перенос из старшего бита, но отсутствует перенос в~него; в~противном случае, флаг OF устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

Из этих флагов только CF можно менять непосредственно (командами stc, clc и~cmc). также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг OF,

\item для беззнаковой арифметики "--- флаг CF,

\item для BCD-арифметики "--- флаг AF.
\end{itemize}

\subsection{Проверка флагов}

Команды условного ветвления jCC, setCC, loopCC и~cmovCC используют один или несколько флагов состояния, проверяя различные условия.

Кроме того, младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить в~регистр \lstinline!%ah! командой~\lstinline!lahf! (Load Flags into AH Register). 
Обратная операция выполняется командой~\lstinline!sahf! (Store AH into Flags).

Регистр \lstinline!%flags/%eflags! можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно.

\subsection{Установка флагов}

Все арифметические команды устанавливают флаги по результатам вычислений.
При этом \lstinline!add $-1, dst! и~\lstinline!sub $1, dst! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит (OF=0); при вычитании единицы из нуля возникает заём из старшего бита  (OF=1).

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
Это:
\begin{itemize}
\item \lstinline!cmp! "--- то же самое, что и~\lstinline!sub!, но операнд-приёмник не изменяется;
\item \lstinline!test! "--- то же самое, что и~\lstinline!and!, но операнд-приёмник не изменяется.
\end{itemize}

Вещественные числа можно сравнить командой \lstinline!fcom!.
Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~eflags таким образом, что результат сравнения можно анализировать так же, как для целых знаковых чисел.


