\input{common/0pres}
\input{common/4archcompsys}


% \setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
% \setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}
% \setbeamerfont{frametitle}{size=\linespread{1.0}\large}

% \addtobeamertemplate{footnote}{}{\vspace{-30ex}}

% \title{Введение в~язык ассемблера}
\title{Связь уровней ассемблера и~языка высокого уровня}
\graphicspath{{fig/}{fig/tanenbaum/}{fig/asm-intro/}{fig/model/}}


% \lstset{language={[x86masm]Assembler}}
% \lstset{commentline={\/}}
\lstset{xleftmargin=0mm}
% \lstset{language={[Motorola68k]Assembler}}
% alsolanguage=[
% h
% dialect
% i
% ]
% h
% language
\lstset{language=C++, alsolanguage=[x86masm]Assembler}
% \lstset{language=C++, alsolanguage=[Motorola68k]Assembler}

\makeatletter
\newcommand{\setlistspacing}[2]{\def\@ld{#1}\expandafter\def\csname
@list\romannumeral\@ld \endcsname{\leftmargin\csname
leftmargin\romannumeral\@ld \endcsname
              \topsep    #2
              \parsep    0\p@   \@plus\p@
              \itemsep   #2}}
\makeatother


\begin{document}
\maketitle

% \section{Оргвопросы}
% \subsection{Компетенции}

\begin{frame}{Цель курса}

% Общепрофессиональные:
Формирование подкомпетенции

\termin{ОПК-2.2}	Знание и~понимание архитектуры и~принципов построения вычислительных систем

\terminblue 
Участвует в~формировании общепрофессиональной компетенции

\termin{ОПК-2}	Владение архитектурой ЭВМ и~систем

\end{frame}



% \section{Синтаксис}

\begin{frame}{Соединение кода на ЯВУ и~ассемблере}
\begin{enumerate}
\item Подпрограммы на ассемблере
\item Ассемблерные вставки
\end{enumerate}
\end{frame}

% \section{Подпрограммы}
\section{Вызов и~возврат из подпрограмм}

\subsection{Вызов подпрограммы}
\begin{frame}{\insertsubsection}
\begin{enumerate}
\item Передача параметров
\item Сохранение адреса возврата
\item Передача управления вызываемой подпрограмме
\item Выполнение вызываемой подпрограммы
\item Подготовка возвращаемого значения
\item Возвращение управления вызывающей программе
\end{enumerate}
\end{frame}

\subsection{Требования}
\begin{frame}{\insertsubsection}
\begin{enumerate}
\item Передача управления на произвольный адрес
\item Возврат управления назад после завершения подпрограммы
\item Вложенные вызовы подпрограмм
\item Сохранение и~восстановление регистров вызывающей программы
\item Передача заданного количества аргументов
\item Передача и~возврат структур
\item Выделение и~освобождение памяти под локальные переменные подпрограмм
\end{enumerate}
\end{frame}

\subsection{Передача и~возврат управления}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{columns}
\lstset{numbers=none}

\begin{column}{0.68\linewidth}
Передача управления в~подпрограмму addr:

\lstinline!call addr!

указатель команд сохраняется в~стеке,
управление передаётся addr
\end{column}
\begin{column}{0.31\linewidth}
\begin{lstlisting}
pushl %eip
movl $addr, %eip  //jmp addr
\end{lstlisting}
\end{column}
\end{columns}
\medskip

\begin{columns}
\lstset{numbers=none}

\begin{column}{0.68\linewidth}
Возврат из подпрограммы:

\lstinline!ret!

\lstinline!ret n!

управление передаётся адресу, снятому со~стека (если указан аргумент n, со~стека затем снимается ещё n байт)
\end{column}
\begin{column}{0.31\linewidth}
\begin{lstlisting}
popl %eip
\end{lstlisting}
\end{column}
\end{columns}
\vspace{-1.5\parskip}

\hfill\includegraphics[width=\linewidth,height=0.3\slideheigth,keepaspectratio,valign=t]{nested-call}
\centering

\end{frame}

\section{Соглашения о~вызовах}

\subsection{Параметры и~возвращаемое значение}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\setlength{\parskip}{0.25\parskip}
\setlength{\leftmargini}{0.5\leftmargini}

\termin{Соглашение о~вызовах} "--- протокол передачи аргументов:
\vspace{-1\parskip}
\begin{enumerate}
\item способ передачи (через регистры, через стек, смешанный);
\item порядок размещения аргументов (Pascal "--- первый аргумент помещается в~стек первым, C "--- последним);
\item кто очищает стек и~сохраняет/восстанавливает регистры (и~какие);
\item инструкции вызова и возврата;
\item как передаётся указатель this (для ООП).
\end{enumerate}

Возвращаемое значение:
\vspace{-1\parskip}
\begin{enumerate}
\item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
\item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
\end{enumerate}

\end{frame}



\subsection{Соглашения о~вызовах (32 бита)}
\begin{frame}[fragile]{\insertsubsection}
% \footnotesize
\scriptsize
\setlength{\parskip}{0.5\parskip}
\setlength{\leftmargini}{0.5\leftmargini}

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\begin{tabularx}{\linewidth}{|M{3.5em}|M{5.5em}|M{3.5em}|L|%L|
}
\hline
&\theadlong{Параметры в~регистрах}
&\theadlong{Порядок}
&\theadlong{Очистка стека}
% &\theadlong{Дополнения}
\\\hline
cdecl&&
 C&
 вызывающая программа
 %&
 \\\hline
pascal&&
 Pascal&
 функция
 %&
\\\hline
winapi (stdcall)&&
 C&
 функция
 %&
 \\\hline
Gnu&&
 C&
%  hybrid
this "--- функция, \mbox{остальные "---  вызывающая программа}
%  &
% Стек иногда выравнивается на 16 бит
\\\hline
Gnu fastcall&
ecx, edx
&
 C&
функция
\\\hline
Gnu regparm (3)&
eax, edx, ecx
&
 C&
функция
\\\hline
Borland fastcall&
ecx, edx
&
Pascal&
функция
\\\hline
 Microsoft fastcall&
 ecx, edx&
 C&
 функция
%  &
%  return pointer on stack if
% not member function
\\\hline
% \\\hline
\end{tabularx}

\tiny
gcc.gnu.org/onlinedocs/gcc-3.4.5/gcc/Function-Attributes.html\\
Agner Fog.
Calling conventions
for different C++ compilers and operating systems.

\end{frame}



% \section{Вызов подпрограммы в~GAS}
\subsection{Вызов подпрограммы в~GAS}
% \begin{frame}[fragile]{\insertsection}
\begin{frame}[fragile]{\insertsubsection}

Соглашение о~вызове: Gnu %(cdecl)

Регистры, значение которых не~должно изменяться подпрограммой:
\vspace{-1\parskip}
% \section{Подпрограммы в~GAS}
% \subsection{Регистры, значение которых не~должно изменяться подпрограммой}
% \begin{frame}[fragile]{\insertsubsection}
\begin{enumerate}
\item\lstinline!%ebx!
\item\lstinline!%esi!
\item\lstinline!%edi!
\item\lstinline!%ebp!
\item Сегментные регистры \lstinline!%ds, %es! и~\lstinline!%ss!
% \item Вершина стека \lstinline!%esp! нет
% \item\lstinline!%r12—%r15! в~64-битном режиме
\end{enumerate}
% Прочие могут изменяться подпрограммами.
\end{frame}
% 
% \subsection{Регистры, значение которых можно изменять}
% \begin{frame}[fragile]{\insertsubsection}
% \begin{enumerate}
% \item\lstinline!%eax! "--- возвращаемое значение (целое до 4 байт или указатель)
% \item\lstinline!%edx! "--- старшие 4 байта возвращаемого значения (long long)
% \end{enumerate}
% \end{frame}


\subsection{Приветствие (GAS, stdlib)}

% \subsection{Приветствие (GAS, GNU/Linux)}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

\begin{lstlisting}
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека
  
    movl $0,%eax
    ret
\end{lstlisting}

\vspace{-2\baselineskip}
\lstset{xleftmargin=14em}
\begin{lstlisting}[numbers=none]
int main(){
    printf("Hello, world!\n");
    return 0;
}
\end{lstlisting}
\end{frame}

\subsection{Форматированный вывод (GAS, stdlib)}

% \subsection{Приветствие (GAS, GNU/Linux)}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

\begin{lstlisting}
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
    pushl foo	// Значение foo в стек
    pushl $19	// Значение 19 в стек
    pushl $fmt	// Адрес строки fmt в стек
    call printf
    addl $3*4, %esp // Три четырёхбайтовых числа из стека
    movl $0,%eax
    ret    
\end{lstlisting}

\vspace{-2\baselineskip}
\lstset{xleftmargin=14em}
\begin{lstlisting}[numbers=none]
int foo = 13;
int main(){
    printf("Переменные: %d %d\n", 19, foo);
    return 0;
}
\end{lstlisting}
\end{frame}

\section{Компоновка}


\subsection{Сборка программы}
% \subsection{Декорирование}
\begin{frame}[fragile]{\insertsubsection}

\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=16ex,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[right= of compiler] (mangling) {Декорирование};
\node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


% \node[right= of cpp] (S) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}};
\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {prog2.o};
\node[stage,on chain=S] (S_linker) {Компоновщик};
% \coordinate[on chain=S] (S_linker);

% \node[file, right= of S_preprocess,text width=20ex] (S_headers) {Заголовочные файлы (\#include)};
% \path[blockarrow] (S_headers) -- (S_preprocess);
\path[blockarrow] (cpp_headers) -- (S_preprocess);

% \path[blockarrow] (cpp_asm) -- (S_asm);

% \path (cpp_linker)
\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[below= of prog-|cpp_linker]  {extern};

\node[below= of prog-|S_linker]  {.globl};


% \coordinate[above=6ex of cpp.south] (linking_start);

\begin{pgfonlayer}{background}
% %   \coordinate[left=0ex of cpp.south west] (cpp_egde);
% %   \coordinate[right=0ex of S.south east] (S_egde);
%   \node[rectangle,fit=(cpp.south west) (S.south east) (linking_start), inner sep=0ex, minimum height=11.8mm,fill=yellow] (linking) {};
\node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};

\end{pgfonlayer} 

\end{tikzpicture}
}
\centering

\end{frame}


\subsection{Префиксы и~суффиксы при~отключённом декорировании (\mbox{extern "C"{}})}
\begin{frame}{\insertsubsection}

% \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{func-prefix-nomangle}
% \centering
\begin{adjustwidth}{-1.8em}{-1.9em}

\includegraphics[width=0.499\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{func-prefix-nomangle}
\hfill
\includegraphics[width=0.499\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{func-suffix-nomangle}
% \centering
\end{adjustwidth}

% \tiny
Agner Fog.
Calling conventions
for different C++ compilers and operating systems.

\end{frame}


\definecolor{codestronghighlight}{RGB}{255, 255,120}
\definecolor{codehighlight}{RGB}{180, 255,180}

\subsection{Импорт в~C++}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{columns}
\begin{column}{0.49\linewidth}
sqr.S (GNU/Linux, BSD)
\begin{lstlisting}
/*@\colorbox{codestronghighlight}{.globl sqr}@*/
/*@\colorbox{codehighlight}{sqr:}@*/
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}

sqr.S \rlap{(... или MS Windows)}
\begin{lstlisting}
.globl sqr
/*@\colorbox{codestronghighlight}{.globl \_sqr}@*/
sqr:
/*@\colorbox{codehighlight}{\_sqr:}@*/
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
% \vspace{-4\parskip}

\end{column}
\begin{column}{0.49\linewidth}
main.cpp
\begin{lstlisting}
#include <iostream>

using namespace std;
/*@\colorbox{codestronghighlight}{extern "C"{} int sqr(int x);}@*/

int main()
{
  int x=2, y;
  y = /*@\colorbox{codehighlight}{sqr(x)}@*/;
  cout << y <<endl;
  return 0;
}
\end{lstlisting}
\end{column}
\end{columns}
\vspace{-2\parskip}
% \begin{lstlisting}
% 
% \end{lstlisting}
\end{frame}

\subsection{Импорт в~Asm}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{columns}
\begin{column}{0.49\linewidth}
unit.cpp
\begin{lstlisting}
/*@\colorbox{codestronghighlight}{extern "C"{}}@*/
__attribute__((__cdecl__)) 
int /*@\colorbox{codehighlight}{bar}@*/(int x)
{
    return 3*x+1;
};
\end{lstlisting}
\end{column}
\begin{column}{0.49\linewidth}
Фрагмент main.S (GNU/Linux, BSD)
\begin{lstlisting}
push $1
call /*@\colorbox{codehighlight}{bar}@*/
addl $4, %esp
\end{lstlisting}

Фрагмент main.S (MS Windows)
\begin{lstlisting}
push $1
call /*@\colorbox{codehighlight}{\_bar}@*/
addl $4, %esp
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}





\section{Ассемблерные вставки}

\subsection{Простой синтаксис}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

Ключевое слово asm (стандарт C++)
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}

GCC "--- ключевые слова \lstinline!asm!  либо \lstinline!__asm__!
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX := ECX
\end{lstlisting}
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX := BH (байт)
\end{lstlisting}
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movl %ecx, $label(%edx,%ebx,$4)\n"
     "movb %ah, (%ebx)");
\end{lstlisting}
\end{frame}


\subsection{Расширенный синтаксис}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\setlength{\parskip}{0\parskip}

\begin{lstlisting}
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}
\begin{lstlisting}
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  
Количество параметров $ input + output + goto \leqslant 30$
\end{frame}


\section{Параметры вставок}

\subsection{Входные и~выходные параметры}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\setlength{\parskip}{0\parskip}

\begin{lstlisting}
     [ [<псевдоним>] ] <строка ограничений> (<выражение>)
\end{lstlisting}
\begin{lstlisting}
int foo;
asm ("movl $12, %[X]\n"  :[X]"=rm"(foo)  );	// foo = 12;
\end{lstlisting}
\begin{lstlisting}
asm ("movl %0, %%eax"    ::"i"(1)  );	// movl $1, %eax
\end{lstlisting}
\begin{lstlisting}
int src = 1, dst, tmp;
asm("movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);	// dst = src
\end{lstlisting}
% \vspace{-\baselineskip}
\end{frame}

\subsection{Модификация входных параметров}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

Входной параметр \lstinline!%1! совпадает с~выходным \lstinline!%0!
\begin{lstlisting}
asm ("addl %2, %0"
    :"=r" (foo)
    :"0" (foo), "g" (bar)
    :"cc"
);	// foo += bar
\end{lstlisting}
\begin{lstlisting}
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}
\end{frame}

\subsection{Ограничения размещения}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{description}[m]
\item[r] "--- регистр; 
\item[m] "--- память;
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки;
\item[g] "--- общий (обычно \lstinline"rim"); %- general effective address
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
% \end{description}
% 
% % But there are some i386-specific ones described in the processor-specific
% % part of the manual and in more detail in GCC's i386.h:
% % Некоторые ограничения (типы), специфичные для i386 (определены в~файле 
% i386%.h GCC)
% \begin{description}
\item[q] "--- любой из EAX, EBX, ECX, EDX; %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров  EDX:EAX;
\item[a, b, c, d, S, D] "---  EAX, EBX, ECX, EDX, ESI, EDI соответственно;

% \item[I..P] "--- машинно-зависимые ограничения для констант:
% % \end{description}
% % 
% % Ограничения для констант:
% % \begin{description}
% % \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% % \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% % %     ("i" would allow an address known only at link time)
% \begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% % \item[K] "--- Signed 8-bit integer constant. ?  255
% % \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (lea);
\item[N] "--- непосредственное значение в~диапазоне 0..255.
% % \item[O] "--- непосредственное значение в~диапазоне 0..32
% \end{description}
\end{description}

\end{frame}


\subsection{Перезаписываемые регистры (clobbers)}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\setlength{\parskip}{0\parskip}

Специальные аргументы:
\begin{description}[m]
\item[cc]код меняет регистр флагов

\item[memory]код меняет память (не считая выходных параметров)
\end{description}

\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}
\begin{lstlisting}
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
);	// foo += bar
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}
\begin{lstlisting}
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}
\end{column}
\end{columns}


\end{frame}

\subsection{Метки}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{lstlisting}
asm goto (
    "btl %1, %0\n\t"
    "jc %l2"
    :: "r" (p1), "r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда BT  копирует бит, номер которого передается вторым параметром, в~флаг CF

\end{frame}



% *****************************************************************************
\section{}
\begin{frame}{Вопросы}
% \setlength{\leftmargini}{0ex}
\setlength{\parskip}{0.25\parskip}
\begin{enumerate}

\item Какие команды используются для вызова и~возврата из подпрограмм?

\item Какие вы знаете соглашения о~вызове?

\item Как передаются параметры в~функцию (соглашение cdecl)?

\item Как возвращается значение функции?

\item Каким ключевым словом открывается ассемблерная вставка?

\item Как из ассемблерной вставки обратиться к~локальным переменным?

% \item Какие вы знаете ограничения на размещение параметров ассемблерных вставок?

\end{enumerate}

\end{frame}

\makethanks
\end{document}
