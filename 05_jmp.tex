\input{commonpres}



% \setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
% \setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}
% \setbeamerfont{frametitle}{size=\linespread{1.0}\large}

% \addtobeamertemplate{footnote}{}{\vspace{-30ex}}

\title{Передача управления (ветвления~и~циклы), обращение~к~структурам и~массивам}
\graphicspath{{fig/}{fig/fpu/}}



\begin{document}
\maketitle




\section{Флаги 
($flags$)
% и~условные команды
}


\colorlet{csControl}{green!50}
\colorlet{csSystem}{blue!20!red!10}
\begin{frame}{\insertsection}
\begin{adjustwidth}{-1.em}{-1.em}
% \footnotesize
% \scriptsize
\tiny
\renewcommand{\arraystretch}{1.05}
\vspace{-1.5\baselineskip}

\begin{tabularx}{\linewidth}{@{}c@{~}|l@{~}|l@{~}|L@{}|l@{}}
% № 	& 	&Название 	&Описание 	&Тип флага \\\hline
\multicolumn{5}{c}{\Reg{flags/eflags}}\\\hline
\rowcolor{csMarker}0 	&CF 	&Carry Flag 	&Флаг переноса 	&Состояние\\\hline
1 	&1 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}2 	&PF 	&Parity Flag 	&Флаг чётности 	&Состояние\\\hline
3 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}4 	&AF 	&Auxiliary Carry Flag 	&Вспомогательный флаг переноса (тетрад) 	&Состояние\\\hline
5 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}6 	&ZF 	&Zero Flag 	&Флаг нуля 	&Состояние\\\hline
\rowcolor{csMarker}7 	&SF 	&Sign Flag 	&Флаг знака 	&Состояние\\\hline
\rowcolor{csSystem}8 	&TF 	&Trap Flag 	&Флаг трассировки 	&Системный\\\hline
\rowcolor{csSystem}9 	&IF 	&Interrupt Enable Flag 	&Флаг разрешения прерываний 	&Системный\\\hline
\rowcolor{csControl}10 	&DF 	&Direction Flag 	&Флаг направления 	&Управляющий\\\hline
\rowcolor{csMarker}11 	&OF 	&Overflow Flag 	&Флаг переполнения 	&Состояние\\\hline
\rowcolor{csSystem}12--13 	&IOPL 	&I/O Privilege Level 	&Уровень приоритета ввода-вывода 	&Системный\\\hline
\rowcolor{csSystem}14 	&NT 	&Nested Task 	&Флаг вложенности задач 	&Системный\\\hline
15 	&0 	&---&Зарезервирован 	&\\\hline
% \\\hline
\multicolumn{5}{c}{\Reg{eflags}}\\\hline
\rowcolor{csSystem}16 	&RF 	&Resume Flag 	&Флаг возобновления 	&Системный\\\hline
\rowcolor{csSystem}17 	&VM 	&Virtual-8086 Mode 	&Режим виртуального процессора 8086 	&Системный\\\hline
\rowcolor{csSystem}18 	&AC 	&Alignment Check 	&Проверка выравнивания 	&Системный\\\hline
\rowcolor{csSystem}19 	&VIF 	&Virtual Interrupt Flag 	&Виртуальный флаг разрешения прерывания 	&Системный\\\hline
\rowcolor{csSystem}20 	&VIP 	&Virtual Interrupt Pending 	&Ожидающее виртуальное прерывание 	&Системный\\\hline
\rowcolor{csSystem}21 	&ID 	&ID Flag 	&Проверка на доступность инструкции CPUID 	&Системный\\\hline
22--31	&	&---&Зарезервированы 	&\\\hline
\end{tabularx}
\end{adjustwidth}

\end{frame}



% \subsection{Сравнение вещественных чисел}
% 
% \newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}
% \begin{frame}{\insertsubsection}
% \begin{adjustwidth}{-1.em}{-1.em}
% \footnotesize
% % \setlength{\parskip}{0\parskip}
% 
% $\left.
% \begin{tabular}{l@{}l}
% $src$ "--- st(i) или в~памяти & 
% $\left\{\begin{tabular}{@{}r@{}}
% \termin{fcom[p[p]]} \farg{[src]}\\
% \termin{fucom[p[p]]} \farg{[src]}
% \end{tabular}\right.$\\
% $src$ "--- целое в~памяти & \termin{ficom[p]} \farg{src}\\
% $src = 0$ & \termin{ftst}
% \end{tabular}
% \right\}$
% % 
% \begin{tabular}{c|@{~}c@{~}c@{~}c}
% Условие & C3 & C0 &C2\\\hline
% $st(0)>src$ & 0 & 0 & 0 \\
% $st(0)<src$ & 0 & 1 & 0 \\
% $st(0)=src$ & 1 & 0 & 0 \\
% несравнимы& 1 & 1 & 1
% \end{tabular}
% 
% {
% \vspace{-0.5\baselineskip}
% \termin{f[n]stsw + sahf:} C3, C0, C2 $\to$ ZF, CF, PF.
% \centering
% 
% }
% 
% \vspace{-\baselineskip}\hrulefill
% 
% 
% \begin{tabular}{r}
% \termin{fcomi[p]} \farg{src, \%st(0)}\\
% \termin{fucomi[p]} \farg{src, \%st(0)}\\
% % $src$ "--- st(i)\hfill \strut сравнивают вершину стека с операндом-источником, который может быть регистром или операндом в памяти (коротким или длинным вещественным).
% \end{tabular}
% % 
% % 
% \begin{tabular}{c|c@{~}c@{~}c|c@{~}c@{~}c}
% Условие & ZF & CF &PF	&OF& SF & AF \\\hline
% $st(0)>src$ & 0 & 0 & 0 &\multirow{4}{*}{0} &\multirow{4}{*}{0}  &\multirow{4}{*}{0} \\
% $st(0)<src$ & 0 & 1 & 0 &&&\\
% $st(0)=src$ & 1 & 0 & 0 &&&\\
% несравнимы& 1 & 1 & 1&&&
% \end{tabular}
% 
% \end{adjustwidth}
% \end{frame}


% \subsection{Флаги сопроцессора}
% \colorlet{csControl}{green!50}
% \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% \colorlet{csSystem}{blue!20!red!10}
% \begin{frame}{\insertsubsection}
% 
% \setlength{\parskip}{0\parskip}
% {
% % \begin{adjustwidth}{-1.em}{-1.em}
% % \footnotesize
% \scriptsize
% % \tiny
% \renewcommand{\arraystretch}{1.05}
% 
% \begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% % № 	& 	&Название 	\\\hline
% \multicolumn{3}{c}{\Reg{SW}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}2 	&ZE 	& Деление на нуль %(#Z)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{csExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}\Reg{eflags}, f(n)stsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
% \\\hline
% \rowcolor{csMarker}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
% \rowcolor{csMarker}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
% \rowcolor{csMarker}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
% \rowcolor{csSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
% \rowcolor{csSystem}12 	& 	&&\cellcolor{csMarker}4 	&\cellcolor{csMarker}AF 	&\cellcolor{csMarker}Auxiliary Carry Flag\\
% \rowcolor{csSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
% \rowcolor{csMarker}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
% \rowcolor{csExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
% \end{tabularx}
% 
% }
% 
% \scriptsize
% 
% % \hfill
% % fstsw \%ax и fnstsw \%ax
% f[n]stsw \%ax
% "--- выгрузка \Reg{SW} в~\Reg{AX};%/память, 
% % \vspace{-\baselineskip}
% % 
% \hfill
% sahf "--- загрузка \Reg{AH} в~младший байт \Reg{eflags}.
% 
% \end{frame}


\subsection{Команды и~флаги}
% \subsection{Команды, изменяющие $flags$}
\begin{frame}{\insertsubsection}

\footnotesize
\setlength{\leftmargini}{0ex}
\setlength{\parskip}{0.\parskip}

{Некоторые команды, изменяющие $flags$:}

\begin{itemize}
\item целочисленные арифметические команды;
\item \lstinline!cmp! (\lstinline!sub!, не изменяющий приёмник);
\item \lstinline!test! (\lstinline!and!, не изменяющий приёмник);
\item \lstinline!fcomi! (сравнение вещественных чисел), \mbox{но не \lstinline!fcom!;}
\item сохранение/восстановление ${flags}$ в~стек (память) \lstinline!pushf/popf!;
\item сохранение/восстановление флагов состояния в~{$ah$} \lstinline!lahf/sahf!.
\end{itemize}
% \end{frame}
% \subsection

{Команды, использующие $flags$:}
% \begin{frame}{\insertsubsection}
\begin{itemize}
\item  условный переход \lstinline!jXXX label!;
\item  условная пересылка \lstinline!cmovXXX src, dst! и~\lstinline!fcmovXXX src, st(0)!;
\item  условная установка байта \lstinline!setXXX dst!.
% \item команды сохранения/восстановления eflags \lstinline!pushf/popf!;

\end{itemize}

\end{frame}

% \subsection{Популярные флаги}
% \begin{frame}{\insertsubsection}
% \begin{description}[W]
% \item[CF] перенос/заём в/из старшего (несуществующего) разряда (беззнаковое переполнение);
% % { (приёмник меньше источника при сравнении вещественных чисел);}
% 
% \item[ZF] результат операции "--- нуль;
% 
% \item[SF] значение старшего (знакового) бита результата;
% 
% \item[OF] потеря старшего бита результата (знаковое переполнение).
% \item[PF] чётность количества единиц младшего байта результата.
% 
% 
% \end{description}
% \end{frame}

% \section{Условные команды}

\subsection{Команды %передачи управления
условного перехода
}


\newcommand\subtable[1]{{{
\begin{tabularx}{1\linewidth}{@{}L@{}L@{}}#1\end{tabularx}
}}}

\begin{frame}{\insertsubsection}
% \begin{adjustwidth}{-2em}{-2em}

% \def\normalsize{\footnotesize}
\def\normalsize{\scriptsize}
\def\theadfont{\scriptsize\bfseries}
\normalsize
\setlength{\parskip}{0\parskip}

\lstinline!jXXX  label! %"--- 
\hfill от 8086/386

передача управления по адресу $label$ при некоторой комбинации флагов ${flags}$

\begin{tabularx}{1\linewidth}{|l|@{}c@{}%|L
|L|}
% {|K{6em}|X|H|}
\hline
\thead{Команда} 
&
% \thead{Условие (флаги)}  
$
\begin{array}{c}
\text{\textbf{\theadfont Условие}}\\[-1ex]
\text{\textbf{\theadfont (флаги)}}\\
\end{array}
$
& %\theadfont Условие (sub src, dst или \mbox{cmp  src, dst})
% \thead{Условие (sub src, dst или \mbox{cmp  src, dst})}
% \thead{Условие (арифметика)}
% &
\theadfont Условие (sub src, dst или \mbox{cmp  src, dst})
\\\hline
jmp
&	
\multicolumn{2}{c|}{{Безусловный переход ($goto$)}}
\\\hline
je/jz
&	
$ZF = 1$
% &
% % $dst - src = 0$ 
% Результат равен нулю
% % 
% % \jname{Jump if zero}
&
$dst = src$	
% 
% \jname{Jump if equal}
\\\hline
jne/jnz
&	
$ZF = 0$
% &
% % $dst - src \neq 0$ (то есть $dst \neq src$)
% Результат не равен нулю
% % 
% % \jname{Jump if not zero}
&
$dst \neq src$
% 
% \jname{Jump if not equal}
\\\hline
jc/jb/jnae
&	
$CF = 1$
% &
% Есть беззнаковое переполнение
% 
% % Результат не умещается в~$dst$ (полные $2^n$ бит) 
% 
% Для сдвигов на один бит "--- вытесненный бит был единицей
% % 
% % \jname{Jump if carry }
&
$dst < src$ как беззнаковое 
% % "--- $dst$ ниже (below) $src$
% % 
% % (не выше и~не равно)
% 
% \jname{Jump if below}
% 
% \jname{Jump if not above or equal }
\\\hline
jna/jbe 	
&
$
\left[
\begin{array}{l}
CF = 1\\
ZF = 1
\end{array}
\right.
$
% &
% Есть беззнаковое переполнение
% или~результат равен нулю
&
% не выше/ниже или равно 	
$dst \leqslant src$ как беззнаковое 
% % "--- $dst$ не выше $src$
% % 
% % (ниже или равно)
% 
% \jname{Jump if below or equal}
% 
% \jname{Jump if not above }
\\\hline
jnc/jnb/jae
&	
$CF = 0$
% &
% Нет беззнакового переполнения
% 
% % Результат умещается в~$dst$ (полные $2^n$ бит)  
% 
% Для сдвигов на один бит "--- вытесненный бит был нулём
% % 
% % \jname{Jump if not carry }
&
$dst \geqslant src$ как беззнаковое 
% % "--- $dst$ не ниже $src$ (выше или равно, above or equal)
% 
% \jname{Jump if not below}
% 
% \jname{Jump if above or equal }
\\\hline
ja/jnbe
&
$
\left\{
\begin{array}{l}
CF = 0\\
ZF = 0
\end{array}
\right.
$
% &
% Нет беззнакового переполнения
% и~результат не равен нулю
&
$dst > src$ как беззнаковое 
% % "--- $dst$ выше (above) $src$ 
% 
% % (не ниже и не равно)
% 
% \jname{Jump if below or equal}
% 
% \jname{Jump if not above }
\\\hline
% 
% js &
% $SF = 1$
% &
% Старший  бит результата (знаковый для знаковых чисел)
%  равен 1 
%  
% \jname{Jump if sign }
% &
% \\\hline
% 
% jns &
% $SF = 0$
% &
% Старший  бит результата (знаковый для знаковых чисел)
%  равен 0 
%  
% \jname{Jump if not sign }
% &
% \\\hline
% 
% jo &
% $OF = 1$
% &
% Есть знаковое переполнение
% 
% \jname{Jump if overflow }
% &
% \\\hline
% 
% jno &
% $OF = 0$
% &
% Нет знакового переполнения
% 
% \jname{Jump if not overflow }
% &
% \\\hline

jl/jnge
&
$SF\neq OF$
% &
&
$dst < src$ как знаковое
% % (не~больше и не~равно)
% % 
% % $dst - src < 0$ как знаковое %и~при этом помещается в~младшие $2^n - 1$ бит
% 
% \jname{Jump if less}
% 
% \jname{Jump if not greater or equal}
\\\hline

jle/jng&
$
\left[
\begin{array}{l}
SF\neq OF\\
ZF = 1
\end{array}
\right.
$&%&
$dst \leqslant src$ как знаковое
% % (меньше или равно/не больше)
% % 
% % $dst - src < 0$ как знаковое %и~при этом помещается в~младшие $2^n - 1$ бит
% 
% \jname{Jump if less or equal}
% 
% \jname{Jump if not greater}
\\\hline

jnl/jge 
&
$SF = OF$
&%&
$dst \geqslant src$ как знаковое
% 
% \jname{Jump if greater or equal}
% 
% \jname{Jump if not less }
\\\hline
jnle/jg
&
$
\left\{
\begin{array}{l}
SF= OF\\
ZF = 0
\end{array}
\right.
$&%&
$dst > src$ как знаковое
% 
% \jname{Jump if greater}
% 
% \jname{Jump if not less or equal }
\\\hline
jp/jpe
&	
$PF = 1$
&
Число единиц младшего байта чётно
\\\hline
jnp/jpo
&	
$PF = 0$
&
Число единиц младшего байта нечётно
\\\hline
% \multicolumn{3}{|c|}{$...$}
% \\\hline

\end{tabularx}
% \end{adjustwidth}
\end{frame}

\subsection{Команды условной пересылки}
\begin{frame}[fragile]{\insertsubsection}
\small

cmovXXX src, dst
\\
{
\scriptsize
$dst$ "--- регистр, $src$ "--- регистр или память; 16/32 бита; от~Pentium Pro (P6)

}

$x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$


\begin{lstlisting}[style=lstsmall]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "cmovngel %[Zero], %[X]\n"
  : [X]"+r"(x)
  : [Zero]"r"(0)
  : "cc"
);
\end{lstlisting}
\end{frame}

\subsection{Установка байта по условию}
\begin{frame}[fragile]{\insertsubsection}
\small

setXXX dst
\hfill от 386
\\
$dst = 1$, если условие верно, 
% 
$dst = 0$ иначе.

$x = (x \geqslant 0)$

\begin{lstlisting}[style=lstsmall]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "movl $0, %[X]\n"
  "setgeb %[X]\n"
  : [X]"+m"(x)
  : : "cc"
);
\end{lstlisting}
\end{frame}







\section{Программирование нелинейных алгоритмов}

\subsection{Условие с~операторами в~одной ветви}
\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-2em}

% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\coordinate[right=  of is_positive] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);

\node[block,on chain=alg_start, join={node[right]{нет}}] (is_positive_no_op) {$x = 0$};
\coordinate[below = of is_positive_no_op] (to_end);

\path[blockarrow] (is_positive_yes) |- (to_end);
\node[terminator, on chain=alg_start, below = of to_end, join/.style=blockarrow] (end) {Конец}; % Удаляет линию вообще
\path[blockarrow] (is_positive_no_op) -- (end);


\coordinate[right=  of is_positive_yes] (asm_coord);


\node[left = 0em of current bounding box]
{
$x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$
};

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = -6;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge end_check\n"
\end{lstlisting}
};
\node[asm] at (is_positive_no_op-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[X]\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  : [X]"+rm"(x)
  : : "cc"
);
\end{lstlisting}
};

% % \coordinate[below = of current bounding box] (lettersline);
% % \node at (end|-lettersline) {а)};
% % \node at (asm-end|-lettersline) {б)};

\end{tikzpicture}
}
\end{adjustwidth}
\end{frame}








\subsection{Условие с~операторами в~двух ветвях}


\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1.5em}{-2em}

{
\scriptsize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\scriptsize}
\lstset{xleftmargin=0em}

\tikzstyle{block}	= [text width=4em,text badly centered, minimum height=3ex, draw=black]

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\tikzset{every join/.style=blockarrow}

\coordinate[right= of is_positive, on chain=if_yes] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);
\node[block,on chain=if_yes] (yes_op) {$y = 1$};

\coordinate[left=  of is_positive, on chain=if_no] (is_positive_no);
\path[blockline] (is_positive) -- node[auto] {нет} (is_positive_no);
\node[block,on chain=if_no] (no_op) {$y = 0$};

\coordinate[below = of yes_op] (to_end_y);

\coordinate[on chain=alg_end, join/.style={}] (to_end) at (to_end_y-|start);
\path[blockline] (yes_op) |- (to_end);
\path[blockline] (no_op) |- (to_end);

\node[terminator, on chain=alg_end, below = of to_end] (end) {Конец};
% \path[blockarrow] (to_end) -- (end);

\node[below =  of current bounding box]
{
$
y(x) = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.
$
};


\tikzset{every join/.style=blockline}


\coordinate[right= 6em of yes_op] (squeeze_coord);

\node[terminator,on chain=squeeze_start] (start2) at (start-|squeeze_coord) {Начало};

\node[decision,on chain=squeeze_start] (is_positive2) {$x\geqslant0$};

\node[block,   on chain=squeeze_start, join={node[right]{нет}}] (no_op2) {$y = 0$};
\coordinate[on chain=squeeze_start] (to_end_no2);


\coordinate[right= of is_positive2] (is_positive_yes2);
\path[blockline] (is_positive2) -- node[auto] {да} (is_positive_yes2);
\tikzset{every join/.style=nodraw}
\coordinate[on chain=squeeze_start] (non-used);

\coordinate[on chain=squeeze_start, join/.style={}] (to_yes2);
\node[block,   on chain=squeeze_start, join/.style={}] (yes_op2) {$y = 1$};
\tikzset{every join/.style=blockline}

\coordinate[on chain=squeeze_start] (to_end_yes2);
% \coordinate[on chain=squeeze_start] (non-used2);

\node[terminator, on chain=squeeze_start, join/.style={}] (end2) {Конец};

\path[blockarrow] (is_positive_yes2) |- (to_yes2) -- (yes_op2);

\coordinate[left=of yes_op2] (from_no_to_end2);
\path[blockline] (to_end_no2) -| (from_no_to_end2);
\path[blockarrow] (from_no_to_end2) |- (to_end_yes2);
\path[blockarrow] (to_end_yes2) -- (end2);



\coordinate[right=  of is_positive_yes2] (asm_coord);

\node[asm] at (start2-|asm_coord) {
\begin{lstlisting}
int x = -6, y;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive2-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge setting_1\n"
\end{lstlisting}
};

\node[asm] at (to_yes2-|asm_coord) {
\begin{lstlisting}
"setting_1:\n"
\end{lstlisting}
};

\node[asm] at (yes_op2-|asm_coord) {
\begin{lstlisting}
  "movl $1, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (no_op2-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (to_end_no2-|asm_coord) {
\begin{lstlisting}
  "jmp end_check\n"
\end{lstlisting}
};

\node[asm] at (to_end_yes2-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end2.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  :[Y]"=rm"(y)
  :[X]"rm" (x)  
  : "cc"
);
\end{lstlisting}
};

% \coordinate[below = of current bounding box] (lettersline);
% \node at (end|-lettersline) {а)};
% \node at (end2|-lettersline) {б)};
% \node at (asm-end|-lettersline) {в)};


\end{tikzpicture}
}

\end{adjustwidth}
\end{frame}










\subsection{Цикл (сумма двоичных цифр  $x$)}


\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-2em}
\vspace*{-\baselineskip}
{
\scriptsize
\def\normalsize{\scriptsize}
\lstset{xleftmargin=0em}

\tikzstyle{asm}	= [text width=16em,text badly ragged, anchor=west]
\tikzstyle{block}	= [text width=10em,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{decision}	= [text width=4em,text badly centered, draw=black, diamond,  aspect=3, inner sep=0pt]


\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=2ex and 3em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[block,on chain=alg_start] (init) {$count = 0$};

\coordinate[on chain=alg_start] (to_shift);
\tikzset{every join/.style=blockarrow}
\node[decision,on chain=alg_start] (is_zero) {$x=0$};
\tikzset{every join/.style=blockline}
\node[block,on chain=alg_start, join={node[right]{нет}}] (shift) {
$CF = x \& 1$,
$x = (x>>1)$
};

\node[decision,on chain=alg_start] (is_last_bit) {$CF=1$};
\node[block,on chain=alg_start, join={node[right]{да}}] (inc) {$count = count+1$};
\coordinate[on chain=alg_start] (from_no_to_next_iter);
\coordinate[on chain=alg_start] (to_next_iter);
\tikzset{every join/.style=blockarrow}
\coordinate[left = of current bounding box] (to_next_iter_middle);
\path[blockarrow] (to_next_iter) -| (to_next_iter_middle) |- (to_shift);

\tikzset{every join/.style=nodraw}
% \coordinate[on chain=alg_start] (non-used);
\coordinate[on chain=alg_start] (to_end);

\node[terminator, on chain=alg_start] (end) {Конец};


\coordinate[right= of is_last_bit] (is_no_last_bit);
\path[blockarrow] (is_last_bit) -- node[auto] {нет} (is_no_last_bit) |- (from_no_to_next_iter);



\coordinate[right= of is_zero-|is_no_last_bit] (is_zero_yes);
\path[blockarrow] (is_zero) -- node[auto] {да} (is_zero_yes) |- (to_end) -- (end);



\coordinate[right=  of current bounding box] (asm_coord);

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = 7, count;
asm
(
\end{lstlisting}
};

\node[asm] at (to_shift-|asm_coord) {
\begin{lstlisting}
"begin_iteration:\n"
\end{lstlisting}
};
\node[asm] at (init-|asm_coord) {
\begin{lstlisting}
  "xorl %[Count], %[Count]\n"
\end{lstlisting}
};
\node[asm] at (shift-|asm_coord) {
\begin{lstlisting}
  "shrl $1, %[X]\n"
\end{lstlisting}
};
\node[asm] at (is_zero-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "je end_loop\n"
\end{lstlisting}
};
\node[asm] at (is_last_bit-|asm_coord) {
\begin{lstlisting}
  "jnc end_iteration\n"
\end{lstlisting}
};
\node[asm] at (inc-|asm_coord) {
\begin{lstlisting}
  "incl %[Count]\n"
\end{lstlisting}
};

\node[asm] at (from_no_to_next_iter-|asm_coord) {
\begin{lstlisting}
"end_iteration:\n"
  "jmp begin_iteration\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_loop:\n"
\end{lstlisting}
};

\node[asm] at (end-|asm_coord) (asm-end) {
\begin{lstlisting}
:[Count]"=rm"(count),[X]"+rm"(x)
: : "cc"
);
\end{lstlisting}
};

% \coordinate[below = of current bounding box] (lettersline);
% \node at (end|-lettersline) {а)};
% \node at (asm-end|-lettersline) {б)};


\end{tikzpicture}
}

\end{adjustwidth}
\end{frame}







\section{Обращение к~элементу структуры}

% \section{Адресация}



\subsection{Формирование адреса}
\begin{frame}{\insertsubsection}
% Виртуальная память "--- плоское адресное пространство "--- адреса линейно возрастают от~0 до~максимального значения.

Адрес в~общем случае 
формируется из четырёх компонент
$$
\text{Адрес} = \text{баз%овый регистр
а} + \alpha \cdot \text{индекс} + \beta
$$
где  база и~индекс "--- регистры, $\alpha$ и~$\beta$ "--- числа, $\alpha = 2^{A}$ (не более $8$)

% \lstinline![base_reg + displacement + offset_reg*scalar_multiplier]! Intel
% \lstinline!displacement(base_reg, offset_reg, scalar_multiplier)!  At&T
GNU Assembler:
$
\beta(\text{баз%овый регистр
а}, \text{индекс}, \alpha)
$
\end{frame}



% \subsection{Адрес элемента структуры}
% \begin{frame}{\insertsubsection}
% 
% Адрес элемента структур \lstinline!M[i]!
% включает две компоненты: адрес структуры  и~смещение поля
% $$
% {\&(M[i])} = \&M + \beta
% $$
% В~GNU Assembler:
% $$
% \beta(\&M)
% $$
% 
% \end{frame}
% \definecolor{codestronghighlight}{RGB}{255, 255,120}
% \definecolor{codehighlight}{RGB}{180, 255,180}

\subsection{Обращение к~элементу структуры}
\begin{frame}[fragile]{\insertsubsection}
% \footnotesize
\small
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
struct TSomeStruct
{
    char Tag;
    int  Val;
} s;
asm
(
"movb $'a', (%[S])\n"
"movl $13, 4(%[S])\n"
:
:[S]"r"(&s)
: "memory"
);
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
cout << s.Tag << " " << s.Val << endl;
\end{lstlisting}
\vspace{2em}

\terminblue
Вывод программы
\begin{lstlisting}[numbers=none]
a 13
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\subsection{Выравнивание}
\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-2em}
\footnotesize
\scriptsize
% \tiny

% \hfill
% \parbox{0.5\linewidth}{
% \begin{lstlisting}[numbers=none,xleftmargin=24em]
% 
% 
% 0 4
% 
% 
% 0 1
% 
% 
% 0 4
% \end{lstlisting}
% \vspace{-10\baselineskip}
% 
% \begin{lstlisting}[numbers=none,xleftmargin=-1em]
% struct TSomeStruct{
%     char Tag;    int  Val;
% } s1;
% #pragma pack (push, 1)
% struct TSqueezedStruct{
%     char Tag;    int  Val;
% } s2;
% #pragma pack (pop)
% struct TAnotherStruct{
%     char Tag;    int  Val;
% } s3;
% 
% cout << reinterpret_cast<char *>(&s1.Tag) - reinterpret_cast<char *>(&s1) << " ";
% cout << reinterpret_cast<char *>(&s1.Val) - reinterpret_cast<char *>(&s1) << endl;
% 
% cout << reinterpret_cast<char *>(&s2.Tag) - reinterpret_cast<char *>(&s2) << " ";
% cout << reinterpret_cast<char *>(&s2.Val) - reinterpret_cast<char *>(&s2) << endl;
% 
% cout << reinterpret_cast<char *>(&s3.Tag) - reinterpret_cast<char *>(&s3) << " ";
% cout << reinterpret_cast<char *>(&s3.Val) - reinterpret_cast<char *>(&s3) << endl;
% \end{lstlisting}
\lstset{language=C++,
	keywordstyle=\color{blue},%\usefont{T2A}{fcr}{b}{n},        % Keywords font ('*' = uppercase)
% 	stringstyle=\color{olive!50!black}
}

\begin{lstlisting}
const int N = 10;
struct TSomeStruct{
    char Tag;    int  Val;
} s1, a1[N];
#pragma pack (push, 1)
struct TSqueezedStruct{
    char Tag;    int  Val;
} s2, a2[N];
#pragma pack (pop)
struct TAnotherStruct{
    char Tag;    int  Val;
} s3, a3[N];
TSqueezedStruct s20, a20[N];

#define PRINT(I) cout << reinterpret_cast<char *>(&s##I.Tag) - reinterpret_cast<char *>(&s##I) << " " \
 << reinterpret_cast<char *>(&s##I.Val) - reinterpret_cast<char *>(&s##I) \
 << " "<< sizeof(s##I) << " " << sizeof(a##I) << endl;
\end{lstlisting}
\vspace{-13\baselineskip}
\begin{lstlisting}[firstnumber=last,xleftmargin=24em]
PRINT(1)	// 0 4 8 80
PRINT(2)	// 0 1 5 50
PRINT(3)	// 0 4 8 80
PRINT(20)	// 0 1 5 50
\end{lstlisting}
\vspace{+8\baselineskip}
% \vfill
% 
% \strut

\end{adjustwidth}
\end{frame}


% \subsection{Модификаторы параметров}
% \begin{frame}[fragile]{\insertsubsection}
% \footnotesize
% 
% % \begin{tabularx}{1\linewidth}{lL}
% z "--- Печать суффикса команды для размера операнда \\
% c "--- Печать константы без префикса \lstinline!$! \\
% b "--- Печать имени младшего байта регистра\\ (\lstinline!%al! для регистра $a$) \\
% h "--- Печать имени старшего байта младшего слова регистра\\ (\lstinline!%ah! для регистра $a$) \\
% w "--- Печать имени младшего слова регистра \\(\lstinline!%ax! для регистра $a$) \\
% k "--- Печать имени младшего двойного слова регистра \\(\lstinline!%eax! для регистра $a$) \\
% q "--- Печать 64-битного варианта имени регистра \\(\lstinline!%rax! для регистра $a$)
% % \end{tabularx}
% 
% % Modifier 	Description 	Operand 	masm=att 	masm=intel
% % z 	Print the opcode suffix for the size of the current integer operand (one of b/w/l/q). 	%z0 	l 	
% % b 	Print the QImode name of the register. 	%b0 	%al 	al
% % h 	Print the QImode name for a “high” register. 	%h0 	%ah 	ah
% % w 	Print the HImode name of the register. 	%w0 	%ax 	ax
% % k 	Print the SImode name of the register. 	%k0 	%eax 	eax
% % q 	Print the DImode name of the register. 	%q0 	%rax 	rax
% % l 	Print the label name with no punctuation. 	%l2 	.L2 	.L2
% % c 	Require a constant operand and print the constant expression with no punctuation. 	%c1 	2 	
% \end{frame}

\subsection{Обращение к~элементу структуры (переносимый код)}
\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-2em}
% \footnotesize
\scriptsize
% \begin{columns}
% \begin{column}{0.50\linewidth}

{Модификаторы параметров:}
% z "--- Печать суффикса команды для размера операнда \\
c "--- печать константы без префикса \lstinline!$! 

\begin{lstlisting}
struct TSomeStruct
{
    char Tag;
    int  Val;
} s;
asm(
"movb $'a', %c[tag_disp](%[S])\n"
"movl $13,  %c[val_disp](%[S])\n"
:
:[S]"r"(&s),
 [tag_disp]"i"(reinterpret_cast<char *>(&s.Tag) 
    - reinterpret_cast<char *>(&s)),
 [val_disp]"i"(reinterpret_cast<char *>(&s.Val) 
    - reinterpret_cast<char *>(&s))
: "memory"
);
\end{lstlisting}
\end{adjustwidth}
% \end{column}
% \begin{column}{0.499\linewidth}
% \begin{lstlisting}[firstnumber=last]
% cout << s.Tag << " " << s.Val << endl;
% \end{lstlisting}
% \vspace{2em}
% 
% \terminblue
% Вывод программы
% \begin{lstlisting}[numbers=none]
% a 13
% \end{lstlisting}
% \end{column}
% \end{columns}
\end{frame}

% \subsection{Обращение к~элементу структуры (переносимый код)}
% \begin{frame}[fragile]{\insertsubsection}
% \begin{adjustwidth}{-1em}{-2em}
% \scriptsize
% 
% \begin{lstlisting}
% struct TSomeStruct
% {
%     char Tag;
%     int  Val;
% } s;
% asm
% (
% "movb $'a', %c[tag_disp](%[S])\n"
% "movl $13,  %c[val_disp](%[S])\n"
% :
% :[S]"r"(&s),
%  [tag_disp]"i"(reinterpret_cast<char *>(&s.Tag) - reinterpret_cast<char *>(&s)),
%  [val_disp]"i"(reinterpret_cast<char *>(&s.Val) - reinterpret_cast<char *>(&s))
% : "memory"
% );
% \end{lstlisting}
% \end{adjustwidth}
% \end{frame}


\section{Обращение к~элементу массива}

\subsection{Адрес элемента массива}
\begin{frame}{\insertsubsection}
\small

Адрес элемента массива \lstinline!M[i]!
включает три компоненты, одна из которых "--- постоянный размер элемента \rlap{$sizeof(M[0])$.}
$$
{\&(M[i])} = \&M + sizeof(M[0]) \cdot i
$$
% то есть 
адрес начала массива "---  база, индекс элемента "--- смещение.

Если размер элемента 1, 2, 4 или 8 байт
% , можно рассчитать адрес элемента непосредственно при обращении, как 
$$
(\&M, i, sizeof(M[0]))
$$

\end{frame}

\subsection{Элемент размера 1 байт}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
int i, x;
char M[N];
asm
(
  "movb $'a', %b[X]\n"
  "xorl %[I], %[I]\n"
"begin_iteration:\n"
  "cmpl %[M_len], %[I]\n"
  "jge end_loop\n"
  "movb %b[X], (%[M],%[I])\n"
  "incb %b[X]\n"
  "incl %[I]\n"
  "jmp begin_iteration\n"
"end_loop:\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[I]"=&r"(i), [X]"=&q"(x)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\begin{lstlisting}[numbers=none]
a b c d e f g h 
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\subsection{Элемент размера 1, 2, 4 или 8 байт (на~примере 4 байт)}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
int M[N], i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"cmpl %[M_len], %[I]\n"
"jge end_loop\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"jmp begin_iteration\n"
"end_loop:\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\begin{lstlisting}[numbers=none]
0 0 0 0 0 0 0 0 
\end{lstlisting}

\end{column}
\end{columns}
\end{frame}

\subsection{Элемент размера 1, 2, 4 или 8 байт %(изменяемый)
}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize

{Модификаторы:}
z "--- печать суффикса размера операнда


\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
short M[N];
int i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"cmpl %[M_len], %[I]\n"
"jge end_loop\n"
"mov%z[el_type] $0, (%[M],%[I],%c[el_size])\n"
"incl %[I]\n"
"jmp begin_iteration\n"
"end_loop:\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M), 
[el_size]"i"(sizeof(M[0])), 
[el_type]"m"(M[0])
: "cc","memory"
);
for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\begin{lstlisting}[numbers=none]
0 0 0 0 0 0 0 0 
\end{lstlisting}

\end{column}
\end{columns}
\end{frame}

% const int N = 8;
% int i;
% double M[N];
% asm
% (
% "xorl %[I], %[I]\n"
% "begin_iteration:\n"
% "cmpl %[M_len], %[I]\n"
% "jge end_loop\n"
% "movl $0, (%[M],%[I],%c[el_size])\n"
% "movl $0, 4(%[M],%[I],%c[el_size])\n"
% "incl %[I]\n"
% "jmp begin_iteration\n"
% "end_loop:\n"
% :[I]"=r"(i)
% :[M_len]"i"(N), [M]"r"(M), "[I]"(i), [el_size]"i"(sizeof(M[0]))
% : "cc","memory"
% );
  
\subsection{Элемент произвольного размера}
\begin{frame}[fragile]{\insertsubsection}
% \footnotesize
\scriptsize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
int i;
long double M[N], *p;
asm
(
"movl %[M_len], %[rev_idx]\n"
"movl %[M],     %[el_addr]\n"
"begin_iteration:\n"
"fldpi\n"
"fstpt (%[el_addr])\n"
"addl %[el_size], %[el_addr]\n"
"decl %[rev_idx]\n"
"jnz begin_iteration\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[rev_idx]"=&r"(i), [el_addr]"=&r"(p)
:[M_len]"i"(N), [M]"r"(M), [el_size]"i"(sizeof(M[0]))
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\scriptsize
\begin{lstlisting}[numbers=none]
3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 
\end{lstlisting}

\end{column}
\end{columns}

\end{frame}
%   \section{}
% \begin{frame}{Вопросы}
% \begin{enumerate}
% 
% \item Из каких компонент формируется эффективный адрес в~x86?
% 
% \item Как расположены в памяти элементы структуры?
% \item Что такое выравнивание?
% \item Какие вы знаете модификаторы параметров в~GAS?
% 
% \item Как расположены в памяти элементы массива?
% 
% \end{enumerate}
% 
% \end{frame}  















% *****************************************************************************
\section{}
\begin{frame}{Вопросы}
\setlength{\leftmargini}{0ex}
\setlength{\parskip}{0.25\parskip}
\small
\begin{enumerate}

\item Какие вы знаете флаги?
% \item Какие вы знаете команды передачи управления?
% \item Какие вы знаете команды условной пересылки?
\item Какие вы знаете условные команды?

\item Как, согласно ЕСПД, изображается блок «терминатор»?
\item Как, согласно ЕСПД, изображается блок «процесс»?
\item Как, согласно ЕСПД, изображается блок «решение»?


\item Из каких компонент формируется адрес в~x86?

\item Как расположены в памяти элементы структуры?
\item Что такое выравнивание?
% \item Какие вы знаете модификаторы параметров в~GAS?

\item Как расположены в памяти элементы массива?


\end{enumerate}

\end{frame}

\makethanks
\end{document}
