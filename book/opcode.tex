\chapter{Архитектура команд семейства x86}
\label{sec:opcode}



\epigraph{\begin{stanza}
Знающий сокровенное и явное, силён, мудр. 
\end{stanza}
}
{64.18}

\section{Регистры}
\label{sec:registers}




\epigraph{\begin{stanza}    
Он на вкус превосходней кальмаров с вином,\\
    Трюфелей и гусиной печёнки.\\
 (Его лучше в горшочке хранить костяном\\
  Или в крепком дубовом бочонке.)\\
\end{stanza}
}
{\Snark}


Процессоры семейства x86 предназначены для обработки целых чисел,
так что в~регистрах процессора %общего назначения 
могут находиться
целочисленные переменные (адреса, индексы и~собственно целые числа).

\subsection{Регистры общего назначения, доступные в~тридцатидвухбитном режиме}

\epigraph{\begin{limerick}
    Жил один старичок из Лагоса, \\
    Плащ которого взяли без спроса.\\
    Он ходил в знак печали\\
    В такой длинной шали,\\
    Что лишь кончик выглядывал носа.\\
\end{limerick}
}
{\Lear}


Под номер регистра в~команде (её структура более подробно рассматривается в~разделе~\ref{sec:command-x86}) отведено всего три бита~\cite{nezumi-disasm, intelInstructionSet},
так что регистров общего назначения в~тридцатидвухбитном режиме  x86 доступно только восемь (рис.~\ref{ris:registers-32}).
% На самом деле в~современных процессорах их больше

% \begin{illustration}%
% \includegraphics[width=\wideImageWidth,keepaspectratio,valign=t]{Registers}
% 
% \caption{Регистры общего назначения x86}
% \label{ris:registers}
% \end{illustration}


% \schemafont
% \tiny
\newlength{\bytewidth}
\setlength{\bytewidth}{12ex}

% % \tikzstyle{arrowline}=[-latex',scale=2]

\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=3.5ex, inner ysep=0ex, textsc]
% \tikzstyle{regpart}	= [reg, solidchaincell]

\tikzstyle{r1}	= [reg, minimum width=\bytewidth]
\tikzstyle{r2}	= [reg, minimum width=2\bytewidth]
\tikzstyle{r4}	= [reg, minimum width=4\bytewidth]

\tikzstyle{commentline}	= [draw=clRegisterDark]
\tikzstyle{textsc}	= [scale=0.5]
\tikzstyle{titlesc}	= [scale=0.7]

\begin{illustration}

\newcommand{\regA}[6][]
{
    
    \node[r2, on chain, #1	,	fill=clRegisterLight!75!clRegisterDark] (h2#2) {};
    \node[r1, solidchaincell, right = of h2#2] (h1#2) {$#4$};
    \node[r1, solidchaincell, right = of h1#2	,	fill=clRegisterLight!75] (l#2) {$#3$};
    
    \node[left = 1ex of h2#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]

  \node[above = 0ex of h1#2.north east, textsc] (#5) {$#5\mathstrut$};  
  \node[below = 0ex of h2#2.south east, textsc] (#6) {$#6$};  
 
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#5/0ex/18/h1#2/l#2/north, #6/1ex/15/h2#2/l#2/south}
  {
    \ifthenelse{\equal{\side}{north}}{
      \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    }{
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
    }
  };
  
  
\end{scope}
}

\newcommand{\regsi}[4][]
{
    
    \node[r2, on chain,	fill=clRegisterLight!75!clRegisterDark,	right=7ex of l#1] (h2#2) {};
    \node[r2, solidchaincell, right = of h2#2] (l#2) {$#3$};
    
    \node[left = 1ex of h2#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]

  \node[below = 0ex of h2#2.south east, textsc] (#4) {$#4$};  
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#4/1ex/15/h2#2/l#2/south}
  {
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
  };
  
  
\end{scope}
}


\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going below,
node distance=5ex]
 
  \foreach \rname/\rbase in {A/a, B/b, C/c, D/d}
  {
    \regA{\rname}{\rbase l}{\rbase h}{\rbase x}{e\rbase x}{r\rbase x}
  };
  \foreach \r/\pos in {si/A, di/B, bp/C, sp/D}
  {
    \regsi[\pos]{\r}{\r}{e\r}
  };

    
\end{tikzpicture}
}

\caption{Регистры общего назначения в~тридцатидвухбитном режиме}
\label{ris:registers-32}
\end{illustration}



% Это

В~некоторых источниках к~регистрам общего назначения относят только четыре регистра "--- $A, B, C$ и~$D$.
Каждый из них конструктивно имеет размер машинного слова (сейчас, как правило, 64 бита),
но в~тридцатидвухбитном режиме доступны только младшие 32.
Разные их части называются разными именами.
% (а~в~команде обозначение части складывается из номера регистра и~разрядности операции).
В~частности, младший байт регистра~$A$ обозначается $al$, % (low), 
следующий байт "--- $ah$, % (high), 
младшие 16 бит "--- $ax$, % (для шестнадцатибитного 8086 это означало eXtended)
младшие 32 бита "--- $eax$,
доступные только в~шестидесятичетырёхбитном режиме 64 бита "--- $rax$.
% 
Для краткости будем использовать однобуквенное обозначение регистра, когда его разрядность %не важна или 
может быть любой или совпадает с~разрядностью системы,
в~частности,~$A$ вместо $rax/eax/ax/al$.

% В~других "--- все регистры, которые можно указать как источник/приёмник,
% тогда
Также имена и~номера существуют для %так называемых
регистров $si, di, bp$ и~указателя вершины стека~$sp$, которые иногда также причисляют к~регистрам общего назначения.
Эти имена соответствуют младшим 16 битам регистров.
Их 32-битные варианты называются соответственно $esi, edi, ebp$ и~$esp$,
64-битные "--- $rsi, rdi, rbp$ и~$rsp$.
Младшие байты этих регистров не имеют имён % (а~соответствующие номера уже заняты $ah-dh$).
в~32-разрядном режиме. 

Для краткости будем использовать оригинальное имя регистра, когда его разрядность %не важна или 
совпадает с~разрядностью системы,
например, $sp$ вместо $rsp/esp/sp$. % или~$A$ вместо $rax/eax/ax/al$.
Это не вызовет путаницы, так как шестнадцатиразрядный код сейчас практически не используется.




Хотя %указатель стека 
$sp$ можно адресовать как регистр общего назначения% (что широко используется )
, использовать его иначе, чем 
как указатель вершины стека, категорически не рекомендуется.
% Кроме того, во многих случаях номер $sp$ в~команде трактуется как «регистр не задан».
Таким образом, будем считать регистрами общего назначения следующие семь "--- %регистров
$A, B, C, D, si, di$ и~$bp$.

\subsection{Регистры общего назначения, доступные в~шестидесятичетырёхбитном режиме}
\epigraph{\begin{limerick}
    Жил старик, на носу у которого \\
    Стая птичек устроилась здорово.\\
    Но в ненастные дни\\
    Улетали они,\\
    Облегчая судьбу его здорово.
\end{limerick}
}
{\Lear}

В~шестидесятичетырёхбитном режиме доступны все описанные выше регистры.
% 
Кроме того,
\index{REX, префикс}%
в~64-разрядном режиме 
% доступны все 64 бита регистров.
% Кроме того,
% увеличена разрядность не только самих регистров, но и~их~номеров в~команде, нет !!!
может быть использован специальный префикс $REX$ (расширения регистров),
который добавляет ещё один бит к~номерам регистров в~команде,
так что
% добавляется 
можно адресовать
ещё восемь регистров общего назначения $r8-r15$ (рис.~\ref{ris:registers-64}).
% Префикс $REX$ игнорируется даже в~шестидесятичетырёхразрядном коде, если размер операнда менее~64. врут
Их младшие части имеют имена $r8b - r15b$ (байты "--- 8 бит),
$r8w-r15w$ (16 бит),
$r8d-r15d$ (32 бита).
% $r8 - r15$
В~32-разрядном режиме они недоступны. %, соответственно, их младшие части не имеют отдельных имён.
Также префикс $REX$ позволяет адресовать младшие байты регистров $si, di, bp$ и~$sp$ "--- $sil, dil, bpl$ и~$spl$~\cite{intelBasic}.


\begin{illustration}[p]

\newcommand{\regc}[7][]
{
    \node[r4, on chain, #1	,	fill=clRegisterLight!50!clRegisterDark] (h4#2) {};
    \node[r2, solidchaincell, right = of h4#2	,	fill=clRegisterLight!75!clRegisterDark] (h2#2) {};
    \node[r1, solidchaincell, right = of h2#2] (h1#2) {$#4$};
    \node[r1, solidchaincell, right = of h1#2	,	fill=clRegisterLight!75] (l#2) {$#3$};
    
%     \node[left = 2ex of h4#2, scale=0.7]  {$#2$}; 
    \node[left = 2ex of h4#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]
    
%   \foreach \lbl/\inangle/\s/\e in {#5/10/h1#2/l#2, #6/15/h2#2/l#2, #7/20/h4#2/l#2}
%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/2ex/15/h2#2/l#2, #7/4ex/18/h4#2/l#2}
%   {
% %     \path[draw=clRegisterDark] (\s.north west)  to[out=\inangle,in=180-\inangle] node[fill=white, text=black, sloped,scale=1] {$\lbl$} (\e.north east);
% %     \path[draw=clRegisterDark] (\s.north west)  .. controls ($(\s.north east) + (0,1)$)  
% % 	  ..
% % 	  node[fill=white, text=black, sloped,scale=1] {$\lbl$} (\e.north east);       
% 
%     \node[text=black, above = \h of \s.north east] (\lbl) {$\lbl$};  
% %     \path[draw=clRegisterDark] (\s.north west)  
% %     to[out=\inangle,in=180] 
% %     (\lbl)
% %     to[out=0,in=180-\inangle] 
% %     (\e.north east);
% 
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
%     
% %      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
% %      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);
%    
%   };

%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/1ex/15/h2#2/l#2, #7/2ex/18/h4#2/l#2}
%   {
%     \node[text=black, above = \h of \s.north east, textsc] (\lbl) {$\lbl$};  
%   };
  \node[above = 0ex of h1#2.north east, textsc] (#5) {$#5\mathstrut$};  
  \node[below = 0ex of h2#2.south east, textsc] (#6) {$#6$};  
  \node[above = 0.1ex of h4#2.north east|-#5.center, textsc] (#7) {$#7$};  
 
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#5/0ex/18/h1#2/l#2/north, #6/1ex/15/h2#2/l#2/south}
  {
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    
    \ifthenelse{\equal{\side}{north}}{
      \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    }{
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
    }
    
%      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
%      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);
   
  };
  
  
  
  \foreach \lbl/\h/\inangle/\s/\e in {#7/2ex/18/h4#2/l#2}
%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/2ex/15/h2#2/l#2, #7/4ex/18/h4#2/l#2}
  {
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    
%      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
%      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);

%      \path[commentline]	(\lbl)		-|	(\e.north east);
%      \path[commentline]	(\s.north west)	|-	(\lbl);

     \path[commentline]	(\lbl.north-|\e.north east)	--	(\e.north east);
     \path[commentline]	(\s.north west)	|-	(\lbl.north-|\s.north west);

     \path[arrowline, commentline]	(\lbl)	--	(\lbl-|\e.north east);
     \path[arrowline, commentline]	(\lbl)	--	(\lbl-|\s.north west);
     
  };  

\end{scope}

}

\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going below,
node distance=5ex]
 
%   \foreach \rn in {0,...,9}
%   {
%     \node[r4, on chain] (h4\rn) {};
%     \node[r2, solidchaincell, right = of h4\rn] (h2\rn) {};
%     \node[r1, solidchaincell, right = of h2\rn] (h1\rn) {};
%     \node[r1, solidchaincell, right = of h1\rn] (l\rn) {};
%   };

  \foreach \rname/\rbase in {A/a, B/b, C/c, D/d}
  {
    \regc{\rname}{\rbase l}{\rbase h}{\rbase x}{e\rbase x}{r\rbase x}
  };
  \foreach \r in {si, di, bp, sp}
  {
    \regc{\r}{\r l}{}{\r}{e\r}{r\r}
  };
  \foreach \r in {8}
  {
    \regc{r\r}{r\r b}{}{r\r w}{r\r d}{r\r}
  };
  \node[below = 1.5ex of h4r8.south east, titlesc] (rdots) {$\ldots$};
  \node[titlesc] at (rdots-|titler8) {$\ldots$};
  \foreach \r in {15}
  {
    \regc[below = 3.5ex of rdots.south, anchor = north east]{r\r}{r\r b}{}{r\r w}{r\r d}{r\r}
  };
    
\end{tikzpicture}
}

\caption{Регистры общего назначения в~шестидесятичетырёхбитном режиме}
\label{ris:registers-64}
\end{illustration}

\subsection{Специальные регистры и~регистры расширений}
\epigraph{\begin{limerick}
    Жил-был старичок в Катманду,\\
    Чей нос был похож на дуду.\\
    Вот на этой дуде\\
    И дудел он везде,\\
    Удивляя народ в Катманду.\\
\end{limerick}
}
{\Lear}

Из специальных регистров следует отметить 
регистры состояния и~управления:
уже упоминавшийся       указатель команды $ip$ (в~32- и~64-битных системах иногда называются $eip$ и~$rip$ соответственно)
и~регистр флагов $flags$ ($eflags/rflags$).
Разряды регистра флагов либо показывают те или иные характеристики последней операции процессора (флаги состояния),
либо влияют на выполнение команд (управляющие флаги).

Современные процессоры семейства x86, кроме основного набора команд, поддерживают несколько расширений.
Для них реализованы несколько групп регистров общего назначения, доступных в~командах соответствующих наборов: %, которые могут быть 
\begin{itemize}
\item восемь 80-разрядных регистров FPU x87 ($r_0- r_7$)
могут быть использованы как командами FPU как %элементы стека FPU 
{$st(0)-st(7)$, хранящие числа с~плавающей запятой}, так и~командами расширения MMX как 64-разрядные регистры {{$mm0-mm7$, }}
(%конструктивно %64-разрядные 
$mm0-mm7$ "--- мантиссы  $r_0- r_7$);
\item восемь 128-разрядных регистров расширения SSE, или XMM {({$xmm0-xmm7$})}.
Каждый из них предназначен для хранения вектора вещественных чисел одинарной точности, а~не длинного 128-битного числа.
В~64-битных системах количество XMM-регистров, как и~количество регистров общего назначения, увеличено до шестнадцати ($xmm0-xmm15$).
Расширение AVX (YMM) вдвое увеличило их разрядность "--- до 256-разрядных $ymm0-ymm15$,
недавно появившееся  AVX-512 (ZMM) "--- до 512-разрядных $ymm0-ymm31$ (в~32-битных системах доступны только первые восемь).
При этом регистры $ymm_i$ "--- младшие половины регистров $zmm_i$, а~$xmm_i$, соответственно, "--- младшие половины $ymm_i$.
Регистры ZMM есть не во всех современных процессорах.
\end{itemize}
Также расширения могут иметь свои специальные регистры, в~частности, регистры флагов.
Например, FPU имеет обширный набор специальных регистров, так как изначально команды набора FPU выполнялись отдельным устройством "--- математическим сопроцессором.


\section{Флаги}
\label{sec:flags}
\epigraph{\begin{limerick}
    Жил один старичок в Девоншире,\\
    Он распахивал окна пошире\\
    И кричал: «Господа!\\
    Трумбаду, трумбада!» "---\\
    Ободряя народ в Девоншире.
\end{limerick}
}
{\Lear}

\subsection{Флаги основного процессора}

 


\epigraph{\begin{limerick}
Дева юная та, чья история\\
Вся таинственность и аллегория,\\
Восседала на травке\\
В неприметной канавке\\
И строчила трактат по истории.\\
\end{limerick}
}
{\Lear}  

Как было сказано в~разделе~\ref{sec:digits-negcodes}, 
при сложении и~вычитании чисел ограниченной разрядности может образоваться бит переноса/заёма из старшего разряда, который сохраняется процессором в~особой ячейке "--- флаге переноса~$CF$.
Процессоры семейства x86 объединяют ячейку~$CF$ и~подобные ей биты, показывающие те или иные свойства последней операции "---
флаги состояния "--- в~специальный регистр  флагов $flags$ %/eflags/rflags$ 
(таблица~\ref{tab:flags}).
% Тридцатидвухбитная версия

Флаг считается установленным, когда он равен~1, и~сброшенным, когда равен 0.

Кроме флагов состояния, регистр флагов включает один бит, не отражающий выполнение последней операции, но влияющий на выполнение некоторых команд (управляющий флаг), а~также несколько битов, недоступных прикладным программам (системные флаги)~\cite{intelSystem,club155,sasm}.
Часть битов зарезервирована и~не используется сейчас как флаги (зарезервированный бит может иметь как произвольное, так и~фиксированное значение).

Доступные прикладным программам флаги состояния в~основном сосредоточены в~младших восьми разрядах $flags$,
% (таблица~\ref{tab:flags}),
поэтому многие команды сохранения/восстановления регистра флагов оперируют только с~младшим байтом.
Старшие восемь бит содержат один флаг состояния~$OF$, управляющий флаг~$DF$ и~несколько системных.
В~тридцатидвухбитном регистре $eflags$ в~старших шестнадцати битах добавлено ещё шесть системных флагов;
старшие тридцать два бита шестидесятичетырёхбитного $rflags$ не используются.


% \footnote{Использованы: 
% Александр Семенко
% http://sasm.narod.ru/apps/eflags/main.htm,
% http://sasm.narod.ru/apps/eflags/app\_a.htm,
% http://www.club155.ru/x86internalreg-eflags
% }

% Флаги разделяются на три группы: флаги состояний, управляющие и~системные~\cite{intelSystem, club155, sasm}.


\begin{table}[!ht]

\caption{Регистр флагов $flags$}
\label{tab:flags}
% \tiny
% \scriptsize
\footnotesize
\renewcommand{\arraystretch}{1.05}
\begin{tabularx}{\linewidth}{@{}c@{~}|l@{~}|l@{~}|L@{}|l@{}}
% № 	& 	&Название 	&Описание 	&Тип флага \\\hline
% \multicolumn{5}{c}{\Reg{flags/eflags}}\\\hline
\multicolumn{5}{c}{\Reg{flags}}\\\hline
\rowcolor{clFlagStatus}0 	&CF 	&Carry Flag 	&Флаг переноса (беззнакового переполнения) 	&Состояние\\\hline
1 	&1 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}2 	&PF 	&Parity Flag 	&Флаг чётности 	&Состояние\\\hline
3 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}4 	&AF 	&Auxiliary Carry Flag 	&Вспомогательный флаг переноса 	&Состояние\\\hline
5 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}6 	&ZF 	&Zero Flag 	&Флаг нуля 	&Состояние\\\hline
\rowcolor{clFlagStatus}7 	&SF 	&Sign Flag 	&Флаг знака 	&Состояние\\\hline
\rowcolor{clFlagSystem}8 	&TF 	&Trap Flag 	&Флаг трассировки 	&Системный\\\hline
\rowcolor{clFlagSystem}9 	&IF 	&Interrupt Enable Flag 	&Флаг разрешения прерываний 	&Системный\\\hline
\rowcolor{clFlagControl}10 	&DF 	&Direction Flag 	&Флаг направления 	&Управляющий\\\hline
\rowcolor{clFlagStatus}11 	&OF 	&Overflow Flag 	&Флаг знакового переполнения 	&Состояние\\\hline
\rowcolor{clFlagSystem}12--13 	&IOPL 	&I/O Privilege Level 	&Уровень приоритета ввода-вывода 	&Системный\\\hline
\rowcolor{clFlagSystem}14 	&NT 	&Nested Task 	&Флаг вложенности задач 	&Системный\\\hline
15 	&0 	&---&Зарезервирован 	&\\\hline
% \\\hline
\multicolumn{5}{c}{\Reg{eflags}}\\\hline
\rowcolor{clFlagSystem}16 	&RF 	&Resume Flag 	&Флаг возобновления 	&Системный\\\hline
\rowcolor{clFlagSystem}17 	&VM 	&Virtual-8086 Mode 	&Режим виртуального процессора 8086 	&Системный\\\hline
\rowcolor{clFlagSystem}18 	&AC 	&Alignment Check 	&Проверка выравнивания 	&Системный\\\hline
\rowcolor{clFlagSystem}19 	&VIF 	&Virtual Interrupt Flag 	&Виртуальный флаг разрешения прерывания 	&Системный\\\hline
\rowcolor{clFlagSystem}20 	&VIP 	&Virtual Interrupt Pending 	&Ожидающее виртуальное прерывание 	&Системный\\\hline
\rowcolor{clFlagSystem}21 	&ID 	&ID Flag 	&Проверка на доступность инструкции CPUID 	&Системный\\\hline
22--31	&	&---&Зарезервированы 	&\\\hline
\end{tabularx}

\end{table}

Регистр $flags$ не может быть явно указан как операнд команды,
но является неявным результатом большинства арифметических команд и~неявным операндом условных команд.

\subsubsection{Флаги состояния}
\index{Флаги!состояния}

Флаги состояния отображают результаты целочисленных арифметических операций (%\lstinline!add, sub, mul! 
сложения, вычитания, умножения, поразрядных логических операций
и~пр.); этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра $flags$.

\paragraph{CF	
(бит 0)} Флаг переноса (Carry Flag = CF). Устанавливается, если происходит перенос
из старшего разряда результата за пределы разрядной сетки при сложении
или заём в старший  разряд из несуществующего  (выходящего за пределы операнда, воображаемого) разряда при вычитании, таким образом, этот флаг показывает переполнение при выполнении беззнаковых арифметических операций. 

Флаг~$CF$  часто используется и~для других целей, тогда его значение не связано с~беззнаковым  переполнением.
Так, этот бит используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит,
командами извлечения бита %(\lstinline!btX!) 
"--- для хранения извлечённого значения
и~многими другими.
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число единиц, иначе "--- сбрасывается.

Флаг чётности использовался для подсчёта контрольных сумм.

\paragraph{AF	
(бит 4)} Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады младшего байта, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)} Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное/отрицательное).

\paragraph{OF	
(бит 11)} Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита (то есть сумма положительных чисел даёт результат, интерпретируемый как отрицательный), или имеется перенос из старшего бита, но отсутствует перенос в~него (сумма отрицательных чисел положительна); в~противном случае, флаг $OF$ устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

% Из этих флагов только $CF$ можно менять непосредственно (командами stc, clc и~cmc); также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
\index{Флаги!установка}
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг $OF$,

\item для беззнаковой арифметики "--- флаг $CF$,

\item для BCD-арифметики "--- флаг $AF$.
\end{itemize}

% \subsubsection{Проверка флагов}
% \index{Флаги!проверка}

\subsection{Флаги FPU}



\epigraph{\begin{limerick}
Иллюзорный старик из Гааги\\
Сделал шар из тряпья и бумаги;\\
Воспарил в вышину\\
И взирал на луну\\
Тот подзорный старик из Гааги.\\
\end{limerick}
}
{\Lear} 

Математический сопроцессор FPU включает собственный регистр флагов "--- слово состояния~$sw$.
Старший байт $sw$ может быть загружен в~младший байт флагов основного процессора. 

В~таблице~\ref{tab:fpu-status} представлено краткое описание структуры слова состояния, а~также соответствие старшего байта слова состояния сопроцессора $sw$ и~младшего байта регистра флагов основного процессора~$flags$.

% \colorlet{csControl}{green!50}
% \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% \colorlet{csSystem}{blue!20!red!10}


\begin{table}[!ht]
\caption{Слово состояния FPU}
\label{tab:fpu-status}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{$sw$}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}$flags$, fnstsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{clFlagStatus}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{clFlagStatus}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{clFlagSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{clFlagSystem}12 	& 	&&\cellcolor{clFlagStatus}4 	&\cellcolor{clFlagStatus}AF 	&\cellcolor{clFlagStatus}Auxiliary Carry Flag\\
\rowcolor{clFlagSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{clFlagExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\end{table}

\pagebreak[3]
%слово состояния $sw$ могло быть выгружено в~память или регистр $ax$ командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки $sw$ в~регистр $ax$ его старший байт загружал

% Таким образом, после выполнения команды сравнения (%и~%пары команд 
% % \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% % или при использовании совместимых с~ними 
% при использовании совместимых с~ранними моделями 
% команд %f*com[p[p]]
% без суффикса~\lstinline!i! 
% необходимы также \lstinline!fnstsw %ax! + \lstinline!sahf!)
% результат  можно 
% анализировать как результат сравнения беззнаковых целых чисел.
% 
% 
% После этого значение $C3$ помещается в~аналогичный ему по смыслу флаг нуля $ZF$ ($st(0) - src = 0$), $C0$ "--- в~флаг переноса~$CF$ ($st(0) - src < 0$),
% то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
% Бит несравнимости $C2$ попадает на место флага чётности~$PF$. 

Как видно из таблицы, при загрузке старшего байта~$sw$ во~$flags$
флаг отрицательности~$C0$ помещается во флаг беззнакового переполнения~$CF$,
флаг нуля~$C3$ "--- в~аналогичный ему по смыслу $ZF$,
а~флаг несравнимости $C2$ "--- во флаг чётности $PF$. 
Другие флаги младшего байта~$flags$ получают фактически неопределённое значение.
% 
Таким образом, результат можно анализировать как результат сравнения беззнаковых целых чисел.


% После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.


\section{Структура команды и~методы адресации}

\epigraph{\begin{stanza}[0mm]
Тот ли идет прямо по дороге, кто ходит потупив лице своё? \\
Или тот на прямом пути, кто ходит, держа себя прямо? 
\end{stanza}
}
{67.22}

Набор команд процессоров семейства x86 имеет тип CISC.
Он создавался в~условиях жёсткой экономии памяти, так что команды имеют максимально компактную (и,~соответственно, сложную для декодирования и~понимания)
структуру и~используют разнообразные %способы задания адреса операнда.
методы адресации операндов.

Необходимость программирования в~машинных кодах возникает крайне редко, но знание формата команды помогает лучше представлять себе возможности и~ограничения архитектуры.

\subsection{Методы адресации}
\index{Адресация!виды}
\label{sec:addressing:common}
\epigraph{\begin{limerick}
Одному господину в~Версале \\
Так внезапно глаза отказали,\\
Что он видеть не мог\\
Даже собственных ног "---\\
И~просил, чтоб ему показали.\\
\end{limerick}
}
{\Lear}

Адрес операнда в~машинной команде 
может быть задан одним из %четырёх 
следующих способов~\cite{asmworld}.
Они называются методами адресации операндов.
% http://asmworld.ru/uchebnyj-kurs/014-rezhimy-adresacii/
\begin{enumerate}
\item \termin{Неявная} адресация.  Местоположение операнда фиксировано и~определяется кодом операции. 
\item \termin{Непосредственная} адресация. Операнд "--- константа, которая включается непосредственно в~команду.
\item \termin{Прямая абсолютная} (прямая) адресация. Операнд "--- переменная в~памяти по~фиксированному адресу (глобальная или статическая).
Этот адрес включается непосредственно в~команду.
\item \termin{Прямая относительная} адресация. 

В~команде содержится смещение, которое прибавляется к значению указателя команд $ip$.


Этот режим используется в командах передачи управления
и~позволяет загружать код в~память по произвольному адресу без нарушения корректности переходов.
% То есть указывается не сам адрес перехода, а на сколько байтов вперёд или назад надо перейти. Пример:

Шестидесятичетырёхбитное расширение позволяет использовать прямую относительную адресацию также и~для данных.

\item \termin{Регистровая}  адресация. Операнд находится в~регистре.
\item \termin{Косвенно-регистровая} (косвенная) адресация. Операнд "--- переменная в~памяти и~её адрес находится в~регистре (регистрах).
% Иногда выделяют косвенную базовую 
Иногда выделяют следующие виды косвенной адресации:
\begin{itemize}
\item  базовая адресация "--- адрес операнда в~регистре (базовом регистре, базе);
\item  базовая адресация со смещением "--- адрес операнда вычисляется как сумма базового регистра и~константы (смещения);
\item  базово-индексная адресация "--- адрес операнда вычисляется как сумма двух регистров "--- базового регистра и~индексного;
\item  базово-индексная адресация  со смещением "--- адрес операнда вычисляется как сумма двух регистров и~константы.
\end{itemize}
\end{enumerate}
Если необходимо обработать значение, адрес которого получается более сложным образом
(в~частности, переменная в~памяти, указатель на которую также находится в~памяти), 
этот адрес надо вычислить отдельно и~поместить в~регистр.

% Смотрите также разделы~\longref{sec:addressing} 
% и~\longref{sec:arrays}.


\subsection{Структура команды}
\label{sec:command-x86}

\epigraph{\begin{limerick}
    Задремавший один старичок\\
    Думал: дверь заперта на крючок.\\
    Но один толстый крыс\\
    Его шляпу изгрыз,\\
    А другой – съел его сюртучок.\\
\end{limerick}
}
{\Lear}

Команды процессоров семейства x86  имеют переменную длину.
Структура команды показана на рис.~\ref{ris:x86-cmd_structure}.

\begin{illustration}
% \includegraphics[width=1\linewidth,keepaspectratio,valign=t]{cmd_structure}
\includegraphics[width=1\linewidth,keepaspectratio,valign=t]{cmd_structure_intel}
\caption{Структура команды x86}
\label{ris:x86-cmd_structure}
\end{illustration}

Все поля, кроме кода операции, необязательны~\cite{nezumi-disasm, intelInstructionSet}.


Команда может предваряться одним или несколькими префиксами, изменяющими её поведение.
% \begin{itemize}
% \item 
% \end{itemize}
Из префиксов x86 следует отметить префикс изменения размера операнда \lstinline!0x66!
и~префикс изменения размера адреса~\lstinline!0x67!.
Для тридцатидвухбитного режима (и~его шестидесятичетырёхбитного расширения) они уменьшают разрядность операнда или адреса соответственно до 16 бит, 
для шестнадцатибитного "--- повышают до 32.
% (по умолчанию разрядность операндов и~адреса
Восьмибитные варианты команд, как правило, представлены отдельными опкодами.

Далее идёт код операции (опкод), занимающий один, два или три байта (и, может быть, ещё три бита в~байте $Mod~R/M$).
% 
% Следующие два байта, $Mod~R/M$ и~$SIB$, согласно~\cite{intelInstructionSet}, задают адресацию операндов. %, если они есть.
% Каждое из них состоит из трёх полей.
Следующий байт, $Mod~R/M$, согласно~\cite{intelInstructionSet}, задаёт адресацию операндов. %, если они есть.
% Он состоит из трёх полей: $Mod$ 
За ним следует необязательный байт $SIB$, уточняющий расположение операнда в~памяти, если %для одного из операндов  
такой есть и~для него используется косвенная базово-индексная адресация.
Каждый из байтов  $Mod~R/M$ и~$SIB$ состоит из трёх полей.

Поле $Displacement$ содержит смещение адреса при косвенной адресации.
Оно трактуется как знаковое тридцатидвухбитное (при использовании понижающего разрядность адреса префикса 0x67 "--- шестнадцатибитное) или восьмибитное число.

Поле $Immediate$ "--- непосредственное значение («магическое число», включённое непосредственно в~команду).
Оно присутствует, если опкод соответствует операции с~непосредственным операндом.

\subsection{Общие для тридцатидвухбитного и~шестидесятичетырёхбитного режимов %типы
сведения об~адресации}


\epigraph{\begin{stanza}[0mm]
Но если б я был не здесь,\\
Всё было б точно так же, как есть.\\
\hspace{\stanzaoddindent}Всё дело во мне самом,\\
\hspace{\stanzaoddindent}И если б я был чуть твёрже умом,\\
\hspace{\stanzaoddindent}Я был бы в пути, но мне всё равно,\\
Там я, или я здесь. \\
\end{stanza}
}{\Aquarium}

Адресация в~системе команд x86 частично задаётся опкодом.
Это относится не только к~неявной адресации (что логично), но и~к~непосредственной. % и~регистровой.
Более того, для самых компактных команд номер операнда-регистра также может быть указан внутри опкода.
Так, тот вариант команды \lstinline!mov!, который записывает непосредственное значение в~регистр, 
состоит из однобайтового опкода и~поля~$Immediate$; при этом собственно код операции  занимает пять старших бит  опкода, а~последние три бита  задают регистр-приёмник.
% Команда загрузки значения в~регистр общего назначения \lstinline!mov $13, %eax! содержит его имя в~явном виде,
\index{Команды!mov}%
% а~соответствующий машинный код \hex{B8\,00\,00\,00\,0D} содержит номер  регистра%~$eax$. %
% ~$A$ ($B8_{16} = 10111000_2$, последние три бита $000$ задают регистр-приёмник).
При этом, если опкодом задаётся использование
двух операндов,
один из которых непосредственный, а~второй 
% в~памяти,
адресуется полем $R/M$,
то в~освободившееся поле $Reg$ байта $Mod~R/M$ может быть записана часть опкода.
% Также опкод включает поле направления, показывая
% Код операции задаёт, в~частности, неявну
% Неявная и~непосредственная адресация задаются кодом операции.
% Значение непосредственного 

% В~большинстве команд адресация задаётся байтом  $Mod~R/M$ и~при необходимости уточняется байтом $SIB$ и~полем $Displacement$.
Кроме непосредственного% операнда
, команда может иметь  два операнда,
расположение которых задаётся байтом  $Mod~R/M$ и~при необходимости уточняется байтом $SIB$ и~полем $Displacement$.

% Один из них "--- всегда регистр, 
Поле $Reg$ байта $Mod~R/M$ содержит трёхбитовый номер операнда-регистра.
\index{Адресация!регистровая}
Является ли он источником или приёмником, определяет специальный бит опкода "--- поле направления.


Поле $R/M$ в~зависимости от поля~$Mod$ может как содержать номер второго  операнда-регистра,
так и~определять адрес операнда в~памяти.
При необходимости совместно с~полями $R/M$ и~$Mod$ используются также $SIB$ и~$Displacement$ (таблица~\ref{tab:command:rm}).


\begin{table}[!ht]
% \caption{Адресация второго операнда}
\caption{Адресация операнда при помощи поля $R/M$}
\label{tab:command:rm}
\renewcommand{\tabularxcolumn}[1]{m{#1}}


\newcommand{\sib}[4]
{
\begin{tikzpicture}[
start chain=going right,
node distance=0ex, outer sep=0ex, inner sep = 0.2ex,
% baseline=(current bounding box.center)
baseline=(q)
]
%   \matrix (m) [matrix of nodes, row sep=3em, column sep=0em]
%     { %$(Scale,$ & $Index$  & $Base)$ \\
%      0  & #1 & #2  \\ };
      
% \foreach \i in {1,...,5}
% {
% \path (m-1-\i) -- node[sloped] {$\geqslant$} (m-2-\i);
% };

\node[on chain] (s) {$~(Scale,$};
\node[on chain, text width=\widthof{$Index,$}, text badly centered] (i) {$#1,$};
\node[on chain, text width=\widthof{$Base)$}, text badly centered] (b) {$#3)$};
\foreach \f/\nf in {i/#2, b/#4}
{
  \ifthenelse{\equal{\nf}{}}{}{
  \node[below = 2ex of \f|-i.base] (n\f) {$\nf$};
  \path (\f|-i.base) -- node[sloped] {$\neq$} (n\f);
%   \path (n\f) -- node[sloped] {$\neq$} (\f|-i.south);
}
};

\ifthenelse{\equal{#2#4}{}}
{
% \node[below = 0.2ex of i] {};
\coordinate (q) at (i.base);
}{
% \node[below = 0.2ex of ni] {};
% \node[above = 0.5ex of i] {};
% \coordinate (q) at ($0.5*(current bounding box.center) + 0.5*(current bounding box.base)$);
\coordinate (q) at (current bounding box.center);
}
\end{tikzpicture}

}


% \bfseries
\small
% \footnotesize
\begin{tabularx}{1\linewidth}{|@{\,}c@{\,}|@{\,}c@{\,}|@{\,}C@{\,}|@{\,}c@{\,}|@{\,}c@{\,}|}
\hline
$\footnotesize{\boldsymbol{Mod}}$	& \footnotesize$\boldsymbol{Displacement}$ & \footnotesize$\boldsymbol{R/M}$	& \footnotesize$\boldsymbol{SIB}$	& \footnotesize\textbf{Операнд}\\\hline
$11$	& --- & %номер регистра 
$Reg2$	& --- & $Reg2$\\\hline
\multirow{3}{*}{$01$}	& \multirow{3}{*}{%восьмибитное смещение 
$Disp8$}	& $Base\neq 100$ &	---& $*\Big(Base + Disp8\Big)$\\\cline{3-5}    
  &	&	$100$	& \sib{Index}{100}{Base}{}	& $*\Big(Base + 2^{Scale} \cdot Index + Disp8\Big)$\\\cline{3-5} 
  &	&	$100$	& \sib{100}{}{Base}{}	& $*\Big(Base  + Disp8\Big)$\\\hline
%  \multirow{2}{*}{$10$}	& \multirow{2}{*}{$Disp32$}	& $Base\neq 100$ &	отсутствует& $*\Big(Base + Disp32\Big)$\\\cline{3-5}    
% % \hhline{~~---}
%   &	&	$100$	& $(Scale, Index, Base)$	& $*\Big(Base + 2^{Scale} \cdot Index + Disp32\Big)$\\\hline
\multirow{3}{*}{$10$}	& \multirow{3}{*}{$Disp32$}	& $Base\neq 100$ &	---& $*\Big(Base + Disp32\Big)$\\\cline{3-5}    
  &	&	$100$	& \sib{Index}{100}{Base}{}	& $*\Big(Base + 2^{Scale} \cdot Index + Disp32\Big)$\\\cline{3-5} 
  &	&	$100$	& \sib{100}{}{Base}{}	& $*\Big(Base  + Disp32\Big)$\\\hline
% $00$	&	  
% \begin{tabular}{@{}c@{}}
% $Disp32$\\(если\\необходимо)
% \end{tabular}
% & 
% \multicolumn{3}{c|}{
% \begin{tabular}{@{}c@{}}
% Частичная косвенная адресация\\
% (зависит от разрядности режима)
% \end{tabular}
% }\\\hline
\multirow{5}{*}{$00$}	& \multirow{2}{*}{---}	& $Base \notin \{100, 101\}$	& --- & $*\Big(Base\Big)$\\\cline{3-5} 
	&	& $100$	& \sib{Index}{100}{Base}{101} & $*\Big(Base + 2^{Scale} \cdot Index\Big)$\\\cline{2-5} 
	& \multirow{3}{*}{$Disp32$}	& $100$	& \sib{Index}{100}{101}{} & $*\Big( 2^{Scale} \cdot Index + Disp32 \Big)$\\\cline{3-5} 
	&	& $100$	& \sib{100}{}{101}{} & $*\Big( Disp32 \Big)$\\\cline{3-5} 
	&	& $101$	& --- & 
\begin{tabular}{@{}c@{}}
зависит от разрядности режима \\
\begin{tabular}{@{}lc@{}}
32-битный: &$*\Big( Disp32 \Big)$ \\
64-битный: & $*\Big( rip + Disp32 \Big)$ \\
\end{tabular}	
\end{tabular}
	\\\hline
% 	&	& \multirow{3}{*}{$101$}	& \multirow{3}{*}{---} & зависит от разрядности режима: \\
% 	&	&	&	&	32-битный: $*\Big( Disp32 \Big)$ \\
% 	&	&	&	&	64-битный: $*\Big( rip + Disp32 \Big)$ \\\hline
\end{tabularx}
\end{table}


При $Mod=11$ поле $R/M$  "--- номер второго  операнда-регистра.
% в~соответствии с~таблицей~\ref{tab:command:reg}.
Остальные три возможных значения $Mod$ соответствуют косвенной адресации,
\index{Адресация!косвенная}
то есть операнд находится в~памяти по некоторому адресу.


Адрес операнда  в~памяти в~общем случае может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = {Base} + 2^{Scale} \cdot {Index} + Displacement
\end{equation}
где масштаб $Scale \in [0, 3]$ "--- константа,
${Base}$ и~${Index}$ "--- регистры.

Каждая из компонент может быть опущена;
таким образом, прямая адресация в~x86 является частным случаем косвенной.


% Адрес складывается из нескольких регистров ()
Значения поля $Mod$ $01$ и~$10$ 
% соответствуют полной форме 
показывают наличие поля $Displacement$ различной длины (при $Mod=01$ "--- восьмибитное, при $Mod=10$ %разрядность этого поля соответствует разрядности команды: шестнадцати или тридцати двум битам
% "--- шестнадцать или тридцать два бита, в~зависимости от режима
"--- тридцатидвухбитное% в~тридцатидвухбитном режиме
), содержащего смещение.
% \begin{equation}
% \label{eq:command:mod10}
% \text{Адрес} = \zeta + Displacement
% \end{equation}
% где $\zeta$ "--- комбинация регистров, определяемая полем $R/M$ и~байтом~$SIB$.
% % Комбинация регистров 
% $\zeta$
% либо включает только один базовый регистр, код которого находится в~поле $R/M$,
% либо определяется байтом~$SIB$, в~этом случае поле $R/M$ принимает специальное значение $100$
% (в~таблице~\ref{tab:command:reg} оно соответствует регистру~$sp$).
При $Mod=00$ смещение может отсутствовать или быть тридцатидвухбитным в~зависимости от значения других полей.


% При этом любое значение поля $R/M$, кроме $100$, соответствует полной форме косвенной базовой адресации со смещением (байт $SIB$ отсутствует),
% а~специальное значение $R/M=100$ "--- %полной форме 
% косвенной базово-индексной адресации с~масштабом и~смещением (базовый и~индексный регистры, а~также масштабный коэффициент индексного регистра задаются байтом~$SIB$).
% \begin{equation}
% \label{eq:command:zeta}
% \zeta = 
% \left\{
% \begin{array}{ll}
% Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% \end{equation}
Байт~$SIB$ следует за байтом $Mod~R/M$, если поле $R/M$ принимает специальное значение $100$.
Первые два его бита "--- масштаб "--- целое число $Scale \in [0, 3]$,  %\{0, 1, 2,  3}$, 
определяющее коэффициент,
на который умножается индексный регистр (соответственно $1, 2, 4$ или $8$),
далее следуют трёхбитные поля $Index$ и~$Base$, хранящие номера регистров.
Значение поля $Index = 100$ является специальным, в~этом случае %в~формуле~\eqref{eq:command:zeta} используется
считается $Index=0$ (то есть получается базовая адресация без индекса).
Таким образом, индексный регистр в~\eqref{eq:command:addressing} не может иметь код $100$ ни при каких значениях прочих полей.
% Базовый регистр 

Если значение поля $R/M$ отлично от $100$, байт $SIB$ отсутствует.

При $Mod=01$ или~$Mod=10$ любое значение $R/M \neq 100$ трактуется как номер базового регистра $Base$ в~базовой адресации со смещением,
то есть адрес операнда в~памяти равен $Base+Displacement$, где $Base$ не может иметь код $100$.
При $R/M=100$ используется базово-индексная адресация со смещением ${Base} + 2^{Scale} \cdot {Index} + Displacement$, где $(Scale, Index, Base) \in SIB$.
Используя специальное значение $Index=100$, можно получить базовую адресацию со смещением; в~этом случае базовый регистр $Base \in SIB$ может быть любым, включая $Base = 100$.
% Соответственно, базовый регистр в~базовой адресации

Режим $Mod=00$ "--- самый запутанный.
% При $Mod=00$ 
По умолчанию используется косвенная %базово-индексная 
адресация без смещения (поле $Displacement$ отсутствует).
При этом значение базового регистра (безразлично, записанного в~поле $R/M$ или в~поле $SIB$) $Base = 101$ является специальным
и~соответствует отсутствию в~\eqref{eq:command:addressing} базового регистра ($Base=0$) и~одновременно "--- присутствию в~команде тридцатидвухбитного смещения.
Таким образом, базовый регистр в~адресации без смещения не может иметь код $101$ (но обратиться к~подобному адресу можно "--- например, используя $Mod=01$, где $101$ является допустимым номером базового регистра, и~указав восьмибитное смещение, равное нулю).

В~шестидесятичетырёхбитном режиме случай $R/M = Base = 101$ при $Mod=00$ трактуется как особый случай и~соответствует адресации относительно %указателя команд
адреса следующей команды (специального регистра $rip$ "--- указателя команд), то есть адрес операнда в~памяти равен $rip+Displacement$~\cite{amd64Instructions}.
В~тридцатидвухбитном режиме аналога этой адресации нет.

% Таким образом, адрес операнда при $Mod=01$ или~$Mod=10$ может иметь вид
% \begin{equation}
% \label{eq:command:base+displacement}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{@{}l@{~}l}
% Base + Displacement, & R/M = 100, Base\in SIB, Index = 100\\
% Base + 2^{Scale} \cdot Index + Displacement, & R/M = 100, (Scale, Index, Base) \in SIB\\
% Base + Displacement, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Первая строка отличается от последней тем, что $Base$ из поля $SIB$ может соответствовать 
% % регистру $sp$ (код $100$).
% номеру~$100$.

% При $Mod=00$ %адрес складывается
% используется косвенная адресация без смещения, 
% кроме специального случая $Base=101$, когда, наоборот, остаётся тридцатидвухразрядное смещение без базы:
% % Также при  $Mod=00$ возможно
% \begin{equation}
% \label{eq:command:baseonly-displacementonly}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{ll}
% Displacement, &R/M = 101~\text{(только в~32-битном режиме)} \\%(bp)\\
% Displacement, & R/M = 100, Base=101, Index = 100\\
% 2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Соответственно, регистр $bp$ (код $101$) не может быть базовым без смещения (но может быть базовым с~нулевым смещением при $Mod \in\{01, 10\}$ и~$Displacement=0$).
% используется частичная косвенная адресация (в~выражении ${Base} + 2^{Scale} \cdot {Index} + Displacement$ отсутствует одна из компонент адреса).
% Адресация при $Mod=00$  в~тридцатидвухбитном и~шестидесятичетырёхбитном режимах немного различается, поэтому этот случай будет рассмотрен отдельно.
% Значен

% В~качестве компонент адреса операнда можно без ограничений использовать регистры~$A, B, C, D, si, di$ необходимой разрядности
% и~ограниченно "--- $bp$ (без ограничений может быть индексным, при $Mod \in\{01, 10\}$ может быть базовым)
% и~$sp$ (может быть базовым, что широко используется при адресации элементов стека, но не индексным),
% номера которых совпадают со специальными значениями полей.

В~шестидесятичетырёхбитном режиме разрядность номеров регистров может быть увеличена с~помощью префиксов расширения регистра.
Разрядность поля $Displacement$ в~шестидесятичетырёхбитном режиме не повышается до 64 бит.


Таким образом, 
всего у~команды x86 может быть не более трёх явных операндов,
среди которых 
не более одного непосредственного значения,
не более одного  значения в~памяти
и~не более двух  регистров, причём два операнда-регистра исключают операнд в~памяти.

Адрес операнда в~памяти складывается из четырёх компонент по базово-индексной схеме со смещением, причём базовым может быть любой регистр общего назначения (в~шестидесятичетырёхбитном режиме "--- ещё и~указатель команд, но только в~базовой адресации без индекса), индексным не может быть регистр с~кодом $100$.


\subsection{Адресация в~тридцатидвухбитном режиме}
\epigraph{\begin{limerick}
    Один старичок был не в духе, \\
    Он решил прокатиться на мухе.\\
    «Далеко не летай,\\
    За горою "--- Китай», "---\\
    Старику объяснили старухи.
\end{limerick}
}
{\Lear}

% Поле $Mod$ (первые два бита следующего байта "--- $Mod~R/M$) задаёт регистровую или косвенно-регистровую адресацию.
% Если оно равно $11$, то используется регистровая адресация и~оба следующие трёхбитовых поля ($Reg$ и~$R/M$) "--- номера регистров.
% Остальные значения задают косвенную адресацию с~различной разрядностью смещения (количеством байт в~$Displacement$). %, тогда .

% Поле $Reg$ байта $Mod~R/M$ содержит трёхбитовый номер операнда-регистра (таблица~\ref{tab:command:reg}).
В~тридцатидвухбитном режиме номера операндов-регистров задаются только трёхбитовыми полями %внутри команды
байтов $Mod~R/M$ и~$SIB$.
Каждому трёхбитному номеру  соответствует определённый регистр общего назначения с~учётом типа и~разрядности команды (таблица~\ref{tab:command:reg}).
\index{Адресация!регистровая}
% Является ли он источником или приёмником, определяет специальный бит опкода "--- поле направления.
% % Поле $Reg$ задаёт номер регистра "--- первого (левого) операнда.
% % В~системе команд x86, если операндов два и~более, то один из них "--- обязательно регистр.
\begin{table}[!ht]
\caption{Номера (коды) регистров}
\label{tab:command:reg}

% \begin{tabular}{|l|l|}
% \hline
% Регистр	& Код \\
% \hline
% eax/ax/al/mm0/xmm0 & 000 \\
% ecx/cx/cl/mm1/xmm1 & 001 \\
% edx/dx/dl/mm2/xmm2 & 010 \\
% ebx/bx/bl/mm3/xmm3 & 011\\
% esp/sp/ah/mm4/xmm4 & 100\\
% ebp/bp/ch/mm5/xmm5 & 101\\
% esi/si/dh/mm6/xmm6 & 110\\
% edi/di/bh/mm7/xmm7 & 111\\ 
% \hline
% \end{tabular}
\bfseries
\begin{tabularx}{1\linewidth}{|ccc|cc|C|}
\hline
\multicolumn{5}{|c|}{Регистр}	& \multirow{2}{*}{Код} \\
\cline{1-5}    
% \hhline{-----~}
32 бита & 16 бит & 8 бит	& Команда MMX & Команда XMM &	\\
\hline
$eax$ & $ax$ & $al$ & $mm0$ & $xmm0$ & $000$ \\
$ecx$ & $cx$ & $cl$ & $mm1$ & $xmm1$ & $001$ \\
$edx$ & $dx$ & $dl$ & $mm2$ & $xmm2$ & $010$ \\
$ebx$ & $bx$ & $bl$ & $mm3$ & $xmm3$ & $011$ \\
$esp$ & $sp$ & $ah$ & $mm4$ & $xmm4$ & $100$ \\
$ebp$ & $bp$ & $ch$ & $mm5$ & $xmm5$ & $101$ \\
$esi$ & $si$ & $dh$ & $mm6$ & $xmm6$ & $110$ \\
$edi$ & $di$ & $bh$ & $mm7$ & $xmm7$ & $111$ \\ 
\hline
\end{tabularx}

\end{table}

В~зависимости от разрядности команды и~от того, входит ли команда в~основной набор инструкций или в~какое-либо из расширений,
один и~тот же номер адресует разные регистры.
Из таблицы~\ref{tab:command:reg} видно, что
в~тридцатидвухбитном режиме
младшие байты  регистров $sp, bp, si, di$ не могут иметь имён, потому что соответствующие номера уже заняты $ah{-}dh$.

% 
% При $Mod=11$ поле $R/M$  "--- номер второго  операнда-регистра в~соответствии с~таблицей~\ref{tab:command:reg}.
% Остальные три возможных значения $Mod$ соответствуют косвенной адресации,
% \index{Адресация!косвенная}
% то есть операнд находится в~памяти по некоторому адресу.
% 
% % Адрес складывается из нескольких регистров ()
% Значения поля $Mod$ $01$ и~$10$ показывают наличие поля $Displacement$ различной длины (при $Mod=01$ "--- восьмибитное, при $Mod=10$ %разрядность этого поля соответствует разрядности команды: шестнадцати или тридцати двум битам
% % "--- шестнадцать или тридцать два бита, в~зависимости от режима
% "--- тридцатидвухбитное в~тридцатидвухбитном режиме), содержащего смещение.
% \begin{equation}
% \label{eq:command:mod10}
% \text{Адрес} = \zeta + Displacement
% \end{equation}
% где $\zeta$ "--- комбинация регистров, определяемая полем $R/M$ и~байтом~$SIB$.
% % Комбинация регистров 
% $\zeta$
% либо включает только один базовый регистр, код которого находится в~поле $R/M$,
% либо определяется байтом~$SIB$, в~этом случае поле $R/M$ принимает специальное значение $100$
% (в~таблице~\ref{tab:command:reg} оно соответствует регистру~$sp$).
% \begin{equation}
% \label{eq:command:zeta}
% \zeta = 
% \left\{
% \begin{array}{ll}
% Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% \end{equation}
% Байт~$SIB$ следует за байтом $Mod~R/M$.
% Первые два его бита "--- масштаб "--- целое число $Scale \in [0, 3]$,  %\{0, 1, 2,  3}$, 
% определяющее коэффициент,
% на который умножается индексный регистр (соответственно $1, 2, 4$ или $8$),
% далее следуют трёхбитные поля $Index$ и~$Base$, хранящие номера регистров.
% Значение поля $Index = 100$ считается специальным, в~этом случае в~формуле~\eqref{eq:command:zeta} используется $Index=0$.
% 
% Таким образом, адрес операнда при $Mod=01$ или~$Mod=10$ может иметь вид
% \begin{equation}
% \label{eq:command:base+displacement}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{ll}
% Base + Displacement, & R/M = 100, Index = 100\\
% Base + 2^{Scale} \cdot Index + Displacement, & R/M = 100\\
% Base + Displacement, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Первая строка отличается от последней тем, что $Base$ из поля $SIB$ может соответствовать регистру $sp$ (код $100$).

% При $Mod=00$ %адрес складывается
% используется косвенная адресация без смещения, 
% кроме специального случая $Base=101$, когда, наоборот, остаётся тридцатидвухразрядное смещение без базы:
% % Также при  $Mod=00$ возможно
% \begin{equation}
% \label{eq:command:baseonly-displacementonly}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{ll}
% Displacement, &R/M = 101~\text{(только в~32-битном режиме)} \\%(bp)\\
% Displacement, & R/M = 100, Base=101, Index = 100\\
% 2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Соответственно, регистр $bp$ (код $101$) не может быть базовым без смещения (но может быть базовым с~нулевым смещением при $Mod \in\{01, 10\}$ и~$Displacement=0$).

% Таким образом, 
% всего у~команды x86 может быть не более трёх явных операндов,
% среди которых 
% не более одного непосредственного значения,
% не более одного  значения в~памяти
% и~не более двух  регистров, причём два операнда-регистра исключают операнд в~памяти.
% 
% Адрес операнда  в~памяти может включать до четырёх компонент: %задаётся 
% \begin{equation}
% \label{eq:command:addressing}
% \text{Адрес} = {Base} + 2^{Scale} \cdot {Index} + Displacement
% \end{equation}
% где масштаб $Scale \in [0, 3]$ "--- константа,
% ${Base}$ и~${Index}$ "--- регистры.
% 
% Каждая из компонент может быть опущена;
% таким образом, прямая адресация в~x86 является частным случаем косвенной.

В~качестве компонент адреса операнда можно без ограничений использовать регистры~$A, B, C, D, si, di, bp$ необходимой разрядности.
% и~ограниченно "--- 
% $bp$ (без ограничений может быть индексным, при $Mod \in\{01, 10\}$ может быть базовым)
% и~$sp$ (может быть базовым, что широко используется при адресации элементов стека, но не индексным),
% номера которых совпадают со специальными значениями полей.
Указатель стека $sp$ может быть базовым, что широко используется при адресации элементов стека, но не индексным,  так как его код совпадает со специальным значением $100$ поля $Index$.

\subsection{Расширение регистров в~шестидесятичетырёхбитном режиме}

\epigraph{\begin{limerick}
Жил старик, по фамилии Плиски,\\
С головою не больше редиски.\\
Но, надевши парик,\\
Становился старик\\
Судьёй, по фамилии Плиски!\\
\end{limerick}
}
{\Lear}


\index{REX, префикс}
В~шестидесятичетырёхбитном режиме между историческими префиксами и~опкодом может находиться
специальный однобайтовый префикс расширения регистров $REX$.
Его 
младшие три бита (биты 0-2, обозначаемые в~документации как $B$, $X$, $R$)
используются для увеличения разрядности номеров регистров, % (добавления старшего бита к~номеру).
следующий (третий) бит ($W$) определяет, используются ли шестидесятичетырёхбитные операнды (1) или разрядность операндов %определяется опкодом,
не изменяется (0),
старшие четыре бита равны $0100$ и~служат для идентификации.

Бит 2 префикса $REX$ ($REX.R$)
 добавляется к~полю $Reg$ байта $Mod~R/M$,
бит 1  ($REX.X$) "--- к~полю $Index$ байта $SIB$,
младший бит~0 ($REX.B$), в~зависимости от используемой адресации "--- к~%номеру регистра в~поле 
полю $R/M$ байта $Mod~R/M$, полю~$Base$ байта~$SIB$ или номеру регистра внутри опкода.

Таким образом, количество адресуемых регистров общего назначения возрастает до шестнадцати.
Номера регистров $A{-}di$, указанные в~таблице~\ref{tab:command:reg},
соответствуют отсутствию префикса $REX$ или нулю  в~соответствующем бите $REX$ (в~последнем случае с~учётом $REX$ получаем четырёхбитовые коды~$0100{-}0111$).
Единица в~$REX$ в~сочетании с~трёхбитовым полем в~команде даёт номера регистров $1000{-}1111$, то есть $r8{-}r15$ (таблица~\ref{tab:command:reg64}).

\begin{table}[!ht]
\caption{Номера (коды) регистров общего назначения при использовании $REX$}
\label{tab:command:reg64}

\bfseries
\begin{tabularx}{1\linewidth}{|CCCC|C|CCCC|C|}
\hline
\multicolumn{4}{|c|}{Регистр}	& \multirow{2}{*}{Код}& \multicolumn{4}{c|}{Регистр}	& \multirow{2}{*}{Код}\\
\hhline{----~----~}
64 бита & 32 бита & 16 бит & 8 бит    && 64 бита & 32 бита & 16 бит & 8 бит & \\
\hline
$rax$ & $eax$ & $ax$ & $al$  & $0000$ & $r8 $ & $r8 d$ & $r8 w$ & $r8 b$ & $1000$\\
$rcx$ & $ecx$ & $cx$ & $cl$  & $0001$ & $r9 $ & $r9 d$ & $r9 w$ & $r9 b$ & $1001$\\
$rdx$ & $edx$ & $dx$ & $dl$  & $0010$ & $r10$ & $r10d$ & $r10w$ & $r10b$ & $1010$\\
$rbx$ & $ebx$ & $bx$ & $bl$  & $0011$ & $r11$ & $r11d$ & $r11w$ & $r11b$ & $1011$\\
$rsp$ & $esp$ & $sp$ & $spl$ & $0100$ & $r12$ & $r12d$ & $r12w$ & $r12b$ & $1100$\\
$rbp$ & $ebp$ & $bp$ & $bpl$ & $0101$ & $r13$ & $r13d$ & $r13w$ & $r13b$ & $1101$\\
$rsi$ & $esi$ & $si$ & $sil$ & $0110$ & $r14$ & $r14d$ & $r14w$ & $r14b$ & $1110$\\
$rdi$ & $edi$ & $di$ & $dil$ & $0111$ & $r15$ & $r15d$ & $r15w$ & $r15b$ & $1111$\\ 
\hline
\end{tabularx}

\end{table}

Изменяя бит 3 префикса $REX$  ($REX.W$), можно получить разрядность от 8 до 64 как для $r8{-}r15$, так и~для $A{-}di$.
% В~шестидесятичетырёхбитном режиме %префикс расширения регистров $REX$ 
% есть возможность дополнить коды регистров 
% (за счёт использования специальных префиксов расширения регистров $REX$).
% % добавить ещё восемь регистров.
При использовании восьмибитной команды в~сочетании с~$REX$ с~нулевым третьим битом (то есть разрядность не изменяется и~операнды занимают 8~бит)  коды регистров $0100{-}0111$ описывают младшие байты  регистров $sp{-}di$
"--- в~документации и~коде программы они обозначаются $spl{-}dil$.
Таким образом, в~шестидесятичетырёхбитном режиме доступны как $ah{-}dh$, так и~$spl{-}dil$.
При этом в~одной и~той же команде нельзя адресовать, например, $ah$ и~$sil$% или $ah$ и~$r8$
, так как для первого требуется обязательное отсутствие у~команды префикса $REX$, а~для второго "--- наличие $REX$ с~нулевым третьим битом.
% % Прочие регистры тридцатидвухбитного режима доступны как с~

$REX$ "--- не единственный префикс расширения регистров.
В~частности, команды расширения AVX (YMM) Intel используют двух- или трёхбайтовый префикс $VEX$, одной из функций которого также является расширение номеров регистров $ymm$; расширение AVX512 (ZMM) "--- префикс $EVEX$.
В~расширении SSE5 (XOP) AMD также используется похожий, но при этом несовместимый с~$VEX$ префикс.

\subsection{Операнды и~адресация в~шестидесятичетырёхбитном режиме}

\epigraph{\begin{limerick}
    Горемыка, страдавший отчаянно, \\
    Приобрёл себе зайца нечаянно "---\\
    И умчал на нём вдаль,\\
    Чтоб размыкать печаль\\
    И уже не страдать так отчаянно.
\end{limerick}
}
{\Lear}

Шестидесятичетырёхбитный режим процессоров семейства x86 является расширением тридцатидвухбитного и~отличается от него менее существенно, чем тридцатидвухбитный защищённый режим от шестнадцатибитного реального.
В~частности, структура команды аналогична описанной ранее.
Режимы адресации (кроме добавленной возможности адресовать данные относительно указателя команд) также сохраняются.

Количество доступных регистров общего назначения в~шестидесятичетырёхбитном режиме увеличено за счёт возможности использования префикса $REX$, хранящего дополнительный бит номера регистра.
При этом при %декодировании команды и~
формировании адреса операнда в~памяти вначале определяются его компоненты, для чего трёхбитовые поля байтов  $Mod~R/M$ и~$SIB$ проверяются на соответствие специальным значениям, а~затем уже рассматривается префикс $REX$ для определения номеров используемых регистров.
Таким образом, в~шестидесятичетырёхбитном режиме индексным не может быть ни один регистр, младшие три бита номера которого равны специальному значению $100$. Это  указатель стека $sp$ с~номером $0100$ 
и~$r12$, обозначаемый номером $1100$.
% специальному значению $Index=100$ соответствует не только указатель стека $sp$ с~номером $0100$, но и~регистр $r12$, обозначаемый номером $1100$ (%при декодировании команды анализируется только поле  
% старший бит $1$ содержится в~префиксе $REX$, а~поле $Index$ байта $SIB$ равно специальному значению).
% Таким образом, в~шестидесятичетырёхбитном режиме регистры $sp$ и~$r12$ оба не могут быть индексными в~косвенной адресации операнда.

\subsubsection{Разрядность операндов в~регистрах и~памяти}


% General-Purpose Programming
% 3.1.2.1  Default Operand Size
% For most instructions, the default operand size in 64-bit mode is 32 bits . To access 16-bit operand sizes, an instruction must contain an operand-size prefix (66h), as described in Section 3.2.3, “Operand Sizes and Overrides,” on page 41. To access the full 64-bit operand size, most instructions must contain a $REX$ prefix. 
Для большинства команд в~шестидесятичетырёхбитном режиме размер операнда по умолчанию "--- 32 бита.
Разрядность операндов может быть понижена до 16 бит соответствующим префиксом или повышена до 64 префиксом $REX$ с~единичным третьим битом $REX.W$   ~\cite{amd64Application}.



% http://support.amd.com/TechDocs/24594.pdf
% In 64-bit mode, two groups of instructions default to 64-bit operand size without the need for a $REX$ prefix:
% • Near branches
%  —CALL, Jcc, JrCX, JMP, LOOP, and RET. 
% • All instructions, except far branches, that implicitly reference the RSP
% —CALL, ENTER, LEAVE, POP, PUSH, and RET (CALL and RET are in both groups of instructions).
\index{Команды!call}
\index{Команды!ret}
\index{Команды!push}
\index{Команды!pop}
% Кроме того, в
В~шестидесятичетырёхбитном режиме есть две группы команд, которые по умолчанию (без указания префикса $REX$) используют шестидесятичетырёхбитные операнды: 
% и~не требуют для этого :
это команды, работающие с~указателями (условные и~безусловные переходы) и~команды, неявно использующие указатель стека (по умолчанию это~$rsp$).
Команды вызова и~возврата из функций относятся к~обеим группам, так что они по умолчанию используют шестидесятичетырёхбитные адреса и~шестидесятичетырёхбитный указатель стека~$rsp$.
% То есть 
% The 64-bit default operand size can be overridden to 16 bits using the 66h operand-size override. 
% However, it is not possible to override the operand size to 32 bits because there is no 32-bit operand-size override prefix for 64-bit mode. See “Operand-Size Override Prefix” on page 7 for details. 
Разрядность  операндов этих команд может быть понижена с~64 бит до 16 указанием соответствующего префикса, но способа понизить её до 32 бит не существует~\cite{amd64Instructions}.

\subsubsection{Разрядность непосредственных операндов и~смещения}

Размер полей $Immediate$ (кроме команды пересылки непосредственного значения в~регистр) и~$Displacement$ в~шестидесятичетырёхбитном режиме не повышается до 64 бит даже при использовании префикса $REX$.

Таким образом, непосредственные операнды занимают 1, 2 или 4 байта. 
Если непосредственный операнд (обычно тридцатидвухбитный) присутствует в~шестидесятичетырёхбитной команде, он расширяется до 64 бит во время исполнения команды.
% Тридцатидвухбитные непосредственные операнды при 
Единственная команда, включающая непосредственный операнд размером 8 байт "--- команда пересылки непосредственного операнда в~регистр
% включающая префикс расширения ре
в~сочетании с~единичным $REX.W$ (что повышает разрядность регистра-приёмника до 64).
В~документации Intel эта форма команды обозначается мнемоникой \lstinline!mov!, как и~другие варианты пересылки значения.
Синтаксис AT\&T выделяет форму с~шестидесятичетырёхбитным непосредственным операндом как мнемонику \lstinline!movabs!.

% Смещение в~косвенной адресации не может быть шестидесятичетырёхбитным.

\subsection{Адресация относительно указателя команды}

\epigraph{\begin{limerick}
Был персонистый старец из Фил,\\
Археолух и скрубиофил;\\
В вёдро влезет на древо \\
И глядит вправо-влево,\\
Озирая развалины Фил.\\
\end{limerick}
}
{\Lear}

В~тридцатидвухбитном режиме, как указано в~%\eqref{eq:command:baseonly-displacementonly}
таблице~\ref{tab:command:rm}, существует два способа прямой адресации (указания на фиксированный адрес $Displacement$ в~памяти): 
\begin{itemize}
\item без использования байта $SIB$, при $R/M = 101$;
\item с~использованием $SIB$ со специальными значениями как поля базы, так и~поля индекса, то есть при $R/M = 100, Base=101, Index = 100$.
\end{itemize}
Оба они доступны при $Mod=00$, так что адрес $Displacement$ тридцатидвухразряден.

В~шестидесятичетырёхбитном режиме к~фиксированному адресу %$Displacement$  
можно обратиться, только указав специальные значения байта $SIB$,
а~при $R/M = 101$ используется адресация относительно счётчика команд~$ip$ (в~шестидесятичетырёхбитном режиме "--- $rip$) \cite{amd64Instructions}:
\begin{equation}
\label{eq:command:baseonly-displacementonly-64}
\text{Адрес} = 
\left\{
\begin{array}{ll}
ip + Displacement, &R/M = 101 \\%(bp)\\
Displacement, & R/M = 100, Base=101, Index = 100\\
2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}
Таким образом, хотя шестидесятичетырёхбитный указатель команд $rip$ по-прежнему не является регистром общего назначения и~не имеет собственного номера,
он может быть базовым при $Mod=00$ без байта $SIB$.

Адресация относительно~$ip$ используется для решения двух задач:
\begin{itemize}
\item получение кода библиотек, работоспособность которого не зависит от адреса библиотеки в~памяти (в~тридцатидвухбитном режиме эта задача решалась корректировкой фиксированных адресов при загрузке);

\item обращение к~переменным по произвольному шестидесятичетырёхразрядному адресу (поле смещения в~шестидесятичетырёхбитном режиме осталось тридцатидвухбитным, так что прямая адресация позволяет обратиться только к~адресам в~пределах младших четырёх гигабайт).
\end{itemize}






\addquestion{Какие вы знаете регистры общего назначения x86?}


\addquestion{Какие вы знаете флаги?}
\addquestion{Какие методы адресации вы знаете?}


\printquestions
