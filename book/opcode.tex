\chapter{Архитектура команд семейства x86}
\label{sec:opcode}

\epigraph{\begin{stanza}
Знающий сокровенное и явное, силён, мудр. 
\end{stanza}
}
{64.18}

Обозначением x86 описывают целый класс вычислительных систем,
включающий уже практически не используемую шестнадцатибитную архитектуру,
тридцатидвухбитную архитектуру IA-32 (i386--i686),
шестидесятичетырёхбитную x86-64 (amd64, Intel 64 или IA-32e).

% В~настоящее время 
% Все x86-совместимые процессоры обладают 


Все модели 
этого многочисленного семейства 
% многочисленного семейства x86
совместимы между собой на уровне архитектуры команд,
то есть все современные процессоры в~определённом режиме могут выполнять программы, написанные для более старых.

В~данной главе рассматриваются режимы работы x86-совместимых процессоров, доступные регистры, флаги,
режимы адресации,
а~также структура команды и~вытекающие из неё ограничения.



\section{Развитие линейки x86 и~режимы работы}
 \epigraph{\begin{limerick}
   Пожилой господин на Таити \\
    Говорил: «Если вы говорите,\\
    Что мой нос длинноват,\\
    В том не я виноват,\\
    А избыток дождей на Таити».\\
\end{limerick}
}
{\Lear} 

% В~данной главе, как и~в~пособии в~целом, 
В~данном пособии
рассматривается тридцатидвухбитный  и~шестидесятичетырёхбитный режимы работы,
как более простые для прикладного программирования и~более распространённые.
Подробное описание качественно отличного от них шестнадцатибитного режима можно найти, в~частности, у~Питера Абеля~\cite{abel}.

Тем не менее, так как многие особенности архитектуры x86 обусловлены исторически 
и~поддерживаются для совместимости, 
% краткий обзор
необходимо сделать краткий экскурс в~историю данной линейки.
% Соответственно, многие аспекты архитектуры унаследованы современными моделями от 



% \subsection{Поколения процессоров Intel}
\subsection{История семейства x86}
\epigraph{\begin{stanza}
Я родился в таможне,\\
Когда я выпал на пол.\\
Мой отец был торговец,\\
Другой отец "--- Интерпол...\\
\end{stanza}
}{\Aquarium}

% Я удолбан весь день "--- самое адекватное описание x86
   
% Так как 
% % данное пособие посвящено ассемблеру процессоров семейства Intel x86,
% % рассмотрим их историю подробнее.
% многие особенности процессоров семейства x86 обусловлены совместимостью с~более ранними моделями,
% рассмотрим их историю подробнее.
% 
% \paragraph{Четырёхбитные и~восьмибитные предшественники}

% \termin{4-битные:}& 4004, 4040\\
Архитектура x86 основана на архитектуре четырёхразрядного микропроцессора Intel 4004\index{Intel 4004}.
Так как микросхема 4004 была разработана для настольного калькулятора,
в~ней не были реализованы многие механизмы,  давно и~успешно применявшиеся в~более ранних компьютерах,
в~частности, аппаратная трансляция адресов.
Позже была выпущена  улучшенная версия 4004 "--- процессор 4040\index{Intel 4040},
% \termin{8-битные:}& 8008, 8080 \terminComment{(адрес "--- 14),} 8085 \terminComment{(частота "--- 5 МГц)}\\
% На базе 4040 
а~на его основе
был разработан восьмиразрядный 8008\index{Intel 8008}, включавший два восьмибитных регистра общего назначения~$a$ и~$b$.
В~улучшенном 8080\index{Intel 8080} их было уже семь "--- $a, b, c, d, e, h, l$, объединявшиеся в~три пары $bc, de, hl$.
Шина адреса в~8080 была шестнадцатиразрядной (то есть можно было адресовать до $2^{16}$ байт, или 64 килобайта), адрес задавался парой регистров~$hl$.
% Улучшенная версия 8080 получила название 8085 из-за частоты 5 МГц.

\subsubsection{Шестнадцатибитные процессоры}

Процессор  8086\index{Intel 8086} "--- родоначальник семейства x86
"--- был шестнадцатибитным, из-за чего 16 бит при программировании для x86 обычно называют \termin{словом.}
\index{Слово!x86}%
Он включал четыре шестнадцатибитных регистра общего назначения $ax, bx, cx, dx$, каждый из которых фактически был парой восьмибитных (в~частности, $ax=ah:al$),
и~четыре неделимых шестнадцатибитных регистра $bp$, $sp$, $si$, $di$.
% Хотя эти регистры и
% http://www.firststeps.ru/asm/r.php?6
У каждого из них было и~специальное назначение: $A$ "--- accumulator (неявный аргумент большинства команд), %аккумулятор
$C$ "---	counter 	(счётчик),
$D$ "---	data		(данные), 
$B$ "---	base		(базовый регистр).
В~отличие от 32-разрядного режима, невозможно было использовать в~косвенной  адресации любые регистры.
Для задания адреса в~памяти использовались только три бита поля $R/M$ и~поле смещения (раздел~\ref{sec:command-x86}).
Базовыми могли быть только $bx$ и~$bp$ (base pointer), индексными "--- только $si$ и~$di$ (source index и~destination index).
Масштабирование индекса не использовалось.

Шина адреса при этом была двадцатиразрядной.
% Для %получения двадцатиразрядного
Для того, чтобы адресовать $2^{20}$ байт (один мегабайт) памяти шестнадцатибитными адресами,
была введена \termin{сегментная модель памяти.}
\index{Память!сегментная модель}
Полный адрес складывался из шестнадцатибитного адреса %, рассчитанного по базе, индексу и~смещению
и~значения специального сегментного регистра, умноженного на~16.

Область памяти, адресуемая с~помощью одного сегментного регистра, называлась сегментом.
Сегмент занимал $2^{16}$ байт, то есть 64 килобайта;
разные сегменты могли пересекаться или полностью совпадать.
% 
В~8086 было четыре сегментных регистра, соответственно в~программе использовалось четыре сегмента:%
\index{Сегмент}%
\begin{itemize}
\item    $cs$ (code segment) "--- сегмент кода; значение регистра $cs$ добавлялось к~адресам команд;
\item    $ds$ (data segment) "--- сегмент данных, его значение добавлялось к~адресам статических переменных;
\item    $es$ (extra segment) "--- дополнительный сегмент данных, иногда там располагалась куча;
\item    $ss$ (stack segment)\index{Стек} "--- сегмент стека, добавлялся к~адресам в~стеке.
\end{itemize}
% Программисту не требовалось 
Добавляемый сегментный регистр определялся процессором автоматически;
для данных при необходимости можно было использовать префикс замены сегмента.

Хотя в~настоящее время используется плоская модель памяти
% , так что разрядность адреса в~регистре совпадает с~разрядностью шины адреса, 
% (без использования сегментных регистров)
(сегментные регистры присутствуют, но 
% их значение равно нулю) неверно
содержат другую структуру данных "--- селектор сегмента)
по традиции области адресного пространства, где располагаются код, данные, стек и~т.\,д., часто называются сегментами.

Так как четырёх сегментов по 64 килобайта часто не хватало,
программисту приходилось изменять значения сегментных регистров во время работы программы для доступа к~различным областям памяти.
Управлять сегментами приходилось вручную. %, операционная систем

В~8086\index{Intel 8086}  всё ещё не было механизма трансляции адресов,
так что прикладные программы использовали реальные физические адреса ОЗУ;
из-за этого режим совместимости с~моделью памяти 8086\index{Intel 8086} 
в~более поздних процессорах называется \termin{реальным режимом.}
\index{Реальный режим}%
При этом каждой программе 
реального режима
была доступна вся память компьютера% и~все устройства
, что не позволяло реализовать полноценную многозадачность.


Для 8086\index{Intel 8086}  был разработан математический сопроцессор 8087\index{Intel 8087}\index{FPU}, предназначенный для вычислений с~плавающей запятой.
Сопроцессор устанавливался в~отдельный сокет на материнской плате.
Начиная с~этой модели, стали выпускаться урезанные варианты процессоров.
Так, 8086\index{Intel 8086}  с~восьмибитной шиной данных получил название 8088.\index{Intel 8088} 

На основе 8086\index{Intel 8086}  был построен компьютер  IBM PC\index{IBM PC}, 
так что большинство последующих  процессоров Intel (и~неинтеловских x86-совместимых процессоров)
% основанные на нём более
% поддерживают 
совместимы с~8086 на уровне машинного кода.
Теоретически любой современный персональный компьютер можно загрузить в~специальном режиме совместимости и~выполнить программу, написанную для 8086\index{Intel 8086}.
Практически с~этим возникнут  трудности, в~частности, из-за несоответствия временн\'{ы}х характеристик.

Непосредственно следующая модель, 80186\index{Intel 80186}, отличалась от 8086 незначительно.
В~80286\index{Intel 80286} появилась частичная поддержка \termin{защищённого режима,} когда память разных программ изолирована (защищена) друг от друга за счёт аппаратной трансляции адресов.
\index{Защищённый режим}%
Шина адреса была увеличена до 24 разрядов.

\subsubsection{Тридцатидвухбитные и~шестидесятичетырёхбитные процессоры}


Полноценная реализация защищённого режима появилась в~тридцатидвухбитном процессоре 80386\index{Intel 80386} (часто называемом просто 386).
\index{Память!плоская модель}
Так как разрядность процессора сравнялась с~разрядностью шины адреса, в~защищённом режиме 386 используется плоская модель памяти.
Количество сегментных регистров возросло до шести. 
% При этом в~защищённом режиме сложилась парадоксальная ситуация, когда сегментные регистры участвуют в~вычислении адресов, сохраняются и~восстанавливаются в~соответствующих ситуациях, но при этом значение любого сегментного регистра всегда должно быть равно нулю.
При этом сегментные регистры защищённого режима содержат не часть адреса, а~селектор, 
% содержащий номер сегмента в~специальной таблице дескрипторов, тип этой таблицы и~уровень привилегий.
кодирующий ссылку на запись в~специальной таблице дескрипторов, которая, в~свою очередь,
задаёт границы сегмента в~плоском адресном пространстве и~атрибуты защиты.
% https://habrahabr.ru/post/118881/

Современные операционные системы используют именно защищённый режим процессора (либо очень схожий с~ним шестидесятичетырёхбитный режим), в~котором прикладной программе недоступны многие функции реального.
При этом, так как эти функции прозрачно обеспечиваются операционной системой, прикладное программирование заметно упрощено. %, так как 

Тем не менее, из-за используемого программного обеспечения даже более поздние модели (до Pentium 4) постоянно или часть времени работали в~реальном режиме,
так что многие учебники ассемблера описывают его наравне с~защищённым.


В~целом разработка 386 "--- наиболее существенный шаг в~развитии архитектуры семейства x86.
В~настоящее время «x86» обозначает, 
% так называют,
как правило, 386\index{Intel 80386}-совместимый процессор (такая архитектура обозначается i386 или IA-32).
% 
Дальнейшее развитие в~основном сводилось к~добавлению новых команд, наращиванию параллелизма и~увеличению частоты.

В~определённый момент четырёх гигабайт памяти, адресуемых 32-битным указателем в~плоской модели, оказалось недостаточно.
В~первую очередь это проявилось на серверах и~специализированных высокопроизводительных рабочих станциях.
Разработчики ПО и~аппаратного обеспечения не стали возрождать неудобную сегментную модель памяти, вместо этого начали продвигаться решения с~64-битными %регистрами и~
виртуальными адресами.

Результатом совместной разработки Intel и~Hewlett Packard стала архитектура IA-64, схожая с~суперкомпьютером Эльбрус\index{Эльбрус} и~свободная от недостатков, унаследованных от калькулятора 4004 и~шестнадцатибитного 8086.
IA-64 несовместима с~набором команд x86.
% VLIW
Она не получила популярности в~основном из-за недостаточного количества портированного под неё ПО и~несовершенства компиляторов, а~также дороговизны и~некоторых конструктивных недоработок воплощавших её процессоров Itanium\index{Intel Itanium}.
В~мае 2017 г. официально объявили о~закрытии этой линейки.

Ведущий конкурент Intel, компания AMD, предложила 
расширение архитектуры IA-32,
% и~длинный режим как 
% расширение %тридцатидвухбитного защищённого режима 
увеличивающее разрядность адресов до 64 бит
и~дающее возможность увеличить разрядность данных с~помощью специального префикса~$REX$.
\index{REX, префикс}%
Именно это расширение, которое в~настоящее время поддерживается и~процессорами Intel
"--- наиболее популярный способ увеличить адресуемую память персонального компьютера.

Разработанная компанией AMD шестидесятичетырёхбитная архитектура  x86-64 (также называемая amd64, IA-32e %, хотя в~настоящее время поддерживается и~процессорами Intel,
и~Intel 64,
но не IA-64) не слишком существенно отличается от тридцатидвухбитной x86. 




\subsection{Режимы работы процессора}

\epigraph{\begin{stanza}
У меня есть две фазы, мама,\\
Я "--- чистый бухарский эмир.\\
Когда я трезв, я "--- Муму и Герасим, мама;\\
А так я "---  Война и Мир.  \\
\end{stanza}
}{\Aquarium}

Процессоры тридцатидвухбитной архитектуры x86 (IA-32) поддерживают четыре режима работы (рис.~\ref{ris:cpu-modes})~\cite{amd64System,intelBasic}.
\begin{itemize}
\item шестнадцатибитный реальный режим (Real Mode);
\index{Реальный режим}%



\item шестнадцатибитный режим виртуального 8086 (Virtual-8086 Mode), используемый тридцатидвухбитными операционными системами для запуска устаревших программ;
\item тридцатидвухбитный защищённый режим (Protected Mode);
\index{Защищённый режим}%

\item режим системного управления (System Management Mode, SMM) "--- сверхпривилегированный режим, в~котором
обрабатываются 
% сигналы включения и~принудительной перезагрузки;
скрытые от операционной системы события.
\end{itemize}
% (рис.~\ref{ris:cpu-modes})
\begin{illustration}
\includegraphics[width=\wideImageWidth,valign=c]{cpu-modes}

\caption{Режимы работы современных процессоров}
\label{ris:cpu-modes}
\end{illustration}

Процессоры семейства x86-64 
% поддерживают пять режимов работы~\cite{amd64System}:
% Три из них 
добавляют к~ним ещё два режима, в~совокупности обозначаемые в~документации~\cite{amd64System} как Long Mode (на рис.~\ref{ris:cpu-modes} эти два режима объединены серым овалом вверху рисунка):

\begin{itemize}
\item тридцатидвухбитный режим совместимости;
\item шестидесятичетырёхбитный режим.
% (он иногда называется шестидесятичетырёхбитным расширением тридцатидвухбитного режима, так как  отличается от 
% него незначительно).
\end{itemize}
\index{Шестидесятичетырёхбитный режим}%
Шестидесятичетырёхбитный режим %, несмотря на название, 
использует по умолчанию тридцатидвухбитные данные и~смещения
% и~не является качественным изменением 
и~концептуально %мало 
отличается от тридцатидвухбитного режима
гораздо меньше, чем шестнадцатибитный.
Соответственно, его
иногда называют шестидесятичетырёхбитным расширением защищённого режима,
а~архитектуру x86-64 обозначают как IA-32e.

\subsubsection{Порядок переключения режимов}

При загрузке или сбросе процессор переходит в~реальный режим.
% Из реального режима процессор
Из реального режима он может переключиться в~защищённый, в~котором работают все тридцатидвухбитные операционные системы.
При необходимости выполнения шестнадцатибитного кода процессор может временно переключаться в~режим виртуального 8086.
\index{Защищённый режим}%

% Затем он может переключиться последовательно в~защищённый режим, режим совместимости и~шестидесятичетырёхбитный режим.

Из тридцатидвухбитного защищённого режима процессор
может переключиться в~тридцатидвухбитный режим совместимости,
а~затем в~шестидесятичетырёхбитный режим.
\index{Шестидесятичетырёхбитный режим}%
Эти два режима используются шестидесятичетырёхбитными операционными системами.
% 
Таким образом, 
для выполнения тридцатидвухбитных приложений процессор может временно переключаться обратно в~режим совместимости.
Выполнить шестнадцатибитное приложение в~шестидесятичетырёхбитной операционной системе невозможно 
"--- необходимо использовать эмулятор или перезагрузить компьютер под другой операционной системой.

На рис.~\ref{ris:cpu-modes} переключения режимов, возможные в~процессе работы, показаны сплошными стрелками, переключения по перезагрузке "--- пунктиром.

Из любого из этих режимов процессор при возникновении соответствующего события может ненадолго перейти в~режим системного управления,
а~после обработки события "--- вернуться в~исходный режим.

В~принципе, возможен переход из шестидесятичетырёхбитного режима через режим совместимости в~защищённый и~из защищённого в~реальный,
% не факт
но, как правило, подобной необходимости не возникает
и~в~современных операционных системах она не реализована.
Прикладная программа, запущенная в~защищённом режиме, не может перевести процессор в~реальный (или, соответственно, из шестидесятичетырёхбитного в~защищённый).

% \subsection{Разделы памяти}
\section{Сегменты памяти}
\index{Сегмент}%
\label{sec:mem-segments}
\label{sec:stack-segment}
\epigraph{\begin{stanza}
Для чего, в самом деле, полюса, параллели,\\
Зоны, тропики и зодиаки?\\
И команда в ответ: «В жизни этого нет,\\
Это "--- чисто условные знаки».\\
\end{stanza}
}
{\Snark}
% \epigraph{\begin{stanza}
% На обыденных картах "--- слова, острова,\\
%    Все сплелось, перепуталось "--- жуть!\\
% А на нашей, как в море, одна синева,\\
%   Вот так карта "--- приятно взглянуть!\\
% \end{stanza}
% }
% {\Snark}
\index{Память!распределение адресов}


В~памяти вычислительной машины фон-неймановской архитектуры хранится как код программы, так и~данные.
Данные (переменные) в~программе на языке высокого уровня, в~частности, C++,
делятся на:
\begin{itemize}
\item глобальные, время жизни которых равно времени жизни программы, а~имя доступно в~любой области  программы;
\item статические локальные, время жизни которых также равно времени жизни программы, но имя доступно только в~ограниченной области;
\item локальные "--- каждый вызов функции порождает новую копию переменной, время жизни которой не превышает времени работы функции  и~которая доступна только в~ограниченной области;
\item динамические "--- память выделяется и~освобождается с~помощью $new/delete$ или $malloc()/free()$.
\end{itemize}

% Каждому физическому адресу соответствует  байт в~оперативной памяти.
% Корректному виртуальному адресу может соответствовать как 

Различные виды переменных и~программы находятся в~разных областях  диапазона доступных виртуальных адресов 
"--- адресного пространства процесса,
исторически называемых \termin{сегментами} (сейчас иногда используется также термин \termin{«секция»,} чтобы подчеркнуть использование плоской модели памяти\index{Память!плоская модель}
и~связь областей памяти с~секциями исполняемого файла).

На рис.~\ref{ris:linuxmem} представлено возможное распределение виртуальных адресов процесса в~тридцатидвухбитной операционной системе  GNU/Linux.

\begin{illustration}
\includegraphics[width=\wideImageWidth,valign=c]{linuxmem}

\caption{Распределение памяти процесса в~тридцатидвухбитной операционной системе GNU/Linux}
\label{ris:linuxmem}
\end{illustration}

Конкретное расположение сегментов в~адресном пространстве процесса
может различаться для различных операционных систем.
Состав также может различаться, но 
% сегменты кода, данных, кучи и~стека есть всегда.
основные сегменты "--- кода, данных, кучи и~стека "--- присутствуют всегда.\index{Стек}
% Иногда стек 

Хотя все сегменты располагаются в~одном адресном пространстве, они могут иметь разные атрибуты защиты.
В~частности, сегмент кода для предотвращения вредоносных модификаций  доступен только для чтения, но не для записи,
а~для сегментов, доступных программе на запись (данные, стек, куча) запрещено исполнение.

Нулевой адрес и~ближайшие к~нему считаются некорректными для выявления и~предотвращения ошибок (разыменования переменных, которые указателями не являются).

Часть адресного пространства процесса (в~тридцатидвухбитных системах по умолчанию 1 Гб, в~шестидесятичетырёхбитных "--- 512 Гб)  занимает ядро операционной системы~\cite{nuclight-kva}.
% Эта память доступна дл"--- общая для всех процессов на данном компьютере

\subsection{Код и~статические данные}
\epigraph{\begin{limerick}
Жил мальчик из города Майена,\\
Свалившийся в чайник нечаянно.\\
Он сидел там, сидел\\
И совсем поседел,\\
Этот бывший мальчишка из Майена.\\
\end{limerick}
}
{\Lear}

Код выполняемой программы находится в~\termin{сегменте кода.}
% \termin{.text} 

Глобальные переменные программы, доступные в~любой её точке 
и~статические переменные, отличающиеся от глобальных только областью видимости,
расположены в~\termin{сегменте данных.}
% \termin{.data} 
% 
Те глобальные и~статические переменные, которые не были инициализированы при объявлении,
отделяются  в~специальный \termin{сегмент BSS.}
% \termin{.bss}
% .noinit 	Данные переменных программы 

Адреса глобальных и~статических переменных в~программе "--- неотрицательные целые константы.
Для адресов в~коде (в~частности, функций) возможно задать как фиксированный адрес, так и~смещение относительно текущего значения указателя команд~$ip$.

Размеры кода программы и~переменных, время жизни которых совпадает со временем жизни программы,
могут быть определены ещё на этапе загрузки программы в~память,
поэтому размеры соответствующих областей памяти постоянны.

При этом адрес, по которому могут быть загружены код и~статические данные, в~принципе может  варьироваться (это особенно актуально для разделяемых библиотек).
В~этом случае требуется каким-то образом сохранить работоспособность программы и~доступность данных.

В~тридцатидвухбитном режиме это достигается 
% путём коррекции фиксированных адресов в~программе при загрузке исполняемого файла в~память
% и~использованием для кода по возможности относительных адресов.
использованием для кода относительных адресов
(так называемых команд ближнего перехода, содержащих не сам адрес, а~его смещение относительно текущего значения указателя команд $ip$). 
% (команды передачи управления содержат не адрес, а).
Для данных возможны два варианта. Первый "---  коррекция фиксированных адресов в~программе при загрузке исполняемого файла в~память (это мешает совместному использованию библиотек, так как, если несколько программ попытаются загрузить библиотеку по разным адресам, получится разный код).
Второй "---  копирование текущего значения $ip$ в~регистр общего назначения обходным путём и~ручной расчёт смещений относительно полученного значения.

В~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим}%
 добавлена возможность задавать 
для данных
адрес в~виде смещения относительно текущего значения $ip$.
% также и~для данных.
Для Mac OS X адресация глобальных и~статических переменных относительно  $ip$ обязательна, для других операционных систем "--- рекомендуется.


\subsection{Куча}
% \epigraph{\begin{limerick}
%     Жил один старичок из Непала, \\
%     Всё глотавший, что в рот ни попало.\\
%     Но, съев десять кроликов,\\
%     Он умер от коликов "---\\
%     Неуёмный старик из Непала.\\
% \end{limerick}
% }
% {\Lear}
\epigraph{\begin{limerick}
Самобытный старик из Милета\\
Никуда не ходил без жилета. \\
"--- «Впору ль вам ваш жилет?»\\
"--- «Разумеется, нет!»\\
"--- Отвечал всем старик из Милета.\\
\end{limerick}
}
{\Lear}

\index{Куча}%
Динамические переменные
% , память для которых в~C++ выделяется  операторами $new/new[]$ или функцией $malloc()$ 
% а~освобождается, соответственно, операторами $delete/delete[]$ или функцией $free()$,
расположены в~\termin{сегменте динамической памяти,} или \termin{куче} (heap).
% Куча 
% управляется операционной системой, так что операторы языка являются обёртками вокруг соответствующих системных вызовов.
% 
% http://sannystark.github.io/architectire/memroy/2016/01/08/anatomy-of-a-program-in-memory.html
% частично управляется библиотекой языка
% 
Первоначально программе выделяется определённый объём динамической памяти,
% который распределяется 
из которого средствами  языка высокого уровня ($new/new[\,]/malloc()$ для C++)  выделяются области памяти под запросы прикладной программы.
Распределённые области помечаются в~куче как занятые.
Если в~свободных областях кучи недостаточно памяти  для обработки запроса, $new/new[\,]/malloc()$ обращается к~операционной системе для расширения кучи.
Соответственно, количество корректных адресов сегмента кучи увеличивается.
% Поэтому 

Когда прикладной программе уже не нужна какая-то динамическая переменная,
соответствующую область памяти необходимо освободить.
Для этого в~C++ используются операторы $delete/delete[\,]$ или функция $free()$,
помечающие область как свободную.
При этом  освобождать область памяти необходимо способом, соответствующим выделению.
Таким образом, если память была выделена оператором $new[\,]$:
\begin{lstlisting}
int *p_array = new int[N];
\end{lstlisting}
освобождать её нужно оператором $delete[\,]$:
\begin{lstlisting}
delete[] p_array;
\end{lstlisting}
После вызова несоответствующего оператора \lstinline!delete p_array!
будет помечен как свободный  только первый элемент массива.
% 
В~некоторых языках есть механизм автоматического сбора мусора, который освобождает те области памяти, к~которым программа уже не обращается, но в~C/C++ его нет.

Если память не освобождена, динамические переменные существуют до завершения программы, даже если адрес, по которому можно обратиться к~ним, утрачен (подобная ситуация называется утечкой памяти). Таким образом, время жизни динамических переменных %, как и~область видимости, 
фактически определяется программистом.


\subsection{Стек}
\index{Стек}%
\epigraph{\begin{limerick}
    Одному старику на верхушке \\
    Досаждали дрозды и кукушки.\\
    «Хватит, – он прорыдал, "---\\
    Я довольно страдал,\\
    Лучше слезу я с этой верхушки».\\
\end{limerick}
}
{\Lear}

Локальные переменные подпрограмм находятся в~\termin{сегменте стека,}
также оптимизирующие компиляторы могут помещать часть целочисленных переменных в~регистры общего назначения.

Стек назван так потому, что организован по принципу LIFO (last in, first out) "--- последним зашёл, первым вышел.
Указателем вершины стека служит специальный регистр $sp$ "--- stack pointer.
Он содержит адрес 
% Он всегда указывает на %последнюю занятую ячейку стека.
% последний записанный в~стек элемент.
начала последнего записанного в~стек элемента.
% 
Соответственно, адреса локальных переменных в~программе отсчитываются относительно вершины стека $sp$.
% или его копии в~другом регистре.
% (обычно~$bp$).


Команды семейства x86 могут записывать в~стек элементы размером от шестнадцати бит, но в~GNU/Linux стек выравнен по long,
то есть на 32~бита (рис.~\ref{ris:stack}).

\begin{illustration}
\resizebox{\wideImageWidth}{!}{
\schemafont
% \input{book/drawings/stack-func}
\input{book/drawings/stack}
}

\caption{Стек}
\label{ris:stack}
\end{illustration}

\index{Команды!push}%
\index{Команды!pop}%
Стек растёт вниз (в~сторону уменьшения адресов).
Таким образом, операция помещения элемента в~стек (\lstinline!push!) уменьшает указатель стека $sp$, % на размер элемента,
операция извлечения (\lstinline!pop!) "--- увеличивает.
Таким образом, с~учётом порядка байт Intel $sp$  указывает на крайний (с~наименьшим адресом) занятый байт стека.

% \begin{lstlisting}[multicols=3,style=lstsmall]
% int foo(int s)
% {
%   int y;  
%   y = s + bar();
%   return y;
% }
% int bar()
% {
%   int z;  
%   ...
%   return z;
% }
% int main()
% {
%   int x = foo();
%   ...
%   return 0;
% }
% \end{lstlisting}

% \begin{lstlisting}[multicols=2,style=lstsmall]
% int foo(int s)
% {
%   int y = bar(s) + s;
%   return y;
% }
% int bar(int w)
% {
%   return (w << 1);
% }
% int main(int argc, 
%   char *argv[])
% {
%   int x;
%   x = foo(1);
%   cout << x;
%   return 0;
% }
% \end{lstlisting}

% В~стеке помещаются
В~частности, рассмотрим рекурсивное вычисление факториала небольшого целого числа (листинг~\ref{lst:stack-fact}). 
\begin{centeredfloat}%
\begin{lstlisting}[label=lst:stack-fact,caption={Рекурсивный вызов функции}]
\end{lstlisting}%
\begin{lstlisting}[multicols=2,style=lstsmall, 
% label=lst:stack-fact,caption={Рекурсивный вызов функции}
]
int fact(int n)
{
  int f;
  if (n <= 2)
    f = n;
  else
    f = n * fact(n-1);
  return f;
}
int main(int argc, 
  char *argv[])
{
  int x;
  x = fact(3);
  cout << x;
  return 0;
}
\end{lstlisting}
\end{centeredfloat}%
Это крайне неэффективный способ  вычисления, но в~учебниках он традиционно рассматривается как наглядный пример рекурсии.
% \index{Вызов функций}%
\index{Подпрограммы!стек вызовов}%

После запуска программы стартовый код запускает головную функцию $main()$.
Соответственно, в~стеке находятся данные этой функции (рис.~\ref{ris:stack-func}, а): 
\begin{illustration}%
\resizebox{1\linewidth}{!}{
\schemafont
% \input{book/drawings/stack-func-abv}
\input{book/drawings/stack-fact-abv}
}

\caption{Изменение указателя стека при вызове и~возврате из функций}
\label{ris:stack-func}
\end{illustration}%
локальная переменная $x$,
адрес возврата, показывающий, какой команде будет передано управление после возврата из $main()$,
а~также аргументы $main()$ "--- количество параметров командной строки, переданных при запуске программы
и~указатель на массив этих параметров.
В~зависимости от используемого соглашения о~вызове (подробнее в~разделе~\ref{sec:asm-calling-conventions}),
\index{Подпрограммы!соглашения о~вызовах}%
часть или все аргументы функции $main()$ могут находиться в~регистрах общего назначения;
но в~тридцатидвухбитном режиме они все передаются через стек.

После вызова функции~$fact(3)$ в~стек добавляется ещё один слой данных (рис.~\ref{ris:stack-func}, б):
параметр $n=3$, адрес возврата из~$fact(3)$ (в~данном случае это адрес команды, записывающей результат в~переменную~$x$ в~$main()$)
и~локальная переменная~$f$.
% 
После анализа~$n$ следует рекурсивный вызов~$fact(2)$,
% Данные вызывающей функции~$fact(3)$
добавляющий в~стек 
новый параметр $n=2$, 
новый адрес возврата (адрес команды умножения на~$n$ в~$fact(3)$)
и~ещё одна копия локальной переменной~$f$ (данные $fact(2)$ на рис.~\ref{ris:stack-func}, в).
Таким образом, каждому вызову функции $fact()$ соответствует свой набор параметров и~локальных переменных.

После анализа  параметра $n$ следует возврат значения~$n$ из функции~$fact(2)$.
При этом 
управление передаётся команде по адресу возврата,
% из стека удаляются все данные этой функции "--- локальные переменные, параметры и~адрес возврата 
а~сам адрес возврата вместе с~локальными переменными и~параметрами этой функции удаляется из стека
(рис.~\ref{ris:stack-func}, г).
Удаление выполняется путём изменения указателя~$sp$,
содержимое памяти при этом не перезаписывается (рис.~\ref{ris:stack-func-del}, а) и~б). %, но для наглядности данные в~пу.
\begin{illustration}%
\resizebox{\approvedImageWidth}{!}{
\schemafont
% \input{book/drawings/stack-func-abv}
\input{book/drawings/stack-fact-abv-del}
}

\caption{Удаление данных из стека "--- изменение указателя}
\label{ris:stack-func-del}
\end{illustration}%
Соответственно, в~незанятых ячейках стека содержатся «мусорные» данные,
поэтому значение неинициализированных локальных переменных непредсказуемо.


После умножения результата $fact(2)$ на~$n$ происходит возврат в~$main()$ 
(рис.~\ref{ris:stack-func}, д).

% Не все локальные переменные находятся в~стеке одновременно
% Для больших функций 

Некоторые модели процессоров, в~том числе ранние не-x86 совместимые процессоры Intel,
организуют стек вызовов не в~памяти, а~в~специальном наборе регистров.
Это ограничивает количество вложенных вызовов функций, зато ускоряет процесс вызова и~возврата.



% % % % % Рассмотрим взаимное расположение 
% Конкретное расположение сегментов в~адресном пространстве процесса
% может различаться для различных операционных систем.
% Состав также может различаться, но сегменты кода, данных, кучи и~стека есть всегда.





\section{Регистры}
\label{sec:registers}
\epigraph{\begin{stanza}    
Он на вкус превосходней кальмаров с вином,\\
    Трюфелей и гусиной печёнки.\\
 (Его лучше в горшочке хранить костяном\\
  Или в крепком дубовом бочонке.)\\
\end{stanza}
}
{\Snark}
\index{Регистры}%

% Регистры семейства x86 де
Процессоры семейства x86 содержат как множество недоступных и~ограниченно доступных %(с~помощью специальных команд) 
программисту специальных регистров,
так и~определённое количество регистров общего назначения, которые можно адресовать на уровне архитектуры команд по номерам, 
а~в~программе на ассемблере "--- явно указанными в~коде именами.

В~частности, команда безусловного перехода \lstinline!jmp label!, аналог оператора C++ $goto~label$,
модифицирует специальный регистр~$ip$ (указатель команд), но не содержит его имени. % (а~её машинный код состоит из кода операции).
% Команда \lstinline!jmp!
\index{Регистры!общего назначения}%
Напротив, команда загрузки значения в~регистр общего назначения \lstinline!mov $13, %eax! содержит его имя в~явном виде,
\index{Команды!mov}%
а~соответствующий машинный код 
\hex{B8\,00\,00\,00\,0D} 
содержит номер  регистра%~$eax$. %
~$A$ ($\digitB 8_{16} = 10111000_2$, последние три бита $000$ задают регистр-приёмник; $00\,00\,00\,0\digitD$ "--- загружаемое тридцатидвухбитное значение $13_{10} = \digitD_{16}$).
% , который может быть заменён на код другого 
Если это имя или номер заменить именем или номером другого регистра общего назначения, получим корректную команду загрузки значения в~этот регистр.

Граница между специальными регистрами и~регистрами общего назначения в~наборе команд x86 достаточно размыта.
Так как регистров в~оригинальном процессоре 8086 было мало, все %они 
% унаследованные от него
адресуемые регистры 
имели ещё и~какое-либо специальное назначение.
% В~частности, регистр~$A$ %(и~только он) 
% используется командами знакового расширения, умножения и~деления.
Со временем %большинство возможностей
специализация % регистров общего назначения 
сглаживается,
но многие команды, унаследованные от оригинального набора, обращаются к~неявному аргументу в~конкретном регистре общего назначения.

Основной набор команд x86 предназначен
% Процессоры семейства x86 предназначены 
для обработки целых чисел,
так что в~регистрах процессора %общего назначения 
могут находиться
целочисленные переменные (адреса, индексы и~собственно целые числа).
% 
Регистры, доступные различным расширениям набора команд, в~частности, 
команд обработки вещественных чисел, хранят данные соответствующего типа.
Такие регистры, как правило, недоступны командам из основного набора и~будут рассматриваться отдельно.

\subsection{Регистры общего назначения, доступные в~тридцатидвухбитном режиме}

\epigraph{\begin{limerick}
    Жил один старичок из Лагоса, \\
    Плащ которого взяли без спроса.\\
    Он ходил в знак печали\\
    В такой длинной шали,\\
    Что лишь кончик выглядывал носа.\\
\end{limerick}
}
{\Lear}
\index{Регистры!общего назначения}%


Под номер регистра в~команде (её структура более подробно рассматривается в~разделе~\ref{sec:command-x86}) отведено всего три бита~\cite{nezumi-disasm, intelInstructionSet},
так что регистров общего назначения в~тридцатидвухбитном режиме  x86 доступно только восемь (рис.~\ref{ris:registers-32}).
% На самом деле в~современных процессорах их больше

% \begin{illustration}%
% \includegraphics[width=\wideImageWidth,keepaspectratio,valign=t]{Registers}
% 
% \caption{Регистры общего назначения x86}
% \label{ris:registers}
% \end{illustration}


% \schemafont
% \tiny
\newlength{\bytewidth}
\setlength{\bytewidth}{12ex}

% % \tikzstyle{arrowline}=[-latex',scale=2]

\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=3.5ex, inner ysep=0ex, textsc]
% \tikzstyle{regpart}	= [reg, solidchaincell]

\tikzstyle{r1}	= [reg, minimum width=\bytewidth]
\tikzstyle{r2}	= [reg, minimum width=2\bytewidth]
\tikzstyle{r4}	= [reg, minimum width=4\bytewidth]

\tikzstyle{commentline}	= [draw=clRegisterDark]
\tikzstyle{textsc}	= [scale=0.5]
\tikzstyle{titlesc}	= [scale=0.7]

\begin{illustration}

\newcommand{\regA}[6][]
{
    
    \node[r2, on chain, #1	,	fill=clRegisterLight!75!clRegisterDark] (h2#2) {};
    \node[r1, solidchaincell, right = of h2#2] (h1#2) {$#4$};
    \node[r1, solidchaincell, right = of h1#2	,	fill=clRegisterLight!75] (l#2) {$#3$};
    
    \node[left = 1ex of h2#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]

  \node[above = 0ex of h1#2.north east, textsc] (#5) {$#5\mathstrut$};  
  \node[below = 0ex of h2#2.south east, textsc] (#6) {$#6$};  
 
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#5/0ex/18/h1#2/l#2/north, #6/1ex/15/h2#2/l#2/south}
  {
    \ifthenelse{\equal{\side}{north}}{
      \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    }{
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
    }
  };
  
  
\end{scope}
}

\newcommand{\regsi}[4][]
{
    
    \node[r2, on chain,	fill=clRegisterLight!75!clRegisterDark,	right=7ex of l#1] (h2#2) {};
    \node[r2, solidchaincell, right = of h2#2] (l#2) {$#3$};
    
    \node[left = 1ex of h2#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]

  \node[below = 0ex of h2#2.south east, textsc] (#4) {$#4$};  
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#4/1ex/15/h2#2/l#2/south}
  {
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
  };
  
  
\end{scope}
}


\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going below,
node distance=5ex]
 
  \foreach \rname/\rbase in {A/a, B/b, C/c, D/d}
  {
    \regA{\rname}{\rbase l}{\rbase h}{\rbase x}{e\rbase x}{r\rbase x}
  };
  \foreach \r/\pos in {si/A, di/B, bp/C, sp/D}
  {
    \regsi[\pos]{\r}{\r}{e\r}
  };

    
\end{tikzpicture}
}

\caption{Регистры общего назначения в~тридцатидвухбитном режиме}
\label{ris:registers-32}
\end{illustration}



% Это

В~некоторых источниках к~регистрам общего назначения относят только четыре регистра "--- $A, B, C$ и~$D$ (на рис.~\ref{ris:registers-32} показаны слева).
Каждый из них конструктивно имеет размер машинного слова (сейчас, как правило, 64 бита),
но в~тридцатидвухбитном режиме доступны только младшие 32.
Разные их части называются разными именами.


% (а~в~команде обозначение части складывается из номера регистра и~разрядности операции).
В~частности, младший байт регистра~$A$ обозначается $al$ (low), 
следующий байт "--- $ah$ (high).
Пара однобайтовых регистров $ah:al$ составляет
младшие 16 бит регистра "--- $ax$ (для шестнадцатибитного 8086 это означало eXtended).
Младшие 32 бита (максимально доступный в~тридцатидвухбитном режиме размер регистра) обозначаются как $eax$,
доступные только в~шестидесятичетырёхбитном режиме 64 бита "--- $rax$.
% 
Для краткости будем использовать однобуквенное обозначение регистра, когда его разрядность %не важна или 
может быть любой или совпадает с~разрядностью системы,
в~частности,~$A$ вместо $rax/eax/ax/al$.

% В~других "--- все регистры, которые можно указать как источник/приёмник,
% тогда
Также имена и~номера существуют для %так называемых
регистров $si, di, bp$ и~указателя вершины стека~$sp$,\index{Стек} которые иногда также причисляют к~регистрам общего назначения (на рис.~\ref{ris:registers-32} справа).
Эти имена соответствуют младшим 16 битам регистров.
Их 32-битные варианты называются соответственно $esi, edi, ebp$ и~$esp$,
64-битные "--- $rsi, rdi, rbp$ и~$rsp$.
Младшие байты этих регистров не имеют имён % (а~соответствующие номера уже заняты $ah-dh$).
в~тридцатидвухбитном режиме. 

Для краткости будем использовать оригинальное имя регистра, когда его разрядность %не важна или 
совпадает с~разрядностью системы,
например, $sp$ вместо $rsp/esp/sp$. % или~$A$ вместо $rax/eax/ax/al$.
Это не вызовет путаницы, так как шестнадцатиразрядный код сейчас практически не используется.




Хотя %указатель стека 
$sp$ можно адресовать как регистр общего назначения% (что широко используется )
, использовать его иначе, чем 
как указатель вершины стека, категорически не рекомендуется.
% Кроме того, во многих случаях номер $sp$ в~команде трактуется как «регистр не задан».
Таким образом, будем считать регистрами общего назначения следующие семь "--- %регистров
$A, B, C, D, si, di$ и~$bp$.

\subsection{Регистры общего назначения, доступные в~шестидесятичетырёхбитном режиме}
\epigraph{\begin{limerick}
    Жил старик, на носу у которого \\
    Стая птичек устроилась здорово.\\
    Но в ненастные дни\\
    Улетали они,\\
    Облегчая судьбу его здорово.
\end{limerick}
}
{\Lear}
\index{Регистры!общего назначения}\index{Шестидесятичетырёхбитный режим}%

В~шестидесятичетырёхбитном режиме доступны все описанные выше регистры.
При этом для регистров общего назначения, доступных в~тридцатидвухбитном режиме, используются те же имена.
Для шестидесятичетырёхбитных регистров имена соответствуют тридцатидвухбитным вариантам, но вместо префикса $e$ используется префикс $r$ ($rax$, $rdi$ и~т.\,д).

Кроме того,
\index{REX, префикс}%
в~64-разрядном режиме 
% доступны все 64 бита регистров.
% Кроме того,
% увеличена разрядность не только самих регистров, но и~их~номеров в~команде, нет !!!
может быть использован специальный префикс $REX$ (расширения регистров),
который добавляет ещё один бит к~номерам регистров в~команде,
так что
% добавляется 
можно адресовать
ещё восемь регистров общего назначения $r8{-}r15$ (рис.~\ref{ris:registers-64}).
% Префикс $REX$ игнорируется даже в~шестидесятичетырёхразрядном коде, если размер операнда менее~64. врут
% $r8 - r15$
В~32-разрядном режиме они недоступны. %, соответственно, их младшие части не имеют отдельных имён.


\begin{illustration}[p]

\newcommand{\regc}[7][]
{
    \node[r4, on chain, #1	,	fill=clRegisterLight!50!clRegisterDark] (h4#2) {};
    \node[r2, solidchaincell, right = of h4#2	,	fill=clRegisterLight!75!clRegisterDark] (h2#2) {};
    \node[r1, solidchaincell, right = of h2#2] (h1#2) {$#4$};
    \node[r1, solidchaincell, right = of h1#2	,	fill=clRegisterLight!75] (l#2) {$#3$};
    
%     \node[left = 2ex of h4#2, scale=0.7]  {$#2$}; 
    \node[left = 2ex of h4#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]
    
%   \foreach \lbl/\inangle/\s/\e in {#5/10/h1#2/l#2, #6/15/h2#2/l#2, #7/20/h4#2/l#2}
%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/2ex/15/h2#2/l#2, #7/4ex/18/h4#2/l#2}
%   {
% %     \path[draw=clRegisterDark] (\s.north west)  to[out=\inangle,in=180-\inangle] node[fill=white, text=black, sloped,scale=1] {$\lbl$} (\e.north east);
% %     \path[draw=clRegisterDark] (\s.north west)  .. controls ($(\s.north east) + (0,1)$)  
% % 	  ..
% % 	  node[fill=white, text=black, sloped,scale=1] {$\lbl$} (\e.north east);       
% 
%     \node[text=black, above = \h of \s.north east] (\lbl) {$\lbl$};  
% %     \path[draw=clRegisterDark] (\s.north west)  
% %     to[out=\inangle,in=180] 
% %     (\lbl)
% %     to[out=0,in=180-\inangle] 
% %     (\e.north east);
% 
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
%     
% %      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
% %      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);
%    
%   };

%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/1ex/15/h2#2/l#2, #7/2ex/18/h4#2/l#2}
%   {
%     \node[text=black, above = \h of \s.north east, textsc] (\lbl) {$\lbl$};  
%   };
  \node[above = 0ex of h1#2.north east, textsc] (#5) {$#5\mathstrut$};  
  \node[below = 0ex of h2#2.south east, textsc] (#6) {$#6$};  
  \node[above = 0.1ex of h4#2.north east|-#5.center, textsc] (#7) {$#7$};  
 
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#5/0ex/18/h1#2/l#2/north, #6/1ex/15/h2#2/l#2/south}
  {
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    
    \ifthenelse{\equal{\side}{north}}{
      \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    }{
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
    }
    
%      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
%      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);
   
  };
  
  
  
  \foreach \lbl/\h/\inangle/\s/\e in {#7/2ex/18/h4#2/l#2}
%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/2ex/15/h2#2/l#2, #7/4ex/18/h4#2/l#2}
  {
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    
%      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
%      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);

%      \path[commentline]	(\lbl)		-|	(\e.north east);
%      \path[commentline]	(\s.north west)	|-	(\lbl);

     \path[commentline]	(\lbl.north-|\e.north east)	--	(\e.north east);
     \path[commentline]	(\s.north west)	|-	(\lbl.north-|\s.north west);

     \path[arrowline, commentline]	(\lbl)	--	(\lbl-|\e.north east);
     \path[arrowline, commentline]	(\lbl)	--	(\lbl-|\s.north west);
     
  };  

\end{scope}

}

\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going below,
node distance=5ex]
 
%   \foreach \rn in {0,...,9}
%   {
%     \node[r4, on chain] (h4\rn) {};
%     \node[r2, solidchaincell, right = of h4\rn] (h2\rn) {};
%     \node[r1, solidchaincell, right = of h2\rn] (h1\rn) {};
%     \node[r1, solidchaincell, right = of h1\rn] (l\rn) {};
%   };

  \foreach \rname/\rbase in {A/a, B/b, C/c, D/d}
  {
    \regc{\rname}{\rbase l}{\rbase h}{\rbase x}{e\rbase x}{r\rbase x}
  };
  \foreach \r in {si, di, bp, sp}
  {
    \regc{\r}{\r l}{}{\r}{e\r}{r\r}
  };
  \foreach \r in {8}
  {
    \regc{r\r}{r\r b}{}{r\r w}{r\r d}{r\r}
  };
  \node[below = 1.5ex of h4r8.south east, titlesc] (rdots) {$\ldots$};
  \node[titlesc] at (rdots-|titler8) {$\ldots$};
  \foreach \r in {15}
  {
    \regc[below = 3.5ex of rdots.south, anchor = north east]{r\r}{r\r b}{}{r\r w}{r\r d}{r\r}
  };
    
\end{tikzpicture}
}

\caption{Регистры общего назначения в~шестидесятичетырёхбитном режиме}
\label{ris:registers-64}
\end{illustration}


Младшие части регистров $r8{-}r15$  имеют имена $r8b {-} r15b$ (размер этих регистров равен одному байту "--- 8 бит),
$r8w{-}r15w$ (размер равен слову "--- 16 бит),
$r8d{-}r15d$ (размер равен двойному слову "--- 32 бита).

Также префикс $REX$ позволяет адресовать младшие байты регистров $si, di, bp$ и~$sp$ "--- они имеют имена $sil, dil, bpl$ и~$spl$~\cite{intelBasic} и~доступны наравне с~$al{-}dl$ и~$r8b {-} r15b$.

Старшие байты младшего слова (разряды $8{-}15$, аналогично $ah{-}dh$) не имеют собственных имён ни для каких регистров, кроме $A{-}D$.
В~некоторых источниках сказано, что $ah{-}dh$ в~шестидесятичетырёхбитном режиме недоступны.
Это не совсем так.
Регистры $ah{-}dh$ доступны, но только в~командах без префикса $REX$.
% , что ограничивает их применение.
% , что ограничивает, но не запрещает их использование в~шестидесятичетырёхбитном режиме.

\subsection{Специальные регистры и~регистры расширений}
\epigraph{\begin{limerick}
    Жил-был старичок в Катманду,\\
    Чей нос был похож на дуду.\\
    Вот на этой дуде\\
    И дудел он везде,\\
    Удивляя народ в Катманду.\\
\end{limerick}
}
{\Lear}
\index{Регистры!специальные}%

Из специальных регистров следует отметить 
регистры состояния и~управления:
уже упоминавшийся       указатель команды $ip$ (в~32- и~64-битных системах иногда называется $eip$ и~$rip$ соответственно)
и~регистр флагов $flags$ ($eflags/rflags$).
Разряды регистра флагов либо показывают те или иные характеристики последней операции процессора (флаги состояния),
либо влияют на выполнение команд (управляющие флаги).

\index{Регистры!расширений}%
Современные процессоры семейства x86, кроме основного набора команд, поддерживают несколько расширений.
Для них реализованы несколько групп регистров общего назначения, доступных в~командах соответствующих наборов: %, которые могут быть 
\begin{itemize}
\item восемь 80-разрядных регистров FPU x87 ($r_0- r_7$)
могут быть использованы как командами FPU как %элементы стека FPU 
{$st(0)-st(7)$, хранящие числа с~плавающей запятой}, так и~командами расширения MMX как 64-разрядные регистры {{$mm0-mm7$, }}
(%конструктивно %64-разрядные 
$mm0-mm7$ "--- мантиссы  $r_0- r_7$);
\item восемь 128-разрядных регистров расширения SSE, или XMM {({$xmm0-xmm7$})}.
Каждый из них предназначен для хранения вектора вещественных чисел одинарной точности, а~не длинного 128-битного числа.
В~64-битных системах\index{Шестидесятичетырёхбитный режим} количество XMM-регистров, как и~количество регистров общего назначения, увеличено до шестнадцати ($xmm0-xmm15$).
Расширение AVX (YMM) вдвое увеличило их разрядность "--- до 256-разрядных $ymm0-ymm15$,
недавно появившееся  AVX-512 (ZMM) "--- до 512-разрядных $ymm0-ymm31$ (в~32-битных системах доступны только первые восемь).
При этом регистры $ymm_i$ "--- младшие половины регистров $zmm_i$, а~$xmm_i$, соответственно, "--- младшие половины $ymm_i$.
Регистры ZMM есть не во всех современных процессорах.
\end{itemize}
Также расширения могут иметь свои специальные регистры, в~частности, регистры флагов.
Например, FPU имеет обширный набор специальных регистров, так как изначально команды набора FPU выполнялись отдельным устройством "--- математическим сопроцессором.






\section{Математический сопроцессор}
\label{sec:regdata-fpu}\index{FPU}

\epigraph{\begin{limerick}
Итальянцу из города Бари\\
Принесли кружку пива в пивбаре.\\
Но спросил он сварливо:\\
"--- А зачем это пиво\\
Вскипятили вы мне в самоваре?\\
\end{limerick}
}
{\Lear}

% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX
% }  



Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой.
% 
Первый математический сопроцессор для линейки x86 "--- FPU 8087 "--- был выпущен в~1980 году.
Он представлял собой отдельную микросхему, устанавливаемую в~специальный сокет на системной плате.
Взаимодействие с~основным процессором выполнялось в~основном через оперативную память.

% Использование сопроцессора 8087 ускоряло вычисления с плавающей точкой, но, так как сопроцессор мог отсутствовать, 
Начиная с~процессора i486DX математический сопроцессор интегрирован в~процессор.
При этом сопроцессор долгое время (вплоть до линейки микропроцессоров Atom) имел почти независимое ядро, так что обработка целых чисел CPU и~вещественных FPU могла выполняться параллельно.
% С одной стороны, это позволяло
Из-за этого в~систему команд была введена команда ожидания завершения работы сопроцессора, а~многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
В~современных  процессорах FPU настолько плотно интегрирован с~ядром CPU, что их параллельная работа невозможна и~ожидание не требуется.


% FPU выполняет все вычисления в~80-битном расширенном формате.
% Для обмена данными с~памятью используются также 
% вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.


\subsection{Регистры сопроцессора}
\epigraph{\begin{stanza}
    А руки всегда непохожи на ноги...\\
\end{stanza}}
{О.\,Арефьева}


% 
% Восемь 80-разрядных регистров, образующих стек (кольцевой буфер).


FPU x87 предоставляет восемь 80-разрядных регистров для хранения данных и~шесть вспомогательных регистров~\cite{intelBasic,amd64Fpu}.
При обращении к~ним в~GAS надо указывать тот же префикс~\lstinline!%!, что и~для регистров основного процессора (CPU).

\begin{illustration}
% \includegraphics[width=\approvedImageWidth]{fpu_reg}

\resizebox{\linewidth}{!}
{
\input{book/drawings/fpureg}
}

\caption{Регистры FPU}
\index{Мантисса}\index{Порядок}
\label{ris:fpu_reg}
\end{illustration}

% Регистры данных ($R0$--$R7$) не адресуются по именам, как регистры основного процессора. 
% Вместо этого эти восемь регистров рассматриваются как стек, вершина которого называется $st(0)$, а~более глубокие элементы "--- $st(1)$, $st(2)$ и~так далее до $st(7)$. 
% Если, например, в~какой-то момент времени регистр $R5$ называется $st(0)$, то после записи в~этот стек числа оно будет записано в~регистр $R4$, который станет называться $st(0)$, $R5$ станет называться $st(1)$ и~т.\,д.~\cite{zubkov}.
% ^^^ прямая цитата

Восемь регистров данных, согласно документации Intel~\cite{intelBasic}, носят имена $r_0-r_7$, но обратиться к~ним по этим именам невозможно.
Они образуют стек с~плавающей вершиной, построенный по принципу кольцевого буфера.
К~регистру, находящемуся сейчас в~вершине стека, можно обратиться как к~$st(0)$; если стек содержит более одного элемента, то к~более глубоким элементам можно обращаться по именам $st(1)$, $st(2)$ и~так далее до $st(7)$~\cite{zubkov}. 
Регистры данных сопроцессора хранят вещественные числа в~80-битном расширенном формате.
Мантисса\index{Мантисса} занимает 64 бита, порядок\index{Порядок} "--- 15 бит, под знак отводится один бит.



% Рисование регистров

\tikzmath{real \bitwidthex, \halfbitex; 
  \bitwidthex=7; 
  \halfbitex = \bitwidthex/2;}
  
\tikzstyle{bitlabel}	= []
\tikzstyle{block}	= [text badly centered, minimum height=\bitwidthex ex, draw=black]
\tikzstyle{reg}	= [block,  fill=clRegisterLight]
\tikzstyle{bit}	= [reg, solidchaincell, minimum width=\bitwidthex ex]

\newcommand{\onebit}[3][]
{
  \node[bit, on chain, label=below:$#2$, #1] (#2) {$#3$};
}

\newcommand{\bitfield}[4][]
{
  \tikzmath{int \bits, \wdex; \bits = #3 - #2 + 1;
    \wdex = \bits * \bitwidthex;}
  \node[bit, minimum width= \wdex ex, on chain, #1] (#2)  {$#4$};
  \coordinate[right = \halfbitex ex of #2.south west, label=below:$#3$] (be#3);
  \coordinate[left = \halfbitex ex of #2.south east, label=below:$#2$] (bs#2);
}

\newcommand{\regfloat}[4][]
{
\begin{tikzpicture}[
baseline=(mant0.base)
]
  \tikzmath{  \bitwidthex=4; }
  \node[reg, solidchaincell, minimum width=32ex, #1]  (mant0) {$#4$};
  \node[reg, solidchaincell, minimum width=10ex, left = of mant0, #1]  (exp0) {$#3$};
  \node[bit, solidchaincell, left = of exp0, #1]  (sign0) {$#2$};
\tikzstyle{bitlabel}	= [scale=0.7]  
\node[above = 0ex of exp0, bitlabel]  (exp) {Порядок};
\node[anchor=base, bitlabel] at (exp.base-|sign0) (sign) {Знак};
\node[bitlabel] at (exp-|mant0)  {Мантисса};  
\end{tikzpicture}
}





Шестнадцатибитный регистр (слово) тегов $tw$ (Tag Word, также используется сокращение $twr$ "--- Tag Word Register)  хранит состояние регистров данных.
Каждому регистру $r_0-r_7$ соответствует два бита слова тегов (рис.~\ref{ris:fpu-tw}):
\begin{alphenumerate}
\item $00$ "--- в~соответствующем регистре корректное ненулевое значение;
\item $01$ "--- в~регистре ноль;
\item $10$ "--- в~регистре специальное значение: некорректное значение ($nan$ или значение, не соответствующее формату вещественного числа с~расширенной точностью), бесконечность или денормализованное число; % Special: invalid (NaN, unsupported), infinity, or denormal
\item $11$ "--- регистр пуст.
\end{alphenumerate}
\begin{illustration}

\resizebox{\linewidth}{!}{\input{book/drawings/fpureg-tw}}

\caption{Слово тегов FPU}
\label{ris:fpu-tw}
\end{illustration}
Если регистр $r_i$ помечен в~слове тегов как пустой, его значение при этом  может быть каким угодно "--- попытка чтения из него приведёт к~ошибке стека.

Флаги математического сопроцессора разбиты на два шестнадцатибитных регистра (рис.~\ref{ris:fpu-sw-cw}) "--- 
управляющие флаги составляют управляющее слово $cw$ (Control Word, также $cwr$),
флаги состояния сгруппированы в~слово состояния "--- $sw$ (Status Word, также $swr$).

\begin{illustration}
% \includegraphics[width=\linewidth,keepaspectratio,valign=t]{swr}
% 
% \includegraphics[width=\linewidth,keepaspectratio,valign=t]{cwr}

\resizebox{\linewidth}{!}
{
\input{book/drawings/fpureg-sw-cw}
}

\caption{Слово состояния и~управляющее слово FPU}
\label{ris:fpu-sw-cw}
\end{illustration}

Управляющее слово содержит 
шесть масок исключений ($IM{-}PM$),
поле управления точностью $PC$,
и~поле управления округлением $RC$.
% Исключением

Слово состояния отображает  текущее состояние сопроцессора после выполнения последней команды.
Младший байт слова состояния
включает %флаг $IE$, соответствующей незамаскированному исключению,   
семь флагов, показывающих корректность операций ($IE{-}SF$) и~флаг $ES$, показывающий, что сбой не только был, но и привёл к~прерыванию.
Старший байт включает
флаги $C0{-}C3$, хранящие результаты сравнения чисел,
% Также слово состояния содержит 
а~также трёхбитный текущий номер вершины стека $top$.
Последний бит~$B$ в~настоящее время не используется.

%  ТОР "--- указатель  вершины стека.
%  шесть флагов исключительных ситуаций;


Таким образом, стек сопроцессора организован с~помощью восьми регистров данных $r_0-r_7$, соответствующих восьми полей слова тегов~$tag(0){-}tag(7)$ и~поля~$top$ слова состояния.
Вершина стека $st(0)$ находится в~регистре $r_{top}$, обозначение $st(1)$ получает следующий регистр~$r_{top+1}$ и так далее.
За $r_7$ по принципу кольцевого буфера следует $r_0$.
На рис.~\ref{ris:fpu-r-st} показаны соотношения между физическими $r_i$ и~логическими $st(i)$ именами регистров данных сопроцессора при различных значениях номера вершины стека $top$.


% \begin{illustration}
% \includegraphics[width=\linewidth,keepaspectratio,valign=c]{fpu_push_pop}
% \caption{Стек FPU}
% \label{ris:fpu-r-st}
% \end{illustration}

\begin{illustration}
\resizebox{\linewidth}{!}
{
\input{book/drawings/fpu-top-change}
}

\caption{Стек FPU}
\label{ris:fpu-r-st}
\end{illustration}

Положение дна стека определяется словом тегов $tw$ (первый пустой регистр).



После инициализации стек пуст.
% В~начале работы стек пуст. 
После завершения вычислений (перед выходом из функции или ассемблерной вставки) его также необходимо оставить пустым. 
Если функция возвращает вещественное значение через стек сопроцессора, в~стеке не должно остаться ничего, кроме возвращаемого значения.

Для вычислений хотя бы один операнд должен быть загружен в~стек сопроцессора.





% Last Instruction Opcode intelBasic
Два 48-битных регистра указателей (на последнюю команду "---  FPU Instruction Pointer, $fip$, в~некоторых источниках также~$ipr$~\cite{urov} и~последний загруженный операнд  Data (Operand) Pointer, $fdp$, также~$dpr$), а~также десятибитный регистр кода операции последней неуправляющей команды (FPU Opcode Register, $fop$) используются в~обработке исключений для определения места сбоя.

\subsection{Исключения сопроцессора}
\label{sec:fpu:exceptions}
\epigraph{\begin{limerick}
    Один старикашка в Савое \\
    Воскликнул: «Сейчас я завою!»\\
    В ответ: «Ах, как жалко!\\
    А мы тебя "--- палкой!» "---\\
    Ответили старцу в Савое.\\
\end{limerick}
}
{\Lear}
Во время работы сопроцессора возможны ситуации, когда по какой-то причине невозможно корректно выполнить требуемые вычисления.
Подобные ситуации называются исключительными ситуациями, или просто исключениями FPU.


Рассмотрим исключения FPU подробнее.

\paragraph{\#I} Недействительная операция (Invalid operation).
Может быть стековой ошибкой~\textbf{\#IS}  или недопустимой арифметической операцией~\textbf{\#IA}.


\paragraph{\#IS} Стековая ошибка (Stack Fault) "--- попытка записи в~полностью заполненный стек или чтения из пустой ячейки стека FPU.


Недействительной арифметической операцией~\textbf{(\#IA)} считается операция, проводимая над некорректными аргументами.
В~этом случае может также возникнуть одна из следующих пяти ситуаций.

\paragraph{\#D} Денормализованный операнд (Denormalized operand) "--- выполнение арифметической операции над денормализованным числом или загрузке такого числа в~стек.

\paragraph{\#Z} Деление на ноль (Zero Divide) "--- деление на ноль.

\paragraph{\#О} Переполнение  порядка (Overflow) "--- порядок результата выходит за максимально допустимое значение.
% 
Для команд выгрузки из стека \lstinline!f*st! переполнение возможно в~том случае, если размер порядка приёмника недостаточен.

\paragraph{\#U} Антипереполнение, или исчезновение порядка (Underflow) "--- порядок результата выходит за минимально допустимое значение (денормализованный результат).

\paragraph{\#Р} Неточный результат (Precision) "--- результат невозможно точно представить в~формате назначения (например, $\frac{1}{3}$, $\sqrt{2}$).

Команды вычисления трансцендентных функций (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда приводят к~неточному результату.




\subsubsection{Маски исключений}
\label{sec:fpu:cw-mask}
% Из рассмотренных выше флагов ошибки первые шесть соответствуют некорректно выполненным вычислениям "--- так называемым исключительным ситуациям, или исключениям FPU.
% % 
% На подобные ситуации FPU может реагировать двояко: помещать на место результата специальное значение (нечисло) или инициировать прерывание вычислений.

Если в~языках высокого уровня термин «исключение» подразумевает прерывание нормального хода программы и~переход к~обработчику,
то FPU на некоторые (арифметические) исключения может реагировать двояко: помещать на место результата специальное значение (нечисло) или инициировать прерывание вычислений.

Поведением FPU управляют шесть масок исключений ($IM{-}PM$),
расположенных в~первых шести битах управляющего слова~$cw$.
На тех же местах  в~слове состояния~$sw$ располагаются соответствующие флаги $IE{-}PE$.

Если бит маски установлен в~единицу, то соответствующее исключительная ситуация не вызывает прерывания выполнения программы (то есть того, что обычно и~называется в~языке высокого уровня исключением).
Такое исключение называется замаскированным.

Стековую ошибку замаскировать невозможно.


\subsubsection{Флаги сопроцессора}
\label{sec:fpu:sw}
\index{Флаги!FPU}%

Математический сопроцессор имеет собственный регистр флагов "--- слово состояния $sw$.
Аналогично $flags$, биты слова состояния сопроцессора представляют те или иные характеристики последней операции сопроцессора~\cite{intelBasic, club155}.

На рис.~\ref{ris:fpu-sw-cw} показано расположение семи флагов ошибок разных видов, флага суммарной ошибки
и~флагов $C0{-}C3$, хранящих результат сравнения чисел специальными командами.
% 
Команды вещественной арифметики не выставляют флаги $C0{-}C3$ аналогично командам сравнения, но могут использовать эти биты иначе.

% Рассмотрим флаги ошибок подробнее.
% 
% \paragraph{IE (бит 0)} Флаг недействительной операции (Invalid operation).
% Устанавливается в~единицу при выполнении недопустимой стековой (в~этом случае устанавливается также флаг $SF$) или арифметической операции.
% 
% Недействительной арифметической операцией считается операция, проводимая над некорректными аргументами.
% В~этом случае могут быть установлены также флаги $DE$, $ZE$, $OE$, $UE$ или $PE$.
% 
% \paragraph{DE (бит 1)} Флаг денормализованного операнда (Denormalized operand).
% Устанавливается в~единицу при выполнении арифметической операции над денормализованным числом или загрузке такого числа в~стек.
% 
% \paragraph{ZE (бит 2)} Флаг деления на ноль (Zero Divide).
% Устанавливается в~единицу при делении на ноль.
% 
% \paragraph{ОЕ (бит 3)} Флаг переполнения порядка (Overflow).
% Устанавливается в~единицу, если порядок результата выходит за максимально допустимое значение.
% % 
% Для команд выгрузки из стека \lstinline!f*st! переполнение возможно в~том случае, если размер порядка приёмника недостаточен.
% 
% \paragraph{UE (бит 4)} Флаг антипереполнения, или исчезновения порядка (Underflow).
% Устанавливается в~единицу, если порядок результата выходит за минимально допустимое значение (денормализованный результат).
% 
% \paragraph{РЕ (бит 5)} Флаг неточного результата (Precision).
% Устанавливается в~единицу, если результат невозможно точно представить в~формате назначения (например, $\frac{1}{3}$, $\sqrt{2}$).
% 
% Команды вычисления трансцендентных функций (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда приводят к~неточному результату.
% 
% \paragraph{SF (бит 6)} Флаг стековой ошибки (Stack Fault).
% Устанавливается в~единицу при попытке записи в~полностью заполненный стек или чтения из пустой ячейки стека.

Первые семь битов слова состояния соответствуют исключениям FPU.
% 
Каждой исключительной ситуации соответствует свой флаг ошибки,
который устанавливается в~единицу при возникновении этой исключительной ситуации.

% \newcommand{\flagbit}[1]{\hspace*{0pt}\rlap{\textbf{#1}}\hspace{6em}}
\newcommand{\flagbit}[1]{\hspace*{0pt}\rlap{\textbf{#1}}\phantom{\textbf{ОE (бит 3)}}}

% \begin{description}
\flagbit{IE (бит 0)} "--- флаг недействительной операции.

Устанавливается в~единицу при выполнении недопустимой стековой (в~этом случае устанавливается также флаг $SF$) или арифметической операции.
В~последнем случае могут быть установлены также флаги $DE$, $ZE$, $OE$, $UE$ или $PE$.

\flagbit{DE (бит 1)} "--- флаг денормализованного операнда.

\flagbit{ZE (бит 2)} "--- флаг деления на ноль.

\flagbit{ОE (бит 3)} "--- флаг переполнения порядка.

\flagbit{UE (бит 4)} "--- флаг антипереполнения, или исчезновения порядка.

\flagbit{РE (бит 5)} "--- флаг неточного результата.

\flagbit{SF (бит 6)} "--- флаг стековой ошибки.
% \end{description}

Также по результатам операции выставляется флаг суммарной ошибки, которому не соответствует ни одно из исключений.

% \begin{description}[WW (бит W)]
\flagbit{ES (бит 7)} "--- флаг суммарной ошибки (Error Summary Status).

Он равен единице, если возникает хотя бы одно незамаскированное исключение.
% Таким образом, если не замаскировано ни одно из исключений, 
% \end{description}

В~некоторых источниках говорится, что $ES$ равен единице  в~том случае, когда в~разрядах $0...6$ есть хотя бы одна единица~\cite{mikroprocessorniesistemi2002}.
Это в~общем случае неверно.
Если какое-то исключение замаскировано% (например, в~C++ деление на ноль не приводит к~исключению)
, $ES$ не дублирует состояние соответствующего флага.

В~частности,  в~C++ деление на ноль не должно приводить к~прерыванию работы программы, поэтому соответствующее исключение при настройке сопроцессора стартовым кодом маскируется.

Соответственно, при попытке деления единицы на ноль, как можно убедиться при помощи отладчика, результат принимает специальное значение $inf$ ($+\infty$), устанавливается флаг $ZE$, но
флаг $ES$ не устанавливается.

% \begin{lstlisting}[caption={Деление $y = \frac{1}{0}$}, label=lst:asm:fpu:zerodivide]
% double y;
% asm(
%     "fld1\n"
%     "fldz\n"
%     "fdivrp\n"
%     "fstpl %[y]\n"
%     :[y]"=m"(y)
% );
% \end{lstlisting}




\section{Флаги}
\label{sec:flags}
\epigraph{\begin{limerick}
    Жил один старичок в Девоншире,\\
    Он распахивал окна пошире\\
    И кричал: «Господа!\\
    Трумбаду, трумбада!» "---\\
    Ободряя народ в Девоншире.
\end{limerick}
}
{\Lear}

Во время выполнения многих команд формируется не только  результат в~виде числа, но и~те или иные признаки результата (в~частности, корректен ли он)
"--- флаги состояния.
Флаг занимает один бит и~считается установленным, когда он равен~1, и~сброшенным, когда равен 0.

В~частности, 
как было сказано в~разделе~\ref{sec:digits-negcodes}, 
при сложении и~вычитании целых беззнаковых чисел ограниченной разрядности может образоваться бит переноса/заёма из старшего разряда, который сохраняется процессором в~особой ячейке "--- флаге переноса~$CF$\index{Флаги!CF (переноса)}.
% также 
При сложении и~вычитании знаковых чисел формируется флаг переполнения $OF$\index{Флаги!OF (переполнения)}.
% Так как беззнаковые и~представленные в~дополнительном коде знаковые числа складываются одним сумматором, этот сумматор формирует и~$OF$, и~$CF$.
% Оба они
Как $CF$, так и~$OF$ 
являются флагами состояния.

Аналогично флагам состояния, однобитовые переменные, не отражающие признаков результата последней операции, но влияющие на выполнение некоторых команд, называются управляющими флагами.
Некоторые флаги состояния или управляющие флаги доступны только операционной системе и, соответственно, называются системными.

\index{Регистры!флагов}%
Флаги и~некоторые системные  переменные часто объединяются в~специальный регистр "--- регистр флагов.
Процессоры семейства x86 
% объединяют флаги, связанные с~определённым набором команд,
% в~регистры флагов.
исторически имеют два регистра флагов 
"--- собственно регистр флагов  $flags$, связанный с~командами основного набора
и~слово состояния FPU $sw$, связанное с~командами математического сопроцессора FPU.

\subsection{Флаги основного процессора}
\epigraph{\begin{limerick}
Дева юная та, чья история\\
Вся таинственность и аллегория,\\
Восседала на травке\\
В неприметной канавке\\
И строчила трактат по истории.\\
\end{limerick}
}
{\Lear}  

Процессоры семейства x86 объединяют ячейку%
% Ячейка
~$CF$ и~подобные ей биты, показывающие те или иные свойства последней целочисленной арифметической операции "---
флаги состояния 
"---
% объединяются
в~специальный регистр  флагов $flags$ %/eflags/rflags$ 
(таблица~\ref{tab:flags}).
% Тридцатидвухбитная версия


Кроме флагов состояния, регистр флагов включает один бит, не отражающий выполнение последней операции, но влияющий на выполнение некоторых команд (управляющий флаг направления $DF$), а~также несколько битов, недоступных прикладным программам (системные флаги)~\cite{intelSystem,club155,sasm}.
Часть битов зарезервирована и~не используется сейчас как флаги (зарезервированный бит может иметь как произвольное, так и~фиксированное значение).

Доступные прикладным программам флаги состояния в~основном сосредоточены в~младших восьми разрядах $flags$,
% (таблица~\ref{tab:flags}),
поэтому многие команды сохранения/восстановления регистра флагов оперируют только с~младшим байтом.
\index{Флаги!OF (переполнения)}%
\index{Флаги!DF (направления)}%
Старшие восемь бит содержат один флаг состояния~$OF$, управляющий флаг~$DF$ и~несколько системных.
В~тридцатидвухбитном регистре $eflags$ в~старших шестнадцати битах добавлено ещё шесть системных флагов;
старшие тридцать два бита шестидесятичетырёхбитного $rflags$ не используются.


% \footnote{Использованы: 
% Александр Семенко
% http://sasm.narod.ru/apps/eflags/main.htm,
% http://sasm.narod.ru/apps/eflags/app\_a.htm,
% http://www.club155.ru/x86internalreg-eflags
% }

% Флаги разделяются на три группы: флаги состояний, управляющие и~системные~\cite{intelSystem, club155, sasm}.


\begin{table}[!ht]

\caption{Регистр флагов $flags$}
\label{tab:flags}
% \tiny
% \scriptsize
\footnotesize
\renewcommand{\arraystretch}{1.05}
\begin{tabularx}{\linewidth}{@{}c@{~}|l@{~}|l@{~}|L@{}|l@{}}
% № 	& 	&Название 	&Описание 	&Тип флага \\\hline
% \multicolumn{5}{c}{\Reg{flags/eflags}}\\\hline
\multicolumn{5}{c}{\Reg{flags}}\\\hline
\rowcolor{clFlagStatus}0 	&CF 	&Carry Flag 	&Флаг переноса (беззнакового переполнения) 	&Состояние\\\hline
1 	&1 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}2 	&PF 	&Parity Flag 	&Флаг чётности 	&Состояние\\\hline
3 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}4 	&AF 	&Auxiliary Carry Flag 	&Вспомогательный флаг переноса 	&Состояние\\\hline
5 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}6 	&ZF 	&Zero Flag 	&Флаг нуля 	&Состояние\\\hline
\rowcolor{clFlagStatus}7 	&SF 	&Sign Flag 	&Флаг знака 	&Состояние\\\hline
\rowcolor{clFlagSystem}8 	&TF 	&Trap Flag 	&Флаг трассировки 	&Системный\\\hline
\rowcolor{clFlagSystem}9 	&IF 	&Interrupt Enable Flag 	&Флаг разрешения прерываний 	&Системный\\\hline
\rowcolor{clFlagControl}10 	&DF 	&Direction Flag 	&Флаг направления 	&Управляющий\\\hline
\rowcolor{clFlagStatus}11 	&OF 	&Overflow Flag 	&Флаг знакового переполнения 	&Состояние\\\hline
\rowcolor{clFlagSystem}12--13 	&IOPL 	&I/O Privilege Level 	&Уровень приоритета ввода-вывода 	&Системный\\\hline
\rowcolor{clFlagSystem}14 	&NT 	&Nested Task 	&Флаг вложенности задач 	&Системный\\\hline
15 	&0 	&---&Зарезервирован 	&\\\hline
% \\\hline
\multicolumn{5}{c}{\Reg{eflags}}\\\hline
\rowcolor{clFlagSystem}16 	&RF 	&Resume Flag 	&Флаг возобновления 	&Системный\\\hline
\rowcolor{clFlagSystem}17 	&VM 	&Virtual-8086 Mode 	&Режим виртуального процессора 8086 	&Системный\\\hline
\rowcolor{clFlagSystem}18 	&AC 	&Alignment Check 	&Проверка выравнивания 	&Системный\\\hline
\rowcolor{clFlagSystem}19 	&VIF 	&Virtual Interrupt Flag 	&Виртуальный флаг разрешения прерывания 	&Системный\\\hline
\rowcolor{clFlagSystem}20 	&VIP 	&Virtual Interrupt Pending 	&Ожидающее виртуальное прерывание 	&Системный\\\hline
\rowcolor{clFlagSystem}21 	&ID 	&ID Flag 	&Проверка на доступность инструкции CPUID 	&Системный\\\hline
22--31	&	&---&Зарезервированы 	&\\\hline
\end{tabularx}
\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!SF (знака)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!AF (коррекции)}%

\index{Флаги!DF (направления)}%

\end{table}

Регистр $flags$ не может быть явно указан как операнд команды,
но является неявным результатом большинства арифметических команд и~неявным операндом условных команд.

\subsubsection{Флаги состояния}
\index{Флаги!состояния}%

Флаги состояния отображают результаты целочисленных арифметических операций (%\lstinline!add, sub, mul! 
сложения и~вычитания; ограниченно умножения и~поразрядных логических операций
и~пр.); этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра $flags$.

\paragraph{CF	
(бит 0)} 
\index{Флаги!CF (переноса)}%
Флаг переноса (Carry Flag = CF). Устанавливается, если происходит перенос
из старшего разряда результата за пределы разрядной сетки при сложении
или заём в старший  разряд из несуществующего  (выходящего за пределы операнда, воображаемого) разряда при вычитании, таким образом, этот флаг показывает переполнение при выполнении беззнаковых арифметических операций. 

Флаг~$CF$  часто используется и~для других целей, тогда его значение не связано с~беззнаковым  переполнением.
Так, этот бит используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит,
командами извлечения бита %(\lstinline!btX!) 
"--- для хранения извлечённого значения
и~многими другими.
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число единиц, иначе "--- сбрасывается.
\index{Флаги!PF (чётности)}%

Флаг чётности использовался для подсчёта контрольных сумм.

\paragraph{AF	
(бит 4)} \index{Флаги!AF (коррекции)}%
Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады младшего байта, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} \index{Флаги!ZF (нуля)}%
Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)}\index{Флаги!SF (знака)}%
Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное/отрицательное).

\paragraph{OF	
(бит 11)} 
\index{Флаги!OF (переполнения)}%
Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита (то есть сумма положительных чисел даёт результат, интерпретируемый как отрицательный), или имеется перенос из старшего бита, но отсутствует перенос в~него (сумма отрицательных чисел положительна); в~противном случае, флаг $OF$ устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

\paragraph{Знаковые и~беззнаковые команды}
% Из этих флагов только $CF$ можно менять непосредственно (командами stc, clc и~cmc); также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
\index{Флаги!установка}%
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~(в~тридцатидвухбитном режиме) двоично-десятичной BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
% При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг $OF$,
\index{Флаги!OF (переполнения)}%
\index{Арифметика!знаковая}%

\item для беззнаковой арифметики "--- флаг $CF$.
\index{Флаги!CF (переноса)}%
\index{Арифметика!беззнаковая}%

% \item для BCD-арифметики "--- флаг $AF$.
% \index{Флаги!AF (коррекции)}%
% \index{Арифметика!двоично-десятичная}%
\end{itemize}

Так как беззнаковые и~представленные в~дополнительном коде знаковые числа складываются с~помощью одного и~того же сумматора и~одной командой, этот сумматор на всякий случай формирует при сложении и~вычитании и~$OF$, и~$CF$, и~остальные флаги состояния.
% 
Выбор для анализа того флага, который соответствует реальному типу операндов "--- ответственность программиста.

% \subsubsection{Проверка флагов}
% \index{Флаги!проверка}%

\subsection{Флаги FPU}
\epigraph{\begin{limerick}
Иллюзорный старик из Гааги\\
Сделал шар из тряпья и бумаги;\\
Воспарил в вышину\\
И взирал на луну\\
Тот подзорный старик из Гааги.\\
\end{limerick}
}
{\Lear} 
\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\index{FPU}
Математический сопроцессор FPU включает собственный регистр флагов "--- слово состояния~$sw$ (раздел \ref{sec:fpu:sw}).
Старший байт $sw$ может быть загружен в~младший байт флагов основного процессора (таблица~\ref{tab:fpu-status}). 

% В~таблице~\ref{tab:fpu-status} представлено 
% краткое описание структуры слова состояния, а~также 
% соответствие старшего байта слова состояния сопроцессора $sw$ и~младшего байта регистра флагов основного процессора~$flags$.
% Соответствие флагов при этом 

% \colorlet{csControl}{green!50}
% \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% \colorlet{csSystem}{blue!20!red!10}


\begin{table}[!ht]
% \caption{Слово состояния FPU}
\caption{Загрузка состояния FPU в~регистр флагов}
\label{tab:fpu-status}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{$sw$}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}$flags$, fnstsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{clFlagStatus}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{clFlagStatus}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{clFlagSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{clFlagSystem}12 	& 	&&\cellcolor{clFlagStatus}4 	&\cellcolor{clFlagStatus}AF 	&\cellcolor{clFlagStatus}Auxiliary Carry Flag\\
\rowcolor{clFlagSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{clFlagExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!PF (чётности)}%

\end{table}

% \pagebreak[3]
% %слово состояния $sw$ могло быть выгружено в~память или регистр $ax$ командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки $sw$ в~регистр $ax$ его старший байт загружал
% 
% % Таким образом, после выполнения команды сравнения (%и~%пары команд 
% % % \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% % % или при использовании совместимых с~ними 
% % при использовании совместимых с~ранними моделями 
% % команд %f*com[p[p]]
% % без суффикса~\lstinline!i! 
% % необходимы также \lstinline!fnstsw %ax! + \lstinline!sahf!)
% % результат  можно 
% % анализировать как результат сравнения беззнаковых целых чисел.
% % 
% % 
% % После этого значение $C3$ помещается в~аналогичный ему по смыслу флаг нуля $ZF$ ($st(0) - src = 0$), $C0$ "--- в~флаг переноса~$CF$ ($st(0) - src < 0$),
% % то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
% % Бит несравнимости $C2$ попадает на место флага чётности~$PF$. 
% 
% Некоторые команды сравнения вещественных чисел помещают результат в~биты $C0, C2, C3$.
% 
% Как видно из таблицы, при загрузке старшего байта~$sw$ во~$flags$
% флаг отрицательности~$C0$ помещается во флаг беззнакового переполнения~$CF$,
% \index{Флаги!CF (переноса)}%
% флаг нуля~$C3$ "--- в~аналогичный ему по смыслу $ZF$,
% а~флаг несравнимости $C2$ "--- во флаг чётности $PF$. 
% Другие флаги младшего байта~$flags$ получают фактически неопределённое значение.
% % 
% Таким образом, результат можно анализировать как результат сравнения беззнаковых целых чисел.
% 
% 
% % После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% % Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.
% 
% Биты  $C0, C1, C2, C3$ используются не только командами сравнения, но и~арифметическими командами.
% В~отличие от команд основного набора, арифметические команды FPU помещают в~эти биты не сведения об отрицательном или нулевом результате, а~другие признаки.

Биты $C0, C2, C3$ %, используемые командами сравнения и~
помещаются соответственно во флаги $CF, PF, ZF$; бит $C1$ игнорируется.
Другие флаги младшего байта~$flags$ получают фактически неопределённое значение.

\section{Структура команды и~методы адресации}

\epigraph{\begin{stanza}[0mm]
Тот ли идёт прямо по дороге, кто ходит потупив лице своё? \\
Или тот на прямом пути, кто ходит, держа себя прямо? 
\end{stanza}
}
{67.22}

Набор команд процессоров семейства x86 имеет тип CISC\index{CISC}.
Он создавался в~условиях жёсткой экономии памяти, так что команды имеют максимально компактную (и,~соответственно, сложную для декодирования и~понимания)
структуру и~используют разнообразные %способы задания адреса операнда.
методы адресации операндов.

Необходимость программирования в~машинных кодах возникает крайне редко, но знание формата команды помогает лучше представлять себе возможности и~ограничения архитектуры.

\subsection{Методы адресации}
\index{Адресация!виды}%
\label{sec:addressing:common}
\epigraph{\begin{limerick}
Одному господину в~Версале \\
Так внезапно глаза отказали,\\
Что он видеть не мог\\
Даже собственных ног "---\\
И~просил, чтоб ему показали.\\
\end{limerick}
}
{\Lear}

Адрес операнда в~машинной команде 
может быть задан одним из %четырёх 
следующих способов~\cite{asmworld}.
Они называются методами адресации операндов.
% http://asmworld.ru/uchebnyj-kurs/014-rezhimy-adresacii/
\begin{enumerate}
\item \termin{Неявная} адресация\index{Адресация!неявная}.  Местоположение операнда фиксировано и~определяется кодом операции. 
\item \termin{Непосредственная} адресация\index{Адресация!непосредственная}. Операнд "--- константа, которая включается непосредственно в~команду.
\item \termin{Прямая абсолютная} (прямая) адресация\index{Адресация!прямая}. Операнд "--- переменная в~памяти по~фиксированному адресу (глобальная или статическая).
Этот адрес включается непосредственно в~команду.

% Так как соответствующее поле команды тридцатидвухбитно, фактически н

\item \termin{Прямая относительная} адресация\index{Адресация!прямая относительная}. 
В~команде содержится смещение, которое прибавляется к значению указателя команд $ip$.


Этот режим используется в командах передачи управления
и~позволяет загружать код в~память по произвольному адресу без нарушения корректности переходов.
% То есть указывается не сам адрес перехода, а на сколько байтов вперёд или назад надо перейти. Пример:

Шестидесятичетырёхбитное расширение позволяет использовать прямую относительную адресацию также и~для данных.

\item \termin{Регистровая}  адресация\index{Адресация!регистровая}. Операнд находится в~регистре общего назначения.
В~команду включается номер этого регистра.

\item \termin{Косвенно-регистровая} (косвенная) адресация\index{Адресация!косвенная}. Операнд "--- переменная в~памяти и~её адрес находится в~регистре (регистрах) общего назначения.
% Иногда выделяют косвенную базовую 

Иногда выделяют следующие виды косвенной адресации:
\begin{itemize}
\item  базовая адресация "--- адрес операнда в~регистре (базовом регистре, базе);
\item  базовая адресация со смещением "--- адрес операнда вычисляется как сумма базового регистра и~константы (смещения);
\item  базово-индексная адресация "--- адрес операнда вычисляется как сумма двух регистров "--- базового регистра и~индексного;
\item  базово-индексная адресация  со смещением "--- адрес операнда вычисляется как сумма двух регистров и~константы.
\end{itemize}
\end{enumerate}
Если необходимо обработать значение, адрес которого получается более сложным образом
(в~частности, переменная в~памяти, указатель на которую также находится в~памяти), 
этот адрес надо вычислить отдельно и~поместить в~регистр.

% Смотрите также разделы~\longref{sec:addressing} 
% и~\longref{sec:arrays}.


\subsection{Структура команды}
\label{sec:command-x86}

\epigraph{\begin{limerick}
    Задремавший один старичок\\
    Думал: дверь заперта на крючок.\\
    Но один толстый крыс\\
    Его шляпу изгрыз,\\
    А другой – съел его сюртучок.\\
\end{limerick}
}
{\Lear}

Команды процессоров семейства x86  имеют переменную длину.
Структура команды показана на рис.~\ref{ris:x86-cmd_structure}.

\begin{illustration}
% \includegraphics[width=1\linewidth,keepaspectratio,valign=t]{cmd_structure}
\includegraphics[width=1\linewidth,keepaspectratio,valign=t]{cmd_structure_intel}
\caption{Структура команды x86}
\label{ris:x86-cmd_structure}
\end{illustration}

Все поля, кроме кода операции, необязательны~\cite{nezumi-disasm, intelInstructionSet}.


Команда может предваряться одним или несколькими префиксами, изменяющими её поведение.
% \begin{itemize}
% \item 
% \end{itemize}
\index{0x66, префикс изменения размера операнда}%
\index{0x67, префикс изменения размера адреса}%
Из префиксов x86 следует отметить префикс изменения размера операнда \lstinline!0x66!
и~префикс изменения размера адреса~\lstinline!0x67!.
Для тридцатидвухбитного режима (и~его шестидесятичетырёхбитного расширения) они уменьшают разрядность операнда или адреса соответственно до 16 бит, 
для шестнадцатибитного "--- повышают до 32.
% (по умолчанию разрядность операндов и~адреса
Восьмибитные варианты команд, как правило, представлены отдельными опкодами.

Далее идёт код операции (опкод), занимающий один, два или три байта (и, может быть, ещё три бита в~байте $Mod~R/M$).
% 
% Следующие два байта, $Mod~R/M$ и~$SIB$, согласно~\cite{intelInstructionSet}, задают адресацию операндов. %, если они есть.
% Каждое из них состоит из трёх полей.
Следующий байт, $Mod~R/M$, согласно~\cite{intelInstructionSet}, задаёт адресацию операндов. %, если они есть.
% Он состоит из трёх полей: $Mod$ 
За ним следует необязательный байт $SIB$, уточняющий расположение операнда в~памяти, если %для одного из операндов  
такой есть и~для него используется косвенная базово-индексная адресация.
Каждый из байтов  $Mod~R/M$ и~$SIB$ состоит из трёх полей.

Поле $Displacement$ содержит смещение адреса при косвенной адресации.
Оно трактуется как знаковое тридцатидвухбитное (при использовании понижающего разрядность адреса префикса 0x67 "--- шестнадцатибитное) или восьмибитное число.

Поле $Immediate$ "--- непосредственное значение («магическое число», включённое непосредственно в~команду).
Оно присутствует, если опкод соответствует операции с~непосредственным операндом.

\subsection{Общие для тридцатидвухбитного и~шестидесятичетырёхбитного режимов %типы
сведения об~адресации}

\epigraph{\begin{stanza}[0mm]
Но если б я был не здесь,\\
Всё было б точно так же, как есть.\\
\hspace{\stanzaoddindent}Всё дело во мне самом,\\
\hspace{\stanzaoddindent}И если б я был чуть твёрже умом,\\
\hspace{\stanzaoddindent}Я был бы в пути, но мне всё равно,\\
Там я, или я здесь. \\
\end{stanza}
}{\Aquarium}

Адресация в~системе команд x86 частично задаётся опкодом.
\index{Адресация!непосредственная}%
Это относится не только к~неявной адресации (что логично), но и~к~непосредственной. % и~регистровой.
Более того, для самых компактных команд номер операнда-регистра также может быть указан внутри опкода.
Так, тот вариант команды \lstinline!mov!, который записывает непосредственное значение в~регистр, 
состоит из однобайтового опкода и~поля~$Immediate$; при этом собственно код операции  занимает пять старших бит  опкода, а~последние три бита  задают регистр-приёмник.
% Команда загрузки значения в~регистр общего назначения \lstinline!mov $13, %eax! содержит его имя в~явном виде,
\index{Команды!mov}%
% а~соответствующий машинный код \hex{B8\,00\,00\,00\,0D} содержит номер  регистра%~$eax$. %
% ~$A$ ($B8_{16} = 10111000_2$, последние три бита $000$ задают регистр-приёмник).
При этом, если опкодом задаётся использование
двух операндов,
один из которых непосредственный, а~второй 
% в~памяти,
адресуется полем $R/M$,
то в~освободившееся поле $Reg$ байта $Mod~R/M$ может быть записана часть опкода.
% Также опкод включает поле направления, показывая
% Код операции задаёт, в~частности, неявну
% Неявная и~непосредственная адресация задаются кодом операции.
% Значение непосредственного 

% В~большинстве команд адресация задаётся байтом  $Mod~R/M$ и~при необходимости уточняется байтом $SIB$ и~полем $Displacement$.
Кроме непосредственного% операнда
, команда может иметь  два операнда,
расположение которых задаётся байтом  $Mod~R/M$ и~при необходимости уточняется байтом $SIB$ и~полем $Displacement$.

% Один из них "--- всегда регистр, 
Поле $Reg$ байта $Mod~R/M$ содержит трёхбитовый номер операнда-регистра.
\index{Адресация!регистровая}%
Является ли он источником или приёмником, определяет специальный бит опкода "--- поле направления.


Поле $R/M$ в~зависимости от поля~$Mod$ может как содержать номер второго  операнда-регистра,
так и~определять адрес операнда в~памяти.
При необходимости совместно с~полями $R/M$ и~$Mod$ используются также $SIB$ и~$Displacement$ (таблица~\ref{tab:command:rm}).

\label{sec:rm:addressing}

\begin{table}[!ht]
% \caption{Адресация второго операнда}
\caption{Адресация операнда при помощи поля $R/M$}
\label{tab:command:rm}
\renewcommand{\tabularxcolumn}[1]{m{#1}}


\newcommand{\sib}[4]
{
\begin{tikzpicture}[
start chain=going right,
node distance=0ex, outer sep=0ex, inner sep = 0.2ex,
% baseline=(current bounding box.center)
baseline=(q)
]
%   \matrix (m) [matrix of nodes, row sep=3em, column sep=0em]
%     { %$(Scale,$ & $Index$  & $Base)$ \\
%      0  & #1 & #2  \\ };
      
% \foreach \i in {1,...,5}
% {
% \path (m-1-\i) -- node[sloped] {$\geqslant$} (m-2-\i);
% };

\node[on chain] (s) {$~(Scale,$};
\node[on chain, text width=\widthof{$Index,$}, text badly centered] (i) {$#1,$};
\node[on chain, text width=\widthof{$Base)$}, text badly centered] (b) {$#3)$};
\foreach \f/\nf in {i/#2, b/#4}
{
  \ifthenelse{\equal{\nf}{}}{}{
  \node[below = 2ex of \f|-i.base] (n\f) {$\nf$};
  \path (\f|-i.base) -- node[sloped] {$\neq$} (n\f);
%   \path (n\f) -- node[sloped] {$\neq$} (\f|-i.south);
}
};

\ifthenelse{\equal{#2#4}{}}
{
% \node[below = 0.2ex of i] {};
\coordinate (q) at (i.base);
}{
% \node[below = 0.2ex of ni] {};
% \node[above = 0.5ex of i] {};
% \coordinate (q) at ($0.5*(current bounding box.center) + 0.5*(current bounding box.base)$);
\coordinate (q) at (current bounding box.center);
}
\end{tikzpicture}

}


% \bfseries
\small
% \footnotesize
\begin{tabularx}{1\linewidth}{|@{\,}c@{\,}|@{\,}c@{\,}|@{\,}C@{\,}|@{\,}c@{\,}|@{\,}c@{\,}|}
\hline
$\footnotesize{\boldsymbol{Mod}}$	& \footnotesize$\boldsymbol{Displacement}$ & \footnotesize$\boldsymbol{R/M}$	& \footnotesize$\boldsymbol{SIB}$	& \footnotesize\textbf{Операнд}\\\hline
$11$	& --- & %номер регистра 
$Reg2$	& --- & $Reg2$\\\hline
\multirow{3}{*}{$01$}	& \multirow{3}{*}{%восьмибитное смещение 
$Disp8$}	& $Base\neq 100$ &	---& $*\Big(Base + Disp8\Big)$\\\cline{3-5}    
  &	&	$100$	& \sib{Index}{100}{Base}{}	& $*\Big(Base + 2^{Scale} \cdot Index + Disp8\Big)$\\\cline{3-5} 
  &	&	$100$	& \sib{100}{}{Base}{}	& $*\Big(Base  + Disp8\Big)$\\\hline
%  \multirow{2}{*}{$10$}	& \multirow{2}{*}{$Disp32$}	& $Base\neq 100$ &	отсутствует& $*\Big(Base + Disp32\Big)$\\\cline{3-5}    
% % \hhline{~~---}
%   &	&	$100$	& $(Scale, Index, Base)$	& $*\Big(Base + 2^{Scale} \cdot Index + Disp32\Big)$\\\hline
\multirow{3}{*}{$10$}	& \multirow{3}{*}{$Disp32$}	& $Base\neq 100$ &	---& $*\Big(Base + Disp32\Big)$\\\cline{3-5}    
  &	&	$100$	& \sib{Index}{100}{Base}{}	& $*\Big(Base + 2^{Scale} \cdot Index + Disp32\Big)$\\\cline{3-5} 
  &	&	$100$	& \sib{100}{}{Base}{}	& $*\Big(Base  + Disp32\Big)$\\\hline
% $00$	&	  
% \begin{tabular}{@{}c@{}}
% $Disp32$\\(если\\необходимо)
% \end{tabular}
% & 
% \multicolumn{3}{c|}{
% \begin{tabular}{@{}c@{}}
% Частичная косвенная адресация\\
% (зависит от разрядности режима)
% \end{tabular}
% }\\\hline
\multirow{5}{*}{$00$}	& \multirow{2}{*}{---}	& $Base \notin \{100, 101\}$	& --- & $*\Big(Base\Big)$\\\cline{3-5} 
	&	& $100$	& \sib{Index}{100}{Base}{101} & $*\Big(Base + 2^{Scale} \cdot Index\Big)$\\\cline{2-5} 
	& \multirow{3}{*}{$Disp32$}	& $100$	& \sib{Index}{100}{101}{} & $*\Big( 2^{Scale} \cdot Index + Disp32 \Big)$\\\cline{3-5} 
	&	& $100$	& \sib{100}{}{101}{} & $*\Big( Disp32 \Big)$\\\cline{3-5} 
	&	& $101$	& --- & 
\begin{tabular}{@{}c@{}}
зависит от разрядности режима \\
\begin{tabular}{@{}lc@{}}
32-битный: &$*\Big( Disp32 \Big)$ \\
64-битный\index{Шестидесятичетырёхбитный режим}: & $*\Big( rip + Disp32 \Big)$ \\
\end{tabular}	
\end{tabular}
	\\\hline
% 	&	& \multirow{3}{*}{$101$}	& \multirow{3}{*}{---} & зависит от разрядности режима: \\
% 	&	&	&	&	32-битный: $*\Big( Disp32 \Big)$ \\
% 	&	&	&	&	64-битный: $*\Big( rip + Disp32 \Big)$ \\\hline
\end{tabularx}
\end{table}


При $Mod=11$ поле $R/M$  "--- номер второго  операнда-регистра.
% в~соответствии с~таблицей~\ref{tab:command:reg}.
Остальные три возможных значения $Mod$ соответствуют косвенной адресации,
\index{Адресация!косвенная}%
то есть операнд находится в~памяти по некоторому адресу.


Адрес операнда  в~памяти в~общем случае может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = {Base} + 2^{Scale} \cdot {Index} + Displacement
\end{equation}
где масштаб $Scale \in [0, 3]$ "--- константа,
${Base}$ и~${Index}$ "--- регистры.

Каждая из компонент может быть опущена;
таким образом, прямая адресация в~x86 является частным случаем косвенной.
\index{Адресация!прямая}%


% Адрес складывается из нескольких регистров ()
Значения поля $Mod$ $01$ и~$10$ 
% соответствуют полной форме 
показывают наличие поля $Displacement$ различной длины (при $Mod=01$ "--- восьмибитное, при $Mod=10$ %разрядность этого поля соответствует разрядности команды: шестнадцати или тридцати двум битам
% "--- шестнадцать или тридцать два бита, в~зависимости от режима
"--- тридцатидвухбитное% в~тридцатидвухбитном режиме
), содержащего смещение.
% \begin{equation}
% \label{eq:command:mod10}
% \text{Адрес} = \zeta + Displacement
% \end{equation}
% где $\zeta$ "--- комбинация регистров, определяемая полем $R/M$ и~байтом~$SIB$.
% % Комбинация регистров 
% $\zeta$
% либо включает только один базовый регистр, код которого находится в~поле $R/M$,
% либо определяется байтом~$SIB$, в~этом случае поле $R/M$ принимает специальное значение $100$
% (в~таблице~\ref{tab:command:reg} оно соответствует регистру~$sp$).
При $Mod=00$ смещение может отсутствовать или быть тридцатидвухбитным в~зависимости от значения других полей.


% При этом любое значение поля $R/M$, кроме $100$, соответствует полной форме косвенной базовой адресации со смещением (байт $SIB$ отсутствует),
% а~специальное значение $R/M=100$ "--- %полной форме 
% косвенной базово-индексной адресации с~масштабом и~смещением (базовый и~индексный регистры, а~также масштабный коэффициент индексного регистра задаются байтом~$SIB$).
% \begin{equation}
% \label{eq:command:zeta}
% \zeta = 
% \left\{
% \begin{array}{ll}
% Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% \end{equation}
Байт~$SIB$ следует за байтом $Mod~R/M$, если поле $R/M$ принимает специальное значение $100$.
Первые два его бита "--- масштаб "--- целое число $Scale \in [0, 3]$,  %\{0, 1, 2,  3}$, 
определяющее коэффициент,
на который умножается индексный регистр (соответственно $1, 2, 4$ или $8$),
далее следуют трёхбитные поля $Index$ и~$Base$, хранящие номера регистров.
Значение поля $Index = 100$ является специальным, в~этом случае %в~формуле~\eqref{eq:command:zeta} используется
считается $Index=0$ (то есть получается базовая адресация без индекса).
Таким образом, индексный регистр в~\eqref{eq:command:addressing} не может иметь код $100$ ни при каких значениях прочих полей.
% Базовый регистр 

Если значение поля $R/M$ отлично от $100$, байт $SIB$ отсутствует.

При $Mod=01$ или~$Mod=10$ любое значение $R/M \neq 100$ трактуется как номер базового регистра $Base$ в~базовой адресации со смещением,
то есть адрес операнда в~памяти равен $Base+Displacement$, где $Base$ не может иметь код $100$.
При $R/M=100$ используется базово-индексная адресация со смещением ${Base} + 2^{Scale} \cdot {Index} + Displacement$, где $(Scale, Index, Base) \in SIB$.
Используя специальное значение $Index=100$, можно получить базовую адресацию со смещением; в~этом случае базовый регистр $Base \in SIB$ может быть любым, включая $Base = 100$.
% Соответственно, базовый регистр в~базовой адресации

Режим $Mod=00$ "--- самый запутанный.
% При $Mod=00$ 
По умолчанию используется косвенная %базово-индексная 
адресация без смещения (поле $Displacement$ отсутствует).
При этом значение базового регистра (безразлично, записанного в~поле $R/M$ или в~поле $SIB$) $Base = 101$ является специальным
и~соответствует отсутствию в~\eqref{eq:command:addressing} базового регистра ($Base=0$) и~одновременно "--- присутствию в~команде тридцатидвухбитного смещения.
Таким образом, базовый регистр в~адресации без смещения не может иметь код $101$ (но обратиться к~подобному адресу можно "--- например, используя $Mod=01$, где $101$ является допустимым номером базового регистра, и~указав восьмибитное смещение, равное нулю).

\index{Адресация!прямая относительная}%
В~шестидесятичетырёхбитном режиме случай $R/M = Base = 101$ при $Mod=00$ трактуется как особый случай и~соответствует адресации относительно %указателя команд
адреса следующей команды (специального регистра $rip$ "--- указателя команд), то есть адрес операнда в~памяти равен $rip+Displacement$~\cite{amd64Instructions}.
В~тридцатидвухбитном режиме аналога этой адресации нет.

% Таким образом, адрес операнда при $Mod=01$ или~$Mod=10$ может иметь вид
% \begin{equation}
% \label{eq:command:base+displacement}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{@{}l@{~}l}
% Base + Displacement, & R/M = 100, Base\in SIB, Index = 100\\
% Base + 2^{Scale} \cdot Index + Displacement, & R/M = 100, (Scale, Index, Base) \in SIB\\
% Base + Displacement, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Первая строка отличается от последней тем, что $Base$ из поля $SIB$ может соответствовать 
% % регистру $sp$ (код $100$).
% номеру~$100$.

% При $Mod=00$ %адрес складывается
% используется косвенная адресация без смещения, 
% кроме специального случая $Base=101$, когда, наоборот, остаётся тридцатидвухразрядное смещение без базы:
% % Также при  $Mod=00$ возможно
% \begin{equation}
% \label{eq:command:baseonly-displacementonly}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{ll}
% Displacement, &R/M = 101~\text{(только в~32-битном режиме)} \\%(bp)\\
% Displacement, & R/M = 100, Base=101, Index = 100\\
% 2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Соответственно, регистр $bp$ (код $101$) не может быть базовым без смещения (но может быть базовым с~нулевым смещением при $Mod \in\{01, 10\}$ и~$Displacement=0$).
% используется частичная косвенная адресация (в~выражении ${Base} + 2^{Scale} \cdot {Index} + Displacement$ отсутствует одна из компонент адреса).
% Адресация при $Mod=00$  в~тридцатидвухбитном и~шестидесятичетырёхбитном режимах немного различается, поэтому этот случай будет рассмотрен отдельно.
% Значен

% В~качестве компонент адреса операнда можно без ограничений использовать регистры~$A, B, C, D, si, di$ необходимой разрядности
% и~ограниченно "--- $bp$ (без ограничений может быть индексным, при $Mod \in\{01, 10\}$ может быть базовым)
% и~$sp$ (может быть базовым, что широко используется при адресации элементов стека, но не индексным),
% номера которых совпадают со специальными значениями полей.

В~шестидесятичетырёхбитном режиме разрядность номеров регистров может быть увеличена с~помощью префиксов расширения регистра.
Разрядность поля $Displacement$ в~шестидесятичетырёхбитном режиме не повышается до 64 бит.\index{Шестидесятичетырёхбитный режим}


Таким образом, 
всего у~команды x86 может быть не более трёх явных операндов,
среди которых 
не более одного непосредственного значения,
не более одного  значения в~памяти
и~не более двух  регистров, причём два операнда-регистра исключают операнд в~памяти.

Адрес операнда в~памяти складывается из четырёх компонент по базово-индексной схеме со смещением, причём базовым может быть любой регистр общего назначения (в~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} "--- ещё и~указатель команд, но только в~базовой адресации без индекса), индексным не может быть регистр с~кодом $100$.


\subsection{Адресация в~тридцатидвухбитном режиме}
\epigraph{\begin{limerick}
    Один старичок был не в духе, \\
    Он решил прокатиться на мухе.\\
    «Далеко не летай,\\
    За горою "--- Китай», "---\\
    Старику объяснили старухи.
\end{limerick}
}
{\Lear}

% Поле $Mod$ (первые два бита следующего байта "--- $Mod~R/M$) задаёт регистровую или косвенно-регистровую адресацию.
% Если оно равно $11$, то используется регистровая адресация и~оба следующие трёхбитовых поля ($Reg$ и~$R/M$) "--- номера регистров.
% Остальные значения задают косвенную адресацию с~различной разрядностью смещения (количеством байт в~$Displacement$). %, тогда .

% Поле $Reg$ байта $Mod~R/M$ содержит трёхбитовый номер операнда-регистра (таблица~\ref{tab:command:reg}).
В~тридцатидвухбитном режиме номера операндов-регистров задаются только трёхбитовыми полями %внутри команды
байтов $Mod~R/M$ и~$SIB$.
Каждому трёхбитному номеру  соответствует определённый регистр общего назначения с~учётом типа и~разрядности команды (таблица~\ref{tab:command:reg}).
\index{Адресация!регистровая}%
% Является ли он источником или приёмником, определяет специальный бит опкода "--- поле направления.
% % Поле $Reg$ задаёт номер регистра "--- первого (левого) операнда.
% % В~системе команд x86, если операндов два и~более, то один из них "--- обязательно регистр.
\begin{table}[!ht]
\caption{Номера (коды) регистров}
\label{tab:command:reg}

% \begin{tabular}{|l|l|}
% \hline
% Регистр	& Код \\
% \hline
% eax/ax/al/mm0/xmm0 & 000 \\
% ecx/cx/cl/mm1/xmm1 & 001 \\
% edx/dx/dl/mm2/xmm2 & 010 \\
% ebx/bx/bl/mm3/xmm3 & 011\\
% esp/sp/ah/mm4/xmm4 & 100\\
% ebp/bp/ch/mm5/xmm5 & 101\\
% esi/si/dh/mm6/xmm6 & 110\\
% edi/di/bh/mm7/xmm7 & 111\\ 
% \hline
% \end{tabular}
\bfseries
\begin{tabularx}{1\linewidth}{|ccc|cc|C|}
\hline
\multicolumn{5}{|c|}{Регистр}	& \multirow{2}{*}{Код} \\
\cline{1-5}    
% \hhline{-----~}
32 бита & 16 бит & 8 бит	& Команда MMX & Команда XMM &	\\
\hline
$eax$ & $ax$ & $al$ & $mm0$ & $xmm0$ & $000$ \\
$ecx$ & $cx$ & $cl$ & $mm1$ & $xmm1$ & $001$ \\
$edx$ & $dx$ & $dl$ & $mm2$ & $xmm2$ & $010$ \\
$ebx$ & $bx$ & $bl$ & $mm3$ & $xmm3$ & $011$ \\
$esp$ & $sp$ & $ah$ & $mm4$ & $xmm4$ & $100$ \\
$ebp$ & $bp$ & $ch$ & $mm5$ & $xmm5$ & $101$ \\
$esi$ & $si$ & $dh$ & $mm6$ & $xmm6$ & $110$ \\
$edi$ & $di$ & $bh$ & $mm7$ & $xmm7$ & $111$ \\ 
\hline
\end{tabularx}

\end{table}

В~зависимости от разрядности команды и~от того, входит ли команда в~основной набор инструкций или в~какое-либо из расширений,
один и~тот же номер адресует разные регистры.
Из таблицы~\ref{tab:command:reg} видно, что
в~тридцатидвухбитном режиме
младшие байты  регистров $sp, bp, si, di$ не могут иметь имён, потому что соответствующие номера уже заняты $ah{-}dh$.

% 
% При $Mod=11$ поле $R/M$  "--- номер второго  операнда-регистра в~соответствии с~таблицей~\ref{tab:command:reg}.
% Остальные три возможных значения $Mod$ соответствуют косвенной адресации,
% \index{Адресация!косвенная}%
% то есть операнд находится в~памяти по некоторому адресу.
% 
% % Адрес складывается из нескольких регистров ()
% Значения поля $Mod$ $01$ и~$10$ показывают наличие поля $Displacement$ различной длины (при $Mod=01$ "--- восьмибитное, при $Mod=10$ %разрядность этого поля соответствует разрядности команды: шестнадцати или тридцати двум битам
% % "--- шестнадцать или тридцать два бита, в~зависимости от режима
% "--- тридцатидвухбитное в~тридцатидвухбитном режиме), содержащего смещение.
% \begin{equation}
% \label{eq:command:mod10}
% \text{Адрес} = \zeta + Displacement
% \end{equation}
% где $\zeta$ "--- комбинация регистров, определяемая полем $R/M$ и~байтом~$SIB$.
% % Комбинация регистров 
% $\zeta$
% либо включает только один базовый регистр, код которого находится в~поле $R/M$,
% либо определяется байтом~$SIB$, в~этом случае поле $R/M$ принимает специальное значение $100$
% (в~таблице~\ref{tab:command:reg} оно соответствует регистру~$sp$).
% \begin{equation}
% \label{eq:command:zeta}
% \zeta = 
% \left\{
% \begin{array}{ll}
% Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% \end{equation}
% Байт~$SIB$ следует за байтом $Mod~R/M$.
% Первые два его бита "--- масштаб "--- целое число $Scale \in [0, 3]$,  %\{0, 1, 2,  3}$, 
% определяющее коэффициент,
% на который умножается индексный регистр (соответственно $1, 2, 4$ или $8$),
% далее следуют трёхбитные поля $Index$ и~$Base$, хранящие номера регистров.
% Значение поля $Index = 100$ считается специальным, в~этом случае в~формуле~\eqref{eq:command:zeta} используется $Index=0$.
% 
% Таким образом, адрес операнда при $Mod=01$ или~$Mod=10$ может иметь вид
% \begin{equation}
% \label{eq:command:base+displacement}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{ll}
% Base + Displacement, & R/M = 100, Index = 100\\
% Base + 2^{Scale} \cdot Index + Displacement, & R/M = 100\\
% Base + Displacement, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Первая строка отличается от последней тем, что $Base$ из поля $SIB$ может соответствовать регистру $sp$ (код $100$).

% При $Mod=00$ %адрес складывается
% используется косвенная адресация без смещения, 
% кроме специального случая $Base=101$, когда, наоборот, остаётся тридцатидвухразрядное смещение без базы:
% % Также при  $Mod=00$ возможно
% \begin{equation}
% \label{eq:command:baseonly-displacementonly}
% {
% \small
% \text{Адрес} = 
% \left\{
% \begin{array}{ll}
% Displacement, &R/M = 101~\text{(только в~32-битном режиме)} \\%(bp)\\
% Displacement, & R/M = 100, Base=101, Index = 100\\
% 2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
% \end{array}
% \right.
% }
% \end{equation}
% Соответственно, регистр $bp$ (код $101$) не может быть базовым без смещения (но может быть базовым с~нулевым смещением при $Mod \in\{01, 10\}$ и~$Displacement=0$).

% Таким образом, 
% всего у~команды x86 может быть не более трёх явных операндов,
% среди которых 
% не более одного непосредственного значения,
% не более одного  значения в~памяти
% и~не более двух  регистров, причём два операнда-регистра исключают операнд в~памяти.
% 
% Адрес операнда  в~памяти может включать до четырёх компонент: %задаётся 
% \begin{equation}
% \label{eq:command:addressing}
% \text{Адрес} = {Base} + 2^{Scale} \cdot {Index} + Displacement
% \end{equation}
% где масштаб $Scale \in [0, 3]$ "--- константа,
% ${Base}$ и~${Index}$ "--- регистры.
% 
% Каждая из компонент может быть опущена;
% таким образом, прямая адресация в~x86 является частным случаем косвенной.

В~качестве компонент адреса операнда можно без ограничений использовать регистры~$A, B, C, D, si, di, bp$ необходимой разрядности.
% и~ограниченно "--- 
% $bp$ (без ограничений может быть индексным, при $Mod \in\{01, 10\}$ может быть базовым)
% и~$sp$ (может быть базовым, что широко используется при адресации элементов стека, но не индексным),
% номера которых совпадают со специальными значениями полей.
Указатель стека $sp$ может быть базовым, что широко используется при адресации элементов стека,\index{Стек} но не индексным,  так как его код совпадает со специальным значением $100$ поля $Index$.

\subsection{Расширение регистров в~шестидесятичетырёхбитном режиме}

\epigraph{\begin{limerick}
Жил старик, по фамилии Плиски,\\
С головою не больше редиски.\\
Но, надевши парик,\\
Становился старик\\
Судьёй, по фамилии Плиски!\\
\end{limerick}
}
{\Lear}


\index{REX, префикс}\index{Шестидесятичетырёхбитный режим}%
В~шестидесятичетырёхбитном режиме между историческими префиксами и~опкодом может находиться
специальный однобайтовый префикс расширения регистров $REX$.
Его 
младшие три бита (биты 0-2, обозначаемые в~документации как $B$, $X$, $R$)
используются для увеличения разрядности номеров регистров, % (добавления старшего бита к~номеру).
следующий (третий) бит ($W$) определяет, используются ли шестидесятичетырёхбитные операнды (1) или разрядность операндов %определяется опкодом,
не изменяется (0),
старшие четыре бита равны $0100$ и~служат для идентификации.

Бит 2 префикса $REX$ ($REX.R$)
 добавляется к~полю $Reg$ байта $Mod~R/M$,
бит 1  ($REX.X$) "--- к~полю $Index$ байта $SIB$,
младший бит~0 ($REX.B$), в~зависимости от используемой адресации "--- к~%номеру регистра в~поле 
полю $R/M$ байта $Mod~R/M$, полю~$Base$ байта~$SIB$ или номеру регистра внутри опкода.

Таким образом, количество адресуемых регистров общего назначения возрастает до шестнадцати.
Номера регистров $A{-}di$, указанные в~таблице~\ref{tab:command:reg},
соответствуют отсутствию префикса $REX$ или нулю  в~соответствующем бите $REX$ (в~последнем случае с~учётом $REX$ получаем четырёхбитовые коды~$0100{-}0111$).
Единица в~$REX$ в~сочетании с~трёхбитовым полем в~команде даёт номера регистров $1000{-}1111$, то есть $r8{-}r15$ (таблица~\ref{tab:command:reg64}).

\begin{table}[!ht]
\caption{Номера (коды) регистров общего назначения при использовании $REX$}
\label{tab:command:reg64}

\bfseries
\begin{tabularx}{1\linewidth}{|CCCC|C|CCCC|C|}
\hline
\multicolumn{4}{|c|}{Регистр}	& \multirow{2}{*}{Код}& \multicolumn{4}{c|}{Регистр}	& \multirow{2}{*}{Код}\\
\hhline{----~----~}
64 бита & 32 бита & 16 бит & 8 бит    && 64 бита & 32 бита & 16 бит & 8 бит & \\
\hline
$rax$ & $eax$ & $ax$ & $al$  & $0000$ & $r8 $ & $r8 d$ & $r8 w$ & $r8 b$ & $1000$\\
$rcx$ & $ecx$ & $cx$ & $cl$  & $0001$ & $r9 $ & $r9 d$ & $r9 w$ & $r9 b$ & $1001$\\
$rdx$ & $edx$ & $dx$ & $dl$  & $0010$ & $r10$ & $r10d$ & $r10w$ & $r10b$ & $1010$\\
$rbx$ & $ebx$ & $bx$ & $bl$  & $0011$ & $r11$ & $r11d$ & $r11w$ & $r11b$ & $1011$\\
$rsp$ & $esp$ & $sp$ & $spl$ & $0100$ & $r12$ & $r12d$ & $r12w$ & $r12b$ & $1100$\\
$rbp$ & $ebp$ & $bp$ & $bpl$ & $0101$ & $r13$ & $r13d$ & $r13w$ & $r13b$ & $1101$\\
$rsi$ & $esi$ & $si$ & $sil$ & $0110$ & $r14$ & $r14d$ & $r14w$ & $r14b$ & $1110$\\
$rdi$ & $edi$ & $di$ & $dil$ & $0111$ & $r15$ & $r15d$ & $r15w$ & $r15b$ & $1111$\\ 
\hline
\end{tabularx}

\end{table}

Изменяя бит 3 префикса $REX$  ($REX.W$), можно получить разрядность от 8 до 64 как для $r8{-}r15$, так и~для $A{-}di$.
% В~шестидесятичетырёхбитном режиме %префикс расширения регистров $REX$ 
% есть возможность дополнить коды регистров 
% (за счёт использования специальных префиксов расширения регистров $REX$).
% % добавить ещё восемь регистров.
При использовании восьмибитной команды в~сочетании с~$REX$ с~нулевым третьим битом (то есть разрядность не изменяется и~операнды занимают 8~бит)  коды регистров $0100{-}0111$ описывают младшие байты  регистров $sp{-}di$
"--- в~документации и~коде программы они обозначаются $spl{-}dil$.
Таким образом, в~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} доступны как $ah{-}dh$, так и~$spl{-}dil$.
При этом в~одной и~той же команде нельзя адресовать, например, $ah$ и~$sil$% или $ah$ и~$r8$
, так как для первого требуется обязательное отсутствие у~команды префикса $REX$, а~для второго "--- наличие $REX$ с~нулевым третьим битом.
% % Прочие регистры тридцатидвухбитного режима доступны как с~

\index{VEX, префикс}%
\index{EVEX, префикс}%
$REX$ "--- не единственный префикс расширения регистров.
В~частности, команды расширения AVX (YMM) Intel используют двух- или трёхбайтовый префикс $VEX$, одной из функций которого также является расширение номеров регистров $ymm$; расширение AVX512 (ZMM) "--- префикс $EVEX$.
В~расширении SSE5 (XOP) AMD также используется похожий, но при этом несовместимый с~$VEX$ префикс~\cite{amd64Media}.

\subsection{Операнды и~адресация в~шестидесятичетырёхбитном режиме}

\epigraph{\begin{limerick}
    Горемыка, страдавший отчаянно, \\
    Приобрёл себе зайца нечаянно "---\\
    И умчал на нём вдаль,\\
    Чтоб размыкать печаль\\
    И уже не страдать так отчаянно.
\end{limerick}
}
{\Lear}

Шестидесятичетырёхбитный режим\index{Шестидесятичетырёхбитный режим} процессоров семейства x86 является расширением тридцатидвухбитного и~отличается от него менее существенно, чем тридцатидвухбитный защищённый режим от шестнадцатибитного реального.
В~частности, структура команды аналогична описанной ранее.
Режимы адресации %(кроме добавленной возможности адресовать данные относительно указателя команд) также сохраняются.
также в~основном сохраняются.
Основным новшеством шестидесятичетырёхбитной адресации является  возможность адресовать данные относительно указателя команд.

Количество доступных регистров общего назначения в~шестидесятичетырёхбитном режиме увеличено за счёт возможности использования префикса $REX$, хранящего дополнительный бит номера регистра.
При этом при %декодировании команды и~
формировании адреса операнда в~памяти вначале определяются его компоненты, для чего трёхбитовые поля байтов  $Mod~R/M$ и~$SIB$ проверяются на соответствие специальным значениям, а~затем уже рассматривается префикс $REX$ для определения номеров используемых регистров.
Таким образом, в~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} индексным не может быть ни один регистр, младшие три бита номера которого равны специальному значению $100$. Это  указатель стека $sp$ с~номером $0100$\index{Стек}
и~$r12$, обозначаемый номером $1100$.
% специальному значению $Index=100$ соответствует не только указатель стека $sp$ с~номером $0100$, но и~регистр $r12$, обозначаемый номером $1100$ (%при декодировании команды анализируется только поле  
% старший бит $1$ содержится в~префиксе $REX$, а~поле $Index$ байта $SIB$ равно специальному значению).
% Таким образом, в~шестидесятичетырёхбитном режиме регистры $sp$ и~$r12$ оба не могут быть индексными в~косвенной адресации операнда.

\subsubsection{Разрядность операндов в~регистрах и~памяти}


% General-Purpose Programming
% 3.1.2.1  Default Operand Size
% For most instructions, the default operand size in 64-bit mode is 32 bits . To access 16-bit operand sizes, an instruction must contain an operand-size prefix (66h), as described in Section 3.2.3, “Operand Sizes and Overrides,” on page 41. To access the full 64-bit operand size, most instructions must contain a $REX$ prefix. 
Для большинства команд в~шестидесятичетырёхбитном режиме размер операнда по умолчанию "--- 32 бита.
Разрядность операндов может быть понижена до 16 бит соответствующим префиксом или повышена до 64 префиксом $REX$ с~единичным третьим битом $REX.W$~\cite{amd64Application,intelInstructionSet}.
\index{0x66, префикс изменения размера операнда}%
\index{REX, префикс}%



% http://support.amd.com/TechDocs/24594.pdf
% In 64-bit mode, two groups of instructions default to 64-bit operand size without the need for a $REX$ prefix:
% • Near branches
%  —CALL, Jcc, JrCX, JMP, LOOP, and RET. 
% • All instructions, except far branches, that implicitly reference the RSP
% —CALL, ENTER, LEAVE, POP, PUSH, and RET (CALL and RET are in both groups of instructions).
\index{Команды!call}%
\index{Команды!ret}%
\index{Команды!push}%
\index{Команды!pop}%
% Кроме того, в
В~шестидесятичетырёхбитном режиме есть две группы команд, которые по умолчанию (без указания префикса $REX$) используют шестидесятичетырёхбитные операнды: 
% и~не требуют для этого :
это команды, работающие с~указателями (условные и~безусловные переходы) и~команды, неявно использующие указатель стека (по умолчанию это~$rsp$).\index{Стек}
Команды вызова и~возврата из функций относятся к~обеим группам, так что они по умолчанию используют шестидесятичетырёхбитные адреса и~шестидесятичетырёхбитный указатель стека~$rsp$.
% То есть 
% The 64-bit default operand size can be overridden to 16 bits using the 66h operand-size override. 
% However, it is not possible to override the operand size to 32 bits because there is no 32-bit operand-size override prefix for 64-bit mode. See “Operand-Size Override Prefix” on page 7 for details. 
\index{0x67, префикс изменения размера адреса}%
Разрядность  операндов этих команд может быть понижена с~64 бит до 16 указанием соответствующего префикса, но способа понизить её до 32 бит не существует~\cite{amd64Instructions}.

\subsubsection{Разрядность непосредственных операндов и~смещения}

Размер полей $Immediate$ (кроме команды пересылки непосредственного значения в~регистр) и~$Displacement$ в~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} не повышается до 64 бит даже при использовании префикса $REX$.

Таким образом, непосредственные операнды занимают 1, 2 или 4 байта. 
Если непосредственный операнд (обычно тридцатидвухбитный) присутствует в~шестидесятичетырёхбитной команде, он расширяется до 64 бит во время исполнения команды.
% Тридцатидвухбитные непосредственные операнды при 
Единственная команда, включающая непосредственный операнд размером 8 байт "--- команда пересылки непосредственного операнда в~регистр
% включающая префикс расширения ре
в~сочетании с~единичным $REX.W$ (что повышает разрядность регистра-приёмника до 64).
\index{REX, префикс}%
\index{Команды!mov}%
\index{Команды!movabs}%
В~документации Intel эта форма команды обозначается мнемоникой \lstinline!mov!, как и~другие варианты пересылки значения.
Синтаксис AT\&T выделяет форму с~шестидесятичетырёхбитным непосредственным операндом как мнемонику \lstinline!movabs!.

% Смещение в~косвенной адресации не может быть шестидесятичетырёхбитным.

\subsection{Адресация относительно указателя команды}

\epigraph{\begin{limerick}
Был персонистый старец из Фил,\\
Археолух и скрубиофил;\\
В вёдро влезет на древо \\
И глядит вправо-влево,\\
Озирая развалины Фил.\\
\end{limerick}
}
{\Lear}

В~тридцатидвухбитном режиме, как указано в~%\eqref{eq:command:baseonly-displacementonly}
таблице~\ref{tab:command:rm}, существует два способа прямой адресации (указания на фиксированный адрес $Displacement$ в~памяти): 
\begin{itemize}
\item без использования байта $SIB$, при $R/M = 101$;
\item с~использованием $SIB$ со специальными значениями как поля базы, так и~поля индекса, то есть при $R/M = 100, Base=101, Index = 100$.
\end{itemize}
Оба они доступны при $Mod=00$, так что адрес $Displacement$ тридцатидвухразряден.

В~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} к~фиксированному адресу %$Displacement$  
можно обратиться, только указав специальные значения байта $SIB$,
а~при $R/M = 101$ используется адресация относительно счётчика команд~$ip$ (в~шестидесятичетырёхбитном режиме "--- $rip$) \cite{amd64Instructions}:
\begin{equation}
\label{eq:command:baseonly-displacementonly-64}
\text{Адрес} = 
\left\{
\begin{array}{ll}
ip + Displacement, &R/M = 101 \\%(bp)\\
Displacement, & R/M = 100, Base=101, Index = 100\\
% 2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
% Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}
Таким образом, хотя шестидесятичетырёхбитный указатель команд $rip$ по-прежнему не является регистром общего назначения и~не имеет собственного номера,
он может быть базовым при $Mod=00$ без байта $SIB$.

Адресация относительно~$ip$ используется для решения двух задач:
\begin{itemize}
\item получение кода библиотек, работоспособность которого не зависит от адреса библиотеки в~памяти (в~тридцатидвухбитном режиме эта задача решалась либо вручную, либо корректировкой фиксированных адресов при загрузке~\cite{RE4B});

\item обращение к~переменным по произвольному шестидесятичетырёхразрядному адресу (поле смещения в~шестидесятичетырёхбитном режиме осталось тридцатидвухбитным~\cite{how-to-use-rip-relative-addressing-in-a-64-bit-assembly-program}, так что прямая адресация позволяет обратиться только к~адресам в~пределах младших четырёх гигабайт).
\end{itemize}




\addquestion{Какие вы знаете режимы работы процессора?}

\addquestion{Какие вы знаете сегменты памяти?}
\addquestion{Чем различается размещение в~памяти локальных, глобальных и~статических переменных?}

\addquestion{Какие вы знаете регистры общего назначения x86?}

% \item Какие регистры используются в~сопроцессоре для хранения операндов?
\addquestion{Какие регистры используются в~FPU для хранения вещественных данных?}

\addquestion{Какие вы знаете флаги?}
\addquestion{Какие методы адресации вы знаете?}


\printquestions
