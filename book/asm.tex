
% \chapter{Уровень архитектуры команд линейки x86}
% \epigraph{
% ЭТО не работает на восьмиразрядных машинах.
% }{\ProgFolk}
% 


\chapter{Программирование на языке ассемблера}
\label{sec:asm}

% \epigraph{\begin{stanza}Ты с~умом и~со свечкой к~нему подступай,\\
%     С~упованьем и~крепкой дубиной,\\
%  Понижением акций ему угрожай\\
%   И~пленяй процветанья картиной...\end{stanza}
% }
% {\Snark}
\epigraph{\begin{limerick}
Удалой старичок из Салоников\\
Очень прыгать любил с~подоконников.\\
На вопрос: «Не опасно?»\\
Говорил он: «Прекрасно! "---\\
В~этом прелесть прыжков с~подоконников».
\end{limerick}
}
{\Lear}

% Для архитектуры x86 разработано множество трансляторов ассемблера, каждый из которых описывает свой язык.

Данное пособие описывает программирование на языке GNU Assembler (GAS) для архитектуры x86
с~использование

Если не указано иное,
примеры соответствуют тридцатидвухбитной платформе.
Вызовы функций описываются в~соответствии с~тридцатидвухбитным соглашением cdecl и~без учёта искажения имён (см. раздел~\ref{sec:calling-functions}).

\section{Особенности GNU Assembler}
\epigraph{\begin{stanza}
А~тот, кто сторожит баржу, спесив \\
И~вообще не святой;\\
Но тот, кто сторожит баржу, красив \\
Неземной красотой.\\
\end{stanza}}
{\Aquarium}

G%NU Assembler
AS, как и~его предок, ассемблер Unix as,
% Ассемблер Unix as (его версия из коллекции GCC назывется gas) 
использует так называемый синтаксис AT\&T System V/386, часто называемый просто синтаксисом AT\&T или синтаксисом GAS~\cite{Assembler-fsf}.

Также для процессоров семейства Intel x86 часто используется  синтаксис, предложенный фирмой Intel.
Основными отличиями синтаксиса Intel от  AT\&T считаются обратный порядок операндов, другие обозначения адресации  и~невозможность явного указания разрядности операции.
Менее известно различие в~мнемонических обозначениях команд.
Современные версии ассемблера GAS  поддерживают оба варианта синтаксиса.

Основными недостатками синтаксиса Intel является неоднозначность и~трудность чтения инструкций.
Кроме того, синтаксис Intel используется только для процессоров Intel или совместимых с~ними.

Синтаксис AT\&T иногда называется кроссплатформенным, так как GCC и, соответственно, GAS  реализован для множества различных архитектур.
Полной кроссплатформенности при использовании языка ассемблера достичь невозможно, 
так как у~каждой платформы свой набор %команд и~регистров, % и~особенностей,
команд, регистров и~методов адресации,
но использование %универсального синтаксиса облегчает %\чтение программ
схожего синтаксиса
переход между ними.

Также инструкции, записанные в~соответствии с~синтаксисом AT\&T, легче читаются (кроме косвенной адресации).


% \footnote{Использованы материалы:
% GCC-Inline-Assembly-HOWTO, << ссылка в~inline
% Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А. << ниже
% Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
% X86 Assembly/GAS Syntax << вики
% }

\subsection{Общие правила}
% \epigraph{\begin{stanza}
% Держали камни в ладонях:\\
% Яшму и оникс; хрусталь, чтобы лучше видеть.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}
 Итак, попался. А теперь что делать?
\end{stanza}}
{О.\,Арефьева}

Так как GAS в~основном используется на одном из этапов компиляции программы на %языке высокого уровня, о 
C/C++, 
многие синтаксические конструкции GAS и~C/C++ совпадают.

В~программе могут использоваться латинские буквы, цифры, %символы \lstinline!%, $, *, ., —!
а~также нижнее подчёркивание и~точка.
% 
Допустимые пробельные символы "--- пробел и~табуляция;
они могут сочетаться в~любом порядке.
Перевод строки является разделителем операторов.

Допускаются многострочные комментарии  /* в~стиле C */
и~однострочные // в~стиле C++.
% Также поддерживается устаревший 
% #<не выражение> устаревший
Также для различных платформ поддерживаются платформоспецифичные виды однострочных комментариев.

Оператор ассемблера целиком размещается на одной строке.
В~начале строки может быть одна или несколько меток, заканчивающихся двоеточием.
% Перед оператором может быть метка.
Если первый символ оператора "--- точка, то это "--- директива ассемблера (первая строка листинга~\ref{lst:asm:directive:instruction}).
Набор директив в~основном совпадает для всех архитектур.
\begin{lstlisting}[caption=Директива и~команда, label=lst:asm:directive:instruction]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}
Пустой оператор может состоять только из пробельных символом или быть пустой строкой (вторая строка).
Оператор, начинающийся с~буквы, представляет собой мнемоническое обозначение машинной команды,
за которым при необходимости следуют операнды, разделённые запятыми (третья строка листинга~\ref{lst:asm:directive:instruction}).
% Оператор оканчивается переводом строки или точкой с~запятой.

Строковые литералы ограничиваются двойными кавычками, экранирующим символом является обратный слеш «\textbackslash»,
спецсимволы кодируются аналогично C/C++.
Числовые литералы также описываются аналогично C/C++.





\subsection{Основные директивы}
% \epigraph{\begin{stanza}
% Что нам подвластно? Гранитные поля,\\
% Птицы из пепла, шары из хрусталя.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}
Не танцевать же мы на танцы ходим!
% Так слово за слово "--- и выучишься мату.
\end{stanza}}
{О.\,Арефьева}
Директива ассемблера не соответствует никакой машинной команде.
Рассмотрим несколько наиболее употребительных директив; их можно разбить на несколько классов.

\subsubsection{Директивы определения сегмента}

Как было описано в~разделе~\ref{sec:mem-segments}, код программы и~различные виды данных должны располагаться в~различных диапазонах адресного пространства.
По историческим причинам эти диапазоны называются сегментами (соответствующие фрагменты исходного кода "--- секциями).
Начало содержимого того или иного сегмента в~исходном ассемблерном коде отмечается специальными директивами.

С~начала файла до первой директивы располагается сегмент кода.
Указать продолжение сегмента кода можно директивой \termin{.text}.

Сегмент данных открывается директивой \termin{.data}.
В~принципе, описание статических данных в~сегменте кода не вызовет ошибки, но такие данные будет невозможно модифицировать, так как сегмент кода защищён от изменений.
% 
% Те глобальные и~статические переменные, которые не были инициализированы при объявлении,
% отделяются  в~специальный \termin{сегмент BSS.}
% % \termin{.bss}

Для сегментов стека и~кучи нет соответствующих секций, они заполняются динамически в~процессе выполнения программы.

\subsubsection{Директивы определения данных}

В~сегменте \termin{.data} статические данные описываются также с~помощью  директив.

После директивы определения данных указывается литерал подходящего типа или несколько литералов, перечисленных через запятую.
В~памяти соответственно  резервируется одна или несколько ячеек соответствующего размера, которые инициализируются указанными значениями.

Для того, чтобы дать адресу ячейки имя, перед соответствующим определением необходимо поставить метку
(листинг~\ref{lst:asm:directive:data}).
\begin{lstlisting}[caption=Определение статических данных, label=lst:asm:directive:data]
foo: .long 0, 1, 2
bar: .double -8.7
\end{lstlisting}
Важно помнить, что ассемблер, в~отличие от языков высокого уровня, не является типизированным.
Таким образом, если, в~частности, 
по адресу $bar$ расположено  восьмибайтовое значение двойной точности~$-8.7$,
а~программист обратится к~нему как к~числу одинарной точности (четыре байта), это не вызовет ошибки, но прочитанное значение будет другим.

Для инициализации памяти целыми значениями различного размера используются следующие директивы:
\termin{.byte} %одно или несколько выражений, разделённых запятыми
"--- однобайтовое (восьмибитное) целое,
\termin{.short}
% \termin{.short .half }
"--- %двухбайтовое,
шестнадцатибитное,
% \termin{.int (.long)}
% "--- четырёхбайтовое,
\termin{.long} 
"--- тридцатидвухбитное,
\termin{.quad}
"--- шестидесятичетырёхбитное. %восьмибайтовое 
Размер и~порядок байтов определяются платформой;  приведены размеры для x86 (они же наиболее распространённые).
Также существуют директивы  \termin{.word} и~\termin{.int}, для x86 %эквивалентные .short и~.long 
определяющие шестнадцати- и~тридцатидвухбитные целые
соответственно.
%  H8/500. However, on this platform the `.int' and `.word' directives generate 16-bit numbers.
% On the Sparc, the .word directive produces 32 bit values, instead of the 16 bit values it produces on many other machines. 
 
Значения с~плавающей запятой одинарной (32 бита) и~двойной (64 бита) точности описываются директивами
\termin{.float
(.single)}
и~\termin{.double}. %одно или несколько вещественных значений, разделённых запятыми

Для инициализации памяти строковыми константами различного вида используются следующие директивы.
Функции стандартной библиотеки C используют строки, завершающиеся нулём; 
их можно описать директивой
\termin{.string (.asciz)} (листинг~\ref{lst:asm:directive:asciz}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки, завершающейся нулём}, label=lst:asm:directive:asciz]
msg: .string "Hello, world!\n"
\end{lstlisting}
Если после директивы указывается несколько строковых литералов через запятую, завершающий ноль добавляется после каждого.

Строка без завершающего нуля
 описывается директивой
\termin{.ascii} (листинг~\ref{lst:asm:directive:ascii}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки без завершающего нуля}, label=lst:asm:directive:ascii]
msg:
.ascii "Hello, world!\n"
len = . - msg // символу len присваивается длина строки
\end{lstlisting}
Для обработки подобных строк нужно знать их длину (её нельзя определить, анализируя содержимое памяти%, так как строка 
).
Для этого используется специальный символ «.» "--- адрес текущего оператора (в~том числе ячейки с~данными).
% Строки без завершающего нуля используются, в~частности

Директивы определения данных точно так же сработают и~будучи размещёнными в~сегменте кода (.text или неименованная секция в~начале программы),
но такое размещение будет ошибкой.
Если данные попадут во фрагмент кода, который выполняется, они будут интерпретированы как команды, что, скорее всего, приведёт к~сбою при декорировании.
Даже если данные находятся в~той части кода, которая не получает управления, их будет невозможно модифицировать.

\subsubsection{Прочие}

Парные директивы
\termin{.rept $\ldots$ .endr} соответствуют повторению фрагмента между ними,
в~частности
\begin{lstlisting}
.rept 4   
.long 0   
.endr     
\end{lstlisting}
интерпретируется как четырёхкратное повторение оператора \lstinline!.long 0!:
\begin{lstlisting}
.long 0
.long 0
.long 0
.long 0
\end{lstlisting}
Директивы .rept $\ldots$ .endr могут применяться и~к~командам. 
При этом происходит именно многократное дублирование  фрагмента кода в~исполняемом файле, а~не циклическое повторение одной и~той же его копии.

\termin{.globl (.global)}
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает символ  доступным из других модулей.
\begin{lstlisting}
.globl main
\end{lstlisting}

Парные директивы
\termin{.func  $\ldots$  .endfunc} включают в~исполняемый файл отладочную информацию о~функции (только при сборке в~отладочном режиме).


\subsection{Порядок операндов}
\epigraph{\begin{stanza}
    Он, пол сменив, сменил и потолок!
\end{stanza}}
{О.\,Арефьева}
\addquestion{Какой порядок операндов принят в~синтаксисе AT\&T?}


В~GAS принят порядок записи операндов слева направо, следуя европейскому направлению письма.
% В~отличие от синтаксиса Intel, 
Соответственно, инструкция GAS обычно имеет вид  
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.

Для команд с~тремя операндами (один из них в~x86 "--- всегда непосредственное значение) вначале записывается непосредственное значение, затем источник, затем приёмник.
\begin{lstlisting}
mnemonic immediate, source, destination
\end{lstlisting} 

Если среди операндов нет приёмника (в~частности, команды %bound, invlpga и~команды 
с~двумя непосредственными операндами, такие как enter), 
порядок в~AT\&T совпадает с~порядком, указанным в~документации Intel~\cite{Assembler-fsf}.
%  AT&T and Intel syntax use the opposite order for source and destination operands. Intel ‘add eax, 4’ is ‘addl $4, %eax’. The ‘source, dest’ convention is maintained for compatibility with previous Unix assemblers. Note that ‘bound’, ‘invlpga’, and instructions with 2 immediate operands, such as the ‘enter’ instruction, do not have reversed order. i386-Bugs. 
 
В~частности, рассмотрим одну из наиболее употребительных мнемоник ассемблера "--- команду пересылки (копирования) \lstinline!mov!.
Она соответствует оператору присваивания языков высокого уровня.
Её операнды "--- источник и~приёмник.
В~синтаксисе Intel пересылка $dst = src$ имела бы вид \lstinline!mov dst, src!; в~используемом в~данном пособии синтаксисе AT\&T она имеет вид \lstinline!mov src, dst!.
% 
Например, команда \lstinline!movb $0x05, %al! помещает значение~5 в~регистр~$al$.

\subsection{Адресация операндов}
% \epigraph{
% %      - Хорошо, - сказал я. - Я~тоже задам  последовательность  вопросов  о
% % местоположении.
% %      - Задавай, задавай, - пробормотал Чапаев.
% %      - Начнем по порядку. 
% "--* Вот вы расчёсываете лошадь. А~где находится  эта лошадь?
% %      Чапаев посмотрел на меня с~изумлением.
% %      - Ты что, Петька, совсем охренел?
% %      - Прошу прощения?
% 
%       "--* Вот она.
% }{В.\,Пелевин}

\epigraph{

"--* Где, "--- спрашивает, "--- ты живёшь?

"--* Ступай, "--- говорит, "--- прямо, повороти направо. Тут будет пень большой. Ты разбегись да треснись башкой. Как искры из глаз посыплются "--- тут меня и~увидишь...
}{П.\,Бажов}



\index{Адресация!виды}
\label{sec:addressing}


Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
В~разделе~\ref{sec:addressing:common} были описаны различные виды адресации.
% Каждому из них соответствует об
Рассмотрим обозначения, принятые в~GAS для методов адресации явно передаваемых параметров команд x86.

% % Данные могут адресоваться различными способами.
% Для %них 
% явно передаваемых параметров
% доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная}\index{Адресация!непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).

Непосредственные операнды отмечаются префиксом~\lstinline!$!.
% 
Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая}\index{Адресация!прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды.

Операнды, описываемые статическим адресом в~памяти, не имеют префикса.
% 
Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n!~(значение глобальной переменной $n$).

\item \termin{Регистровая}\index{Адресация!регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;

Операнды в~регистрах отмечаются префиксом~\lstinline!%!.
% 
Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!.

\item \termin{Косвенно-регистровая (косвенная)}\index{Адресация!косвенная} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).


%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров.

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}


В~языке ассемблера x86 конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
\begin{equation}
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% *\big({Base} + scalar\,multiplier \cdot {Index} + Displacement\big)
*\big({base} + scalar\,multiplier \cdot {index} + displacement\big)
\end{equation}
где $base$ и~$index$ "--- регистры (32-разрядные для соответствующей платформы), $displacement$ "--- целое число (смещение), $scalar\,multiplier$ "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется $scalar\,multiplier = 1$, вместо остальных пропущенных параметров  используется~$0$).

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS имеет вид
\begin{lstlisting}
displacement(base, index, scalar multiplier)
\end{lstlisting} 
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
Таким образом, прямая адресация в~принципе может рассматриваться как частный случай косвенной,
когда  оба регистра и~масштабный коэффициент опущены вместе со скобками.

}

Например, следующая команда использует все четыре параметра и~загружает 
% в~$a$ значение  $*\big(bp - 4 + (d \cdot 4)\big)$
в~$A$ значение  $*\big(bp+ D \cdot 4 - 4 \big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dst! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}
movl  -4(%ebp, %edx, 4), %eax	// eax = *(ebp + 4edx - 4)
\end{lstlisting} 
Чаще используются сокращённые варианты адресации, когда указывается только часть параметров.

Если используется только параметр~$base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает %значение $*C$ 
четырёхбайтовое значение по адресу~$C$
в~регистр $D$.
\begin{lstlisting}
movl  (%ecx), %edx	// edx = *ecx
\end{lstlisting} 

С~параметрами~$base$ и~$displacement$ получим $*\big(base + displacement\big)$, что соответствует обращению к~полю структуры ($base$ "--- адрес структуры, константа~$displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса $bp - 4$)
в~регистр $A$.
\begin{lstlisting}
movl  -4(%ebp), %eax	// eax = *(ebp - 4)
\end{lstlisting} 
При передаче параметров функции через стек обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека~$sp$.
% 
На вершине стека, то есть по адресу $*sp =$\lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

 

При использовании всех параметров, кроме $displacement$, получим $*\big(base + scalar\,multiplier \cdot {index}\big)$, что соответствует обращению к~элементу массива.
Действительно, адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
он может быть масштабным коэффициентом ($scalar\,multiplier$)
и~к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(base + index \cdot scalar\,multiplier\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! %обычно 
равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~$C$, а~индекс "--- в~$si$, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Соответственно, запись~$M[i]$ в~регистр~$A$ будет выглядеть следующим образом:
\begin{lstlisting}
movl (%ecx, %esi, 4), %eax  // eax = *(ecx + 4esi) = C[si]
\end{lstlisting} 


% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 


\subsection{Размер операндов команды}
\epigraph{\begin{stanza}
    Из вредности на красный свет не ходит!
\end{stanza}}
{О.\,Арефьева}

Большая часть мнемоник соответствует не одной команде уровня архитектуры команд, а~целому семейству однотипных команд, которые выполняют одни и~те же действия над операндами различных размеров и, соответственно, имеют разные коды.

Размер операндов маркируется суффиксом,
добавляемым к~базовой форме мнемоники;
например,
копирование  (базовая форма команды "--- $mov$) из~$edx$ в~$eax$ (размер операндов $long$) записывается как
\lstinline!movl %edx, %eax!.
Суффиксы перечислены в~таблице~\ref{tab:asm-suffixes}.

\begin{table}[!ht]
\caption{Суффиксы размера операндов}
\label{tab:asm-suffixes}

\noindent\begin{tabularx}{\linewidth}{|c|L|L|}
\hline
\thead{Суффикс} & \thead{Целые} & \thead{Вещественные} \\\hline
    b & byte (8  бит) &\\\hline
    s & short (16  бит) & single (32 бит) \\\hline
    w & word (16  бит) &\\\hline
    l & long (32  бит) & double (64 бит) \\\hline
    q & quad (64  бит) &\\\hline
    t & & ten bytes (80 бит) \\\hline
%     o & octuple (128 бит)&\\\hline
\end{tabularx}
\end{table}
Необходимо отметить, что для целочисленных команд и~команд обработки вещественных чисел одни  и~те же суффиксы означают различную разрядность.
Некоторые суффиксы допустимы только для одного семейства команд.
Для целочисленных команд суффиксы~\lstinline!s! и~\lstinline!w! обозначают 16-битное целое и~в~целом  равноправны
(для команды \lstinline!mov! используется только~\lstinline!w!, так как существует другая команда с~базовой формой \lstinline!movs!).

У~команд с~операндами разных размеров указывается два суффикса.
Порядок суффиксов, как и~порядок операндов "--- слева направо (от источника к~приёмнику).
Так, копирование целого числа со знаковым расширением (базовая форма команды "--- $movs$) из~$al$ в~$edx$ выглядит как
\lstinline!movsbl %al, %edx!.
% в синтаксисе AT&T означает "расширить знак от %al к %edx". Таким образом возможны суффиксы `bl' (от byte к long), `bw' (от byte к word) и `wl' (от word к long). 
% http://www.opennet.ru/docs/RUS/gas/gas-8.html
Возможны двойные суффиксы \lstinline'bl' (от $byte$ к~$long$), \lstinline'bw' (от $byte$ к~$word$) и~\lstinline'wl' (от $word$ к~$long$) и~так далее.
Суффикс~\lstinline!s! не используется как компонент составного суффикса.

% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  %размер может быть определён по регистровому операнду.
GAS определяет размер по  регистровому операнду.
% Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
Это несовместимо с~оригинальным ассемблером AT\&T Unix, который предполагает, что отсутствие суффикса означает размер операнда $long$ (не влияет на компиляцию с~ЯВУ, так как компиляторы всегда выставляют суффиксы размера)~\cite{Assembler-fsf}.

Если размер не удалось определить по операндам (то есть используются непосредственные и~в~памяти),
по умолчанию принимается размер $long$ (32 бита).
% Отсутствие суффикса чаще всего не вызывает ошибки компиляции,
Такая ситуация не всегда вызывает ошибку компиляции,
но %в~некоторых случаях (
при обработке чисел с~плавающей запятой, находящихся в~памяти, приводит к~странному результату, так как по умолчанию используется операнд одинарной точности.


\subsection{Мнемоники}
\epigraph{\begin{stanza}
    Нет, я людей практически не ем...
\end{stanza}}
{О.\,Арефьева}

Первоначальные мнемонические обозначений команд процессора предлагаются
% предложена 
его разработчиками в~документации, описывающей набор команд.
В~дальнейшем ассемблеры в~основном используют именно их.
Большая часть мнемоник GAS (их базовые формы) также совпадает с~документацией Intel.

Тем не менее, часть обозначений различается.
В~частности, отличаются базовые формы команд копирования со знаковым расширением ($movs$ в~GAS, $movsx$ в~Intel)
и~копирования с~беззнаковым расширением  ($movz$ в~GAS, $movzx$ в~Intel).

% Кроме того, 
Синтаксис AT\&T предлагает для команд расширения (их неявным аргументом всегда является регистр~$A$) обозначения, построенные по схеме $cStD$ (convert $S$ to $D$), 
где $S$ "--- суффикс размера источника, $D$ "---  суффикс размера или обозначение расположения (в~случае расширения в~пару регистров) приёмника.
В~документации Intel приведены другие обозначения: они построены по схеме $cSD$ или $cSDe$ и~используют другие обозначения размера (раздел~\ref{sec:asm-conversion-A}).
% https://sourceware.org/binutils/docs/as/i386_002dMnemonics.html
% The Intel-syntax conversion instructions
% 
%  ‘cbtw’   ‘cbw’ — sign-extend byte in ‘%al’ to word in ‘%ax’,
%  ‘cwtl’   ‘cwde’ — sign-extend word in ‘%ax’ to long in ‘%eax’,
%  ‘cwtd’   ‘cwd’ — sign-extend word in ‘%ax’ to long in ‘%dx:%ax’,
%  ‘cltd’   ‘cdq’ — sign-extend dword in ‘%eax’ to quad in ‘%edx:%eax’,
%  ‘cltq’   ‘cdqe’ — sign-extend dword in ‘%eax’ to quad in ‘%rax’ (x86-64 only),
%  ‘cqto’   ‘cqo’ — sign-extend quad in ‘%rax’ to octuple in ‘%rdx:%rax’ (x86-64 only), 
% 
% are called ‘cbtw’, ‘cwtl’, ‘cwtd’, ‘cltd’, ‘cltq’, and ‘cqto’ in AT&T naming. as accepts either naming for these instructions. 
GAS поддерживает как вариант AT\&T, так и~вариант Intel.

Для несимметричных арифметических команд обработки чисел с~плавающей точкой (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
GAS использует те же мнемоники, что и~Intel, но при этом реализует качественно иное поведение %(подробнее в~разделе).
(раздел~\ref{sec:fpu-trouble-with-fsub}).

\subsection{Префиксы}
\epigraph{\begin{stanza}
%     Чудесны рифмы в Ваших одностишьях…
        Инструкция к ёлке: «товар несъедобен».
\end{stanza}}
{О.\,Арефьева}

Как уже было сказано, регистры и~непосредственные операнды обозначаются специальными префиксами.
Для ассемблера x86 имена {регистров} начинаются с~\lstinline!%!,
% (\lstinline!%eax!, \lstinline!%dl!);
% 
а~непосредственные значения (константы) отмечаются префиксом \lstinline!$!.
% , например,
% \lstinline!addl $5, %eax!
% (добавить константу 5 к~регистру $A$).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных. Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Префикс непосредственного операнда~\lstinline!$! указывается перед префиксом системы счисления (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!).

% Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

% \index{Адресация!непосредственная}
% \index{Адресация!прямая}
% Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
% \lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
% команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

% \paragraph{Вычисление адреса}
% 
% Вычисление адреса с~одновременным разыменованием
% $$
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% $$
% в~соответствии с~синтаксисом~AT\&T имеет вид
% {
% \lstset{language=}
% % There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
% \begin{lstlisting}
% displacement(base, offset, scalar multiplier)
% \end{lstlisting} 
% 
% где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% % в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% % где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% 
% В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% % \lstinline![base + displacement + offset * scalar multiplier]!.
% \begin{lstlisting}
% [base + displacement + offset * scalar multiplier]
% \end{lstlisting} 



% \subsection{Сравнение синтаксиса AT\&T и~Intel}
% \epigraph{\begin{stanza}
%     Ой, не тому угрозы ты отправил!
% \end{stanza}}
% {О.\,Арефьева}
% 
% % Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% % % 
% % % Синтаксис AT&T немного 
% % отличается от синтаксиса Intel, который используется, например, MASM. 
% % %
% % Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.
% 
% \cite{linux_parallel,}
% 
% % Рассмотрим 
% Сравним 
% \termin{AT\&T}
% 
% \begin{lstlisting}[numbers=none]
% movl $42, %eax
% 
% movl $0x10, %ebx
% 
% 
% lea  -0x30(%rcx,%rax,8), %eax
% movl (%ebx), %eax
% 
% movl $0xCCCCCCCC, %ecx
% 
% 
% movl 0xCCCCCCCC, %ecx
% \end{lstlisting}
% 
% 
% % -4(%ebp), Intel:  [ebp - 4]
% {} \termin{Intel}
% 
% \begin{lstlisting}[numbers=none]
% mov eax, 42
% 
% mov ebx, 10h
% mov ebx, 0x10 ; masm
% 
% lea eax, [rcx+rax*8-0x30]
% mov eax, dword ptr [ebx]
% 
% mov ecx, 0xCCCCCCCC   
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; masm}@*/
% mov ecx, ds:[0xCCCCCCCC]
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; nasm}@*/
% \end{lstlisting}



\section{Структура программы на ассемблере}
\epigraph{\begin{stanza}Так скажем «Банзай», и~Бог с~ней, с~твердью;\\
Все, что прошло "--- сдадим в~утиль.\\
А~здесь у~нас в~центре циклона "---\\
Снежные львы и~полный штиль.\\
\end{stanza}}
{\Aquarium}

% Исполняемый файл обязательно содержит

Программа обязательно должна включать точку входа "--- адрес, с~которого начинается её выполнение.
По умолчанию %компоновщик
линкер GCC ищет точку входа по имени  $\_start$.
% (здесь нижнее подчёркивание "--- часть имени без учёта искажения имён компилятором). 
Для программ на C/C++ по адресу $\_start$ находится стартовый код библиотеки stdlib, который, в~частности, инициализирует все используемые библиотекой ресурсы и~вызывает так называемую головную функцию $main()$.
После этого  программа выполняется по определённому алгоритму (в~частности, с~помощью цикла обработки сообщений можно реализовать событийно-ориентированную модель)
и~при определённых обстоятельствах должна корректно завершать  свою работу.
\index{main()}

Минимальная программа 
% включает точку входа (многие библиотеки определяют стартовую функцию, которая )
запускается
и~немедленно завершает  работу.
% Соответственно
Также в~учебных целях часто описывается программа, выводящая на экран приветствие «Hello, world!».

\subsection{Программирование с~использованием stdlib}


\epigraph{\begin{limerick}
    Жила-была дама приятная,\\
    На вид совершенно квадратная.\\
    Кто бы с ней ни встречался,\\
    От души восхищался:\\
    «До чего эта дама приятная!»
\end{limerick}
}
{\Lear}

По умолчанию в~GCC программа (как на языке C/C++, так и~на языке ассемблера) собирается с~поддержкой стандартной библиотеки stdlib.
Соответственно, стартовой (главной) функцией программы является $int~main(int~argc,$ $char~*argv[])$.
%  $int~main(int, char *[])$

% \section{Точка входа на ассемблере и~использование stdlib}

% Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.
Стартовая функция $main()$ может находиться как в~модуле на языке C/C++, так и~в~ассемблерном модуле.

\subsubsection{Минимальная программа с~использованием stdlib}

% Минимальная программа 
Приведём код минимальной программы на ассемблере GAS
с~использованием стандартной библиотеки stdlib: 
\begin{lstlisting}[caption=Минимальная программа (stdlib), label=lst:asm:minmain]
.globl main // точка входа (stdlib)
main:
     xor %eax, %eax // A ^= A, то есть A = 0
     ret // return A
\end{lstlisting}
Команда ret, в~отличие от оператора return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах (раздел~\ref{sec:calling-functions}) всегда подразумевается в~регистре~$A$.
Для тридцатидвухбитного кода это \lstinline!%eax!, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр \lstinline!%eax!.
В~данном случае это делается при помощи побитового исключающего «или».
Эта команда компактнее %\lstinline!!
явного копирования нуля в~регистр и~выполняется быстрее.

Параметры $argc$ и~$argv$ располагаются в~соответствии с~используемом соглашением о~вызове,
то есть находятся в~стеке для тридцатидвухбитных систем и~в~регистрах для шестидесятичетырёхбитных.

Эквивалент данной программы на С++  выглядит следующим образом:
\begin{lstlisting}
int main()
{
    return 0;
}
\end{lstlisting}

\subsubsection{Приветствие миру}



Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции \lstinline!printf! библиотеки stdlib
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие (C++)}, label=lst:asmmain:printf-cpp]
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на тридцатидвухбитном ассемблере выглядит следующим образом:
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие}, label=lst:asmmain:printf-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    xor %eax, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются (но в~некоторых версиях Microsoft Windows могут дополняться префиксом, как описано в~разделе~\ref{sec:mangling}). 

Параметры функции \lstinline!printf! в~соответствии с~соглашением cdecl передаются через стек (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).
Так как нам не нужно извлечённое из стека значение, команду \lstinline!popl %eax! можно заменить изменением значения указателя стека~\lstinline!addl $4, %esp!.
Эта команда быстрее и~к~тому же не требует приёмника для сохранения неиспользуемого %вычищаемого из стека 
значения.

Так как для вывода приветствия не используются возможности форматированного вывода, вместо  $printf()$ можно использовать более простую функцию~$puts()$:
\begin{lstlisting}
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call puts
    addl $4, %esp	// Вычищаем параметр из стека
    xor %eax, %eax
    ret
\end{lstlisting}



\subsubsection{Форматированный вывод}

Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}[caption={Программа, выводящая на экран два числа (C++)}, label=lst:asmmain:printf-cpp-params]
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению cdecl эти параметры передаются в~обратном порядке (то есть на вершине стека оказывается первый):
\begin{lstlisting}[caption={Программа, выводящая на экран два числа}, label=lst:asmmain:printf-asm-params]
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  xor %eax, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~$sp$, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности,~$A$) меняется (раздел~\ref{sec:calling-conventions}).
% Список регистров, которые могут изменяться подпрограммой, подробнее рассмотрен в~разделе~\ref
Если в~таких регистрах хранятся данные вызывающей программы, их надо сохранить перед вызовом функции.




\subsection{Программирование без stdlib}
\epigraph{\begin{limerick}
Старичок так следил за осанкой,\\
что питался лишь только овсянкой.\\
Но однажды съел лишку,\\
положив в~неё мышку,\\
И~серьёзно испортил осанку.\\
\end{limerick}
}
{\Lear}

Минимальная программа с~stdlib (листинг~\ref{lst:asm:minmain}) после ассемблирования занимает 4704 байт.
% % [caption=min.S]
% \begin{lstlisting}
% .globl main // точка входа (stdlib)
% main:
%      xorl %eax,%eax // EAX ^= EAX, то есть EAX = 0
%      ret // return EAX
% \end{lstlisting}
% % Сборка (полученный файл включает stdlib и~занимает %4.6 Кб "--- 
% % 4704 байт)
% % \begin{lstlisting}[language=Bash]
% % $ gcc -o min min.S
% % \end{lstlisting}
% % Сборка с~stdlib: 
% \lstinline!gcc -o min min.S!
В~этот размер входят библиотечные функции, обеспечивающие обработку параметров, вызов стартовой функции~$main()$
и~завершение программы после возврата управления из $main()$.

Отключить использование stdlib при сборке позволяет ключ~\lstinline!-nostdlib!.
В~этом случае взаимодействие с~операционной системой, в~том числе завершение программы, необходимо осуществлять с~помощью системных вызовов.

Точкой входа в~этом случае будет непосредственно метка $\_start$.
% После неё можно вручную вызвать $main()$ и~обработать возвращаемое ей значение.

Каждая операционная система имеет свой набор %системных вызовов
функций
и~свой способ их вызова.
В~большинстве операционных системные вызовы осуществляются с~помощью программных прерываний.
При этом, если в~GNU/Linux, BSD и~FreeDOS системные вызовы хорошо документированы,
в~Microsoft Windows как механизм их вызова, так и~набор функций постоянно меняются и~не документированы.
Вместо прямых системных вызовов под Microsoft Windows предлагается использовать функции библиотеки Windows API.
% Сборка без stdlib (полученный файл занимает 600 байт)
% \begin{lstlisting}[language=Bash]
% $ gcc -o nsmin  nsmin.S  -nostdlib
% \end{lstlisting}

В~GNU/Linux к~функциям операционной системы можно обратиться с~помощью прерывания \hex{0x80}.
% int 0x80, \lstinline!%eax! "--- номер функции
Номер функции указывается в~регистре~$A$.
% до 6 аргументов: \lstinline!%ebx!, \lstinline!%ecx!, \lstinline!%edx!, \lstinline!%esi!, \lstinline!%edi! и~\lstinline!%ebp!
Вызов может принимать до шести аргументов в~регистрах $B, C, D, si, di, bp$.
Если требуется передать семь значений или больше, они объединяются в~структуру, адрес которой передаётся в~$B$.


\subsubsection{Минимальная программа без stdlib}

Рассмотрим
минимальную программу, не использующую функции stdlib (в~том числе $main()$) для GNU/Linux. % (600 байт)
Сразу после запуска она должна завершиться с~кодом~0.
Для завершения программы используется системный вызов с~кодом~1 "--- $sys\_exit()$.
Её единственный параметр "--- код возврата.
\begin{lstlisting}[caption=Минимальная программа без stdlib, label=lst:asm:minstart]
.globl _start
_start: // точка входа 
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}
% Сборка без~stdlib: 
% \lstinline!gcc -o min min.S -nostdlib!
Если код \ref{lst:asm:minstart} сохранён как файл~\lstinline!nsmin.S!,
собрать его без стандартной библиотеки можно командой:
\begin{lstlisting}[language=Bash]
$ gcc -o nsmin  nsmin.S  -nostdlib
\end{lstlisting}
полученный исполняемый файл %не  включает stdlib и~
занимает 600 байт.

% Эквивалент на С++
% \begin{lstlisting}
% int main(int argc, char* argv[]){
%     return 0;
% }
% \end{lstlisting}

\subsubsection{Приветствие миру}


Для вывода строки на экран в~GNU/Linux используется системный вызов с~кодом~4 "--- $sys\_write()$.
Он предназначен для записи в~файл;
требует трёх параметров "--- дескриптор файла, указатель на начало записываемых данных и~длина этих данных в~байтах.
Согласно концепции Unix всё есть файл;
для вывода на экран используется специальный дескриптор 1 ($stdout$).



\begin{lstlisting}
.data
    msg:
    .ascii "Hello, world!\n"
    len = . - msg // символу len присваивается длина строки
.global _start // точка входа в программу
_start:
    movl $4, %eax // системный вызов №4 — sys_write
    movl $1, %ebx // поток №1 — stdout
    movl $msg, %ecx // указатель на выводимую строку
    movl $len, %edx // длина строки
    int $0x80 // вызов ядра
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}






\section{Основные команды}
\epigraph{\begin{limerick}
Жил один старичок из Марокко,\\
Погрязший в пучине порока.\\
Он отплясывал джигу\\
И~показывал фигу,\\
Возмущая сограждан в~Марокко.\\
\end{limerick}
}
{\Lear}

Основной набор команд x86 включает команды обработки целых чисел и~разнообразные команды управления вычислениями.

Структура команды такова, что
если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что src и~dest могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.


\subsection{Общие команды}
\label{sec:asm-commandsintro}
\epigraph{
\begin{stanza}[0mm]
I like to move it, move it,\\
She like to move it, move it,\\
We like to move it, move it,\\
We like to move it!\\
\end{stanza}
}{Reel 2 Real}

В~таблице приведены некоторые наиболее употребительные команды x86-совместимых процессоров.%
\index{Команды!пересылки}%

\begin{table}[!ht]
\caption{Основные общие команды}
\label{tab:asm-common-list}
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-common.tex}

\end{table}

Наверное, самой популярной командой является команда пересылки (move)
% \lstinline!mov источник, приёмник! 
% "--- присваивание \lstinline!приёмник = источник!
\lstinline!mov src, dest! "--- аналог оператора присваивания $dest := src$ языков высокого уровня.
Рассмотрим некоторые примеры её работы:
\begin{lstlisting}[numbers=none]
movl $4, %eax	// eax = 4
movb $42, %al	// al = 42
movl %eax, (%esi)	// *esi = eax
movl %eax, 4(%esi)	// *(esi+4 байта) = eax
movl $some_var, %eax	// eax = &some_var
movl $some_var+4, %eax	// eax = &some_var+4 байта
movl some_var, %eax	// eax = some_var
movl %eax, foo	// foo = eax
\end{lstlisting}

Аналогом оператора получения адреса является команда \lstinline!lea!.
Если \lstinline!mov mem, reg! загружает в~регистр~$reg$ значение по адресу~$mem$, 
то  \lstinline!lea mem, reg! загружает в~$reg$ адрес~$mem$.

Например, следующая команда 
% использует все четыре параметра косвенной адресации и~
загружает в~$A$ значение  
$*\big(bp + 4D  - 4\big)$,
используя косвенную адресацию "--- вычисление адреса из четырёх компонент с~разыменованием:
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
% (команда \lstinline!mov src, dst! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда %\lstinline!lea src, dst! 
\lstinline!lea! 
загружает в~приёмник адрес источника, что компенсирует разыменование, то есть команда
\begin{lstlisting}
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~$A$ значение  
$bp + 4D  - 4$.

Команда вычисления адреса~\lstinline!lea! часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем %команда беззнакового умножения~\lstinline!mul!:
команды умножения~\lstinline!mul/imul!:
\begin{lstlisting}
leal    8(,%eax,4), %eax    // A := A*4 + 8   
leal    (%eax,%eax,2), %eax // A := A*2 + A = A*3
\end{lstlisting} 


\subsubsection{Работа со стеком}

Для работы со стеком предназначены в~основном команды \lstinline!push! и ~\lstinline!pop!.
Они работают только с операндами размером 4 или 2 байта, то есть указатель вершины стека всегда выравнен на 2 байта (его начальное значение делается двоично-круглым).
В~GNU/Linux стек по соглашению выравнен по $long$ (на 4~байта).


% \lstinline!push источник! \\
Команда \lstinline!push src! помещает источник в~стек.
При этом указатель стека~$sp$ уменьшается на размер источника.

Таким образом, если попытаться смоделировать работу команды \lstinline!push! при помощи команды пересылки, 
то, в~частности
% \lstinline!pushl %eax! эквивалентна
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(eax)
% movl %eax, (%esp)// *esp = %eax
% \end{lstlisting}
% Здесь суффиксы 
\lstinline!pushl $13! (здесь суффикс~$l = long$ необходим, так как разрядность операнда невозможно определить без явного указания) 
эквивалентна последовательному уменьшению~$sp$ и~записи значения в~память:
\begin{lstlisting}[numbers=none]
sub  $4, %esp	 // esp -= sizeof(long)
movl $13, (%esp) // *esp = 13
\end{lstlisting}
% \begin{lstlisting}[numbers=none]
% pushl foo
% \end{lstlisting}
% \lstinline!pushl foo! эквивалентно
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(int)
% movl foo, %eax	// eax= foo
% movl %eax, (%esp)// *esp = eax
% \end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки неэффективна, так как она и~выполняется медленнее, чем~\lstinline!push!, и~занимает больше места в~памяти.
Тем не менее, %часто встречается задача 
иногда необходимо зарезервировать в~стеке место для локальных переменных, начальное значение которых пока неизвестно.
В~этом случае можно воспользоваться командой~\lstinline!sub $size, %esp!.



Команда~\lstinline!pop dest!
"--- извлечение значения из стека и~помещение его в~приёмник~$dest$ "---
увеличивает указатель стека~$sp$  на размер приёмника.

Таким образом, \lstinline!popl %eax! можно также выполнить с~помощью команд
\begin{lstlisting}
movl (%esp), %eax // eax = *esp
add  $4, %esp     // esp += sizeof(int)
\end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки здесь так же менее эффективна, чем~\lstinline!pop!.
При этом отдельная команда~\lstinline!add $size, %esp! для удаления элемента или набора элементов из стека «в~никуда»
используется очень часто.
Она быстрее, чем однократный вызов~\lstinline!pop!, так как не обращается к~памяти; короче множественного вызова~\lstinline!pop!,
а~также не требует указания приёмника.
%множественного 
% \lstinline!popl foo! эквивалентно
% \begin{lstlisting}
% movl (%esp), %eax // eax = *esp
% movl %eax, foo	// foo = eax
% addl $4, %esp	// esp += sizeof(int)
% \end{lstlisting}



\subsubsection{Вызов и~возврат}
\addquestion {Какая команда передаёт управление подпрограмме?}
\addquestion {Какая команда возвращает управление вызывающей программе?}
\addquestion {Что такое адрес возврата?}

Вызов подпрограммы в~ассемблере выполняется командой \lstinline!call!.
Эта команда имеет один операнд "--- адрес подпрограммы в~памяти.
\begin{lstlisting}
...
  movl $10, %eax
  call foo
  // теперь %eax == 15
...
foo:
  addl $5, %eax
  ret
 \end{lstlisting}
Команда \lstinline!call foo! сохраняет указатель команд в~стеке,
управление передаётся $foo$.
% 
Возврат из подпрограммы выполняется командой 
\lstinline!ret!
"--- управление передаётся адресу, снятому со~стека.

% При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
% На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше $sp$, то есть первый параметр равен \lstinline!4(%esp)!.
% % \begin{lstlisting}[numbers=none]
% % 4(%esp)   // *(ESP+4)
% % \end{lstlisting} 
% Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее.


\subsection{Команды обнуления регистра}
% \epigraph{\begin{limerick}
%     Жил один господин из Ливорно,\\
%     Он вкушал только крошки и зёрна,\\
%     Их клюя по привычке,\\
%     Как прочие птички\\
%     На лужках и аллеях Ливорно.\\
% \end{limerick}
% }
% {\Lear}
\epigraph{\begin{stanza}
Но он побрил лицо лифтом,\\
Он вышел в январь;\\
Он сосал бирюзу и ел кусками янтарь.
\end{stanza}}
{\Aquarium}
% https://habrahabr.ru/post/183462/
% • XOR REG,REG
% • SUB REG,REG
% • PXOR/VPXOR XMMREG,XMMREG
% • PSUBB/W/D/Q XMMREG,XMMREG
% • VPSUBB/W/D/Q XMMREG,XMMREG
% • XORPS/PD XMMREG,XMMREG
% • VXORPS/PD YMMREG, YMMREG
% Более подробно – в Intel® 64 and IA-32 Architectures Optimization Reference Manual, страница 43. 
Исторически для обнуления регистров использовались команды побитового исключающего «или» с~одинаковыми операндами~\lstinline!xor %reg, %reg! и~вычитания регистра из самого себя~\lstinline!sub %reg, %reg!,
так как они выполнялись быстрее команды пересылки \lstinline!mov $0, %reg!, а~также занимали меньше места.
Зависимость по данным в~ранних моделях процессора не имела значения, так как вычисления не были конвейеризированы.

После введения конвейера традиция обнуления регистров командами \lstinline!xor! и~\lstinline!sub! сохранилась.
Поэтому в~современных моделях процессоров команды обнуления регистров (zero idioms) распознаются при декодировании 
и~выполняются как не имеющие зависимостей по данным.

% Начиная с~Pentiun~4, 
Таким образом, сейчас руководство по оптимизации Intel~\cite{intelOptimization} снова рекомендует использовать для обнуления регистров общего назначения команды:
\begin{lstlisting}
xor %reg, %reg
sub %reg, %reg
\end{lstlisting}
Для регистров расширения XMM распознаются следующие команды обнуления:
\begin{lstlisting}
xorps/pd  %xmmreg,  %xmmreg
pxor  %xmmreg,  %xmmreg
subps/pd  %xmmreg,  %xmmreg
psubb/w/d/q  %xmmreg,  %xmmreg
\end{lstlisting}
Для некоторых архитектур используются и~другие  команды обнуления регистров расширения X/Y/ZMM~\cite{intelOptimization}.

При этом команды \lstinline!xor! и~\lstinline!sub!, не распознающиеся как zero idioms, выполняются медленнее из-за зависимости по данным
(даже если результатом будет ноль).

% GENERAL OPTIMIZATION GUIDELINES
% 3-26
% 3.5.1.8  
% Clearing Registers and Dependency Breaking Idioms
% Code sequences that modifies partial register can ex
% perience some delay in its dependency chain, but 
% can be avoided by using dependency breaking idioms.
% In processors based on Intel Core microarchitecture, a number of instructions can help clear execution 
% dependency when software uses these instruction to clear register content to zero. The instructions 
% include:
% XOR REG, REG
% SUB REG, REG
% XORPS/PD XMMREG, XMMREG
% PXOR XMMREG, XMMREG
% SUBPS/PD XMMREG, XMMREG
% PSUBB/W/D/Q XMMREG, XMMREG
% In processors based on Intel microarchitecture code name Sandy Bridge, the instruction listed above plus 
% equivalent AVX counter parts are also zero idioms that can be used to break dependency chains. Further-
% more, they do not consume an issue port or an execut
% ion unit. So using zero id
% ioms are preferable than 
% moving 0’s into the register. The AVX equivalent zero idioms are:
% VXORPS/PD XMMREG, XMMREG
% VXORPS/PD YMMREG, YMMREG
% VPXOR XMMREG, XMMREG
% VSUBPS/PD XMMREG, XMMREG
% VSUBPS/PD YMMREG, YMMREG
% VPSUBB/W/D/Q XMMREG, XMMREG
% In Intel Core Solo and Intel Core Duo processors, the XO



\subsection{Флаги}
\label{sec:asm-flags}
\epigraph{\begin{stanza}[0ex]
I can talk with you,\\
I can walk with you,\\
\hspace{\stanzaoddindent}All throughout your life;\\
Stay with you, smile on you,\\
\hspace{\stanzaoddindent}Light in your fire.\\
\end{stanza}}
{\Aquarium}

Как было сказано в~разделе~\ref{sec:digits-negcodes}, при сложении и~вычитании чисел ограниченной разрядности может образоваться бит переноса/заёма из старшего разряда, который сохраняется процессором в~особой ячейке "--- флаге переноса~$CF$.
Процессоры семейства x86 объединяют ячейку~$CF$ и~подобные ей биты, показывающие те или иные свойства последней операции "---
флаги состояния "--- в~специальный регистр  флагов $flags$ %/eflags/rflags$ 
(таблица~\ref{tab:flags}).
% Тридцатидвухбитная версия

Флаг считается установленным, когда он равен~1, и~сброшенным, когда равен 0.

Кроме флагов состояния, регистр флагов включает один бит, не отражающий выполнение последней операции, но влияющий на выполнение некоторых команд (управляющий флаг), а~также несколько битов, недоступных прикладным программам (системные флаги)~\cite{intelSystem, club155, sasm}.
Часть битов зарезервирована и~не используется сейчас как флаги (зарезервированный бит может иметь как произвольное, так и~фиксированное значение).

Доступные прикладным программам флаги состояния в~основном сосредоточены в~младших восьми разрядах $flags$,
% (таблица~\ref{tab:flags}),
поэтому многие команды сохранения/восстановления регистра флагов оперируют только с~младшим байтом.
Старшие восемь бит содержат один флаг состояния~$OF$, управляющий флаг и~несколько системных.
В~тридцатидвухбитном регистре $eflags$ в~старших шестнадцати битах добавлено ещё несколько системных флагов;
старшие тридцать два бита шестидесятичетырёхбитного $rflags$ не используются.


% \footnote{Использованы: 
% Александр Семенко
% http://sasm.narod.ru/apps/eflags/main.htm,
% http://sasm.narod.ru/apps/eflags/app\_a.htm,
% http://www.club155.ru/x86internalreg-eflags
% }

% Флаги разделяются на три группы: флаги состояний, управляющие и~системные~\cite{intelSystem, club155, sasm}.


\begin{table}[!ht]

\caption{Регистр флагов $flags$}
\label{tab:flags}
% \tiny
% \scriptsize
\footnotesize
\renewcommand{\arraystretch}{1.05}
\begin{tabularx}{\linewidth}{@{}c@{~}|l@{~}|l@{~}|L@{}|l@{}}
% № 	& 	&Название 	&Описание 	&Тип флага \\\hline
% \multicolumn{5}{c}{\Reg{flags/eflags}}\\\hline
\multicolumn{5}{c}{\Reg{flags}}\\\hline
\rowcolor{csMarker}0 	&CF 	&Carry Flag 	&Флаг переноса (беззнакового переполнения) 	&Состояние\\\hline
1 	&1 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}2 	&PF 	&Parity Flag 	&Флаг чётности 	&Состояние\\\hline
3 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}4 	&AF 	&Auxiliary Carry Flag 	&Вспомогательный флаг переноса 	&Состояние\\\hline
5 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}6 	&ZF 	&Zero Flag 	&Флаг нуля 	&Состояние\\\hline
\rowcolor{csMarker}7 	&SF 	&Sign Flag 	&Флаг знака 	&Состояние\\\hline
\rowcolor{csSystem}8 	&TF 	&Trap Flag 	&Флаг трассировки 	&Системный\\\hline
\rowcolor{csSystem}9 	&IF 	&Interrupt Enable Flag 	&Флаг разрешения прерываний 	&Системный\\\hline
\rowcolor{csControl}10 	&DF 	&Direction Flag 	&Флаг направления 	&Управляющий\\\hline
\rowcolor{csMarker}11 	&OF 	&Overflow Flag 	&Флаг знакового переполнения 	&Состояние\\\hline
\rowcolor{csSystem}12--13 	&IOPL 	&I/O Privilege Level 	&Уровень приоритета ввода-вывода 	&Системный\\\hline
\rowcolor{csSystem}14 	&NT 	&Nested Task 	&Флаг вложенности задач 	&Системный\\\hline
15 	&0 	&---&Зарезервирован 	&\\\hline
% \\\hline
\multicolumn{5}{c}{\Reg{eflags}}\\\hline
\rowcolor{csSystem}16 	&RF 	&Resume Flag 	&Флаг возобновления 	&Системный\\\hline
\rowcolor{csSystem}17 	&VM 	&Virtual-8086 Mode 	&Режим виртуального процессора 8086 	&Системный\\\hline
\rowcolor{csSystem}18 	&AC 	&Alignment Check 	&Проверка выравнивания 	&Системный\\\hline
\rowcolor{csSystem}19 	&VIF 	&Virtual Interrupt Flag 	&Виртуальный флаг разрешения прерывания 	&Системный\\\hline
\rowcolor{csSystem}20 	&VIP 	&Virtual Interrupt Pending 	&Ожидающее виртуальное прерывание 	&Системный\\\hline
\rowcolor{csSystem}21 	&ID 	&ID Flag 	&Проверка на доступность инструкции CPUID 	&Системный\\\hline
22--31	&	&---&Зарезервированы 	&\\\hline
\end{tabularx}

\end{table}

Регистр $flags$ не может быть явно указан как операнд команды,
но является неявным результатом большинства арифметических команд и~неявным операндом условных команд.

\subsubsection{Флаги состояния}
\index{Флаги!состояния}

Флаги состояния отображают результаты целочисленных арифметических операций (\lstinline!add, sub, mul! и~пр.); этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра $flags$.

\paragraph{CF	
(бит 0)} Флаг переноса (Carry Flag = CF). Устанавливается, если арифметическая операция приводит к~переносу или заёму в/из старшего (выходящего за пределы операнда, воображаемого) разряда, таким образом, этот флаг показывает условие переполнения при выполнении арифметических операций. Также этот флаг используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит,
командами извлечения бита (\lstinline!btX!)
и~многими другими.
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число бит, иначе "--- сбрасывается.

\paragraph{AF	
(бит 4)} Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады младшего байта, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)} Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное / отрицательное).

\paragraph{OF	
(бит 11)} Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита, или имеется перенос из старшего бита, но отсутствует перенос в~него; в~противном случае, флаг $OF$ устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

Из этих флагов только $CF$ можно менять непосредственно (командами stc, clc и~cmc); также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
\index{Флаги!установка}
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг $OF$,

\item для беззнаковой арифметики "--- флаг $CF$,

\item для BCD-арифметики "--- флаг $AF$.
\end{itemize}

\subsubsection{Проверка флагов}
\index{Флаги!проверка}

Команды условного ветвления \lstinline!jCC, setCC, loopCC! и~условной пересылки~\lstinline!cmovCC! используют один или несколько флагов состояния, проверяя различные условия (таблица~\ref{tab:cc-command-list}).

\begin{table}[!ht]
\caption{Условные команды}
\label{tab:cc-command-list}

\small
\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
jCC label	&	Переход по адресу $label$, если установлено сочетание флагов $CC$	\\\hline
setCC dest	&	Установка $dest = 1$, если установлено сочетание флагов $CC$, и~$dest=0$ иначе	

$dest$ может быть однобайтовым регистром или переменной в~памяти
\\\hline
cmovCC src, dest	&	Присваивание $dest = src$, если установлено сочетание флагов $CC$	\\\hline
\end{tabularx}
\end{table}

Кроме того, младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить для анализа в~регистр \lstinline!%ah! командой~\lstinline!lahf! (Load Flags into AH Register). 
Обратная операция выполняется командой~\lstinline!sahf! (Store AH into Flags).
% 
Регистр \lstinline!%flags/%eflags! можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно (таблица~\ref{tab:flags-command-list}).

\subsubsection{Установка флагов}
\index{Флаги!установка}

Все арифметические команды устанавливают флаги по результатам вычислений.
При этом \lstinline!add $-1, dst! и~\lstinline!sub $1, dst! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит ($OF=0$); при вычитании единицы из нуля возникает заём из старшего бита  ($OF=1$).

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
\index{Команды!сравнения}
Это:
\begin{itemize}
\item \lstinline!cmp! "--- то же самое, что и~\lstinline!sub!, но операнд-приёмник не изменяется;
\item \lstinline!test! "--- то же самое, что и~\lstinline!and!, но операнд-приёмник не изменяется.
\end{itemize}

Вещественные числа можно сравнить командой \lstinline!fcom!.
Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~$flags$ таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел.
 
Кроме того,  флаги можно установить или сбросить вручную 
с~помощью специальных команд или загрузив изменённый регистр~$flags$
(таблица~\ref{tab:flags-command-list}).
\begin{table}[!ht]
\small
\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/instr-flags.tex}
\end{table}


\subsection{Команды целочисленной арифметики
% Основные арифметические команды
}
\index{Команды!арифметические}%
\epigraph{\begin{stanza}
Те, кто рисует нас, рисуют красным на сером.\\
Цвета как цвета, но я говорю о другом,\\
Если бы я умел это, я нарисовал бы тебя\\
Там, где зелёные деревья и золото на голубом. \\
\end{stanza}
}{\Aquarium}

Из-за ограниченного количества операндов в~системе команд x86 практически нет привычных по языкам высокого уровня неразрушающих арифметических операторов.
% Вместо них используются
Один из операндов, как правило, используется и~как исходное данное, и~как ячейка для записи результата.
В~частности, аналогом ассемблерной команды сложения \lstinline!add src, dest! в~C++ будет не оператор «плюс», не изменяющий свои операнды ($dest = src_1 + src_2$), а~оператор «${+}{=}$» ($dest~ {+}{=} ~src$, то есть $dest = dest+src$).

Некоторые команды, предназначенные для обработки целых чисел, перечислены в~таблице~\ref{tab:ar-command-list}.
% Некоторые команды целочисленной арифметики перечислены в~таблице~\ref{tab:ar-command-list}.

\begin{table}[p]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar.tex}

\endgroup
\end{table}


Как было сказано в~разделе~\ref{sec:digits-negcodes}, представление отрицательных чисел выбиралось так, чтобы 
знаковые  числа можно было складывать и~вычитать с~помощью беззнакового сумматора.
Соответственно, операции сложения и~вычитания не делятся на знаковые и~беззнаковые.
% Каждая из них выставляет как флаг знак
Команды из группы сложения и вычитания выставляют значения  
% флагов $OF, SF, ZF, AF, PF, CF,$ 
всех шести флагов состояния
соответственно результату,
так что программист, понимая, какого рода числа он обрабатывает, может выбрать для анализа нужные флаги.
% \begin{description}
% \item[CF] беззнаковое переполнение  (перенос из~старшего разряда)
% \item[ZF] результат равен нулю
% \item[SF] старший (знаковый) бит результата
% \item[OF] знаковое переполнение (перенос в~старший разряд, но не из него или наоборот)
% \end{description}

Источник и~приёмник должны быть одного размера.
Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
Более длинные числа при необходимости можно складывать и~вычитать по частям.
Для этого вначале младшие части обрабатываются командами \lstinline!add/sub!, затем~к~остальным в~порядке возрастания адресов "---  \lstinline!adc/sbb!, учитывающие перенос из младшей части.
Части могут иметь любую разрядность (в~частности, шестибайтовые целые можно разбить на две части "---  четыре и~два байта или на шесть однобайтовых), но логичнее использовать четырёхбайтовые части на тридцатидвухбитной системе и~восьмибайтовые "--- на шестидесятичетырёхбитной.

Также для арифметических вычислений используется команда \lstinline!lea!, которая, в~соответствии с~возможностями косвенной адресации,
может рассчитать выражение~$r1 + \gamma\cdot r2 + \delta$ (может быть опущен любой из регистров и~любая из констант).
Команда \lstinline!lea! предназначена для манипуляций с~беззнаковыми данными (указателями),
но в~том самом распространённом случае, когда разрядность $r1$ и~$r2$ совпадает с~разрядностью $dest$, результат совпадает со знаковым.

\subsubsection{Команды умножения и~деления}
Самые старые команды умножения рассчитывают произведение заданного множителя~$arg$ на неявный операнд "--- регистр $A$ той же разрядности, что и~$arg$.
Разрядность произведения при этом вдвое больше разрядности множителей, так что младшая его половина помещается в~регистр~$A$ на место неявного множителя,
а~старшая "--- в~регистр~$D$ той же разрядности.
Исключением является случай с~восьмибитными множителями "--- так как на момент появления команд умножения уже существовали шестнадцатибитные регистры,
результат $al\cdot arg$ размещается в~$ax$ (таблица~\ref{tab:ar-command-muldiv}).
Старшая половина результата отличается для знаковой и~беззнаковой интерпретации множителей, так что существуют две команды описанного действия "--- \lstinline!mul! для беззнакового умножения и~\lstinline!imul! для знакового.
% Если старшую половину можно отбросить,
% % (она равна $0$ для \lstinline!mul! и~состоит только из копий знака для~\lstinline!imul!)
% сбрасываются оба флага~$CF$ и~$OF$,
% если в~старшей половине есть значащие биты, $CF$ и~$OF$ оба взводятся.
\begin{table}[!ht]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar-muldiv.tex}

\endgroup
\end{table}

Введённая позже команда \lstinline!imul src, dest! рассчитывает только младшую половину произведения, а~она совпадает для знаковых и~беззнаковых чисел.
Таким образом, 
% \lstinline!imul src, dest! "--- умножение
двухоперандная форма команды~\lstinline!imul! можно использовать и~для знакового, и~для беззнакового умножения.

Трёхоперандная форма \lstinline!imul imm, src, dest! также рассчитывает только младшую половину произведения,
но перед этим константа \lstinline!imm! при необходимости расширяется.
Данная форма
соответствует двум опкодам "--- с~константой \lstinline!imm!, разрядность которой соответствует разрядности источника и~приёмника
(в~этом случае расширение не требуется)
и~с~восьмибитной константой \lstinline!imm8!~\cite{intelInstructionSet}.
Во втором случае случае \lstinline!imm8! расширяется как знаковое, поэтому трёхоперандную форму~\lstinline!imul! следует считать командой знакового умножения.

% Как двух-, так и~трёхоперандная форма 
Если произведение помещается в~младшей половине произведения, 
все формы команд \lstinline!mul/imul!
сбрасывают оба флага~$CF$ и~$OF$.
Если в~старшей половине есть значащие биты (для двух- и~трёхоперандной форм~\lstinline!imul! это значит, что результат некорректен),
оба этих флага взводятся~\cite{asmworld}.

Для %обратной операции "--- 
деления существуют только однооперандная форма.
Делимое (неявный операнд) всегда вдвое больше делителя (явного операнда~$arg$)
и~располагается в~паре регистров $D{:}A$ (старшая половина "--- в~$D$, младшая "--- в~$A$), кроме случая восьмибитного делителя  (таблица~\ref{tab:ar-command-muldiv}).
Необходимо помнить об этом и~корректно инициализировать регистр~$D$ перед делением.

Таким образом, команды  деления обратны однооперандной форме умножения.
Соответственно, деление также будет беззнаковым (\lstinline!div!) и~знаковым (\lstinline!idiv!).

После деления частное помещается на место младшей половины делимого (в~$A$), остаток "--- на место старшей половины (в~$D$).




\subsubsection{Расширение целых чисел}
\label{sec:asm-conversion-A}

Также к~командам целочисленной арифметики можно отнести команды расширения~\ref{tab:ext-command-list}.

Современная система команд x86 включает 


\begin{table}[!ht]
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ext.tex}

\endgroup
\end{table}

\begin{table}[!ht]
\caption{Мнемоники команд знакового расширения~$A$}
\label{tab:asm-conversion}

\noindent\begin{tabularx}{\linewidth}{|c|cCC|cCC|}
\hline
\multirow{2}{*}{\thead{Размер}}	& \multicolumn{3}{c|}{Расширение в~регистр~$A$}	&	\multicolumn{3}{c|}{Расширение в~пару~$D:A$}	\\
\cline{2-7}
% \thead{Размер} & \thead{Действие} & \thead{Intel} & \thead{GAS} & \thead{Действие} &\thead{Intel} & \thead{GAS} \\\hline
		& \thead{Действие} & \thead{Intel} & \thead{GAS} & \thead{Действие} &\thead{Intel} & \thead{GAS} \\\hline
$8\to16$	&	$al\to ax$	& cbw 	& cbtw	&	\multicolumn{3}{c|}{---}	\\\hline
$16\to32$	&	$ax\to eax$	& cwde 	& cwtl	&	$ax\to dx:ax$		& cwd 	& cwtd	\\\hline
$32\to64$	&	$eax\to rax$	& cdqe 	& cltq	&	$eax\to edx:eax$	& cdq 	& cltd	\\\hline
$64\to128$	&	\multicolumn{3}{c|}{---}	&	$rax\to rdx:rax$	& cqo 	& cqto	\\\hline
\end{tabularx}
\end{table}

\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-bit.tex}

\end{table}

\subsection{Битовые операции}
\epigraph{\begin{stanza}
Я сидел на крыше и видел, как оно есть:\\
Нигде нет неба ниже, чем здесь.\\
Нигде нет неба ближе, чем здесь.\\
Теперь меня не остановить. \\
\end{stanza}
}{\Aquarium}

\begin{tabularx}{\linewidth}{l|L}
\lstinline!shr cдвиг, приёмник! & приёмник >{}>= cдвиг \rlap{(беззнаковый)}\\
\lstinline!sar cдвиг, приёмник! & приёмник >{}>= cдвиг (знаковый)\\
\lstinline!ror cдвиг, приёмник! & циклический сдвиг вправо\\
\hline
\lstinline!shl cдвиг, приёмник! & приёмник <{}<= cдвиг\\
\lstinline!sal cдвиг, приёмник! & приёмник <{}<= cдвиг\\
\lstinline!rol cдвиг, приёмник! & циклический сдвиг влево\\
\hline
\lstinline!and источник, приёмник! & приёмник \&= источник\\
\lstinline!or источник, приёмник! & приёмник |= источник\\
\lstinline!xor источник, приёмник! & приёмник \lstinline!^=! источник\\
\lstinline!not приёмник! & приёмник = $\sim$приёмник\\
\end{tabularx}











\subsection{Условные операторы}
\epigraph{\begin{stanza}
Я~могу быть бессмысленным,\\
Выбрать пути не те,\\
Но есть смелая истина\\
В~широте-долготе.\\
\end{stanza}}
{О.\,Арефьева}




\subsubsection{Условные и~безусловные переходы\footnote{Использованы: 
http://asmworld.ru/spravochnik-komand/jcond/,
http://unixwiz.net/techtips/x86-jumps.html
}}
\index{Флаги!проверка}

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода.

Безусловный переход 
\begin{lstlisting}
  jmp label
\end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу label.

Команды условного перехода
\begin{lstlisting}
  jCC label
\end{lstlisting}
передают адресу label при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).
Если условие не выполнено,  \lstinline!jCC! не делает ничего,  и~выполняется команда, следующая за \lstinline!jCC! по тексту программы.

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

В~следующей таблице приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.
\index{Команды!передачи управления}

\begingroup
\small
\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
\providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}


% \singlespacing

\LTXtable{\textwidth}{book/tables/jmp-list.tex}

\endgroup

Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop, loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если \lstinline!%cx/%ecx! равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop метка! эквивалентна  командам \lstinline!dec %ecx; jz метка!, при этом loop не меняет флаги eflags. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только \lstinline!%cx/%ecx!, но и~флаг нуля ZF (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).
 
Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода\footnote{Optimizing subroutines in assembly 
language.
An optimization guide for x86 platforms. 
By Agner Fog. Technical University of Denmark. }.

\subsubsection{Условная пересылка}
\index{Флаги!проверка}
\index{Команды!условной пересылки}

Для каждой команды условного перехода jCC существует команда условной пересылки cmovCC src, dst, выполняющая присваивание $dst = src$, если соответствующее условие верно.

Команды условной пересылки не полностью аналогичны mov: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

Для флагов, которые могут быть установлены командами сравнения FPU (ZF, CF, PF) существует также команда условной пересылки в~стеке FPU из $st(i)$ в~$st(0)$
\lstinline!fcmovCC  %st(i), %st(0)! (раздел \ref{sec:fcmovCC}).



\subsubsection{Установка байта по условию}
\index{Флаги!проверка}
\index{Команды!установки байта}

Для каждой команды условного перехода jCC существует команда установки байта по условию setCC dst, выполняющая присваивание $dst = 1$, если соответствующее условие верно, и~$dst = 0$ иначе.

% \section{Установка флагов}







\input{book/fpu}








\input{book/fragments/alg}




% \addquestion Знаковой или беззнаковой является операция инкремента?




% \addquestion{Какие вы знаете регистры общего назначения?}
\addquestion{Какие вы знаете команды ассемблера x86?}
\addquestion{Какие вы знаете флаги?}
\addquestion{Какие команды используются для выполнения тригонометрических операций?}
\addquestion{Какие команды используются для сравнения вещественных чисел?}
\addquestion{Какие флаги регистра \Reg{eflags} содержат результат сравнения вещественных чисел?}

\addquestion{Какие вы знаете флаги?}
\addquestion{Какие вы знаете команды передачи управления?}
\addquestion{Какие вы знаете команды условной пересылки?}
\addquestion{Как, согласно ЕСПД, изображается блок «терминатор»?}
\addquestion{Как, согласно ЕСПД, изображается блок «процесс»?}
\addquestion{Как, согласно ЕСПД, изображается блок «решение»?}





\printquestions







