
\chapter{Уровень архитектуры команд линейки x86}
\epigraph{
ЭТО не работает на восьмиразрядных машинах.
}{\ProgFolk}

\label{sec:asm}

\section{Адресация операндов}
% \epigraph{
% %      - Хорошо, - сказал я. - Я~тоже задам  последовательность  вопросов  о
% % местоположении.
% %      - Задавай, задавай, - пробормотал Чапаев.
% %      - Начнем по порядку. 
% "--* Вот вы расчёсываете лошадь. А~где находится  эта лошадь?
% %      Чапаев посмотрел на меня с~изумлением.
% %      - Ты что, Петька, совсем охренел?
% %      - Прошу прощения?
% 
%       "--* Вот она.
% }{В.\,Пелевин}

\epigraph{

"--* Где, "--- спрашивает, "--- ты живёшь?

"--* Ступай, "--- говорит, "--- прямо, повороти направо. Тут будет пень большой. Ты разбегись да треснись башкой. Как искры из глаз посыплются "--- тут меня и~увидишь...
}{П.\,Бажов}



\index{Адресация!виды}

Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
% Данные могут адресоваться различными способами.
Для них доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная}\index{Адресация!непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).


Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая}\index{Адресация!прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды;


Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n! (значение глобальной переменной $n$).

\item \termin{Регистровая}\index{Адресация!регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;


Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!.

\item \termin{Косвенно-регистровая (косвенная)}\index{Адресация!косвенная} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).


%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров.

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}


В~языке ассемблера конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
$$
*\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
$$
где $base$ и~$\mathit{offset}$ "--- регистры (32-разрядные для соответствующей платформы), $displacement$ "--- целое число (смещение), $scalar\,multiplier$ "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется $scalar\,multiplier = 1$, вместо остальных пропущенных параметров  используется~$0$).

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS имеет вид
\begin{lstlisting}
displacement(base, offset, scalar multiplier)
\end{lstlisting} 
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.

}

Например, следующая команда использует все четыре параметра и~загружает в~\EAX{} значение  
$*\big(\mathReg{EBP} - 4 + (\mathReg{EDX} \cdot 4)\big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dst! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда \lstinline!lea src, dst! загружает в~приёмник адрес источника, что компенсирует разыменование, то есть
\begin{lstlisting}
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~\EAX{} значение  
$\mathReg{EBP} - 4 + (\mathReg{EDX} \cdot 4)$.
Команда вычисления адреса~\lstinline!lea! часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем команда беззнакового умножения~\lstinline!mul!:
\begin{lstlisting}
leal    8(,%eax,4), %eax    // EAX := EAX*4 + 8   
leal    (%eax,%eax,2), %eax // EAX := EAX*2 + EAX = EAX*3
\end{lstlisting} 


Чаще используются сокращённые варианты адресации, когда указывается только часть параметров.

Если используется только параметр~$base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает значение \lstinline!*ECX! в~регистр \EDX.
\begin{lstlisting}
movl    (%ecx), %edx
\end{lstlisting} 

С~параметрами~$base$ и~$displacement$ получим $*\big(base + displacement\big)$, что соответствует обращению к~полю структуры ($base$ "--- адрес структуры, константа~$displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса \lstinline!EBP - 4!)
в~регистр \EAX.
\begin{lstlisting}
movl    -4(%ebp), %eax
\end{lstlisting} 

Адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
% он может быть масштабным коэффициентом ($scalar\,multiplier$)
к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(base + \mathit{offset} \cdot scalar\,multiplier\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! обычно равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~\ECX, а~индекс "--- в~\ESI, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Запись~$M[i]$ в~\EAX:
\begin{lstlisting}
movl    (%ecx, %esi, 4), %eax
\end{lstlisting} 


При передаче параметров функции через стек обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека \lstinline!%esp!.

На вершине стека, то есть по адресу \lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше \lstinline!%esp!, то есть первый параметр равен \lstinline!4(%esp)!.
% \begin{lstlisting}[numbers=none]
% 4(%esp)   // *(ESP+4)
% \end{lstlisting} 

Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее. 

% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 


\section{Основные команды}
\label{sec:asm-commandsintro}
\epigraph{
\begin{stanza}[0mm]
I like to move it, move it,\\
She like to move it, move it,\\
We like to move it, move it,\\
We like to move it!\\
\end{stanza}
}{Reel 2 Real}

В~таблице приведены некоторые команды x86-совместимых процессоров.
\index{Команды!арифметические}
\index{Команды!пересылки}

Если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что src и~dest могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.

\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/instr-list.tex}

\endgroup



\lstinline!mov источник, приёмник! \\
"--- присваивание \lstinline!приёмник = источник!
\begin{lstlisting}[numbers=none]
movl $4, %eax	// eax = 4
movb $42, %al	// al = 42
movl %eax, (%esi)	// *esi = eax
movl %eax, 4(%esi)	// *(esi+4 байта) = eax
movl $some_var, %eax	// eax = &some_var
movl $some_var+4, %eax	// eax = &some_var+4 байта
movl some_var, %eax	// eax = some_var
movl %eax, foo	// foo = eax
\end{lstlisting}


{Арифметика: сложение и~вычитание}


\begin{tabularx}{\linewidth}{l|L}
\lstinline!add источник, приёмник! & приёмник += источник\\
\lstinline!adc источник, приёмник! & приёмник += (источник + CF)\\\hline
\lstinline!sub источник, приёмник! & приёмник -= источник\\
\lstinline!sbb источник, приёмник! & приёмник -= (источник + CF)\\\hline
\lstinline!inc приёмник! & ++приёмник\\
\lstinline!dec приёмник! & -{}-приёмник\\\hline
\end{tabularx}


Флаги:
\begin{description}
\item[CF] беззнаковое переполнение (перенос)
\item[ZF] результат равен нулю
\item[SF] старший (знаковый) бит результата
\item[OF] знаковое переполнение
\end{description}

{Арифметика: умножение и~деление}

\begin{tabularx}{\linewidth}{l@{}|L}
\lstinline!mul множитель! & edx:eax = eax * множитель32

dx:ax = ax * множитель16

ax = al * множитель8\\
\lstinline!imul множитель! & 
\\\hline
\lstinline!div делитель! & eax = edx:eax/делитель32, \rlap{edx = edx:eax\%делитель32}

ax = dx:ax/делитель16, \rlap{dx = dx:ax\%делитель16}

al = ax/делитель8, ah = ax\%делитель8\\
\lstinline!idiv делитель! & \\\hline
\end{tabularx}

\begin{tabularx}{\linewidth}{l|L}
\lstinline!imul источник, приёмник! & приёмник *= источник\\
\lstinline!imul константа, источник, приёмник! & приёмник = источник*константа\\\hline

\end{tabularx}

{Битовые операции}


\begin{tabularx}{\linewidth}{l|L}
\lstinline!shr cдвиг, приёмник! & приёмник >{}>= cдвиг \rlap{(беззнаковый)}\\
\lstinline!sar cдвиг, приёмник! & приёмник >{}>= cдвиг (знаковый)\\
\lstinline!ror cдвиг, приёмник! & циклический сдвиг вправо\\
\hline
\lstinline!shl cдвиг, приёмник! & приёмник <{}<= cдвиг\\
\lstinline!sal cдвиг, приёмник! & приёмник <{}<= cдвиг\\
\lstinline!rol cдвиг, приёмник! & циклический сдвиг влево\\
\hline
\lstinline!and источник, приёмник! & приёмник \&= источник\\
\lstinline!or источник, приёмник! & приёмник |= источник\\
\lstinline!xor источник, приёмник! & приёмник \lstinline!^=! источник\\
\lstinline!not приёмник! & приёмник = $\sim$приёмник\\
\end{tabularx}






\subsection{Стек}

\lstinline!push источник! \\
"--- помещение источника в~стек


% \begin{lstlisting}[numbers=none]
% pushl $13
% \end{lstlisting}
\lstinline!pushl $13! эквивалентно
\begin{lstlisting}[numbers=none]
subl $4, %esp	// esp -= sizeof(int)
movl $13, (%esp)// *esp = 13
\end{lstlisting}

% \begin{lstlisting}[numbers=none]
% pushl foo
% \end{lstlisting}
\lstinline!pushl foo! эквивалентно
\begin{lstlisting}[numbers=none]
subl $4, %esp	// esp -= sizeof(int)
movl foo, %eax	// eax= foo
movl %eax, (%esp)// *esp = eax
\end{lstlisting}



\lstinline!pop приёмник! \\
"--- извлечение значения из стека и~помещение его в~приёмник



\lstinline!popl %eax! эквивалентно
\begin{lstlisting}
movl (%esp), %eax // eax = *esp
addl $4, %esp	// esp += sizeof(int)
\end{lstlisting}

\lstinline!popl foo! эквивалентно
\begin{lstlisting}
movl (%esp), %eax // eax = *esp
movl %eax, foo	// foo = eax
addl $4, %esp	// esp += sizeof(int)
\end{lstlisting}

В Linux стек выравнен по long (соглашение).

Команды push и pop работают только с операндами размером 4 или 2 байта.







\section{Флаги}
\label{sec:asm-flags}
\epigraph{\begin{stanza}
I can talk with you,\\
I can walk with you,\\
All throughout your life;\\
Stay with you, smile on you,\\
Light in your fire.\\
\end{stanza}}
{\Aquarium}

\epigraph{\begin{stanza}
Пронзает он как рентген,\\
Бессмертен, велик, священ,\\
Весь этот озон и~оксиген.\\
\end{stanza}}
{О.\,Арефьева}


% \footnote{Использованы: 
% Александр Семенко
% http://sasm.narod.ru/apps/eflags/main.htm,
% http://sasm.narod.ru/apps/eflags/app\_a.htm,
% http://www.club155.ru/x86internalreg-eflags
% }

Флаги разделяются на три группы: флаги состояний, управляющие и~системные~\cite{intelSystem, club155, sasm}.


\begin{table}[!ht]

\caption{Регистр флагов flags/eflags}

\tiny
\renewcommand{\arraystretch}{1.05}
\begin{tabularx}{\linewidth}{@{}c@{~}|l@{~}|l@{~}|L@{}|l@{}}
% № 	& 	&Название 	&Описание 	&Тип флага \\\hline
\multicolumn{5}{c}{\Reg{flags/eflags}}\\\hline
\rowcolor{csMarker}0 	&CF 	&Carry Flag 	&Флаг переноса 	&Состояние\\\hline
1 	&1 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}2 	&PF 	&Parity Flag 	&Флаг чётности 	&Состояние\\\hline
3 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}4 	&AF 	&Auxiliary Carry Flag 	&Вспомогательный флаг переноса 	&Состояние\\\hline
5 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{csMarker}6 	&ZF 	&Zero Flag 	&Флаг нуля 	&Состояние\\\hline
\rowcolor{csMarker}7 	&SF 	&Sign Flag 	&Флаг знака 	&Состояние\\\hline
\rowcolor{csSystem}8 	&TF 	&Trap Flag 	&Флаг трассировки 	&Системный\\\hline
\rowcolor{csSystem}9 	&IF 	&Interrupt Enable Flag 	&Флаг разрешения прерываний 	&Системный\\\hline
\rowcolor{csControl}10 	&DF 	&Direction Flag 	&Флаг направления 	&Управляющий\\\hline
\rowcolor{csMarker}11 	&OF 	&Overflow Flag 	&Флаг переполнения 	&Состояние\\\hline
\rowcolor{csSystem}12--13 	&IOPL 	&I/O Privilege Level 	&Уровень приоритета ввода-вывода 	&Системный\\\hline
\rowcolor{csSystem}14 	&NT 	&Nested Task 	&Флаг вложенности задач 	&Системный\\\hline
15 	&0 	&---&Зарезервирован 	&\\\hline
% \\\hline
\multicolumn{5}{c}{\Reg{eflags}}\\\hline
\rowcolor{csSystem}16 	&RF 	&Resume Flag 	&Флаг возобновления 	&Системный\\\hline
\rowcolor{csSystem}17 	&VM 	&Virtual-8086 Mode 	&Режим виртуального процессора 8086 	&Системный\\\hline
\rowcolor{csSystem}18 	&AC 	&Alignment Check 	&Проверка выравнивания 	&Системный\\\hline
\rowcolor{csSystem}19 	&VIF 	&Virtual Interrupt Flag 	&Виртуальный флаг разрешения прерывания 	&Системный\\\hline
\rowcolor{csSystem}20 	&VIP 	&Virtual Interrupt Pending 	&Ожидающее виртуальное прерывание 	&Системный\\\hline
\rowcolor{csSystem}21 	&ID 	&ID Flag 	&Проверка на доступность инструкции CPUID 	&Системный\\\hline
22--31	&	&---&Зарезервированы 	&\\\hline
\end{tabularx}

\end{table}


\index{Флаги!состояния}

Флаги состояния отображают результаты целочисленных арифметических операций (add, sub, mul и~пр.), этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра eflags.

\paragraph{CF	
(бит 0)} Флаг переноса (Carry Flag = CF). Устанавливается, если арифметическая операция приводит к~переносу или заёму в/из старшего (выходящего за пределы операнда, воображаемого) разряда, таким образом, этот флаг показывает условие переполнения при выполнении арифметических операций. Также этот флаг используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит. 
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число бит, иначе "--- сбрасывается.

\paragraph{AF	
(бит 4)} Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады младшего байта, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)} Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное / отрицательное).

\paragraph{OF	
(бит 11)} Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита, или имеется перенос из старшего бита, но отсутствует перенос в~него; в~противном случае, флаг OF устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

Из этих флагов только CF можно менять непосредственно (командами stc, clc и~cmc). также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
\index{Флаги!установка}
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг OF,

\item для беззнаковой арифметики "--- флаг CF,

\item для BCD-арифметики "--- флаг AF.
\end{itemize}

\subsection{Проверка флагов}
\index{Флаги!проверка}

Команды условного ветвления jCC, setCC, loopCC и~cmovCC используют один или несколько флагов состояния, проверяя различные условия.

Кроме того, младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить в~регистр \lstinline!%ah! командой~\lstinline!lahf! (Load Flags into AH Register). 
Обратная операция выполняется командой~\lstinline!sahf! (Store AH into Flags).

Регистр \lstinline!%flags/%eflags! можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно.

\subsection{Установка флагов}
\index{Флаги!установка}

Все арифметические команды устанавливают флаги по результатам вычислений.
При этом \lstinline!add $-1, dst! и~\lstinline!sub $1, dst! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит (OF=0); при вычитании единицы из нуля возникает заём из старшего бита  (OF=1).

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
\index{Команды!сравнения}
Это:
\begin{itemize}
\item \lstinline!cmp! "--- то же самое, что и~\lstinline!sub!, но операнд-приёмник не изменяется;
\item \lstinline!test! "--- то же самое, что и~\lstinline!and!, но операнд-приёмник не изменяется.
\end{itemize}

Вещественные числа можно сравнить командой \lstinline!fcom!.
Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~eflags таким образом, что результат сравнения можно анализировать так же, как для целых знаковых чисел.





\input{book/fpu}







\section{Условные операторы}
\epigraph{\begin{stanza}
Я~могу быть бессмысленным,\\
Выбрать пути не те,\\
Но есть смелая истина\\
В~широте-долготе.\\
\end{stanza}}
{О.\,Арефьева}




\subsection{Условные и~безусловные переходы\footnote{Использованы: 
http://asmworld.ru/spravochnik-komand/jcond/,
http://unixwiz.net/techtips/x86-jumps.html
}}
\index{Флаги!проверка}

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода.

Безусловный переход 
\begin{lstlisting}
  jmp label
\end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу label.

Команды условного перехода
\begin{lstlisting}
  jCC label
\end{lstlisting}
передают адресу label при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).
Если условие не выполнено,  \lstinline!jCC! не делает ничего,  и~выполняется команда, следующая за \lstinline!jCC! по тексту программы.

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

В~следующей таблице приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.
\index{Команды!передачи управления}

\begingroup
\small
\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
\providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}


% \singlespacing

\LTXtable{\textwidth}{labs/jmp-list.tex}

\endgroup

Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop, loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если \lstinline!%cx/%ecx! равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop метка! эквивалентна  командам \lstinline!dec %ecx; jz метка!, при этом loop не меняет флаги eflags. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только \lstinline!%cx/%ecx!, но и~флаг нуля ZF (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).
 
Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода\footnote{Optimizing subroutines in assembly 
language.
An optimization guide for x86 platforms. 
By Agner Fog. Technical University of Denmark. }.

\subsection{Условная пересылка}
\index{Флаги!проверка}
\index{Команды!условной пересылки}

Для каждой команды условного перехода jCC существует команда условной пересылки cmovCC src, dst, выполняющая присваивание $dst = src$, если соответствующее условие верно.

Команды условной пересылки не полностью аналогичны mov: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

Для флагов, которые могут быть установлены командами сравнения FPU (ZF, CF, PF) существует также команда условной пересылки в~стеке FPU из $st(i)$ в~$st(0)$
\lstinline!fcmovCC  %st(i), %st(0)! (раздел \ref{sec:fcmovCC}).



\subsection{Установка байта по условию}
\index{Флаги!проверка}
\index{Команды!установки байта}

Для каждой команды условного перехода jCC существует команда установки байта по условию setCC dst, выполняющая присваивание $dst = 1$, если соответствующее условие верно, и~$dst = 0$ иначе.

% \section{Установка флагов}







\input{book/alg}




% \addquestion Знаковой или беззнаковой является операция инкремента?




\addquestion Какие вы знаете регистры общего назначения?
\addquestion Какие вы знаете команды ассемблера x86?
\addquestion Какие вы знаете флаги?
\addquestion Какие команды используются для выполнения тригонометрических операций?
\addquestion Какие команды используются для сравнения вещественных чисел?
\addquestion Какие флаги регистра \Reg{eflags} содержат результат сравнения вещественных чисел?

\addquestion Какие вы знаете флаги?
\addquestion Какие вы знаете команды передачи управления?
\addquestion Какие вы знаете команды условной пересылки?
\addquestion Как, согласно ЕСПД, изображается блок «терминатор»?
\addquestion Как, согласно ЕСПД, изображается блок «процесс»?
\addquestion Как, согласно ЕСПД, изображается блок «решение»?





\printquestions







