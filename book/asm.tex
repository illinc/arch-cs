
\chapter{Уровень архитектуры команд линейки x86}
\epigraph{
ЭТО не работает на восьмиразрядных машинах.
}{\ProgFolk}

\label{sec:asm}

\section{Адресация операндов}
% \epigraph{
% %      - Хорошо, - сказал я. - Я~тоже задам  последовательность  вопросов  о
% % местоположении.
% %      - Задавай, задавай, - пробормотал Чапаев.
% %      - Начнем по порядку. 
% "--* Вот вы расчёсываете лошадь. А~где находится  эта лошадь?
% %      Чапаев посмотрел на меня с~изумлением.
% %      - Ты что, Петька, совсем охренел?
% %      - Прошу прощения?
% 
%       "--* Вот она.
% }{В.\,Пелевин}

\epigraph{

"--* Где, "--- спрашивает, "--- ты живёшь?

"--* Ступай, "--- говорит, "--- прямо, повороти направо. Тут будет пень большой. Ты разбегись да треснись башкой. Как искры из глаз посыплются "--- тут меня и~увидишь...
}{П.\,Бажов}



\index{Адресация!виды}

Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
% Данные могут адресоваться различными способами.
Для них доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная}\index{Адресация!непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).


Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая}\index{Адресация!прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды;


Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n! (значение глобальной переменной $n$).

\item \termin{Регистровая}\index{Адресация!регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;


Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!.

\item \termin{Косвенно-регистровая (косвенная)}\index{Адресация!косвенная} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).


%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров.

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}


В~языке ассемблера конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
$$
*\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
$$
где $base$ и~$\mathit{offset}$ "--- регистры (32-разрядные для соответствующей платформы), $displacement$ "--- целое число (смещение), $scalar\,multiplier$ "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется $scalar\,multiplier = 1$, вместо остальных пропущенных параметров  используется~$0$).

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS имеет вид
\begin{lstlisting}
displacement(base, offset, scalar multiplier)
\end{lstlisting} 
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.

}

Например, следующая команда использует все четыре параметра и~загружает в~\EAX{} значение  
$*\big(\mathReg{EBP} - 4 + (\mathReg{EDX} \cdot 4)\big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dst! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда \lstinline!lea src, dst! загружает в~приёмник адрес источника, что компенсирует разыменование, то есть
\begin{lstlisting}
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~\EAX{} значение  
$\mathReg{EBP} - 4 + (\mathReg{EDX} \cdot 4)$.
Команда вычисления адреса~\lstinline!lea! часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем команда беззнакового умножения~\lstinline!mul!:
\begin{lstlisting}
leal    8(,%eax,4), %eax    // EAX := EAX*4 + 8   
leal    (%eax,%eax,2), %eax // EAX := EAX*2 + EAX = EAX*3
\end{lstlisting} 


Чаще используются сокращённые варианты адресации, когда указывается только часть параметров.

Если используется только параметр~$base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает значение \lstinline!*ECX! в~регистр \EDX.
\begin{lstlisting}
movl    (%ecx), %edx
\end{lstlisting} 

С~параметрами~$base$ и~$displacement$ получим $*\big(base + displacement\big)$, что соответствует обращению к~полю структуры ($base$ "--- адрес структуры, константа~$displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса \lstinline!EBP - 4!)
в~регистр \EAX.
\begin{lstlisting}
movl    -4(%ebp), %eax
\end{lstlisting} 

Адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
% он может быть масштабным коэффициентом ($scalar\,multiplier$)
к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(base + \mathit{offset} \cdot scalar\,multiplier\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! обычно равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~\ECX, а~индекс "--- в~\ESI, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Запись~$M[i]$ в~\EAX:
\begin{lstlisting}
movl    (%ecx, %esi, 4), %eax
\end{lstlisting} 


При передаче параметров функции через стек обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека \lstinline!%esp!.

На вершине стека, то есть по адресу \lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше \lstinline!%esp!, то есть первый параметр равен \lstinline!4(%esp)!.
% \begin{lstlisting}[numbers=none]
% 4(%esp)   // *(ESP+4)
% \end{lstlisting} 

Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее. 

% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 


\section{Основные команды}
\label{sec:asm-commandsintro}
\epigraph{
\begin{stanza}[0mm]
I like to move it, move it,\\
She like to move it, move it,\\
We like to move it, move it,\\
We like to move it!\\
\end{stanza}
}{Reel 2 Real}

В~таблице приведены некоторые команды x86-совместимых процессоров.
\index{Команды!арифметические}
\index{Команды!пересылки}

Если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что src и~dest могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.

\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/instr-list.tex}

\endgroup


\section{Флаги}
\label{sec:asm-flags}
\epigraph{\begin{stanza}
I can talk with you,\\
I can walk with you,\\
All throughout your life;\\
Stay with you, smile on you,\\
Light in your fire.\\
\end{stanza}}
{\Aquarium}

\epigraph{\begin{stanza}
Пронзает он как рентген,\\
Бессмертен, велик, священ,\\
Весь этот озон и~оксиген.\\
\end{stanza}}
{О.\,Арефьева}


\footnote{Использованы: 
Александр Семенко
http://sasm.narod.ru/apps/eflags/main.htm,
http://sasm.narod.ru/apps/eflags/app\_a.htm,
http://www.club155.ru/x86internalreg-eflags
}
\index{Флаги!состояния}

Флаги состояния отображают результаты целочисленных арифметических операций (add, sub, mul и~пр.), этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра eflags.

\paragraph{CF	
(бит 0)} Флаг переноса (Carry Flag = CF). Устанавливается, если арифметическая операция приводит к~переносу или заёму в/из старшего (выходящего за пределы операнда, воображаемого) разряда, таким образом, этот флаг показывает условие переполнения при выполнении арифметических операций. Также этот флаг используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит. 
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число бит, иначе "--- сбрасывается.

\paragraph{AF	
(бит 4)} Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)} Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное / отрицательное).

\paragraph{OF	
(бит 11)} Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита, или имеется перенос из старшего бита, но отсутствует перенос в~него; в~противном случае, флаг OF устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

Из этих флагов только CF можно менять непосредственно (командами stc, clc и~cmc). также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг OF,

\item для беззнаковой арифметики "--- флаг CF,

\item для BCD-арифметики "--- флаг AF.
\end{itemize}

\subsection{Проверка флагов}
\index{Флаги!проверка}

Команды условного ветвления jCC, setCC, loopCC и~cmovCC используют один или несколько флагов состояния, проверяя различные условия.

Кроме того, младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить в~регистр \lstinline!%ah! командой~\lstinline!lahf! (Load Flags into AH Register). 
Обратная операция выполняется командой~\lstinline!sahf! (Store AH into Flags).

Регистр \lstinline!%flags/%eflags! можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно.

\subsection{Установка флагов}
\index{Флаги!установка}

Все арифметические команды устанавливают флаги по результатам вычислений.
При этом \lstinline!add $-1, dst! и~\lstinline!sub $1, dst! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит (OF=0); при вычитании единицы из нуля возникает заём из старшего бита  (OF=1).

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
\index{Команды!сравнения}
Это:
\begin{itemize}
\item \lstinline!cmp! "--- то же самое, что и~\lstinline!sub!, но операнд-приёмник не изменяется;
\item \lstinline!test! "--- то же самое, что и~\lstinline!and!, но операнд-приёмник не изменяется.
\end{itemize}

Вещественные числа можно сравнить командой \lstinline!fcom!.
Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~eflags таким образом, что результат сравнения можно анализировать так же, как для целых знаковых чисел.





\section{Модули и~функции на ассемблере}
\label{sec:asm-func}
\epigraph{\begin{stanza}
При встрече с~медвежьим капканом\\
Пойди объясни, что ты не медведь.
\end{stanza}}
{\Aquarium}




\subsection{Вызов подпрограммы}
\index{Подпрограммы!вызов}

Вызов подпрограммы в~ассемблере выполняется командой call.
Эта команда имеет один операнд "--- адрес подпрограммы в памяти.
\begin{lstlisting}
...
  movl $10, %eax
  call foo
  // теперь %eax == 15
...
foo:
  addl $5, %eax
  ret
 \end{lstlisting}
Команда \lstinline!call foo! сохраняет указатель команд в~стеке,
управление передаётся foo.
% 
Возврат из подпрограммы выполняется командой 
\lstinline!ret!
"--- управление передаётся адресу, снятому со~стека.


\subsection{Импорт внешних функций в~подпрограмму на ассемблере}

Подпрограмма на ассемблере может обращаться не только к~другим подпрограммам из того же модуля на ассемблере, 
но и~к~внешним, в~частности, к~функциям, из других объектных файлов проекта или к~стандартной библиотеке stdlib.

Для того, чтобы функция, описанная на языке C++, была доступна для экспорта в~другие модули, используется ключевое слово extern, как и~для импорта внешних функций (для отключения декорирования также используется \lstinline!extern "C"!):
\begin{lstlisting}
/*@\colorbox{codestronghighlight}{extern "C"{}}@*/
__attribute__((__cdecl__)) 
int /*@\colorbox{codehighlight}{bar}@*/(int x)
{
    return 3*x+1;
};
\end{lstlisting}
% Декорирование C++-функций делает их имена неопознаваемыми, поэтому на практике при экспорте функций лучше использовать только "C" 
% Соглашение о~вызове на всякий случай указано явно с~использованием ключевого слова \lstinline!__attribute__!, но чаще всего для использования cdecl достаточно\lstinline!extern "C"!. 

Для импорта функции в~ассемблере не требуется никаких директив, достаточно знать её имя.
\begin{lstlisting}
pushl $1
call /*@\colorbox{codehighlight}{bar}@*/
addl $4, %esp
\end{lstlisting}
Команда call, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
Она только помещает в~стек адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.

Параметры необходимо поместить вручную туда, где их ожидает увидеть подпрограмма.
Для соглашения cdecl они должны находиться в~стеке, куда помещаются командой push в~обратном порядке (приведённый код рассчитывает bar(1)).

После завершения работы такой функции параметры необходимо вручную удалить из стека.
% 
Возвращаемое значение типа int можно найти, в~соответствии с~соглашением о~вызове, в~регистре~\lstinline!%eax!.

% Необходимо всегда помнить о~том, что после вызова функции значения многих регистров меняется.





\section{Соглашения о~вызовах}
\label{sec:asm-calling-conventions}
\epigraph{\begin{stanza}
 Объясните  мне,  где  теперь  правда,  где  ложь, \\
 где  жало  змеи, где пылающий   уголь,  где  тюрьма.
\end{stanza}}
{\Aquarium}







\footnote{Использованы материалы:
Agner Fog.
Calling conventions
for different C++ compilers and operating systems.
}
\index{Подпрограммы!соглашения о~вызовах}

\termin{Соглашение о~вызовах} "--- протокол передачи аргументов:
% \vspace{-1\parskip}
\begin{enumerate}
\item способ передачи (через регистры, через стек, смешанный);
\item порядок размещения аргументов (Pascal "--- первый аргумент помещается в~стек первым, C "--- последним);
\item кто очищает стек и~сохраняет/восстанавливает регистры (и~какие);
\item инструкции вызова и возврата;
\item как передаётся указатель this (для ООП).
\end{enumerate}

\bigskip

\begingroup
% \scriptsize
% \footnotesize
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|M{4em}|l|l|L|%L|
}
\hline
&{Параметры в~регистрах}
&{Порядок}
&{Очистка стека}
% &\theadlong{Дополнения}
\\\hline
cdecl&&
 C&
 вызывающая программа
 %&
 \\\hline
pascal&&
 Pascal&
 функция
 %&
\\\hline
winapi (stdcall)&&
 C&
 функция
 %&
 \\\hline
Gnu&&
 C&
%  hybrid
this "--- функция, \mbox{остальные "---  вызывающая программа}
%  &
% Стек иногда выравнивается на 16 бит
\\\hline
Gnu fastcall&
ecx, edx
&
 C&
функция
\\\hline
Gnu regparm (3)&
eax, edx, ecx
&
 C&
функция
\\\hline
Borland fastcall&
ecx, edx
&
Pascal&
функция
\\\hline
 Microsoft fastcall&
 ecx, edx&
 C&
 функция
%  &
%  return pointer on stack if
% not member function
\\\hline
% \\\hline
\end{tabularx}
\endgroup
\bigskip


Возвращаемое значение:
% \vspace{-1\parskip}
\begin{enumerate}
\item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
\item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
\end{enumerate}

\subsection{Вызов подпрограммы в~GAS}

Соглашения о~вызове: Gnu, cdecl, Gnu fastcall, Gnu regparm (0--3).

\index{Подпрограммы!использование регистров}
Регистры, значение которых не~должно изменяться подпрограммой "---
% \vspace{-1\parskip}
% \section{Подпрограммы в~GAS}
% \subsection{Регистры, значение которых не~должно изменяться подпрограммой}
% \begin{frame}[fragile]{\insertsubsection}
% \begin{enumerate}
% \item
\lstinline!%ebx!
% \item
\lstinline!%esi!
% \item
\lstinline!%edi!
% \item
\lstinline!%ebp!
% \item С
и~сегментные регистры \lstinline!%ds, %es, %ss!.
% \item Вершина стека \lstinline!%esp! нет
% \item\lstinline!%r12—%r15! в~64-битном режиме
% \end{enumerate}
Прочие могут изменяться подпрограммами.















\section{Математический сопроцессор}

\epigraph{
"--*  Фапофадофажди, "--- сказала Алиса Пашке, пользуясь старым школьным кодом. "--- Фамыфаосфатафанемфася фаодфани.

"--*  Фапофанял, "--- ответил Пашка.

"--*  Фавлефасу, "--- сказала Алиса.
}
{Кир.\,Булычёв}


\section{Математический сопроцессор\footnote{Использованы: %http://devotes.narod.ru/Books/3/
Зубков С.\,В. Assembler для DOS, Windows и~UNIX
}  
}


Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой (начиная с~i486DX "--- интегрирован в~процессор).

FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.


% \section{Регистры сопроцессора}
% 
% Восемь 80-разрядных регистров, образующих стек (кольцевой буфер).

FPU предоставляет восемь регистров для хранения данных и~пять вспомогательных регистров.
При обращении к~ним в~GAS надо указывать тот же префикс, что и~для регистров основного процессора (CPU).

\begin{illustration}
\includegraphics[width=\approvedImageWidth]{fpu_reg}
\caption{Регистры FPU}
\label{ris:fpu_reg}
\end{illustration}

Регистры данных (R0--R7) не адресуются по именам, как регистры основного процессора. Вместо этого эти восемь регистров рассматриваются как стек, вершина которого называется st(0), а~более глубокие элементы "--- st(1), st(2) и~так далее до st(7). Если, например, в~какой-то момент времени регистр R5 называется st(0), то после записи в~этот стек числа оно будет записано в~регистр R4, который станет называться st(0), R5 станет называться st(1) и~т.\,д.

Для вычислений хотя бы один операнд должен быть загружен в~стек сопроцессора.

% http://stackoverflow.com/questions/612507/what-are-the-applications-benefits-of-an-80-bit-extended-precision-data-type
Значения в~сопроцессоре представлены в 80-битном формате (с~двойной расширенной точностью соответственно IEEE 754-1985).
Старший бит "--- знак,
порядок занимает 15 бит, %(как для чисел четверной точности соответственно IEEE 754-2008 https://en.wikipedia.org/wiki/Extended_precision ??? не нашла в 2008)
мантисса "--- 64 бита, причём мантисса включает целую часть (рис.~\ref{ris:fpu_digits}).

\begin{illustration}
\includegraphics[width=\linewidth]{X86_Extended_Floating_Point_Format_ru}
\caption{Внутренний 80-битный формат сопроцессора}
\label{ris:fpu_digits}
\end{illustration}

Регистры сопроцессора могут содержать следующие значения:
\begin{itemize}
\item  вещественные числа "--- порядок не равен 0 и~не состоит из всех единиц, %то есть не равен 0x7FFF
целая часть мантиссы равна 1; %, корректно представимые
\item денормализованные вещественные числа "--- порядок и~целая часть мантиссы равны 0, но мантисса не равна нулю;
\item нули ($+0.0$ и~$-0.0$, в~соответствии со знаковым битом) "--- порядок и~мантисса равны нулю;
\item бесконечности ($+\infty$ и~$-\infty$, в~соответствии со знаковым битом) "--- порядок состоит из всех единиц, целая часть мантиссы "--- единица, дробная часть равна нулю;
\item нечисла двух типов:
\begin{itemize}
\item сигнальные нечисла (при  появлении такого значения в~стеке генерируется исключение недействительной операции);
\item тихие нечисла (не генерируют исключения, но результат вычислений с~операндом-нечислом "--- тоже нечисло):
\begin{itemize}
\item вещественная неопределённость (знаковый бит не имеет значения) "--- порядок состоит из всех единиц, целая часть и~старший бит дробной части "--- единицы, остальные нули;
\item другие тихие нечисла "--- порядок состоит из всех единиц, целая часть и~старший бит дробной части "--- единицы, остальные "--- не все нули;
\end{itemize}
\end{itemize}
\item недопустимые значения.
\end{itemize}
Начиная с~80387 некоторые ранее недопустимые значения стали нечислами различного типа, и~наоборот "--- многие недопустимые для современных сопроцессоров значения были корректными нечислами в~ранних дискретных моделях.

Регистр состояний SW содержит слово состояния FPU.
Регистр управления CW содержит управляющие биты и~маски.

Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.

Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.



\subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
% 
Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти:
\begin{lstlisting}[style=lstsmall]
const double a = 12;
double x = 1, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "faddl %[A]\n"  // st(0) = %[SRC] + %[A]
    "fstpl %[DST]\n"// %[DST] = %[SRC] + %[A], стек пуст
    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = x + a
\end{lstlisting}

В~списке  перезаписываемых регистров GCC не позволяет описывать элементы стека сопроцессора.
Это, как правило, не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).


\subsection{Набор инструкций x87}
% http://www.studfiles.ru/preview/4034449/

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы:

Все мнемонические обозначения начинаются с~символа f (Float).

Вторая буква мнемонического обозначения определяет тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item i "--- целое двоичное число;

\item b "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы "--- вещественное число.
\end{itemize}

Последняя буква p в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная pp "---  из стека извлекаются оба операнда). 

\subsubsection{Сброс сопроцессора}

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Команда finit восстанавливает значения по умолчанию в~регистрах CW, SW, TW, а~начиная с~80387 "--- FIP и~FDP. Управляющий регистр инициализируется значением 037Fh (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на 0, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Регистр состояния обнуляется (ТОР = 0, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~регистре TW. Регистры FIP и~FDP обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.



\subsubsection{Загрузка данных в~стек сопроцессора}
\index{Команды!FPU!загрузки}

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций f*ld.
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение st(0).

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры

\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-fld-list.tex}

\endgroup

Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
double x = 5.7, y;
int i = 10;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fldz\n"        // st(0) = 0, st(1) = %[SRC]
    "fld1\n"        // st(0) = 1, st(1) = 0, st(2) = %[SRC]
    "fild %[I]\n"   // st(0) = %[I], st(1) = 1, st(2) = 0, st(3) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = %[I],   st(0) = 1, st(1) = 0, st(2) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = 1,      st(0) = 0, st(1) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = 0,      st(0) = %[SRC]
    "fstpl %[DST]\n"// %[DST] = %[SRC], стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [I]"m"(i)
    :"cc"
);
\end{lstlisting}


\subsubsection{Выгрузка и~пересылка данных% из~стека сопроцессора
}
\index{Команды!FPU!выгрузки}
\index{Команды!FPU!пересылки}


\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-fst-list.tex}

\endgroup

\subsubsection{%Арифметические 
Основные арифметические команды\footnote{Использованы: Александр Фролов, Григорий Фролов Аппаратное обеспечение персонального компьютера}  
}
\index{Команды!FPU!арифметические}
Основные арифметические команды сопроцессора выполняют бинарные арифметические операции.
Хотя бы один операнд должен быть %в~стеке сопроцессора.
в~вершине стека сопроцессора~$st(0)$.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.
Приёмник должен быть в~стеке сопроцессора, но не обязательно на его вершине. %, таким образом, .

Сопроцессор использует шесть основных типов арифметических команд (XXX "--- операция): 
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-arcommon-list.tex}

\endgroup

Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
Так, для операции add это команды:
\begin{itemize}[wide=\parindent]
\item \lstinline!fadd!	(синоним \lstinline!faddp!,
эквивалент \lstinline!faddp %st(0), %st(1)!)

"--- st(1) := st(0) + st(1) и~выталкивание  st(0) из стека, так что после этой операции результат оказывается в~st(0);
\item \lstinline!fadd src!	"--- st(0) := st(0) + вещественное src;
\item \lstinline!fiadd src!	"--- st(0) := st(0) + целое src;
\item \lstinline!fadd %st(i), %st(0)!	"--- st(0) := st(0) + st(i);
\item \lstinline!fadd %st(0), %st(i)!	"--- st(i) := st(i) + st(0);
\item \lstinline!faddp %st(0), %st(i)!	"--- st(i) := st(i) + st(0) и~выталкивание  st(0) из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{itemize}

\warning{ 
Внимание!

Ассемблер Unix исторически использовал для некоторых команд FPU \emph{в~некоторых ситуациях} обратное расположение операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel и~большинстве учебников.
}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
всегда, в~том числе
в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
% в~таком случае 
для двух регистров
вычисляет $st(0) - st(i)$ независимо от того, какой из этих регистров является приёмником (в~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры). 
Обратное вычитание~\lstinline!fsubr! вычисляет $st(i) - st(0)$.


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub[p] %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.

Такое поведение в~случае сочетания синтаксиса AT\&T и~платформы x86 в~некоторых источниках описывается как баг GCC, но из соображений совместимости с~имеющимся кодом меняться не будет.
Из-за него, кроме всего прочего, в~GCC для всех основных арифметических команд доступна <<нелегальная>> седьмая форма записи, например, \lstinline!fsubp %st(i), %st(0)!.
Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)! (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
Подобную некорректную форму лучше не использовать.

Поведение Intel и~GAS совпадает в~тех случаях, когда приёмником является~$st(0)$, в~том числе в~ситуациях, когда источник находится в~памяти.

Также поведение Intel и~GAS полностью совпадает для симметричных операций "--- сложения и~умножения.

\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-ar-list.tex}

\endgroup


Пример использования (так как используется GAS, \lstinline!fdivr! рассчитывает %прямое деление 
$st(1)/st(0)$, после чего источник $st(0)$ выталкивается из стека):
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 0.01;
double x = 5, y;
int i = 10;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fldpi\n"       // st(0) = pi, st(1) = %[SRC]
    "fld1\n"        // st(0) = 1, st(1) = pi, st(2) = %[SRC]
    "fildl %[I]\n"  // st(0) = %[I], st(1) = 1, st(2) = pi, st(3) = %[SRC]
    "fdivr\n"       // st(0) = 1/%[I], st(1) = pi, st(2) = %[SRC]
    "fldl  %[A]\n"  // st(0) = %[A], st(1) = 1/%[I], st(2) = pi, st(3) = %[SRC]
    "fmulp %%st(0), %%st(2)\n"  // st(0) = 1/%[I], st(1) = pi*%[A], st(2) = %[SRC]
    "faddp\n"       // st(0) = 1/%[I] + pi*%[A], st(1) = %[SRC]
    "faddp\n"       // st(0) = 1/%[I] + pi*%[A] + %[SRC]
    "fstpl %[DST]\n"// %[DST] = 1/%[I] + pi*%[A] + %[SRC], стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a), [I]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}

\subsubsection{Дополнительные арифметические и~трансцендентные команды\footnote{Использованы: %http://devotes.narod.ru/Books/3/
Зубков С.\,В. Assembler для DOS, Windows и~UNIX
} }
Дополнительные арифметические и~трансцендентные команды работают с~вершиной стека st(0) и,~при необходимости, с~st(1). Они не имеют аргументов и~соответствующих пяти форм.

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
% Если операнд выходит за эти пределы, флаг С2 устанавливается в 1, значение st(0) и~стек не изменяются. 

Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице ниже.
\index{Команды!FPU!трансцендентные}
\index{Команды!FPU!дополнительные}
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{labs/fpu-arex-list.tex}

\endgroup


Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fsincos\n"     // st(0) = cos(%[SRC]), st(1) = sin(%[SRC])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[SRC]), st(1) = sin(%[SRC])
    "fadd\n"        // st(0) = %[A]*cos(%[SRC]) + sin(%[SRC])
    "fstpl %[DST]\n"// %[DST] = %[A]*cos(%[SRC]) + sin(%[SRC]) стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}

\subsection{Сравнение вещественных чисел}


\begingroup

\subsubsection{Флаги сопроцессора}
\colorlet{csControl}{green!50}
\colorlet{csExceptionStatus}{green!7!yellow!7!white}
\colorlet{csSystem}{blue!20!red!10}
\index{Флаги!сопроцессора}

Математический сопроцессор имеет собственный регистр флагов "--- слово состояния \Reg{SW}.
Команды сравнения оригинального FPU 8087 (fcom, fcomp, fcompp, ftst) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (fucom, fucomp, fucompp), не генерирующее исключений при сравнении некоторых нечисел, сохраняют результат сравнения в~биты C3, C0 и,~в~случае несравнимости операндов, в~бит~C2 слова состояния.


\begin{table}[!ht]
\caption{Слово состояния FPU}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{\Reg{SW}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}2 	&ZE 	& Деление на нуль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}\Reg{eflags}, f(n)stsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{csMarker}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{csMarker}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{csMarker}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{csSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{csSystem}12 	& 	&&\cellcolor{csMarker}4 	&\cellcolor{csMarker}AF 	&\cellcolor{csMarker}Auxiliary Carry Flag\\
\rowcolor{csSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{csMarker}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{csExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\end{table}

% \pagebreak[3]
Для анализа результата сравнения вещественных чисел в~ранних (отдельных) моделях сопроцессора было необходимо вручную перенести его в~регистр флагов \Reg{eflags} основного процессора.  
\pagebreak[3]

Это выполнялось в~два этапа:
\begin{itemize}
\item слово состояния \Reg{SW} выгружалось в~регистр \Reg{AX} командами fstsw (проверяет на наличие отложенных необработанных исключений) или~fnstsw (также данные команды могут выгрузить \Reg{SW}  в~память);
\item старший байт \Reg{AX} загружался в~младший байт регистра флагов \Reg{flags} командой sahf.
\end{itemize}
\pagebreak[3]
%слово состояния \Reg{SW} могло быть выгружено в~память или регистр \Reg{AX} командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки \Reg{SW} в~регистр \Reg{AX} его старший байт загружал

После этого флаги C3 и~C0 помещались в~биты ZF и~CF, а~бит C2 "--- в~бит~PF. 
В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.

Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (fcomi, fcomip, fucomi, fucomip), которые напрямую устанавливают флаги ZF, CF, PF в~\Reg{eflags}.
Эти команды не изменяют биты C0,  C3 регистра \Reg{SW}.
% и~не дублируют туда результат сравнения.


Таким образом, после выполнения команды сравнения (%и~%пары команд 
% \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% или при использовании совместимых с~ними 
при использовании совместимых с~ранними моделями 
команд %f*com[p[p]]
без суффикса~\lstinline!i! 
необходимы также \lstinline!fstsw %ax! + \lstinline!sahf!)
результат  можно 
анализировать как результат сравнения беззнаковых целых чисел.
% 

\subsubsection{Команды сравнения\footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается
}
\index{Команды!сравнения!вещественных чисел}
\index{Команды!FPU!сравнения}

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

Все команды сравнения вещественных чисел сравнивают вершину стека $st(0)$ с~другим операндом (источником $src$).

\subsubsection{Команды, устанавливающие флаги сопроцессора}

Команды сравнения, унаследованные от ранних (дискретных) моделей сопроцессора, выставляют по результатам сравнения биты C0, C2, C3 слова состояния сопроцессора (рис.~\ref{fig:fcom}).
Бит~C3 взводится в~случае равенства операндов, бит~C0 "---  в~случае $st(0) < src$.
% ; бит C2 в~этих случаях равен $0$. 
Если операнды несравнимы, взводится бит~C2, а~также оба бита C0 и~C3.

К командам, помещающим результат в~слово состояния сопроцессора, относятся:
\begin{description}
\item[fcom] %Семейство команд сравнения.
Источник может быть указан явно (\lstinline!fcom %st(i)!, \lstinline!fcom mem!) или не указан (\lstinline!fcom!, находится в~$st(1)$). Источник в~памяти может иметь одинарную~или двойную точность.

Команда может иметь формы \lstinline!fcom [src]! (из стека ничего не выталкивается), \lstinline!fcomp [src]! (из стека выталкивается $st(0)$), \lstinline!fcompp! (из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$).

\item[fucom] Семейство команд, аналогичное \lstinline!fcom!. Отличается тем, что при сравнении тихих нечисел не генерируется исключений. 
% Сравнение чисел выполняется аналогично

\item[ficom] Источник "--- целое число (16 или 32 бита), находится в~памяти и~должен быть указан явно (\lstinline!ficom mem!).
Команда может иметь формы \lstinline!ficom src! (из стека ничего не выталкивается) и~\lstinline!ficomp src! (из стека выталкивается $st(0)$).
Если $st(0)$ "--- нечисло, генерируется исключение и~выставляются флаги, как для несравнимых значений.

\item[ftst] Источник равен нулю. Действие аналогично \lstinline!fcom!.

\end{description}

\begin{illustration}

$\left.
\begin{tabular}{l@{}l}
$src$ "--- st(i) или в~памяти & 
$\left\{\begin{tabular}{@{}r@{}}
\termin{fcom[p[p]]} \farg{[src]}\\
\termin{fucom[p[p]]} \farg{[src]}
\end{tabular}\right.$\\
$src$ "--- целое в~памяти & \termin{ficom[p]} \farg{src}\\
$src = 0$ & \termin{ftst}
\end{tabular}
\right\}$
% 
\begin{tabular}{c|@{~}c@{~}c@{~}c}
Условие & C3 & C0 &C2\\\hline
$st(0)>src$ & 0 & 0 & 0 \\
$st(0)<src$ & 0 & 1 & 0 \\
$st(0)=src$ & 1 & 0 & 0 \\
несравнимы& 1 & 1 & 1
\end{tabular}

{
\termin{f[n]stsw + sahf:} C3, C0, C2 $\to$ ZF, CF, PF.
\centering

}

\caption{Команды, выставляющие флаги сопроцессора (\Reg{SW})}
\label{fig:fcom}
\end{illustration}

Так как условные команды, в~частности, команды условной пересылки регистров сопроцессора fcmovXXX, используют флаги \Reg{eflags}, а~не слово состояния сопроцессора,
% 
после выполнения команд сравнения этой группы необходимо перенести результат сравнения в~\Reg{eflags} парой команд \lstinline!fstsw %ax! + \lstinline!sahf!.

После этого значение C3 помещается в~аналогичный ему по смыслу флаг нуля ZF ($st(0) - src = 0$), C0 "--- в~флаг переноса~CF ($st(0) - src < 0$),
то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
Бит несравнимости C2 попадает на место флага чётности~PF. 


\subsubsection{Команды, устанавливающие флаги CPU}

Современные процессоры включают два семейства команд сравнения, напрямую выставляющие флаги ZF, CF, PF (рис.~\ref{fig:fcomi}):
\begin{description}
\item[fcomi] %Семейство команд сравнения.
Источник должен находиться в~стеке сопроцессора, при этом и~источник, и~приёмник $st(0)$ должны быть указаны явно (\lstinline!fcomi %st(i), %st(0)!).

Команда может иметь формы \lstinline!fcomi %st(i), %st(0)! (из стека ничего не выталкивается) и~\lstinline!fcomip %st(i), %st(0)! (из стека выталкивается $st(0)$).

\item[fucomi] Отличается от \lstinline!fcomi! тем, что при сравнении тихих нечисел не генерируется исключений. 
\end{description}


\begin{illustration}

\begin{tabular}{r}
\termin{fcomi[p]} \farg{src, \%st(0)}\\
\termin{fucomi[p]} \farg{src, \%st(0)}\\
% $src$ "--- st(i)\hfill \strut сравнивают вершину стека с операндом-источником, который может быть регистром или операндом в памяти (коротким или длинным вещественным).
\end{tabular}
% 
% 
\begin{tabular}{c|c@{~}c@{~}c|c@{~}c@{~}c}
Условие & ZF & CF &PF	&OF& SF & AF \\\hline
$st(0)>src$ & 0 & 0 & 0 &\multirow{4}{*}{0} &\multirow{4}{*}{0}  &\multirow{4}{*}{0} \\
$st(0)<src$ & 0 & 1 & 0 &&&\\
$st(0)=src$ & 1 & 0 & 0 &&&\\
несравнимы& 1 & 1 & 1&&&
\end{tabular}
\caption{Команды, выставляющие флаги основного процессора (\Reg{eflags})}
\label{fig:fcomi}
\end{illustration}



Неиспользуемые три флага состояния \Reg{eflags} сбрасываются в~$0$; биты C0, C2,  C3 слова состояния сопроцессора не изменяются.

\endgroup





\section{Условные операторы}
\epigraph{\begin{stanza}
Я~могу быть бессмысленным,\\
Выбрать пути не те,\\
Но есть смелая истина\\
В~широте-долготе.\\
\end{stanza}}
{О.\,Арефьева}




\section{Условные и~безусловные переходы\footnote{Использованы: 
http://asmworld.ru/spravochnik-komand/jcond/,
http://unixwiz.net/techtips/x86-jumps.html
}}
\index{Флаги!проверка}

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода.

Безусловный переход 
\begin{lstlisting}
  jmp label
\end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу label.

Команды условного перехода
\begin{lstlisting}
  jXXX label
\end{lstlisting}
передают адресу label при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).
Если условие не выполнено,  \lstinline!jXXX! не делает ничего,  и~выполняется команда, следующая за \lstinline!jXXX! по тексту программы.

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

В~следующей таблице приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.
\index{Команды!передачи управления}

\begingroup
\small
\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
\providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}


% \singlespacing

\LTXtable{\textwidth}{labs/jmp-list.tex}

\endgroup

Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop, loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если \lstinline!%cx/%ecx! равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop метка! эквивалентна  командам \lstinline!dec %ecx; jz метка!, при этом loop не меняет флаги eflags. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только \lstinline!%cx/%ecx!, но и~флаг нуля ZF (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{l}
ECX\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).
 
Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода\footnote{Optimizing subroutines in assembly 
language.
An optimization guide for x86 platforms. 
By Agner Fog. Technical University of Denmark. }.

\subsection{Условная пересылка}
\index{Флаги!проверка}
\index{Команды!условной пересылки}

Для каждой команды условного перехода jXXX существует команда условной пересылки cmovXXX src, dst, выполняющая присваивание $dst = src$, если соответствующее условие верно.

Команды условной пересылки не полностью аналогичны mov: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

\subsection{Установка байта по условию}
\index{Флаги!проверка}
\index{Команды!установки байта}

Для каждой команды условного перехода jXXX существует команда установки байта по условию setXXX dst, выполняющая присваивание $dst = 1$, если соответствующее условие верно, и~$dst = 0$ иначе.

% \section{Установка флагов}














\nsection{Контрольные вопросы}

\begin{enumerate}
\item Какие вы знаете соглашения о~вызове?
\item Какая команда передаёт управление подпрограмме?
\item Какая команда возвращает управление вызывающей программе?
\item Что такое адрес возврата?

\item Как в~функции передаются целые параметры ?
\item Как в~функции передаются вещественные параметры?
\item Как в~функции передаются три и~более параметров?
% \item Какие вы знаете соглашения о вызове?

\item Чем различается код, созданный компиляторами одного семейства для различных платформ?
\item Чем различается код, созданный различными компиляторами для одной платформы?


\item Какие вы знаете регистры общего назначения?
\item Какие вы знаете команды ассемблера x86?
\item Какие вы знаете флаги?


\item Какие регистры используются в~сопроцессоре для хранения операндов?

\item Какие команды используются для выполнения арифметических операций над вещественными числами?

\item Какие команды используются для выполнения тригонометрических операций?
\item Какие команды используются для сравнения вещественных чисел?
\item Какие флаги регистра \Reg{eflags} содержат результат сравнения вещественных чисел?


% \item Какие вы знаете флаги?
\item Какие вы знаете команды передачи управления?
\item Какие вы знаете команды условной пересылки?

\item Как, согласно ЕСПД, изображается блок «терминатор»?
\item Как, согласно ЕСПД, изображается блок «процесс»?
\item Как, согласно ЕСПД, изображается блок «решение»?



\end{enumerate}









