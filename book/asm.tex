

\chapter{Программирование на языке Ассемблера}
\epigraph{\begin{stanza}[0mm]
Есть великая правда у тех, кем хранится завет\\
Но для тех, кто им стал, нет завета и истины нет.\\
\end{stanza}}{\Orgia}
% \label{sec:asm}

% Идеология и~ритм
Некоторые приёмы
программирования на ассемблере существенно отличаются от используемых в~языках высокого уровня.
При этом GNU Assembler является неотъемлемой частью процесса компиляции этих языков, в~первую очередь "--- C/C++. 
Соответственно, структура программы на GNU Assembler аналогична C/C++,
кроме того, полностью доступна стандартная библиотека stdlib.
Данная глава показывает как возможную связь программ на C/C++ и~ассемблере, так и~различия в~реализации алгоритмов.

Если не указано иное,
примеры соответствуют тридцатидвухбитной платформе.
Вызовы функций описываются в~соответствии с~тридцатидвухбитным соглашением \lstinline!cdecl! и~без учёта искажения имён (см. раздел~\ref{sec:calling-functions}).




\section{Структура программы на ассемблере}
\epigraph{\begin{stanza}Так скажем «Банзай», и~Бог с~ней, с~твердью;\\
Всё, что прошло "--- сдадим в~утиль.\\
А~здесь у~нас в~центре циклона "---\\
Снежные львы и~полный штиль.\\
\end{stanza}}
{\Aquarium}
\label{sec:asm-main}

% Исполняемый файл обязательно содержит

Программа обязательно должна включать точку входа "--- адрес, с~которого начинается её выполнение.
По умолчанию %компоновщик
компоновщик GCC ищет точку входа по имени  $\_start$.
% (здесь нижнее подчёркивание "--- часть имени без учёта искажения имён компилятором). 
Для программ на C/C++ по адресу $\_start$ находится стартовый код библиотеки stdlib, который, в~частности, инициализирует все используемые библиотекой ресурсы и~вызывает так называемую головную функцию $main()$.
После этого  программа выполняется по определённому алгоритму (в~частности, с~помощью цикла обработки сообщений можно реализовать событийно-ориентированную модель)
и~при определённых обстоятельствах должна корректно завершать  свою работу.
\index{main()}%

Минимальная программа 
% включает точку входа (многие библиотеки определяют стартовую функцию, которая )
запускается
и~немедленно завершает  работу.
% Соответственно
Также в~учебных целях часто описывается программа, выводящая на экран приветствие «Hello, world!».

\subsection{Программирование с~использованием stdlib}
\epigraphcensoredtwo[\epigraph{
Какое наслаждение для шляпника сознавать, что весь мир приходит в~движение для того, чтобы он мог произвести и~продать эту шляпу! 
}
{К.\,Маркс}
]{
\epigraph{\begin{limerick}
    Жила-была дама приятная,\\
    На вид совершенно квадратная.\\
    Кто бы с ней ни встречался,\\
    От души восхищался:\\
    «До чего эта дама приятная!»
\end{limerick}
}
{\Lear}
}

По умолчанию в~GCC программа (как на языке C/C++, так и~на языке ассемблера) собирается с~поддержкой стандартной библиотеки stdlib.
Соответственно, стартовой (главной) функцией программы является $int~main(int~argc,$ $char~*argv[])$.
%  $int~main(int, char *[])$

% \section{Точка входа на ассемблере и~использование stdlib}

% Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.
Стартовая функция $main()$ может находиться как в~модуле на языке C/C++, так и~в~ассемблерном модуле.

\subsubsection{Минимальная программа с~использованием stdlib}

% Минимальная программа 
Приведём код минимальной программы на ассемблере GAS
с~использованием стандартной библиотеки stdlib (листинг~\ref{lst:asm:minmain}).
\begin{lstlisting}[caption=Минимальная программа с~использованием stdlib, label=lst:asm:minmain]
.globl main // головная функция (stdlib)
main:
     xor %eax, %eax // A ^= A, то есть A = 0
     ret // return A
\end{lstlisting}
Команда \texttt{ret}, в~отличие от оператора C++ return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах (раздел~\ref{sec:calling-functions}) всегда подразумевается в~регистре~$A$.
Для тридцатидвухбитного кода это $eax$, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр~$eax$.
В~данном случае это делается при помощи побитового исключающего «или».
\index{Команды!xor}%
\index{Команды!обнуления регистра}%
Эта команда компактнее %\lstinline!!
явного копирования нуля в~регистр и~выполняется быстрее.

Параметры $argc$ и~$argv$ располагаются в~соответствии с~используемом соглашением о~вызове,
то есть находятся в~стеке\index{Стек} для тридцатидвухбитных систем и~в~регистрах для шестидесятичетырёхбитных.
\modifytwo[
Имя функции $main()$, как и~имена других функций stdlib, в~GNU/Linux не искажается.
]{}

Эквивалент программы~\ref{lst:asm:minmain} на С++  выглядит следующим образом.
\begin{lstlisting}[caption=Минимальная программа с~использованием stdlib (C++), label=lst:asm:minmain-cpp]
int main()
{
    return 0;
}
\end{lstlisting}

% Головная функция $main()$ здесь завершается с~кодом~0 сразу после запуска, 
% Параметры $argc$ и~$argv$ здесь не используются и,~как позволяет
% стандарт, опущены.
Неиспользуемые параметры $main()$ стандарт позволяет опустить.

\subsubsection{Приветствие миру}

\index{Команды!call}%
\index{Команды!push}%
\index{Команды!pop}%

Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции $printf()$ библиотеки stdlib (листинг~\ref{lst:asmmain:printf-cpp})
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие (C++)}, label=lst:asmmain:printf-cpp]
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на тридцатидвухбитном ассемблере 
\modifytwo[(как сказано в~разделе~\ref{sec:calling-functions}%{sec:calling-conventions}
, в~этом случае для функций stdlib независимо от операционной системы используется соглашение \lstinline!cdecl!%, а~имена в~GNU/Linux не искажаются
)
]{}
выглядит следующим образом (листинг~\ref{lst:asmmain:printf-asm}).
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие}, label=lst:asmmain:printf-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    xor %eax, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются (но в~некоторых версиях Microsoft Windows могут дополняться префиксом, как описано в~разделе~\ref{sec:mangling}). 

Параметры функции $printf()$ в~соответствии с~соглашением \lstinline!cdecl! передаются через стек\index{Стек} (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).
\index{Команды!add}%
Так как нам не нужно извлечённое из стека значение, команду \lstinline!popl %eax! можно заменить изменением значения указателя стека~\lstinline!addl $4, %esp!.
Эта команда быстрее и~к~тому же не требует приёмника для сохранения неиспользуемого %вычищаемого из стека 
значения.

Так как для вывода приветствия не используются все возможности  $printf()$, вместо неё можно использовать более простую функцию~$puts()$.
\begin{lstlisting}[caption={Программа, выводящая приветствие с~помощью $puts()$}, label=lst:asmmain:puts-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call puts
    addl $4, %esp	// Вычищаем параметр из стека
    xor %eax, %eax
    ret
\end{lstlisting}



\subsubsection{Форматированный вывод}

Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}[caption={Программа, выводящая на экран два числа (C++)}, label=lst:asmmain:printf-cpp-params]
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению \lstinline!cdecl! эти параметры передаются в~обратном порядке (то есть на вершине стека\index{Стек} оказывается первый):
\begin{lstlisting}[caption={Программа, выводящая на экран два числа}, label=lst:asmmain:printf-asm-params]
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  xor %eax, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~$sp$, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности,~$A$) меняется (раздел~\ref{sec:calling-conventions}).
% Список регистров, которые могут изменяться подпрограммой, подробнее рассмотрен в~разделе~\ref
Если в~таких регистрах хранятся данные вызывающей программы, их надо сохранить перед вызовом функции.



\bottompagebreak
\subsection{Программирование без stdlib}
\epigraphcensoredtwo[\epigraph{
 Натурализм здесь "--- видимость, и~только эстетическая видимость, создаваемая большими и~малыми робинзонадами. 
%   Производство обособленного одиночки вне общества "--- редкое явление, которое, конечно, может произойти с~цивилизованным человеком, случайно заброшенным в необитаемую местность и~потенциально уже содержащим в себе общественные силы, "--- такая же бессмыслица, как развитие языка без совместно живущих и~разговаривающих между собой индивидов.
}
{К.\,Маркс}
]{
\epigraph{\begin{limerick}
Старичок так следил за осанкой,\\
что питался лишь только овсянкой.\\
Но однажды съел лишку,\\
положив в~неё мышку,\\
И~серьёзно испортил осанку.\\
\end{limerick}
}
{\Lear}
}

Минимальная программа с~stdlib (листинг~\ref{lst:asm:minmain}) после ассемблирования занимает 4704 байт.
% % [caption=min.S]
% \begin{lstlisting}
% .globl main // точка входа (stdlib)
% main:
%      xorl %eax,%eax // EAX ^= EAX, то есть EAX = 0
%      ret // return EAX
% \end{lstlisting}
% % Сборка (полученный файл включает stdlib и~занимает %4.6 Кб "--- 
% % 4704 байт)
% % \begin{lstlisting}[language=Bash]
% % $ gcc -o min min.S
% % \end{lstlisting}
% % Сборка с~stdlib: 
% \lstinline!gcc -o min min.S!
В~этот размер входят библиотечные функции, обеспечивающие обработку параметров, вызов стартовой функции~$main()$
и~завершение программы после возврата управления из $main()$.

Отключить использование stdlib при сборке позволяет ключ~\lstinline!-nostdlib!.
В~этом случае взаимодействие с~операционной системой, в~том числе завершение программы, необходимо осуществлять напрямую, с~помощью системных вызовов.\index{Системные вызовы}%

Точкой входа в~этом случае будет непосредственно метка $\_start$.
% После неё можно вручную вызвать $main()$ и~обработать возвращаемое ей значение.

Каждая операционная система имеет свой набор %системных вызовов
функций
и~свой способ их вызова\modifytwo[{} (раздел~\ref{sec:sys-call})]{}.
В~большинстве тридцатидвухбитных операционных систем системные вызовы осуществляются с~помощью программных прерываний.
При этом, если в~GNU/Linux, BSD и~FreeDOS системные вызовы хорошо документированы,
то в~Microsoft Windows как механизм их вызова, так и~набор функций постоянно меняются и~%не документированы.
скрыты от прикладного программиста.
Вместо прямых системных вызовов под Microsoft Windows предлагается использовать функции библиотеки Windows API.
% Сборка без stdlib (полученный файл занимает 600 байт)
% \begin{lstlisting}[language=Bash]
% $ gcc -o nsmin  nsmin.S  -nostdlib
% \end{lstlisting}
\index{Системные вызовы}%

В~GNU/Linux к~функциям операционной системы в~тридцатидвухбитном режиме можно обратиться с~помощью прерывания \hex{0x80}.
% int 0x80, \lstinline!%eax! "--- номер функции
Номер функции указывается в~регистре~$eax$.
% до 6 аргументов: \lstinline!%ebx!, \lstinline!%ecx!, \lstinline!%edx!, \lstinline!%esi!, \lstinline!%edi! и~\lstinline!%ebp!
Вызов может принимать до шести аргументов в~регистрах $ebx, ecx, edx, esi, edi, ebp$.
% Если требуется передать семь значений или больше, они объединяются в~структуру, адрес которой передаётся в~$ebx$.
\index{Системные вызовы}%


\subsubsection{Минимальная программа без stdlib}
% Мне ничего не нужно и ничего не жаль, 
% Голым и безоружным взлетаю вдаль

\index{Команды!int}%
Рассмотрим
минимальную программу, не использующую функции stdlib (в~том числе $main()$) для GNU/Linux. % (600 байт)
Сразу после запуска она должна завершиться с~кодом~0.
Для завершения программы используется системный вызов с~кодом~1 "--- $sys\_exit()$.
\index{Системные вызовы}%
Его единственный параметр "--- код возврата.
\begin{lstlisting}[caption=Минимальная программа без stdlib, label=lst:asm:minstart]
.globl _start
_start: // точка входа 
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}
% Сборка без~stdlib: 
% \lstinline!gcc -o min min.S -nostdlib!
Если код \ref{lst:asm:minstart} сохранён как файл~\lstinline!nsmin.S!,
собрать его без стандартной библиотеки можно командой:
\begin{lstlisting}[language=Bash]
$ gcc -o nsmin  nsmin.S  -nostdlib
\end{lstlisting}
полученный исполняемый файл %не  включает stdlib и~
занимает 600 байт.

% Эквивалент на С++
% \begin{lstlisting}
% int main(int argc, char* argv[]){
%     return 0;
% }
% \end{lstlisting}

\subsubsection{Приветствие миру}


Для вывода строки на экран ядром~Linux используется системный вызов с~кодом~4 "--- $sys\_write()$.
Он предназначен для записи в~файл;
требует трёх параметров "--- дескриптор файла, указатель на начало записываемых данных и~длина этих данных в~байтах.
Согласно концепции Unix всё есть файл;
для вывода на экран используется специальный дескриптор 1 ($stdout$).
\index{Системные вызовы}%



\begin{lstlisting}[caption={Вывод приветствия при помощи системных вызовов Linux}, label=lst:asmmain:syscall-asm]
.data
    msg:
    .ascii "Hello, world!\n"
    len = . - msg // символу len присваивается длина строки
.global _start // точка входа в программу
_start:
    movl $4, %eax // системный вызов №4 — sys_write
    movl $1, %ebx // поток №1 — stdout
    movl $msg, %ecx // указатель на выводимую строку
    movl $len, %edx // длина строки
    int $0x80 // вызов ядра
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}

Для вывода более сложных данных, в~частности, чисел, необходимо вручную сформировать в~программе выводимую в~файл $stdout$ строку.
% Написание подобных обёрток
Такой код, предназначенный для взаимодействия с~системными вызовами, займёт существенный объём, так что в~итоге выигрыш от неиспользования stdlib может оказаться несущественным.
\index{Системные вызовы}%




\section{Подпрограммы и~функции}
\label{sec:calling-functions}
% \epigraph{\begin{stanza}[0mm]
% Как мне найти тебя, когда прожекторы прямо в~лицо?
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}
Если ты рододендрон "---\\
Твоё место в окне.\\
Если ты истинный якорь "---\\
Давай, брат, лежи на дне.\\
Но если ты хочешь войти "---\\
Придётся выйти вовне. \\
\end{stanza}
}{\Aquarium}

Как сказано в~разделе~\ref{sec:compilation-functions}, одним из способов соединения кода на различных языках программирования является 
% совместная компиляция модулей и~
вызов внешних функций, описанных в~модулях, соединяемых с~головным на этапе компоновки.

Функции языка высокого уровня являются частным случаем \termin{подпрограмм} "--- последовательностей команд, завершающихся командой возврата.
\index{Подпрограммы}%
% 
% Для вызова функции используется команда \lstinline!call!, которая помещает в~стек адрес возврата из функции, а~затем передаёт управление вызываемой функции; для возврата "--- команда \lstinline!ret!, которая передаёт управление адресу, снятому со стека.
Для вызова подпрограммы используется команда \lstinline!call!, которая помещает в~стек адрес возврата, а~затем передаёт управление на начало вызываемой подпрограммы; для возврата управления вызывающей программе "--- команда \lstinline!ret!, которая передаёт управление адресу, снятому со стека.

Таким образом, п%
% П
ри вызове внешних функций необходимо решить четыре основные задачи.
% 
Первые две связаны с~возможностью связать вызов функции из одного модуля с~её описанием в~другом на стадии компоновки;
третья и~четвёртая требуются для корректного взаимодействия вызывающей программы и~функции на этапе выполнения.

\begin{enumerate}
\item Имена функций (как вызываемых из данного модуля, так и~тех, которые описаны в~данном модуле и~могут быть вызваны извне) должны быть видимы для компоновщика.

Для этого используются ключевое слово \lstinline!extern! в~C++ и~директива \lstinline!.globl! в~языке ассемблера.

\item Имя одной и~той же функции на этапе компоновки должно выглядеть одинаково как в~том модуле, где она описана, так и~в~том, где она вызывается.

Для этого необходимо отказаться от такой возможности языка C++, как перегрузка (она приводит к~декорированию имён)
% , и~описывать внешние функции как C-функции.
с~помощью дополнительной строки \lstinline!"C"! для ключевого слова \lstinline!extern!.
Кроме того, многие версии операционной системы Microsoft Windows требуют от компиляторов дополнительно искажать имена; это необходимо компенсировать вручную при помощи макросов.

\item Параметры должны помещаться вызывающей программой именно туда, где их будет искать вызываемая функция; возвращаемое значение функции также должно оказаться на том месте, где его ожидает вызывающая программа.

% Для этого обе стороны должны соблюдать так называемые соглашения о~вызовах.
Для языков высокого уровня протокол взаимодействия вызывающей и~вызываемой программ называется соглашением о~вызовах.
Используемое соглашение определяется платформой, операционной системой, языком высокого уровня, компилятором, а~также специальными ключевыми словами при описании функции.
Соответственно, функцией можно назвать подпрограмму, следующую необходимому соглашению о~вызове.

\item Функция перед возвратом должна удалить из стека все те данные, которые она поместила поверх адреса возврата, и~ни в~коем случае не удалять больше, чем поместила.

Баланс стека должен быть сохранён, иначе во время возврата из функции управление будет передано не туда (а~именно "--- по адресу, равному значению в~текущей вершине стека), что приведёт к~некорректной работе программы и,~возможно, к~её краху.
\end{enumerate}

Рассмотрим процесс взаимодействия вызывающей программы и~функции подробнее.

\subsection{Требования к~вызовам функций}
\label{sec:asm-calling-conventions}

\epigraph{\begin{stanza}[0mm]
И может быть мы сразу друг друга поймём,\\
Если у нас один и тот же разъём.
\end{stanza}}
{\Aquarium}

% Функции 
К~механизму вызова 
подпрограммы
% функции
(в~различных языках используется также термины «функция», «метод», «процедура») 
можно сформировать ряд требований.
\begin{enumerate}
\item Возможность передачи управления на произвольный адрес.
\item Возврат управления назад после завершения подпрограммы.
\item Вложенные вызовы подпрограмм.
\item Сохранение и~восстановление регистров вызывающей программы.
\item Передача заданного количества аргументов.
\item Возврат значения. % (часто подпрограмму, способную возвращать).
% \item Передача и~возврат структур.
\item Выделение и~освобождение памяти под локальные переменные подпрограмм.
\end{enumerate}
В~системе команд x86 реализованы только первые три из них.
Обеспечить выполнение остальных можно только в~том случае, если вызывающая и~вызываемая программа «договорятся», где будут находиться передаваемые  аргументы и~локальные переменные.



В~некоторых источниках считается, что функцией можно назвать только подпрограмму, написанную на языке высокого уровня.
При этом подпрограмма, написанная на ассемблере и~соответствующая используемому в~данном языке высокого уровня соглашению о~вызове,
может быть вызвана наравне с~написанными на ЯВУ.
Таким образом, логичнее считать термин «функция» либо синонимом подпрограммы,
либо обозначать им подпрограмму, соответствующую одному из общепринятых соглашений.


% \subsection{Модули и~функции на ассемблере}
% \subsection{Вызов подпрограммы}
% \subsection{Подпрограммы на ассемблере}
% \subsection{Вызов подпрограммы на ассемблере}
\subsection{Механизм вызова подпрограммы}
\index{Подпрограммы!вызов}%
\label{sec:asm-func}
\epigraph{
Что такое заклинание, понятно всем.\\Это когда говоришь "--- а оно случается.
% 
% Нет, как-то ненаучно вышло. Заглянем в трактат профессора Югоруса Лужжа «Основные направления развития всеобщего магического образования на 1975-2125 годы»:
% 
% «Заклинание "--- вербализованная модуляция унитарного магического воздействия, подкрепленная спорадически сознательным, а иногда эмерджентным импульсом психофизиологического характера».
% 
% Вот.
% 
% А так было все понятно…
% 
% Сейчас попробуем объяснить. «Вербализованный» "--- это значит «словами», «модуляция» "--- это… ну… то сильнее, то слабее…
% 
% Ладно, все равно слово «эмерджентный» авторы даже руками показать не смогут. Вернемся к прежнему определению. Из него следует, что достаточно что-то произнести, и что-то случится. В такой, наиболее общей форме определение верно абсолютно: что бы вы ни произнесли, где-нибудь что-нибудь случится.
% 
% Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{\ZhvalevskijMytko}
% \index{Вызов функций}%
\index{Стек}%
\index{Команды!push}%
\index{Команды!pop}%
\index{Команды!call}%
\index{Команды!ret}%


% Вызов подпрограммы (функции или процедуры) можно разбить на последовательность следующих действий.
% \begin{enumerate}
% \item Передача параметров.
% \item Сохранение адреса возврата.
% \item Передача управления вызываемой подпрограмме.
% \item Выполнение вызываемой подпрограммы.
% \item Подготовка возвращаемого значения.
% \item Возвращение управления вызывающей программе.
% \end{enumerate}


% Соответственно, к~механизму вызова подпрограммы можно сформировать ряд требований.
% \begin{enumerate}
% \item Возможность передачи управления на произвольный адрес.
% \item Возврат управления назад после завершения подпрограммы.
% \item Вложенные вызовы подпрограмм.
% \item Сохранение и~восстановление регистров вызывающей программы.
% \item Передача заданного количества аргументов.
% \item Передача и~возврат структур.
% \item Выделение и~освобождение памяти под локальные переменные подпрограмм.
% \end{enumerate}

% В~системе команд x86 реализованы только первые три из них.

В~системе команд x86 для реализации механизма подпрограмм используются всего две команды:
\begin{itemize}
\item команда вызова подпрограммы \lstinline!call!, единственным аргументом которой является адрес начала подпрограммы;
\item команда возврата из подпрограммы \lstinline!ret!.
\end{itemize}
Пусть следующая команда, расположенная по адресу $c_i$ "--- \lstinline!call f!
(рис.~\ref{ris:call-stack}, а).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-abv}
}

\caption{Изменение указателя стека командами вызова и~возврата}
\label{ris:call-stack}
\end{illustration}%
Команда \lstinline!call! помещает в~стек адрес следующей по порядку команды $c_{i+1}$ "--- \termin{адрес возврата,}
после чего в~указатель команд~$ip$ помещается адрес~$f$, так что эта команда становится следующей для исполнения процессором
(рис.~\ref{ris:call-stack}, б).
Когда в~процессе исполнения подпрограммы~$f$ встретится команда \lstinline!ret!
(рис.~\ref{ris:call-stack}, в),
\index{Слово!машинное}%
из стека извлекается верхнее машинное слово "--- там должен быть адрес возврата "--- и~помещается в~указатель команд~$ip$
(рис.~\ref{ris:call-stack}, г).
Соответственно, выполнение вызывающей программы продолжится со следующей за  \lstinline!call! команды.  

\subsubsection{Локальные переменные}
\index{Стек}

Как уже говорилось в~разделе~\ref{sec:stack-segment}, локальные переменные подпрограммы хранятся в~стеке;
также программист или оптимизирующий компилятор может поместить часть локальных переменных в~регистрах общего назначения.
Это не предписано системой команд, но является общепринятым.

Так как память под локальные переменные подпрограммы выделяется подпрограммой после %её вызова
передачи управления на её начало, 
эти переменные будут расположены в~стеке над адресом возврата (так как стек растёт вниз "--- по меньшим адресам).
Для выделения и~освобождения памяти под переменные служат 
\index{Подпрограммы!пролог}%
\index{Подпрограммы!эпилог}%
специальные фрагменты кода в~начале и~в~конце подпрограммы "--- пролог и~эпилог соответственно.

Современные компиляторы 
% сразу после 
помещают в~пролог команду уменьшения указателя стека $sp$ на величину, равную общему объёму локальных переменных, помещаемых в~стеке
(рис.~\ref{ris:call-stack-var-sp}, а) и~б).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-var-sp-abv}
}
\index{Стек}

\caption{Размещение локальных переменных в~стеке оптимизирующим компилятором}
\label{ris:call-stack-var-sp}
\end{illustration}%
В~эпилоге указатель $sp$ увеличивается на ту же величину (рис.~\ref{ris:call-stack-var-sp}, в) и~г),
так что к~моменту выхода из подпрограммы на вершине стека окажется адрес возврата (рис.~\ref{ris:call-stack-var-sp}, г).
\index{Стек}

% После этого локальные переменные можно 
Адреса локальных переменных можно выразить через $sp$.
В~процессе выполнения программы указатель $sp$ может меняться% (в~частности, для размещения)
, в~этом случае необходимо соответственно корректировать смещения переменных относительно $sp$.
Также,  %если в~процессе выполнения в~стеке резервировалась память под новые локальные
если код подпрограммы нарушает баланс стека,
может понадобиться скорректировать величину, добавляемую к~$sp$ в~эпилоге.

Ранние компиляторы сохраняли в~регистре~$bp$ значение $sp$ до резервирования памяти под локальные переменные.
Это позволяло адресовать переменные относительно $bp$ и~не корректировать смещение, а~в~эпилоге восстановить значение~$sp$ из~$bp$
(рис.~\ref{ris:call-stack-var-bp}, а)--д).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-var-bp-abv}
}

\caption{Размещение локальных переменных в~стеке (устаревший вариант)}
\label{ris:call-stack-var-bp}
\end{illustration}%
Это удлиняло пролог и~эпилог за счёт необходимости сохранять и~восстанавливать исходное значение~$bp$.
Кроме того, при этом невозможно использовать~$bp$ для других целей.

Размещение локальных переменных происходит внутри вызываемой подпрограммы и~не затрагивает данные вызывающей программы.
При ручном программировании можно использовать как современную, так и~устаревшую форму пролога и~эпилога;
если все локальные переменные размещены в~регистрах, пролог и~эпилог вообще не требуются.

Следует отметить два момента:
\begin{itemize}
\item при компиляции с~языка высокого уровня порядок локальных переменных в~стеке может не совпадать с~порядком их объявления;
\item содержимое резервируемой в~стеке памяти, как и~начальное значение регистров, не определено, поэтому локальные переменные обязательно нужно инициализировать.
\end{itemize}

\subsubsection{Параметры и~возвращаемое значение}
\index{Стек}

Параметры  также могут передаваться в~подпрограмму через стек или регистры.
Вызывающая программа должна разместить параметры в~условленных местах до того, как управление будет передано подпрограмме.
Соответственно, параметры, передаваемые через стек, окажутся под адресом возврата, то есть будут иметь б\'{о}льшие адреса.

Возвращаемое значение функции не может передаваться вызывающей подпрограмме через стек, так как %оно должно быть записано на своё место до команды \lstinline!ret!, 
% возвращающей
% а~
% к~моменту возврата 
при выполнении команды~\lstinline!ret!
в~стеке не должно остаться ничего после адреса возврата.
Соответственно, возвращаемое значение может передаваться в~вызывающую подпрограмму только через регистр.

Иногда значение, которое, согласно синтаксису языка высокого уровня, является возвращаемым, не может быть размещено в~регистре (в~частности, это может быть объект).
В~этом случае зарезервированное для него место (или его адрес) фактически передаётся как ещё один параметр.


Таким образом, «настоящее» возвращаемое значение может быть только числом.
Если это целое число или указатель, 
в~программах для x86
для возврата используется регистр~$A$.
% если  разрядность результата превышает разрядность платформы "--- пара регистров $D:A$ (старшая часть в~$D$, младшая в~$A$).
% 
Вещественное значение возвращается через вершину стека математического сопроцессора $st(0)$\modifyone[{} или через $x/y/zmm0$]{}.

% В~языке высокого уровня функция может возвращать только одно значение.



\subsection{Соглашения о~вызовах}
\label{sec:calling-conventions}
\epigraph{
Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{\ZhvalevskijMytko}




% \footnote{Использованы материалы:
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.
% }
\index{Подпрограммы!соглашения о~вызовах}%

{Соглашение о~вызовах} определяет протокол взаимодействия вызывающей и~вызываемой программ;
в~частности, необходимо согласовать следующие правила.
% \vspace{-1\parskip}
\begin{enumerate}
\item Способ передачи параметров (через стек,\index{Стек} через регистры, смешанный; а~также используемые регистры и~их порядок).
\item Порядок размещения параметров в~стеке 
(%прямой порядок, или 
порядок Pascal подразумевает, что первый параметр помещается в~стек первым, 
% обратный порядок, или 
порядок C "--- что первый параметр помещается последним, непосредственно перед адресом возврата).
\item Как передаётся указатель $this%/self
$ (для методов объекта).

\item Какие регистры могут изменяться подпрограммой.
% Если 

\item Кто очищает стек и~сохраняет/восстанавливает регистры.

\item Инструкции вызова и возврата из подпрограмм.
\item Возврат значения из подпрограммы (функции).
\end{enumerate}



На платформе x86 для вызова и~возврата из подпрограммы используются соответственно команды \lstinline!call! и~\lstinline!ret!;
а~значение обычно возвращается через регистр~$A$.
Параметры обычно передаются либо через стек, либо смешанным способом: первые из тех, что можно разместить в~отведённых регистрах, передаются через регистры,
оставшиеся "--- через стек.
% Если 

% Возвращаемое значение:
% % \vspace{-1\parskip}
% \begin{enumerate}
% \item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
% \item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
% \end{enumerate}

Остальные пункты по-разному реализованы в~различных языках, компиляторах,  операционных системах
и~для различной разрядности.
% Также для передачи 
Подробно эти различия рассмотрены в~исследовании Агнера Фога~\cite{agner_fog_calling_conventions}.

% \subsubsection{}
В~таблице~\ref{tab:calling-conventions-32} приведены наиболее популярные соглашения о~вызовах, используемые на 32-битных платформах.
Регистры для передачи параметров используются в~указанном порядке.
Если столбец «Параметры в~регистрах» пуст, все параметры передаются через стек.\index{Стек}
Указатель $this$ обычно передаётся первым параметром.

\begin{table}[!ht]

\caption{Тридцатидвухбитные соглашения о~вызовах}
\label{tab:calling-conventions-32}

% \renewcommand\theadfont{\bfseries\small}
\renewcommand\theadfont{\bfseries\footnotesize}
% \newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{@{}l@{}}#1\end{tabular}}}}

% \scriptsize
% \footnotesize

\singlespacing
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|>{\theadfont}L|L|l|L|L|L|
}
\hline
\theadlong{Соглашение} &\tdhead{Параметры\\в~регистрах}	&%\theadlong{Порядок}	
\tikz[baseline]\node[rotate=90] {\theadlong{Порядок}};
&\theadlong{Очистка стека}
% &\tikz[baseline]\node[rotate=90] {\theadlong{Изменяемые регистры}};
% &\tikz[baseline]\node[rotate=90] {\theadlong{Неизменяемые регистры}};
&\tdhead{Изменяемые\\регистры}
&\tdhead{Неизменяемые\\регистры}
\\\hline
cdecl		&	&	C	&	вызывающая программа
&\multirow{8}{*}{{$\begin{array}{l}eax, ecx, edx,\\st(0){-}st(7),\\x/y/zmm\end{array}$}}
&\multirow{8}{*}{{$\begin{array}{l}ebx, ebp,\\esi, edi\end{array}$}}
\\\cline{1-4}   
pascal		&	&	Pascal	&	функция			&&\\\cline{1-4}   
winapi (stdcall)&	&	C	&	функция			&&\\\cline{1-4}
gnu		&	&	C	&	this "--- функция, {остальные "---  вызывающая программа}	&&\\\cline{1-4}
gnu fastcall		&	$ecx, edx$	&	C	&	функция	&&\\\cline{1-4}
gnu regparm (3)		&	$eax, edx, ecx$	&	C	&	функция	&&\\\cline{1-4}
Borland fastcall	&	$ecx, edx$	&	Pascal	&	функция	&&\\\cline{1-4}
Microsoft fastcall	&	$ecx, edx$	&	C	&	функция	&&\\\hline
\end{tabularx}
\end{table}

Для соглашения gnu regparm можно указать количество параметров в~регистрах (от одного до трёх).

Кроме того, регистры делятся на те, которые подпрограмма может изменять по своему усмотрению 
(соответственно, если они используются в~вызывающей программе, вызывающей программе необходимо сохранить их перед обращение к подпрограмме и~восстановить после того, как подпрограмма закончит работу)
и~те, которые должны сохранить своё значение 
(если в~подпрограмме потребуется использовать один из таких регистров, то сохранить и~потом восстановить их исходное значение должна сама подпрограмма).

Согласно Фогу,  в~тридцатидвухбитных программах, как в~Microsoft Windows, так и~в~Unix-подобных операционных системах (GNU/Linux, BSD, Mac~OS~X),
подпрограмма может изменять 
регистры
$eax, ecx, edx,$ регистры сопроцессора $st(0)-st(7)$
и~регистры расширений $xmm/ymm/zmm.$
Неприкосновенными должны остаться $ebx, ebp$ и~$esi, edi.$

На~шестидесятичетырёхбитных платформах применяется всего два соглашения о~вызовах (таблица~\ref{tab:calling-conventions-64}).
К~сожалению, они несовместимы между собой.
Также для разных платформ теперь различается набор регистров, которые могут изменяться в~подпрограмме.
% В~таблице~\ref{tab:calling-conventions-64} приведены соглашения о~вызовах, используемые на 64-битных платформах.
Регистры для передачи параметров используются в~указанном порядке.
Указатель $this$ передаётся первым параметром.

\begin{table}[!ht]

\caption{Шестидесятичетырёхбитные соглашения о~вызовах}\index{Шестидесятичетырёхбитный режим}
\label{tab:calling-conventions-64}

\renewcommand\theadfont{\bfseries\footnotesize}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{@{}l@{}}#1\end{tabular}}}}

\singlespacing
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|L|L|l|L|L|L|
}
\hline
\theadlong{Соглашение} &\tdhead{Параметры\\в~регистрах}	&\tikz[baseline]\node[rotate=90] {\theadlong{Порядок}};	&\theadlong{Очистка стека}	
&\tdhead{Изменяемые\\регистры}	&	%\tdhead{Неприкосновенные\\регистры}
\tdhead{Неизменяемые\\регистры}
\\\hline
{\theadfont Microsoft Windows,} компиляторы MinGW, Microsoft, Intel	&	
% $rcx/zmm0,$
% $rdx/zmm1,$
% $r8/zmm2,$
% $r9/zmm3$
\begin{tabular}{@{}>{$}c<{$}@{$/$}>{$}c<{$}@{}}
rcx&zmm0,\\
rdx&zmm1,\\
r8&zmm2,\\
r9&zmm3 \\
\end{tabular}
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$ $r8{-}r11,$ $st(0){-}st(7),$ 
$x/y/zmm,$
кроме младших частей $6{-}15$
&
$rbx, rbp,$ $rsi, rdi,$ $r12{-}r15,$ $xmm6{-}xmm15$
\\\hline
% Unix-подобные (
{\theadfont GNU/Linux, BSD, Mac~OS~X,} компиляторы GCC, Intel	&	
% $rdi, rsi,$
% $rdx, rcx,$ 
% $r8, r9,$ 
\begin{tabular}{@{}>{$}c<{$}@{$~$}>{$}c<{$}@{}}
rdi,& rsi,\\
rdx,& rcx,\\
r8, & r9,\\
\end{tabular}
$zmm0{-}zmm7$
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$  $rsi, rdi,$ $r8{-}r11,$ $st(0){-}st(7),$ $x/y/zmm$
&
$rbx, rbp,$ $r12{-}r15$ 
\\\hline
\end{tabularx}
\end{table}

Как видно из таблицы~\ref{tab:calling-conventions-64}, в~64-битном режиме под разными операционными системами в~подпрограмме необходимо сохранять и~восстанавливать разные регистры.


\subsubsection{Вызов подпрограммы в~GAS}

На тридцатидвухбитной платформе в~GCC используются 
соглашения о~вызове gnu, cdecl, gnu fastcall, gnu regparm (0--3).
Для внешних функций с~отключённым декорированием  (\lstinline!extern "C"!)
применяется только cdecl, то есть: % все параметры передаются через стек.
\begin{itemize}%[wide=\parindent]

\item размещение аргументов исключительно \emph{в~стеке,}\index{Стек} без использования регистров, причём аргументы, меньшие 4 байт, расширяются до 4 байт;

\item размещение аргументов в~стеке %\emph{справа налево,} так 
таким образом,
что первый аргумент оказывается на вершине стека;
% (после вызова первый аргумент находится непосредственно под адресом возврата, как показано на рис.~\ref{ris:cdecl-stack});

\item очистка стека выполняется \emph{вызывающей программой,} так что
в~функции 
аргументы должны не сниматься со стека, а~копироваться оттуда.


\end{itemize}
Размещение аргументов в~стеке {справа налево} и~очистка стека вызывающей программой позволяет определить функции с~переменным количеством аргументов, такие, как  \lstinline!printf! и~\lstinline!scanf! из стандартной библиотеки \lstinline!C! \modifytwo[(stdlib)]{}, но надо помнить о~небезопасности таких функций.

% Адрес возврата принято передавать через стек
При вызове функции в~стек сначала помещаются аргументы в~соответствии с~соглашением о~вызовах, 
а~затем команда вызова кладёт сверху адрес возврата.
Соответственно, когда функция получает управление, 
% http://trubetskoy1.narod.ru/arttranslate/FuncCallPart2_1.html
то первые четыре байта по адресу, хранящемуся в~$sp$, будут содержать адрес возврата. 
Далее идут аргументы функции. При использовании соглашения о~вызовах \lstinline!cdecl!
непосредственно за адресом возврата (по адресу $sp + 4$) будет находиться первый параметр,
% следующие 4 байта (т.\,е. 4 байта по адресу $\text{\ESP} + 4$) будут содержать первый параметр, 
% в четырёх байтах по адресу $\text{\ESP} + 8$ будет второй параметр
за ним идёт второй 
и~т.\,д. (рис.~\ref{ris:cdecl-stack})

\begin{illustration}
\resizebox{\approvedImageWidth}{!}{
\schemafont
\input{book/drawings/cdecl-stack}
}

\caption{Параметры и~адрес возврата в~соглашении cdecl}
\label{ris:cdecl-stack}
\end{illustration}%

Регистры $B, bp, si, di$ не~должны изменяться подпрограммой.
% 
Возврат значения по возможности выполняется через регистры:
\begin{itemize}
\item $eax$, если результат "--- указатель или целое число до 4 байт (если результат меньше 4~байт, старшую часть $eax$ необходимо обнулить);
\item пара регистров $edx:eax$, если результат "--- целое число размером 8~байт;
\item вершина стека сопроцессора, если результат "--- вещественное число;

если результат не помещается в~регистры, возвращается указатель на него (через $eax$).
\end{itemize}

На шестидесятичетырёхбитной платформе в~GCC для любых функций,
в~том числе внешних  с~отключённым декорированием  (\lstinline!extern "C"!),
используется соглашение, соответствующее операционной системе.


\subsection{Описание функций на ассемблере}
\label{sec:gas-functions}
\epigraph{
Итак, в~предыдущих главах вы узнали о~сути колдовства, секрете вечного счастья и~основных правилах техники безопасности. 
}{\ZhvalevskijMytko}

Пусть требуется описать функцию, рассчитывающую для целых беззнаковых чисел $x,y$ значение $z = 1 + x/8 + y$.
%
На языке высокого уровня она будет иметь вид, приведённый в~листинге~\ref{lst:sample:foo.cpp}.
\begin{lstlisting}[caption=Функция на языке C++, label=lst:sample:foo.cpp]
unsigned foo(unsigned x, unsigned y)
{
    return 1 + x/8 + y;
};
\end{lstlisting}

Так как делитель $8 = 2^3$ является степенью двойки, деление $x/8$ можно заменить беззнаковым сдвигом $x >> 3$.

В~принципе, если функция предназначена для использования внутри ассемблерного файла и~гарантированно не будет вызываться языком высокого уровня, она может и~не соответствовать стандартным соглашениям о~вызове.
% Это может использоваться для реализации 
Таким образом, можно реализовать собственные нестандартные соглашения, %связывающие 
позволяющие, в~частности, передать параметры через регистры даже на тридцатидвухбитной платформе или вернуть несколько результатов в~разных регистрах.

Тем не менее, если нестандартного поведения от функции не требуется, лучше использовать стандартные соглашения,
так как в~перспективе может понадобиться вызвать функцию из модуля на ЯВУ.

\subsubsection{Описание функции (cdecl)}

% На тридцатидвухбитной платформе 
% Соответственно, в~
Пусть используемая платформа тридцатидвухбитна и~используется соглашение \lstinline!cdecl!.
Тогда на ассемблере код, рассчитывающий и~возвращающий значение $z = 1 + x/8 + y = x/8+y+1$, в~простейшем случае выглядит как в~листинге~\ref{lst:sample:foo.S}.

\begin{lstlisting}[caption=Простейшая функция на ассемблере, label=lst:sample:foo.S]
foo:
  movl 4(%esp), %eax	// eax = x
  shrl $3, %eax		// eax >>= 3
  addl 8(%esp), %eax	// eax +=y
  incl %eax		// ++eax
  ret		// возврат управления вызывающей программе
\end{lstlisting}

% Директива \lstinline!.globl! делает функцию   $sqr()$ видимой для внешних модулей.
В~первой строке находится метка, показывающая начало функции $foo()$.

Параметры, в~соответствии с~соглашением \lstinline!cdecl!, находятся в~стеке;\index{Стек}
при этом стек в~GNU/Linux по умолчанию выравнен по $long$, то есть любое не более чем тридцатидвухбитное значение должно занимать 32 бита.

Таким образом, на вершине стека (ячейка \lstinline!(%esp)!) находится адрес возврата; 
в~ячейке памяти, смещённой на четыре байта относительно вершины стека $sp$\index{Стек} (по адресу $sp + 4$, что обозначается как \lstinline!4(%esp)!) "--- первый параметр $x$, 
по адресу $sp+8$ (ячейка \lstinline!8(%esp)!) "--- второй параметр $y$.
Оба параметра тридцатидвухбитны.
% , так что %расширение не требуется.
% их размер совпадает с~размером 

Команда \lstinline!movl 4(%esp), %eax! копирует (move) четырёхбайтовый (что обозначается суффиксом~$l$, то есть $long$) параметр $x$  в~регистр~$eax$. 
\index{Команды!mov}%
Следующая команда выполняет беззнаковый, или логический сдвиг вправо (shift right) на три бита, что эквивалентно беззнаковому делению на $8$.
После этого к~$eax$ добавляются параметр $y$ и~единица.

Возвращаемое значение, согласно соглашению, \lstinline!cdecl!, должно находиться в~регистре $eax$;
результат вычислений находится именно там. 
В~стеке нет ничего над адресом возврата, поэтому далее
% Затем 
следует возврат из функции (ret).


% Функция $sqr()$ принимает единственный параметр $x$ типа $int$ (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком),
% то есть этот параметр занимает четыре байта и~должен непосредственно следовать за адресом возврата (то есть находиться по адресу $sp+4$).
% % т.\,е. четыре байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $sp + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.
% 
% % Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, 
% После умножения результат %(квадрат аргумента)
% $x^2$
% находится в~регистре~$A$,
% через который и нужно вернуть значение.
% Таким образом, сразу после команды умножения можно выйти из функции командой \lstinline!ret!.

\subsubsection{Вызов функции (cdecl)}

Вызов описанной функции, в~частности, расчёт значения $foo(17, 2)$, выглядит следующим образом (листинг~\ref{lst:sample:call-foo}).
\begin{lstlisting}[caption=Вызов функции $foo()$, label=lst:sample:call-foo]
pushl $2	// второй параметр
pushl $17	// первый параметр
call foo	// вызов подпрограммы foo
add $8, %esp	// очистка стека от параметров
\end{lstlisting}


Команда \lstinline!call!, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
Она только помещает в~стек\index{Стек} адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.

Таким образом, перед вызовом функции командой \lstinline$call$ параметры необходимо вручную поместить  туда, где их ожидает увидеть подпрограмма.
Для соглашения \lstinline!cdecl! они должны находиться в~стеке. %, куда помещаются командой push 
% в~обратном порядке.
Соответственно, фактические параметры $17$ и~$2$ нужно загрузить в~стек как четырёхбайтовые целые числа, что и~делает команда \lstinline!pushl!.

После завершения работы такой функции параметры необходимо вручную удалить из стека;
для этого к~указателю стека добавляется общий размер параметров "--- восемь байтов.

Возвращаемое значение типа $unsigned~int$ можно найти, в~соответствии с~соглашением о~вызове, в~регистре~$A$ ($eax$).

\subsubsection{Сохранение изменяемых функцией регистров}

Если вызывающая подпрограмма хранит какие-то долгоживущие данные в~регистре, изменяемом подпрограммой 
(для тридцатидвухбитных соглашений это $eax, ecx, edx,$ регистры сопроцессора $st(0)-st(7)$
и~регистры расширений $xmm/ymm/zmm$), их необходимо сохранить перед вызовом функции
и~восстановить после её завершения.

В~частности, в~листинге~\ref{lst:sample:call-foo-savereg} сохраняется и~восстанавливается регистр $eax$.
Так как в~этом регистре по соглашению после выхода из функции содержится её возвращаемое значение, оно (если оно требуется вызывающей программе) должно быть скопировано или использовано до восстановления оригинального значения $eax$.

\begin{lstlisting}[caption=Вызов функции $foo()$ с~сохранением $eax$, label=lst:sample:call-foo-savereg]
z: .long 0
...
pushl %eax	// сохранение eax
pushl $2	// второй параметр
pushl $17	// первый параметр
call foo	// вызов подпрограммы foo
add $8, %esp	// очистка стека от параметров
movl %eax, z	// z = foo()
popl %eax	// восстановление eax
\end{lstlisting}

При этом значения регистров, которые по соглашению могут быть изменены функцией, необходимо сохранять, даже если текущая реализация конкретной функции $foo()$ их не меняет (в~следующей версии функции они могут быть использованы).

Наилучшим выходом будет %не использовать изменяемые функциями регистры для хранения долгоживущих переменных.
использовать изменяемые функциями регистры только как временные
и~не хранить там долгоживущие переменные.

\subsubsection{Локальные переменные}

Пусть требуется использовать в~функции $foo()$ локальную переменную $t$.
Например, зададим вначале  $t=1$, затем добавим к~этому значению $x/8$ и~$y$
(хотя для таких простых вычислений введение переменной в~памяти явно избыточно, данная функция не использует даже всех разрешённых по соглашению регистров).
Получим листинг~\ref{lst:sample:foo-t}.

\begin{lstlisting}[caption=Функция с локальной переменной, label=lst:sample:foo-t]
foo:
  pushl $1	// пролог: создание t = 1
  
  movl 8(%esp), %eax	// eax = x
  shrl $3, %eax		// eax >>= 3
  addl %eax, (%esp)	// t += eax (t = 1 + x/8)
  
  movl 12(%esp), %eax	// eax = y
  addl %eax, (%esp)	// t += eax (t = 1 + x/8 + y)

  movl (%esp), %eax	// eax = t
  add $4, %esp	// эпилог: уничтожение t
  ret
\end{lstlisting}

У функции появляются пролог и~эпилог. В~листинге~\ref{lst:sample:foo-t} показана современная форма пролога и~эпилога, \modifytwo[используемая,]{} когда все локальные переменные и~параметры адресуются через $sp$.

\modifytwo[Так как после пролога (создания стековой локальной переменной $t$) значение указателя стека~$sp$ уменьшилось на $sizeof(t)=4$, смещения параметров $x$ и~$y$ относительно $sp$ здесь отличаются от листинга~\ref{lst:sample:foo.S} (увеличились на те же $4$ байта).]
{Так как указатель стека~$sp$ изменён, смещения параметров относительно $sp$ также изменились.}

\subsection{Импорт функций из модулей на ассемблере в~код на C++}
\label{sec:gas-extern}

\epigraph{
Вы представляете, какой жест при взмахе волшебной палочкой выглядит наиболее эффектно, куда~её~направлять в~начальной фазе ворожбы и~куда~прятаться, если она вдруг заработает.
}{\ZhvalevskijMytko}

   
% \section{Подключение модуля на ассемблере к~C++-проекту}
% \index{Подключение модуля на ассемблере}%
Функции, описанные в~ассемблерном модуле, необходимо описать в~коде C++ как внешние (\lstinline!extern!).
После спецификатора \lstinline!extern!, согласно стандарту C++, могут быть указаны строки \lstinline!"C++"! (подразумевается по умолчанию) или \lstinline!"C"! (различные компиляторы могут поддерживать и~иные строки) для указания компоновщику, какой язык использовался при написании внешней функции.
Конкретные свойства таких функций не описываются в~стандарте. На практике \lstinline!"C++"! подразумевает %декорирование (mangling) имён функций
искажение имён функций до неузнаваемости (что подробнее описано в~%предыдущем 
разделе~\ref{sec:mangling})
и\modifytwo[, для тридцатидвухбитных систем,
{}]{~}передачу параметров по возможности через регистры, что реализуется в~разных компиляторах по-разному.
% 
Указание \lstinline!"C"! %на практике
уменьшает искажение имён и~для тридцатидвухбитных платформ
подразумевает соглашение о~вызовах \lstinline!cdecl!\modifytwo[{} 
(для шестидесятичетырёхбитных платформ C-функции, как и~C++-функции, следуют соглашению, соответствующему операционной системе)]{}.

Рассмотрим функцию $int~sqr(int~x)$, вычисляющую квадрат целого числа на тридцатидвухбитной платформе GNU/Linux~\cite{opennet.ru/base/dev/from_c_to_asm}.
% \lstset{language=[Motorola68k]Assembler}
Текст ассемблерного модуля \programname{sqr.S} с~текстом функции
% \footnote{
% Использованы материалы статьи Hiran Ramankutty «От C к~Ассемблеру», перевод: Андрей Киселев
% } 
% находится в~файле \programname{sqr.S} % (так как здесь нет необходимости в~препроцессинге, можно было использовать также имя \programname{sqr.s})
приведён в~листинге~\ref{lst:sqr.S}.

\index{Команды!ret}%
\index{Команды!mov}%
\index{Команды!imul}%
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
\end{lstlisting}

% В~следующей строке находится метка, показывающая начало этой функции.
% 
% Команда \lstinline!movl 4(%esp), %eax! копирует (move) четыре байта (что обозначается суффиксом~$l$) из ячейки памяти, смещённой на четыре байта относительно вершины стека $sp$\index{Стек} (по адресу $sp + 4$), в~регистр~$A$. 
% \index{Команды!mov}%
% Следующая команда выполняет умножение $A ~{*}{=}~ A$.
% Затем следует возврат из функции.



Функция $sqr()$ копирует единственный параметр $x$ типа $int$ (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком)
из стека \modifytwo[(соглашение \lstinline!cdecl!)]{} в~регистр $A$, затем умножает \modifytwo[его]{$eax$} сам на себя\modifytwo[.
Результат $x^2$ при этом остаётся в~регистре~$A$. По соглашению значение функции возвращается именно через этот регистр, так что дополнительных действий для формирования возвращаемого значения предпринимать не нужно;
сразу после умножения управление возвращается]{
и~возвращает управление} вызывающей программе.
% то есть этот параметр занимает четыре байта и~должен непосредственно следовать за адресом возврата (то есть находиться по адресу $sp+4$).
% % т.\,е. четыре байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $sp + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.

% % Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, 
% После умножения результат %(квадрат аргумента)
% $x^2$
% находится в~регистре~$A$,
% через который и нужно вернуть значение.
% Таким образом, сразу после команды умножения можно выйти из функции командой \lstinline!ret!.

% Если в~файле несколько функций, можно указать для отладчика их границы.
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S:endfunc]
% .globl sqr
% .func sqr
%         sqr:
%                 movl 4(%esp), %eax
%                 imull %eax, %eax
%                 ret
% .endfunc
% \end{lstlisting}
% Парные директивы .func  $\ldots$  .endfunc не влияют ни на что, кроме добавления некоторой отладочной информации при сборке в~отладочном режиме.
% В~режиме Release игнорируются.

% В~шестидесятичетырёхбитном GNU/Linux  тип $int$ часто 32-битен
% $di$
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
% .globl sqr
%         sqr:
%                 movl %edi, %eax
%                 imull %eax, %eax
%                 ret
% \end{lstlisting}

Директива \lstinline!.globl! делает функцию   $sqr()$ видимой для внешних модулей.


Основной файл \programname{main.cpp} содержит импорт функции  $sqr()$ %как \lstinline!extern "C"!
и~её вызов
из головной функции $main()$.
% Функция \lstinline!sqr! может использоваться так же, как и~функция, описанная на языке C++ (кроме перегрузки).
\begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:main.cpp]
#include <iostream>

using namespace std;
extern "C" int sqr(int x);

int main()
{
    int x=2, y;
    y = sqr(x);
    cout << y <<endl;
    return 0;
}
\end{lstlisting}

Для импорта функции из другого объектного файла здесь она описана как внешняя (\lstinline!extern "C"!).
% 
В~GNU/Linux имена внешних C-функций не искажаются, поэтому в~модулях \programname{main.cpp} и~\programname{sqr.S}
используется одно и~то же имя~$sqr()$.


\modifytwo[
В~шестидесятичетырёхбитных системах импорт функций в~код на C++ выполняется таким же образом.
% При этом в~описании функции в~ассемблерном файле 
В~ассемблерном файле экспорт имени выполняется так же, как и~в~листинге~\ref{lst:sqr.S},
% будут отличия: 
а~вот параметры шестидесятичетырёхбитной функции извлекаются не из стека, а~из регистров (это связано с~тем, что используются соглашения о~вызовах, отличные от \texttt{cdecl}).
% Это связано с~тем, что %на шестидесятичетырёхбитных платформах 
% используются соглашения о~вызовах, отличные от \texttt{cdecl}.
]{}


% \subsection{Импорт внешних функций в~подпрограмму на ассемблере}
\subsection{Импорт функций из модулей на C++ в~код на ассемблере}
% \subsection{Экспорт функций из C++}

\epigraph{
Если заклинание не сработало нужным образом, обратитесь к разработчику. Возможно, вы неправильно его активировали (заклинание, а~не~разработчика).
}{\ZhvalevskijMytko}


Подпрограмма на ассемблере может обращаться не только к~другим подпрограммам из того же модуля на ассемблере, 
но и~к~внешним, в~частности, к~функциям из других объектных файлов проекта или к~стандартной библиотеке stdlib.

Для того, чтобы функция, описанная на языке C++, была доступна для экспорта в~другие модули, используется ключевое слово extern, как и~для импорта внешних функций (для отключения декорирования также используется \lstinline!extern "C"!):
% \begin{lstlisting}
% /*@\colorbox{codestronghighlight}{extern "C"{}}@*/
% __attribute__((__cdecl__)) 
% int /*@\colorbox{codehighlight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
\begin{lstlisting}[caption=Файл \programname{bar.cpp}, label=lst:demangle:bar.cpp]
extern "C" int bar(int x)
{
    return 3*x+1;
};
\end{lstlisting}
% Декорирование C++-функций делает их имена неопознаваемыми, поэтому на практике при экспорте функций лучше использовать только "C" 
% Соглашение о~вызове на всякий случай указано явно с~использованием ключевого слова \lstinline!__attribute__!, но чаще всего для использования cdecl достаточно\lstinline!extern "C"!. 

Для импорта функции в~ассемблере не требуется никаких директив, достаточно знать её имя.
\modifytwo[Для работы с~параметрами, если они есть, необходимо также знать соглашение о~вызове.
Для тридцатидвухбитных систем и~C-функций это \lstinline!cdecl!, то есть параметры передаются через стек.
]{}
% \begin{lstlisting}
% pushl $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}

\index{Команды!push}%
\index{Команды!call}%
\index{Команды!add}%
\begin{lstlisting}[caption=Фрагмент файла \programname{main.S}, label=lst:main.S]
pushl $1
call bar
add $4, %esp
\end{lstlisting}
Приведённый фрагмент кода рассчитывает $bar(1)$.
% 
% Команда \lstinline!call!, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
% Она только помещает в~стек\index{Стек} адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.
% 
% Таким образом, перед вызовом функции командой \lstinline$call$ параметры необходимо вручную поместить  туда, где их ожидает увидеть подпрограмма.
% Для соглашения cdecl они должны находиться в~стеке. %, куда помещаются командой push 
% % в~обратном порядке.
% Соответственно, единицу нужно загрузить в~стек как четырёхбайтовое целое число, что и~делает команда \lstinline!pushl $1!.
% 
% После завершения работы такой функции параметры необходимо вручную удалить из стека;
% для этого к~указателю стека добавляется размер параметров "--- четыре байта.
% 
% % 
\modifytwo[Возвращаемое значение типа $int$ можно найти, в~соответствии с~соглашением о~вызове, в~регистре~$A$.]{}

% Необходимо всегда помнить о~том, что после вызова функции значения многих регистров меняется.

Здесь также во всех модулях используется одно и~то же имя $bar$,
так как 
в~GNU/Linux имена внешних C-функций не искажаются.

Все функции стандартной библиотеки C (stdlib) описаны как  внешние C-функции, поэтому их также можно, аналогично функции $bar()$, вызывать по оригинальному (в~GNU/Linux "--- вообще неискажённому) имени.

При вызове функции с~несколькими параметрами
\modifytwo[на тридцатидвухбитной платформе]{}
необходимо помнить, что
в~соответствии с~соглашением \lstinline!cdecl! они должны находиться в~стеке в~обратном порядке.\index{Стек}
\begin{lstlisting}[caption={Вывод двух чисел на экран}, label=lst:demangle:printf]
fmt: .string "Переменные: %d, %d\n"
foo: .int 13
...
// printf(fmt, 19, foo)
pushl foo	// Значение foo в стек
pushl $19	// Значение 19 в стек
pushl $fmt	// Адрес строки fmt в стек
call printf
addl $3*4, %esp // Три четырёхбайтовых числа из стека  
\end{lstlisting}
Приведённый код выведет на экран сообщение «Переменные: 19, 13».

\modifytwo[На шестидесятичетырёхбитной платформе параметры передаются через регистры в~соответствии с~операционной системой (раздел \ref{sec:calling-conventions}).]{}


\subsection{Искажение имён при компиляции}
\label{sec:mangling}
\epigraphcensored[
\epigraph{
% Хотя грустил он по другому поводу: 
...Подразделение было секретным и~для конспирации его фамилию официально сокращали до одной буквы "--- О. Теперь лейтенант скучал по прежней фамилии, которая состояла из тринадцати букв и~начиналась с~«3».
}{\ZhvalevskijMytko}
]{
\epigraph{
"--* Как вы его зовёте?

"--* Штырь.

"--* Ну и~имечко!

"--* А~что такое? Уменьшительное от Алджернон.
}{П.\,Г.\,Вудхауз}
}

Имена функций, задаваемые программистом, в~процессе компиляции искажаются;
наиболее заметные изменения связаны с~процессом \termin{декорирования} (name mangling).\index{Декорирование}
Механизм декорирования имён отсутствовал в~языке~C.
Язык C++, в~отличие от C, поддерживает перегрузку функций, то есть программа, написанная на C++, 
может содержать множество функций, носящих одно и~то же имя.
При этом на этапе компоновки для корректной сборки программы у~каждой функции должно быть уникальное имя.
Соответственно, на этапе компиляции в~имя каждой функции включается информация о~всех её параметрах (явных и~неявных),
причём так, что в~изменённом  имени используются только допустимые символы.

Алгоритм декорирования не стандартизирован;
различные компиляторы для различных платформ используют разные схемы.

Декорирование имён можно отключить вместе с~возможностью перегрузки,
объявив функцию  внешней C-функцией \lstinline!extern "C"!.
Большинство современных операционных систем вообще не искажает имён таких функций\modifytwo[{} (рис.~\ref{ris:cpp-mangling}, а)]{}.
% но на некоторых платформах искажение имён 
В~Microsoft Windows к~имени функции даже при отключённом декорировании
может быть приписан префикс или суффикс.
Конкретный способ искажения зависит от разрядности, компилятора и~версии Windows.

Чаще всего в~Microsoft Windows при компиляции к~именам добавляется  префикс \lstinline!_! (ведущее нижнее подчёркивание).
Имена функций стандартной библиотеки stdlib  также подвергаются искажению (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).
На некоторых (но не на всех) 64-разрядных версиях Microsoft Windows при использовании GCC имена не искажаются.

Если имя функции искажается компилятором,
описанный в~предыдущих разделах код вызовет ошибку компоновки\modifytwo[{} (рис.~\ref{ris:cpp-mangling}, б)]{}.\index{Компоновка}


\newcommand{\foocompile}[4]
{
\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=22ex,text badly centered, minimum height=4ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white, minimum height=3ex]

\node[file,on chain=cpp] (prog1_cpp) {extern "C"\ int foo()};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {extern "C"\ int foo()};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {#1};
  
  \ifthenelse{\isempty{#4}}{}{  
  \node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
  \node[file,on chain=cpp] (prog1_o) {#1};
  \node[stage,on chain=cpp] (cpp_linker) {Компоновщик};

  \node[fit=(prog1_cpp), inner sep=0ex] (cpp_box) {};
  \coordinate[right=0ex of cpp_box] (cpp_egde);
  }


\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {#2};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {#3};
  \ifthenelse{\isempty{#4}}{}{  
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {#3};
\node[stage,on chain=S] (S_linker) {Компоновщик};

\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  

\node[file,below= of linker] (prog) {#4};
\path[blockarrow] (linker) -- (prog);
}
\end{tikzpicture}
}
}

\begin{illustration}
\begin{tabularx}{\linewidth}{@{}CC@{}}
\foocompile{foo}{foo}{foo}{Исполняемый файл}
&
\foocompile{\_foo}{foo}{foo}{Ошибка компоновки}
\\
а)& б)\\
\end{tabularx}

\caption{Компиляция C-функции 
без искажения имён 
% в~GNU/Linux, BSD и~некоторых 64-разрядных версиях Microsoft Windows 
(a) и~с~искажением, принятым в~большинстве версий \mbox{Microsoft Windows} (б)}
\label{ris:cpp-mangling}
\end{illustration}


% Также \lstinline!extern "C"! подразумевает
% % \item 
% \emph{отсутствие декорирования имён,} % "--- имена функций воспринимаются линкером «как есть»
% % что позволяет не задумываться о~том, как имя, используемое линкером, складывается из имени, данного разработчиком и~характеристик аргументов функции,
% % но делает невозможной перегрузку таких функций.
% что  в~GNU/Linux значит, что имена не будут изменяться компилятором вообще;
% в~Microsoft Windows искажение имён зависит от разрядности, компилятора и~версии Windows.
% Чаще всего при компиляции к~именам добавляется  префикс \lstinline!_!



Если используемый компилятор для данной платформы изменяет имена внешних C-функций, %упоминаемых в~модулях C++, 
например, добавляет префикс \lstinline!_!, как в~случае gcc (mingw) под Microsoft Windows, то ссылка на внешнюю функцию %\lstinline!sqr! 
\lstinline!extern "C" int sqr(int x)!, упоминаемую в~некотором cpp-файле, %к~моменту компоновки 
в~соответствующем объектном файле
будет выглядеть как \lstinline!_sqr!.
Таким образом, для корректной компоновки под Microsoft Windows имя данной функции в~объектном файле, полученном из ассемблерного модуля,  также должно быть \lstinline!_sqr!.
Так как на этапе ассемблирования имена не искажаются ни на какой платформе,
это означает, что в~ассемблерном модуле имя также должно выглядеть как  \lstinline!_sqr!.

При этом в~других операционных системах имена не искажаются,
так что для корректной компоновки в~GNU/Linux имя этой же функции должно выглядеть как \lstinline!sqr!.

Если речь идёт об импорте в~C++ функции, описанной на ассемблере, 
то в~ассемблерном файле можно указать оба варианта имени (листинг~\ref{lst:demangle:sqr:S}).
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:demangle:sqr:S]
% /*@\colorbox{clExportLight}{.globl sqr}@*/
% /*@\colorbox{clExportLight}{.globl \_sqr}@*/
% /*@\colorbox{clFuncnameLight}{sqr:}@*/
% /*@\colorbox{clFuncnameLight}{\_sqr:}@*/
%   movl 4(%esp), %eax
%   imull %eax, %eax
%   ret
% \end{lstlisting}
\begin{lstlisting}[caption=Файл \programname{sqr.S}: экспорт вариантов без искажения и~с~ним, label=lst:demangle:sqr:S]
.globl sqr
.globl _sqr
sqr:
_sqr:
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
В~этом случае код на C++  (листинг~\ref{lst:main.cpp}) соберётся с~модулем~\ref{lst:demangle:sqr:S} как под GNU/Linux или BSD,
так и~под Microsoft Windows,
но это не лучшее решение.
% \begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:demangle:sqr:cpp]
% #include <iostream>
% 
% using namespace std;
% /*@\colorbox{clExportLight}{extern "C"{} int sqr(int x);}@*/
% 
% int main()
% {
%   cout << /*@\colorbox{clFuncnameLight}{sqr(2)}@*/ << endl;
%   return 0;
% }
% \end{lstlisting}




% \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.
% % Имена 
% % C++ искорёжены почти до неузнаваемости, C — у меня сохранены, а у вас, если статья Фога не ошибатеся, к ним приписывается префикс _: _Sqr вместо Sqr (и было бы __Sqr вместо _Sqr, но такой функции в C++-программе нет).
% В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
% Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
% (в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).
% 
% Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
% В~статье Агнера Фога 
% «Calling conventions for different C++ compilers and operating systems»~\cite{agner_fog_calling_conventions}
% приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
% В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
% На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).






В~случае импорта в~программу на ассемблере функции из модуля на C++, в~частности, % одной из функций stdlib
% или 
функции $int~bar(int~x)$, описанной в~листинге~\ref{lst:demangle:bar.cpp},
уже невозможно описать два имени одновременно.
% \begin{lstlisting}[caption=Файл \programname{unit.cpp}, label=lst:demangle:unit:cpp]
% /*@\colorbox{clExportLight}{extern "C"{}}@*/ int /*@\colorbox{clFuncnameLight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
Вызов подобной функции из программы на ассемблере
будет выглядеть как \lstinline!call bar! под GNU/Linux или BSD и~как~\lstinline!call _bar! под тридцатидвухбитными и~некоторыми шестидесятичетырёхбитными версиями  Microsoft Windows.

Как правило, программа  вызывает 
% функции, импортированные из  модулей на C++, и~функции stdlib
% не в~одном месте, 
подобные функции из множества мест,
так что править её вручную затруднительно.

% Можно описать два варианта вызова с~помощью директив условной компиляции.
% Определим макрос-флаг \lstinline!#define ISPREFIX!, если имена искажаются 
% \begin{lstlisting}[caption=Фрагмент файла \programname{main.S}, label=lst:main.S]
% #ifdef ISPREFIX
% call _bar
% #else
% call bar
% #endif\end{lstlisting}

% 
% Фрагмент main.S (GNU/Linux, BSD)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}
% 
% Фрагмент main.S (MS Windows)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{\_bar}@*/
% addl $4, %esp
% \end{lstlisting}

Кроссплатформенности в~этом случае можно достичь использованием макросов для искажения имён в~\programname{.S}-файле вручную \modifytwo[{} (рис.~\ref{ris:cpp-demangling}, а) и~б)]{}.
Опишем макрос~\lstinline!FUNC_NAME! с~параметром $s$ "--- именем функции, который либо добавляет к~$s$ ведущее подчёркивание
(тогда его нужно описать как~\lstinline!#define FUNC_NAME(s) _##s!),
либо ничего с~$s$ не делает (\lstinline!#define FUNC_NAME(s) s!)
и~вместо имени функции, например, $bar$, будем указывать \lstinline!FUNC_NAME(bar)!.


\begin{illustration}
\begin{tabularx}{\linewidth}{@{}CC@{}}
\foocompile{foo}{FUNC\_NAME(foo)}{foo}{Исполняемый файл}
&
\foocompile{\_foo}{FUNC\_NAME(foo)}{\_foo}{Исполняемый файл}
\\
а)& б)\\
\end{tabularx}

\caption{Компиляция C-функции 
% в~GNU/Linux, BSD и~некоторых версиях Microsoft Windows (a) и~с~искажением, принятым в~большинстве версий Microsoft Windows (б)}
без искажения имён (a) и~с~компенсацией искажения (б)
}
\label{ris:cpp-demangling}
\end{illustration}

% В~этом случае для переноса с~GNU/Linux на Microsoft Windows в~случае 32-разрядных систем достаточно будет закомментировать 
% 
% для искажающих имена версий Microsoft Windows и~как~ для остальных операционных систем,
% будет преобразовывать имена в~необходимый вид.
% В~этом случае при переносе программы %с~GNU/Linux на 
% достаточно будет изменить описание макроса, чтобы
% вызов~\lstinline!call FUNC_NAME(bar)! или~\lstinline!call FUNC_NAME(printf)! всегда был корректным.

В~случае тридцатидвухбитных систем подчёркивание необходимо добавлять при работе под  Microsoft Windows
и~не нужно для остальных операционных систем.
Для этого можно воспользоваться предопределённым макросом препроцессора~\lstinline!_WIN32!:
\begin{lstlisting}
#ifdef _WIN32
#define FUNC_NAME(s) _##s
#else
#define FUNC_NAME(s) s
#endif 
\end{lstlisting}
Данное определение можно поместить в~начало ассемблерного файла с~расширением~\programname{.S}
или в~файл, включаемый в~него директивой \lstinline!#include!. %, так как 

После этого макрос~\lstinline!FUNC_NAME! можно применять для \modifytwo[компенсации]{} искажения имён во всех случаях
"--- при экспорте имени функции (листинг~\ref{lst:demangle:sqr:S:FUNC_NAME}):
\index{Команды!mov}%
\index{Команды!imul}%
\begin{lstlisting}[caption=Файл \programname{sqr.S}: кроссплатформенный экспорт, label=lst:demangle:sqr:S:FUNC_NAME]
.globl FUNC_NAME(sqr)
FUNC_NAME(sqr):
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
при импорте (листинг~\ref{lst:demangle:main.S:FUNC_NAME}):
\index{Команды!push}%
\index{Команды!call}%
\index{Команды!add}%
\begin{lstlisting}[caption=Фрагмент файла \programname{main.S}: кроссплатформенный импорт, label=lst:demangle:main.S:FUNC_NAME]
pushl $1
call FUNC_NAME(bar)
add $4, %esp
\end{lstlisting}
или при вызове библиотечных функций (листинг~\ref{lst:demangle:printfS:FUNC_NAME}).

\bottompagebreak
\begin{lstlisting}[caption={Вывод двух чисел на экран}, label=lst:demangle:printfS:FUNC_NAME]
pushl foo	// Значение foo в стек
pushl $19	// Значение 19 в стек
pushl $fmt	// Адрес строки fmt в стек
call FUNC_NAME(printf)
addl $3*4, %esp // Три четырёхбайтовых числа из стека  
\end{lstlisting}

Шестидесятичетырёхбитный перенос функций из GNU/Linux в~Microsoft Windows или наоборот сложнее.
Во-первых, не все шестидесятичетырёхбитные версии Microsoft Windows искажают имена, так что нужный вариант макроса \lstinline!FUNC_NAME!, возможно, придётся выбирать вручную.
Во-вторых,
если на тридцатидвухбитных платформах для внешних C-функций использовалось соглашение \lstinline!cdecl!, 
то здесь 
% в~шестидесятичетырёхбитных платформах используются разные
соглашения для разных операционных систем разные, 
так что для достижения кроссплатформенности придётся 
описать два варианта копирования параметров из регистров,
воспользовавшись директивами условной компиляции.

% В~дальнейшем все примеры будут рассматриваться без учёта искажения имён.









\subsection{Системные вызовы}
\index{Системные вызовы}%
\label{sec:sys-call}


\epigraph{
\begin{stanza}[0mm]
И дракон прочёл, наклоняя\\
Взоры к смертному в первый раз:\\
"--- Есть, владыка, нить золотая,\\
Что связует тебя и нас.\\
\end{stanza}
}{Н.\,C.\,Гумилёв}



Системный вызов (system call) "--- обращение прикладной программы к~ядру операционной системы для выполнения какой-либо операции.
В~принципе, системные вызовы соответствуют определению подпрограмм, но, так как ядро системы работает в~привилегированном режиме,
нельзя давать программе возможность передать управление на произвольный фрагмент кода ядра.
Соответственно, количество функций, выполняемых ядром, ограничено. %ядром операционной системы.
% так что 
Сами эти функции, как правило, пронумерованы 
% и~описаны в~документации.
и~для обращения к~ним необходим номер, а~не адрес.
Кроме того, для системных вызовов используются другие соглашения% о~вызове
; в~частности, вместо \lstinline!call!/\lstinline!ret! применяются другие команды вызова и~возврата%, позволяющие указать номер
.
\index{Команды!call}%
\index{Команды!ret}%

Для обращения к~ядру используются следующие способы:
\begin{enumerate}

\item Программное прерывание (команда \lstinline!int!) %/\lstinline!iret!
\index{Команды!int}%
 "--- этот способ доступен на всех x86-совместимых системах.
%  
Как правило, для вызова всех функций ядра используется какой-то один номер прерывания, 
а~номер самой функции передаётся через один из регистров.



\item 
% Начиная с~Pentium II, доступна предложенная Intel команда \lstinline!sysenter!, %/sysexit (Intel)
% ускоряющая обращение к~ядру.
Быстрый вызов ядра в~тридцатидвухбитном режиме выполняется командой \lstinline!sysenter!.
\index{Команды!sysenter}%

% В~шестидесятичетырёхбитном режиме использование \lstinline!sysenter! невозможно.

\item 
% Для быстрого обращения к~функциям ядра  в~шестидесятичетырёхбитном режиме применяется команда \lstinline!syscall!, %/sysret 
% (AMD, 64-битный режим Intel);
% предложенная AMD.
Быстрый вызов в~шестидесятичетырёхбитном режиме "--- командой \lstinline!syscall!.
\index{Команды!syscall}%

\end{enumerate}

% Таким образом, каждое 

\subsubsection{Системные вызовы различных ОС}
% \epigraph{
% "--- Просвещенья Дух! "--- возвысил голос Фантом. "--- Если ты будешь говорить с нами, стукни один раз!
% 
% "--- Плюх! "--- раздалось в ответ.
% 
% "--- А если не будешь, стукни два раза, "--- брякнул Гаргантюа.
% 
% "--- Плюх-плюх!
% }{Жвалевский/Мытько}
\index{Системные вызовы}%

Как и~для функций, соглашение о~вызовах описывает команду вызова, а~также передачу параметров и~возврат значения.
% , а~также правила использования регистров.
% 
Ядра~различных операционных систем %по-разному 
поддерживают различные соглашения.
\begin{itemize}

\item к~ядру Linux на платформе x86 можно обратиться по программному прерыванию \lstinline!int 0x80!,
на x86-64 "--- с~помощью команды \lstinline!syscall!,
номер функции и~параметры передаются в~регистрах;
\index{Команды!int}%
\index{Команды!syscall}%

\item BSD на x86 также использует  \lstinline!int 0x80!, номер функции в~регистре $eax$, параметры в~стеке;

\item FreeDOS предоставляет большую часть функций через \lstinline!int 0x21!, также используются \lstinline!int 0x20! (завершение программы), \lstinline!int 0x29! (печать символа), \lstinline!int 0x2E! (выполнение команды).
\end{itemize}

В~большинстве операционных систем функции, выполняемые ядром, документированы и~могут быть напрямую вызваны прикладной программой.
Операционная система Microsoft Windows, напротив, скрывает их и~меняет от версии к~версии как сами функции, так и~механизм их вызова.
Прикладным программам предлагается использовать обёртки для обёрток над обёртками системных вызовов ядра Windows "--- функции Windows API из разделяемых библиотек.

Тем не менее, в~различных источниках сообщается, что линейка
% \begin{itemize}
% \item 
Microsoft Windows NT/2000/XP/2003/Vista  использует прерывание \lstinline!int 0x2E!,
% \item 
а~в~Microsoft Windows XP/7/8  для обращения к~ядру используется команда \lstinline!sysenter! в~тридцатидвухбитной версии и~\lstinline!syscall! в~шестидесятичетырёхбитной.
% \end{itemize}
\index{Команды!int}%
\index{Команды!sysenter}%
\index{Команды!syscall}%

\subsubsection{Системные вызовы Linux}
% \epigraph{\begin{stanza}
% По пояс в траве босыми ногами\\
% Вот мы пришли, мы танцуем с богами.
% \end{stanza}
% }{\Aquarium}
\index{Системные вызовы}%

% \subsubsection{Параметры системных вызовов Linux}

Для обращения к~ядру Linux в~тридцатидвухбитном режиме используется вызов программного прерывания
% прерывание 
\lstinline!int 0x80!,
\index{Команды!int}%
при этом в~регистре $eax$ должен быть  номер функции.
% 
В~частности, номеру~$1$ соответствует вызов $sys\_exit()$, 
% 1 "--- 
% exit, %\hfill
% \lstinline!%ebx! "--- код завершения
% 
$2$ "--- $sys\_fork()$,
% 
$3$ "--- $sys\_read()$,
% 
$4$ "--- $sys\_write()$ и~т.\,д.
% \\
% ...

Системный вызов принимает 
до шести аргументов в~регистрах $ebx$, $ecx$, $edx$, $esi$, $edi$, $ebp$.
В~частности, при завершении программы системным вызовом $sys\_exit()$ ($eax=1$) в~$ebx$ должен находиться единственный параметр этого вызова "--- код завершения программы.
% 
Если требуется передать функции ядра от семи параметров и~выше, из них формируется структура, адрес которой передаётся в~$ebx$.

Результат помещается в~$eax$.

В~шестидесятичетырёхбитном режиме обращение к~ядру Linux выполняется командой \lstinline!syscall!.
\index{Команды!syscall}%
Номер вызова также должен быть в~регистре $rax$, но сами номера иные, чем для тридцатидвухбитного ядра:
$0$ "--- $sys\_read()$,
$1$ "--- $sys\_write()$,
$2$ "--- $sys\_open()$,
$3$ "--- $sys\_close()$ и~т.\,д.

Параметры передаются в~регистрах $rdi$,	$rsi$,	$rdx$,	$r10$,	$r8$,	$r9$.

Возвращаемое системным вызовом значение помещается в~$rax$.




% восстанавливаем стиль block
\input{\COMMONPATH/4espdblocks.tex}



% \section{Простые вычисления}
% \epigraph{
% Конструктор Трурль построил однажды мыслящую машину "--- девятиэтажную; окончив самую важную работу, он покрыл машину белым лаком, 
% наугольники покрасил в~лиловый цвет, пригляделся потом издали и~добавил еще небольшой узорчик на фасаде, а~там, где можно было вообразить лоб машины, провёл тонкую оранжевую чёрточку и, очень довольный собой, небрежно посвистывая, задал порядка ради сакраментальный вопрос: сколько будет дважды два?
% }{С.\,Лем}



% \section{Ветвления и~циклы}






\section{Программирование нелинейных алгоритмов и~взаимодействие со структурами данных}
\label{sec:asm-alg}

\epigraphcensored[
\epigraph{Козебар Мат характеризуется совершенной неприменимостью любых логических концепций к~паттернам происходящего в~этот период. \\То есть "--- происходящее ясно, но не поддаётся линейному описанию.}
{\Aquarium}
]{
\epigraph{\begin{stanza}
В~действительности всё не так, как на самом деле.
\end{stanza}}
{%Станислав Ежи Лец (а~может быть, и~Антуан де Сент-Экзюпери)
% уже фольклор
Приписывается Станиславу~Ежи~Лецу и~Антуану~де~Сент-Экзюпери.
Фольклор, в~общем
}
}
В~языках высокого уровня существуют
% такие алгоритмические конструкции, как ветвления и~циклы,
операторы цикла и~условные операторы,
используемые для реализации нелинейных алгоритмов.
% Они, как и~
% Язык ассемблера не
Система машинных команд предлагает 
только команды условного и~безусловного перехода 
(хотя в~наборе команд x86 есть команда \lstinline!loop!, 
\index{Команды!loop}%
она 
% также является командой условного перехода, а~не цикла, 
не является полноценным аналогом цикла,
к~тому же не рекомендуется к~использованию из-за медленной работы).

Тем не менее, с~помощью команд перехода можно реализовать все нелинейные алгоритмические конструкции,
а~режим косвенной адресации позволяет обращаться к~элементам составных структур данных.
% 
Для визуализации нелинейных алгоритмов воспользуемся схемами программы~\cite{espd-alg}.

\subsection{Условие с~операторами в~одной ветви}
\epigraph{\begin{stanza}[0mm]
Мне нужно было всё, а иначе "--- нет.\\
Образцовый нищий, у Галери Лафайет;\\
Но я смотрел на эту ветку сорок пять лет,\\
\hspace{\stanzaoddindent}В конце концов, она взяла и взлетела. \\
\end{stanza}}
{\Aquarium}

Пусть необходимо заменить значение целой знаковой переменной $x$ нулём, если   оно отрицательно.
\begin{equation}
\label{eq:asm-alg:if}
x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.
\end{equation}

На языке C++ код, решающий эту задачу, будет использовать условный оператор (листинг~\ref{lst:asm:alg:if-cpp}).
\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if}, C++}, label=lst:asm:alg:if-cpp]
if (x < 0)
{
  x = 0;
}
\end{lstlisting}

Так как условный оператор включает только ветвь «да», а~в~ней "--- только простой оператор присваивания,
эту конкретную задачу можно решить с~помощью команд условной пересылки.
Начиная с~Pentium Pro, %добавлены команды  условной пересылки: Для более быстрой реализации подобных ветвлений (присваивания по условию) 
это наиболее быстрый способ присваивания по условию.

Кроме того, 
можно воспользоваться командой условного перехода для обхода кода ветви «да» в~случае, когда условие не выполнено.
Этот способ не только поддерживается начиная с~оригинального 8086, но и~универсален.
Так можно реализовать условный оператор со сколь угодно сложным кодом внутри.


\subsubsection{Условная пересылка}
\index{Команды!cmp}%
\index{Команды!cmovCC}%


% Данную задачу можно также решить с~помощью команд условной пересылки:
% Для более быстрой реализации подобных ветвлений (присваивания по условию) начиная с~Pentium Pro добавлены команды  условной пересылки:
Сравним $x$ с~нулём (оценим знак разности $x -0$).
Присваивание необходимо выполнить в~случае, когда $x < 0$ как знаковое.
Это соответствует условию~\lstinline!l! (\ethm{if less}) или, что то же самое, \lstinline!nge! (\ethm{if not greater or equal}).
С учётом размера типа~$int$ можно также добавить суффикс размера~\lstinline!l! (листинг~\ref{lst:asm:alg:if-cmov}).

\begin{lstlisting}[style=lstsmall, caption={Условие \eqref{eq:asm-alg:if}, \texttt{cmovCC}}, label=lst:asm:alg:if-cmov]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "cmovngel %[Zero], %[X]\n"
  : [X]"+r"(x)
  : [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Так как источником для команды \lstinline!cmovCC! не может быть константа, вводится входной параметр \lstinline![Zero]!, расположенный в~памяти или регистре и~равный нулю.

\subsubsection{Обход части операторов с~помощью команд условного перехода}

Построим схему алгоритма (рис.~\ref{ris:if}, а) для решения этой задачи.

\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\coordinate[right=  of is_positive] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);

\node[block,on chain=alg_start, join={node[right]{нет}}] (is_positive_no_op) {$x = 0$};
\coordinate[below = of is_positive_no_op] (to_end);

\path[blockarrow] (is_positive_yes) |- (to_end);
\node[terminator, on chain=alg_start, below = of to_end, join/.style=blockarrow] (end) {Конец}; % Удаляет линию вообще
\path[blockarrow] (is_positive_no_op) -- (end);


\coordinate[right=  of is_positive_yes] (asm_coord);

% \node[asm] at (start-|asm_coord) {
%   \begin{lstlisting}
%   int x;
%   asm
%   (
%       "movl $12, %[X]\n"
%       :[X]"=rm"(x)
%   );
%   \end{lstlisting}
%   };

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = -6;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "cmpl $0, %[X]\n"
  "jge end_check\n"
\end{lstlisting}
};
\node[asm] at (is_positive_no_op-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "movl $0, %[X]\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end.south-|asm_coord) (asm-end) {
\begin{lstlisting}[firstnumber=last]
  : [X]"+rm"(x)
  : : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};

\end{tikzpicture}
}
\index{Команды!cmp}%
\index{Команды!jCC}%

\caption{Алгоритм и~реализация ветвления с~операторами в~одной ветви}
\label{ris:if}
\end{illustration}


В~отличие от операторов  \lstinline!if! большинства языков высокого уровня,
ветвь, где должны выполняться операторы, лучше сделать ветвью «нет» (таким образом, по ветви «да» будет выполняться обход части программы).

Построим по данной схеме программу  (рис.~\ref{ris:if}, б). 
Основная вертикаль схемы будет соответствовать последовательности команд в~памяти,
потоки, отходящие от вертикали "--- командам передачи управления,
потоки, входящие в~основную вертикаль "--- меткам, на которые передаётся управление.
Если команда не является командой передачи управления, после неё выполняется непосредственно следующая, что соответствует движению вниз по основной вертикали.

Каждому  блоку процесса здесь будет соответствовать линейный фрагмент кода (строка 6); 
блок решения включает установку флагов и~завершится условным переходом по метке (строки 4-5); точка соединения двух потоков соответствует метке на строке~7.

Подобным способом можно реализовать условный оператор со сколь угодно объёмным кодом только в~одной ветви.
Необходимый код помещается на место строки~7, между командой условного обхода ветви и~соответствующей меткой.


\subsection{Условие с~операторами в~двух ветвях}
\epigraph{\begin{stanza}[0mm]
Человеческая жизнь имеет более одного аспекта;\\
В городе Таганроге есть два Звёздных проспекта...\\
\end{stanza}}
{\Aquarium}
Пусть в~зависимости от условия необходимо выполнить один из двух операторов:
\begin{equation}
\label{eq:asm-alg:if-else}
y(x) = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.
\end{equation}


На языке C++ код, решающий эту задачу, будет использовать условный оператор с~двумя ветвями (листинг~\ref{lst:asm:alg:if-else-cpp}).
\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if-else}, C++}, label=lst:asm:alg:if-else-cpp]
if (x >= 0)
{
  y = 1;
}
else
{
  y = 0;
}
\end{lstlisting}
Из-за специфического кода ветвей данную задачу можно решить на ассемблере тремя способами.

\subsubsection{Условная установка байта}
\index{Команды!cmp}%
\index{Команды!setCC}%

% Для данных значений (
Так как 
$y$ равен либо нулю, либо единице, задачу можно  решить с~помощью команды условной установки байта.

Единичное значение $y$ соответствует случаю, когда $x \geqslant 0$ как знаковое (\ethm{if greater or equal}), то есть мнемоника условия может быть записана как \lstinline!ge!.

\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if-else}, \texttt{setCC}}, label=lst:asm:alg:if-else-setCC]
int x = -7, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $0, %[Y]\n"
  "setgeb %[Y]\n"
  :[Y]"=m"(y)
  :[X]"rm"(x)
  : "cc"
);
\end{lstlisting}
Здесь мы записываем ноль в~четырёхбайтовую переменную  \lstinline![Y]!, находящуюся в~памяти (это не изменяет флагов), а~затем устанавливаем по условию её младший байт (так как платформа x86 использует  порядок байтов Intel, адрес младшего байта \lstinline![Y]! совпадает с~адресом \lstinline![Y]!).
Оба возможных значения $y$ неотрицательны, поэтому дополнение нулями является корректным расширением и~для знаковой, и~для беззнаковой их~интерпретации.

Также можно было 
использовать для хранения параметра \lstinline![Y]! регистр~$A$,
установить по условию байт  $al$ и~специальными командами расширить его вначале до $ax$, а~затем до четырёхбайтового~$eax$.

При использовании для $y$ однобайтового типа \lstinline!char! вместо четырёхбайтового \lstinline!int! расширение не будет нужным.



\subsubsection{Условная пересылка}
\index{Команды!cmp}%
\index{Команды!cmovCC}%


Данную задачу также можно  решить с~помощью команд условной пересылки.
Для подобного задания такая реализация будет компактнее и~быстрее. 
% \pagebreak[3]

\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if-else}, \texttt{cmovCC}}, label=lst:asm:alg:if-else-cmovCC]
int x = 10, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $1, %[Y]\n"
  "cmovll %[Zero], %[Y]\n"
  : [Y]"+r"(y)
  : [X]"rm"(x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Здесь параметр \lstinline![Y]! объявлен как выходной с~начальным значением, хотя, казалось бы, его исходное значение нам не требуется.
Это сделано, чтобы компилятор не совместил его с~входным параметром  \lstinline![Zero]! (совмещение с~входным параметром \lstinline![X]! не повредит выполнению, так как значение \lstinline![X]! используется только для сравнения с~литералом \lstinline!$0!, до первого присваивания \lstinline![Y]!).
Если %не указать \lstinline![Y]! в~списке входных и~он 
\lstinline![Y]! будет совмещён с~\lstinline![Zero]!, мы всегда получим на выходе $y=1$.

\pagebreak[3]

\subsubsection{Обход части операторов с~помощью команд условного перехода}

% Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи, выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, в).
% 
% Потоки, выходящие за пределы основной линии "--- условные и~безусловные  переходы, точки входа таких потоков-переходов в~основной вертикальный поток "--- метки.


Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи и~затем выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б).

\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\tikzset{every join/.style=blockarrow}

\coordinate[right= of is_positive, on chain=if_yes] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);
\node[block,on chain=if_yes] (yes_op) {$y = 1$};

\coordinate[left=  of is_positive, on chain=if_no] (is_positive_no);
\path[blockline] (is_positive) -- node[auto, swap] {нет} (is_positive_no);
\node[block,on chain=if_no] (no_op) {$y = 0$};

\coordinate[below = of yes_op] (to_end_y);

\coordinate[on chain=alg_end, join/.style={}] (to_end) at (to_end_y-|start);
\path[blockline] (yes_op) |- (to_end);
\path[blockline] (no_op) |- (to_end);

\node[terminator, on chain=alg_end, below = of to_end] (end) {Конец};
% \path[blockarrow] (to_end) -- (end);



\tikzset{every join/.style=blockline}


\coordinate[right= 6em of yes_op] (squeeze_coord);

\node[terminator,on chain=squeeze_start] (start2) at (start-|squeeze_coord) {Начало};

\node[decision,on chain=squeeze_start] (is_positive2) {$x\geqslant0$};

\node[block,   on chain=squeeze_start, join={node[right]{нет}}] (no_op2) {$y = 0$};
\coordinate[on chain=squeeze_start] (to_end_no2);


\coordinate[right= of is_positive2] (is_positive_yes2);
\path[blockline] (is_positive2) -- node[auto] {да} (is_positive_yes2);
\tikzset{every join/.style=nodraw}
\coordinate[on chain=squeeze_start] (non-used);

\coordinate[on chain=squeeze_start, join/.style={}] (to_yes2);
\node[block,   on chain=squeeze_start, join/.style={}] (yes_op2) {$y = 1$};
\tikzset{every join/.style=blockline}

\coordinate[on chain=squeeze_start] (to_end_yes2);
% \coordinate[on chain=squeeze_start] (non-used2);

\node[terminator, on chain=squeeze_start, join/.style={}] (end2) {Конец};

\path[blockarrow] (is_positive_yes2) |- (to_yes2) -- (yes_op2);

\coordinate[left=of yes_op2] (from_no_to_end2);
\path[blockline] (to_end_no2) -| (from_no_to_end2);
\path[blockarrow] (from_no_to_end2) |- (to_end_yes2);
\path[blockarrow] (to_end_yes2) -- (end2);



\coordinate[right=  of is_positive_yes2] (asm_coord);

\node[asm] at (start2-|asm_coord) {
\begin{lstlisting}
int x = -6, y;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "cmpl $0, %[X]\n"
  "jge setting_1\n"
\end{lstlisting}
};

\node[asm] at (no_op2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "movl $0, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (to_end_no2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "jmp end_check\n"
\end{lstlisting}
};


\node[asm] at (to_yes2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"setting_1:\n"
\end{lstlisting}
};

\node[asm] at (yes_op2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "movl $1, %[Y]\n"
\end{lstlisting}
};


\node[asm] at (to_end_yes2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end2.south-|asm_coord) (asm-end) {
\begin{lstlisting}[firstnumber=last]
  :[Y]"=rm"(y)
  :[X]"rm" (x)  
  : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (end2|-lettersline) {б)};
\node at (asm-end|-lettersline) {в)};


\end{tikzpicture}
}
\index{Команды!cmp}%
\index{Команды!jCC}%
\index{Команды!jmp}%

\caption{Алгоритм и~реализация ветвления}
\label{ris:if-else}
\end{illustration}

Схема на рис.~\ref{ris:if-else}, б)  не вполне соответствует  ЕСПД
(стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости, так как схемы алгоритмов предназначены в~основном для чтения человеком)
но при таком расположении можно однозначно сопоставить расположение блоков на схеме и~расположение команд в~памяти.

У~схемы на рис.~\ref{ris:if-else}, а) два возможных варианта «вертикализации» "--- изображённый на рис.~\ref{ris:if-else}, б)
и~тот, где ветвь «да» окажется выше ветви «нет». Эти варианты равноправны и~оба приведут к~одинаково корректным, но различным между собой программам.
В~данном разделе рассматривается вариант рис.~\ref{ris:if-else}, б).

Сопоставим каждому блоку одну или несколько команд ассемблера.
В~этом случае излом потока (отход от базовой вертикали без ветвления) будет соответствовать безусловному переходу, блок решения включает вычисление условия и~условный переход, а~точки входа боковых потоков-переходов в~основной вертикальный поток соответствуют меткам (рис.~\ref{ris:if-else}, в).
% \pagebreak[3]

\index{Команды!jCC}%
Таким образом, код ветви «нет», расположенной на базовой вертикали первой, обходится с~помощью команды условного перехода, если условие $x \geqslant 0$ верно (\texttt{ge}, строка~5),
а~в~конце, после собственно кода ветви, вставлена команда безусловного перехода к~первой команде, которая будет выполнена независимо от условия, чтобы после ветви «нет» выполнение естественным путём не перешло к~ветви «да» (переход к~метке \texttt{end\_check:}, строка~7).
Сразу после этого начинается код ветви «нет» (метка \texttt{setting\_1}, строка~8). %; после её завершения 

Описанный способ наиболее универсален и~позволяет реализовать условный оператор со сколь угодно объёмным кодом ветвей.
Необходимый код ветвей «нет» и~«да» заместит соответственно строки~6 и~9.



% \subsection{Цикл с~предусловием}
\subsection{Цикл}
\epigraph{\begin{stanza}
Достаточно бросить здесь спичку, и огня будет уже не унять\\
В джунглях. 
\end{stanza}
}{\Aquarium}

Цикл "--- единственн%ый оператор языков 
ая алгоритмическая конструкция
высокого уровня,
позволяющая передать управление назад.
Соответственно, цикл на ассемблере можно реализовать только с~помощью команд передачи управления.


Пусть необходимо найти сумму двоичных цифр беззнакового числа $x$.


% Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, а), реализован цикл с~предусловием) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, б).

Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:while}, а), реализован цикл с~предусловием). 



\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\tikzstyle{asm}	= [text width=16em,text badly ragged, anchor=west]

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[block,on chain=alg_start] (init) {$count = 0$};

\coordinate[on chain=alg_start] (to_shift);
\tikzset{every join/.style=blockarrow}
\node[decision,on chain=alg_start] (is_zero) {$x=0$};
\tikzset{every join/.style=blockline}
\node[block,on chain=alg_start, join={node[right]{нет}}] (shift) {
$CF = x \And 1$

$x = (x>>1)$
};

\node[decision,on chain=alg_start] (is_last_bit) {$CF=1$};
\node[block,on chain=alg_start, join={node[right]{да}}] (inc) {$count = count+1$};
\coordinate[on chain=alg_start] (from_no_to_next_iter);
\coordinate[on chain=alg_start] (to_next_iter);
\tikzset{every join/.style=blockarrow}
\coordinate[left = of current bounding box] (to_next_iter_middle);
\path[blockarrow] (to_next_iter) -| (to_next_iter_middle) |- (to_shift);

\tikzset{every join/.style=nodraw}
% \coordinate[on chain=alg_start] (non-used);
\coordinate[on chain=alg_start] (to_end);
\node[terminator, on chain=alg_start] (end) {Конец};


\coordinate[right= of is_last_bit] (is_no_last_bit);
\path[blockarrow] (is_last_bit) -- node[auto] {нет} (is_no_last_bit) |- (from_no_to_next_iter);



\coordinate[right= of is_zero-|is_no_last_bit] (is_zero_yes);
\path[blockarrow] (is_zero) -- node[auto] {да} (is_zero_yes) |- (to_end) -- (end);



\coordinate[right=  of current bounding box] (asm_coord);

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = 7, count;
asm
(
\end{lstlisting}
};

\node[asm] at (to_shift-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"begin_iteration:\n"
\end{lstlisting}
};
\node[asm] at (init-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "xorl %[Count], %[Count]\n"
\end{lstlisting}
};
\node[asm] at (is_zero-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "cmpl $0, %[X]\n"
  "je end_loop\n"
\end{lstlisting}
};

\node[asm] at (shift-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "shrl $1, %[X]\n"
\end{lstlisting}
};

\node[asm] at (is_last_bit-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "jnc end_iteration\n"
\end{lstlisting}
};
\node[asm] at (inc-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "incl %[Count]\n"
\end{lstlisting}
};

\node[asm] at (from_no_to_next_iter-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_iteration:\n"
  "jmp begin_iteration\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_loop:\n"
\end{lstlisting}
};

\node[asm] at (end-|asm_coord) (asm-end) {
\begin{lstlisting}[firstnumber=last]
:[Count]"=rm"(count),[X]"+rm"(x)
: : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};


\end{tikzpicture}
}
\index{Команды!xor}%
\index{Команды!shr}%
\index{Команды!cmp}%
\index{Команды!inc}%
\index{Команды!jmp}%
\index{Команды!jCC}%

\caption{Алгоритм и~реализация цикла}
\label{ris:while}
\end{illustration}

При соединении блоков ещё немного отступим от требований ЕСПД 
% (стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости)
и~отделим точку, где боковой поток случая $CF\neq 0$ входит в~основную вертикаль, от~точки, где поток отходит от вертикали, чтобы перейти назад к~началу итерации.
Расположение этих точек выберем так, чтобы поток основной вертикали на каждом её участке шёл в~естественном направлении "--- сверху вниз (это не только позволяет не~рисовать стрелку для обозначения направления, но и~соответствует выполнению %программы 
кода, не включающего команд передачи управления).


Теперь сопоставим каждому блоку одну или несколько команд ассемблера.
Отход потока от базовой вертикали будет соответствовать команде перехода, точки входа боковых потоков в~основной вертикальный  "--- меткам 
(рис.~\ref{ris:while}, б).

Цикл с~постусловием будет отличаться только на этапе построения схемы алгоритма.

Цикл с~параметром можно реализовать либо как цикл с~предусловием, как и~в~C/C++,
либо как цикл с~постусловием.

При этом, если счётчик цикла не является одновременно индексом массива в~памяти, имеет смысл
% организовать цикл
инициализировать счётчик максимальным значением $i = i_{max}$ и~уменьшать его на каждом шаге $i = i-1$.
Это позволит избавиться от команды сравнения, так как команды декремента и~вычитания не только изменяют операнд $i$, но и~выставляют флаги.
При переходе от~ненулевого значения к~$0$ получим $ZF=1$, при переходе от неотрицательного значения, в~частности нуля, к~отрицательному "--- $CF=1$ и~$SF\neq OF$.



















\bottompagebreak[4\baselineskip]
\subsection{Массивы}
\label{sec:arrays}
\epigraphcensoredtwo[
% \epigraph{\begin{stanza}[0mm]
% Улица рада,\\
% весной умытая.\\
% Шагаем отрядом,\\
% и мы,\\
% \hspace{\stanzaoddindent}и~ты,\\
% \hspace{2\stanzaoddindent}и~я.\\
% \end{stanza}
% }
% {\Vvm}
\epigraph{
\emph{Эм} "---  распыление объёма на бесконечно малые части. 
}{\Khlebnikov}
]{
\epigraph{\begin{limerick}
Жил один старичок из Пенджаба,\\
Ему на ногу прыгнула жаба,\\
Впавши в~ярость и~гнев,\\
Он позвал сорок дев, "---\\
Чтобы выгнать всех жаб из Пенджаба.
\end{limerick}
}
{\Lear}
}

% \section{Одномерные массивы}
\index{Массивы!одномерные}%

Массив "---  структура данных в~виде набора однородных компонент (элементов массива), расположенных в памяти непосредственно друг за другом (независимо от настроек выравнивания). 
Элемент с~наименьшим индексом располагается по младшему адресу.
% 
Доступ к~отдельным элементам массива осуществляется с помощью индексации, то есть через ссылку на массив с~указанием номера (индекса) нужного элемента. 


В~языке C++ наименьший индекс массива всегда равен $0$, а~имя массива %фактически 
является константным указателем на его начало.
Таким образом, адрес $i$-го элемента массива $M$ равен $M + i\cdot size$, где~$size$ "--- размер одного элемента и,~в~случае, когда длина массива не равна нулю, может быть определён как \lstinline!sizeof(M[0])!.
% Если массив содержит элементы простых типов 
Для большинства простых типов
(\lstinline!char, bool, short, int, long, long long, float, double, size_t, ptrdiff_t, void*!)
этот размер как на 32-, так и~на 64-битной платформе равен~$1, 2, 4$ или~$8$.

Соответственно, в~ассемблере для получения элемента массива (если элементы массива имеют размер~$1, 2, 4$ или~$8$) будут использованы три из~четырёх компонент эффективного адреса \lstinline!displacement(base, index, multiplier)! "---  база (адрес начала массива~$M$), индекс и~масштаб (размер~элемента).
\index{Адресация!косвенная}%

В~частности, адрес $i$-го элемента массива  $M$ из~чисел типа \lstinline!int! на 32-разрядных и~многих 64-разрядных платформах равен $M + i\cdot 4$, и~элемент будет записан как~\lstinline!(M, i, 4)!. При этом база~$M$ и~индекс~$i$ должны быть 32-разрядны (на соответствующей платформе) и~располагаться в~регистрах.
\begin{lstlisting}[caption={Инициализация четырёхбайтового элемента массива~\texttt{M[i]}}, label=lst:asm:alg:mi4]
const int N = 8;
int M[N], i = 0;
asm
(
"movl $0, (%[M], %[I], 4)\n"
:[I]"+r"(i)
:[M]"r"(M)
:"memory"
);
\end{lstlisting}
Так как мы модифицируем во вставке элементы массива (а~не сами параметры \lstinline![I]! и~\lstinline![M]!), необходимо указать в~списке перезаписываемых элементов\index{Перезаписываемые элементы} специальное значение \lstinline!"memory"!.

Для инициализации массива в~целом необходим цикл.
\index{Команды!xor}%
\index{Команды!cmp}%
\index{Команды!inc}%
\index{Команды!jmp}%
\index{Команды!jCC}%
В~листинге~\ref{lst:asm:alg:m4} показана инициализация нулями массива  из элементов типа~$int$ (на большинстве платформ он четырёхбайтовый) циклом с~предусловием, аналогичным циклу~\lstinline!for! языка C++.
\begin{lstlisting}[caption={Инициализация массива~\texttt{M} из четырёхбайтовых элементов}, label=lst:asm:alg:m4]
const int N = 8;
int M[N], i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"cmpl %[M_len], %[I]\n"
"jge end_loop\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"jmp begin_iteration\n"
"end_loop:\n"
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}
Действительно, при выводе массива~\texttt{M} мы увидим нули:
\begin{lstlisting}[numbers=none]
0 0 0 0 0 0 0 0 
\end{lstlisting}

Если в~массиве гарантированно есть хотя бы один элемент, можно сократить код, использовав постусловие (листинг~\ref{lst:asm:alg:m4-1}).
\begin{lstlisting}[caption={Инициализация непустого массива~\texttt{M}}, label=lst:asm:alg:m4-1]
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"cmpl %[M_len], %[I]\n"
"jnge begin_iteration\n"
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);
\end{lstlisting}

В~приведённом выше коде на тип~\lstinline!int! у~элементов~массива указывают как суффикс~\lstinline!l! у~команды~\lstinline!mov!, так и~масштаб~\lstinline!4! при вычислении адреса.
Обе характеристики важны: попытка опустить суффикс команды приведёт к~ошибке, так как ни один из операндов~команды~\lstinline!mov! здесь не является регистром и,~следовательно, не имеет определённого размера. %, по которому можно было бы понять разрядность команды

Также %обе характеристики 
суффикс и~вычисление адреса
должны соответствовать друг другу: хотя  команды~\lstinline!movw $0, (%[M], %[I], 4)! и~\lstinline!movl $0, (%[M], %[I], 2)! синтаксически корректны и~не вызовут ошибок компиляции%
% \footnote{Ошибка возможна при использовании здесь суффикса~\lstinline!s! вместо~\lstinline!w!, хотя в~целом они оба для команд CPU равноправны и~обозначают 16-битное целое, так как существует отдельная команда~\lstinline!movs! с~поведением, отличным от~\lstinline!mov!}
,  обе они при обработке массива из элементов типа~\lstinline!int! некорректны по смыслу.
Команда~\lstinline!movw $0, (%[M], %[I], 4)! запишет по адресу~$M[i]$ 16-битный ноль, который инициализирует только младшие два байта из четырёх%, зарезервированных за~$M[i]$
; таким образом, значение элемента~$M[i]$ останется неопределённым. % и,~фактически, элемент  
Команда~\lstinline!movl $0, (%[M], %[I], 2)! перезапишет не~$M[i]$, а~либо элемент~$M[i/2]$ (для чётного~$i$), либо два старших байта 
% половину 
одного элемента и~два младших следующего  (для нечётного~$i$).

Избавиться от явного указания суффикса и~масштаба можно, используя модификаторы параметров:
\begin{lstlisting}[caption={Инициализация элемента массива~\texttt{M[i]} размера \texttt{el\_size}}, label=lst:asm:alg:misize]
const int N = 8;
short M[N];
int i = 3;
asm
(
"mov%z[el_type] $0, (%[M], %[I], %c[el_size])\n"
:[I]"+r"(i)
:[M]"r"(M), [el_size]"i"(sizeof(M[0])), [el_type]"m"(M[0])
: "memory"
);
\end{lstlisting}
Такой код будет компилироваться и~выполняться корректно для любого типа элементов массива~$M$, причём для типа~\lstinline!short! выбирается тот из синонимичных суффиксов, который не вызовет неоднозначности с~командой~\lstinline!movs!.
К~сожалению, это потребовало введения двух новых входных параметров: константа~\lstinline![el_size]! для масштаба~\lstinline!sizeof(M[0])! и~\lstinline![el_type]!, равный~\lstinline!M[0]!, для определения суффикса размера (так как ни один из ранее использованных параметров
"--- ни указатель~$M$, ни индекс~$i$ "---
в~общем случаем не совпадает~по размеру с~элементом массива%: $M$ "--- указатель, индекс~$i$ "--- \lstinline!size_t!, то есть их размер определяется платформой и~компилятором, а~не типом элемента
).

В~листинге~\ref{lst:asm:alg:mf} показана инициализация нулями массива  из элементов целого типа.
\begin{lstlisting}[caption={Инициализация  массива~\texttt{M} из элементов 2-8 байт}, label=lst:asm:alg:mf]
const int N = 8;
short M[N];
int i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"mov%z[el_type] $0, (%[M],%[I],%c[el_size])\n"
"incl %[I]\n"
"cmpl %[M_len], %[I]\n"
"jnge begin_iteration\n"
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M), 
[el_size]"i"(sizeof(M[0])), 
[el_type]"m"(M[0])
: "cc","memory"
);
for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}
Тип~$short$ в~листинге~\ref{lst:asm:alg:mf} может быть заменён на~$long$ или~$long~long$.
Не вызовет ошибки компиляции и~замена на~однобайтовое целое~$char$, но вывод будет выглядеть пустым.
При выводе на экран числа типа $char$ стандартными средствами C++ отображается символ ASCII\index{ASCII}, код которого равен числу.
% Отображение чисел, не равных кодам печатных символов ASCII, не определено и~может быть разным для различных реализаций,
Нулевой символ отображается как конец строки, то есть никак.
Если заменить в~команде \lstinline!mov! константу \lstinline!$0! на номер печатного символа~ASCII, в~частности, на~\lstinline!$'y'!, вывод на экран покажет~$N$ заданных символов.

Масштаб, равный~$1$, может быть опущен.
Таким образом, если размер элемента равен~одному байту, то адрес $i$-го элемента массива  $M$ равен $M + i$ и~сам элемент может быть записан и~как~\lstinline!(M, i, 1)!, и~как~\lstinline!(M, i)!.

% Пусть выделена память под массив однобайтовых целых чисел. В~C++ соответствующий тип обозначается как $char$.
% При выводе на экран числа типа $char$ стандартными средствами отображается символ ASCII, код которого равен числу.
% Отображение чисел, не равных кодам ASCII,  не определено и~может быть разным для различных реализаций,
% так что рассмотрим инициализацию массива кодами строчных латинских букв, начиная с~\lstinline!'a'! (листинг~\ref{lst:asm:alg:m-byte}).
Рассмотрим инициализацию массива кодами строчных латинских букв, начиная с~\lstinline!'a'! (листинг~\ref{lst:asm:alg:m-byte}).

\begin{lstlisting}[caption={Инициализация массива строчными латинскими буквами}, label=lst:asm:alg:m-byte]
const int N = 8;
int i, x;
char M[N];
asm
(
  "movb $'a', %b[X]\n"
  "xorl %[I], %[I]\n"
"begin_iteration:\n"
  "cmpl %[M_len], %[I]\n"
  "jge end_loop\n"
  "movb %b[X], (%[M],%[I])\n"
  "incb %b[X]\n"
  "incl %[I]\n"
  "jmp begin_iteration\n"
"end_loop:\n"
:[I]"=&r"(i), [X]"=&q"(x)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);
\end{lstlisting}

Вывод инициализированного таким образом массива
% \begin{lstlisting}[numbers=none]
% for(i = 0; i < N; ++i)
% {
%     cout << M[i] << " ";
% }
% cout << endl;
% \end{lstlisting}
приведёт к~следующему результату:
\begin{lstlisting}[numbers=none]
a b c d e f g h 
\end{lstlisting}

Если размер~$size$ элемента отличен от~$1, 2, 4$ или~$8$, он не может быть масштабом при вычислении адреса; таким образом, смещение $i$-го элемента относительно начала массива%, равное $i\cdot size$, 
$$
\mathit{offset} = i\cdot size % без \mathit{} между ff дырка
$$
необходимо вычислить отдельно и~затем получить элемент как~\lstinline!(M, offset)!.
% Смещение 
Так как элементы массива, как правило, обрабатываются в~цикле, это можно сделать последовательным сложением % начального адреса
с~$size$ на каждой итерации.

Один из возможных вариантов инициализации массива из элементов типа~$long~double$ (в~GCC число~$long~double$ имеет размер 10 байт, а~выделяемая под него память может занимать как 12, так и~16 байт) показан в~листинге~\ref{lst:asm:alg:m-ten}.

\begin{lstlisting}[caption={Инициализация массива~80-битных вещественных чисел}, label=lst:asm:alg:m-ten]
const int N = 8;
int i;
long double M[N], *p;
asm
(
"movl %[M_len], %[rev_idx]\n"
"movl %[M],     %[el_addr]\n"
"begin_iteration:\n"
"fldpi\n"
"fstpt (%[el_addr])\n"
"addl %[el_size], %[el_addr]\n"
"decl %[rev_idx]\n"
"jnz begin_iteration\n"
:[rev_idx]"=&r"(i), [el_addr]"=&r"(p)
:[M_len]"i"(N), [M]"r"(M), [el_size]"i"(sizeof(M[0]))
: "cc","memory"
);
\end{lstlisting}

Каждый элемент 
получает значение $\pi$.
% \begin{lstlisting}[numbers=none]
% 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 
% \end{lstlisting}

Для инициализации массива нулями можно воспользоваться тем, что нулевое вещественное значение состоит из одних нулей (листинг~\ref{lst:asm:alg:m-ten0}).

\begin{lstlisting}[caption={Инициализация массива вещественных чисел нулями}, label=lst:asm:alg:m-ten0]
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"cmpl %[M_len], %[I]\n"
"jnge begin_iteration\n"
:[I]"=&r"(i)
:[M_len]"i"(N*sizeof(M[0])/4), [M]"r"(M)
: "cc","memory"
);
\end{lstlisting}

Память, отведённая под массив~$M$ ($N*sizeof(M[0])$ байтов) целиком заполняется четырёхбайтовыми нулевыми блоками.
В~результате каждый элемент~$M[i], ~ i \in [0, N-1]$ получает нулевое значение, что можно увидеть, выведя $M$ на экран поэлементно.

% http://www.sql.ru/forum/1121399/nu-ochen-bystryy-move-dlya-x86-x64
% Так вот несколько месяцев назад я с ужасом обнаружил, что используемые ранее (REP) MOVS команды - тормозные. Что обычный цикл записи работает быстрее. Кроме того реализация Move() в Delphi x64 оставляет желать лучшего мягко говоря (впрочем как и многое в RTL x64).

% Также можно воспользоваться функциями stdlib для заливки памяти одним символом.

\subsubsection{Многомерные массивы}
\index{Массивы!многомерные}%

Если массивы с~одним индексом естественно отображаются на~одномерное адресное пространство памяти, 
то о~расположении элементов двумерного массива необходимо условиться дополнительно.

В~большинстве ЯВУ элементы статических многомерных массивов располагаются в~памяти так, что при движении от начала массива по возрастанию адресов быстрее всего меняется последний индекс. После того, как последний индекс достигнет максимального значения, увеличивается предпоследний и~так далее.

В~частности, статические двумерные массивы (матрицы) развёрнуты в~одномерный по строкам "--- сначала идёт вся нулевая строка, затем вся первая и~так далее, то есть в~массиве
\index{Массивы!матрицы}%
\begin{lstlisting}
const int I = 8, J = 8;
int M[I][J];
\end{lstlisting}
адрес элемента~$M[i][j]$ равен~$M+(i\cdot J +j)\cdot size$, где $size = $\lstinline$sizeof(M[0][0])$.

При обработке всех элементов матрицы можно рассматривать её как одномерный массив длины~$I\cdot J$, так как все её элементы однородны и~расположены в~памяти непосредственно друг за другом. 
В~этом случае %эффективный 
индекс элемента~$M[i][j]$ в~этом массиве $index = i\cdot J +j$.


Обратное преобразование (расщепление при необходимости эффективного индекса на номера строки и~столбца) выглядит следующим образом: 
$$
\left\{
\begin{array}{l}
i = index / J\\
j = index \Mod J
\end{array}
\right.
$$
и~может быть выполнено одной командой беззнакового деления.


Если требуется выполнить одно и~то же действие, в~частности, инициализацию, над всеми элементами матрицы, достаточно выполнить один проход, как по массиву $M[I\cdot J]$.
% Если при обработке нужно 

\subsubsection{Динамические массивы}

Динамические массивы,
\index{Массивы!динамические}%
память под которые выделяется из кучи с~помощью оператора $new[\,]$ или функций $*alloc()$ и~освобождается $delete[\,]/free()$, могут быть только одномерными.
При необходимости размещения в~куче многомерного массива программист вручную либо разворачивает его в~длинный одномерный, либо размещает в~древоподобной структуре данных из нескольких небольших одномерных массивов.
Способ обращения к~элементу в~таком случае зависит от способа организации данных.

Обращение к~одномерному динамическому массиву, после того, как адрес его начала помещён в~регистр, ничем не отличается от обращения к~одномерному статическому.




\subsection{Структуры и~объекты}
\modifytwo[
% \epigraph{
% "--* А~как  я~узнаю, какой порядок правильный?
% 
% "--* Это очень просто! "--- ответил Браунинг. "--- Прислушайся к~чувству прекрасного, которое должно переполнить тебя при прочтении этих строк...
% 
% }{\ZhvalevskijMytko}
\epigraph{
\emph{Эс} "--- пути движений, имеющие общую начальную и~неподвижную точку (сой, солнце, сад, село).
}{\Khlebnikov}
]{
\epigraph{\begin{limerick}
Говорил бородатый старик:\\
«Я~совсем от покоя отвык "---\\
Шебуршат, как в~гнезде,\\
У~меня в~бороде\\
Две совы, утка, дрозд и~кулик!»
\end{limerick}
}
{\Lear}
}


% \section{Доступ к~элементам массивов в~памяти}
% \section{Временн\'{ы}е характеристики памяти}
\subsubsection{Выравнивание данных}


Хотя оперативная память "--- устройство с~произвольным доступом, то есть возможно читать значения по любым адресам в~любом порядке, время доступа различается в~зависимости от расположения данных.
% 
Конкретные особенности временн\'{ы}х характеристик обращения к~оперативной памяти зависят от особенностей процессора и~чипсета.


Тем не менее, есть несколько общих правил, позволяющих не потерять в~производительности слишком сильно.

\begin{enumerate}

\item Выравнивание.
Фактически процессор не работает с~данными, взятыми напрямую из оперативной памяти.
При чтении данные поступают в~сверхоперативную память (кеш); изменения вначале фиксируются в~кеше, затем попадают в~оперативную память.
Обмен между памятью и~кешем производится пакетами, длина которых %различна для разного аппаратного обеспечения, но 
составляет от~$32$ до~$128$ байт.
% и~всегда составляет круглое (равное~$2^r$) количество байт. 
Начало пакета кратно его длине.

Таким образом, если элемент попадает на границу таких блоков-пакетов, для его загрузки потребуется два запроса к~памяти~\cite{nezumi-memory}.

% читаются и~записываются в~оперативную память

Чтобы избежать таких ситуаций, достаточно (хотя и~не всегда необходимо), чтобы граница между элементами в~памяти была кратна определённому числу (таблица~\ref{tab:alg:struct-align-size}) "--- выравнена.

\begin{table}[!ht]
\caption{Размер выравнивания для данных различных типов}
\label{tab:alg:struct-align-size}

% \cite{nezumi-memory} Техника оптимизации программ. Эффективное использование памяти
\noindent\begin{tabularx}{\linewidth}{|l@{~}L|L@{~}l|}
\hline
\multicolumn{2}{|c|}{\thead{Размер данных}} & \multicolumn{2}{c|}{\thead{Граница}} \\\hline
1 байт &(8 бит) & Произвольная  &\\\hline
2 байта &(16 бит) & Кратная 2 байтам  &\\\hline
4 байта &(32 бита) & Кратная 4 байтам  &\phantom{4 байта} \\\hline
8 байт &(64 бита) & Кратная 8 байтам  &\\\hline
10 байт &(80 бит) & Кратная 16 байтам  &\\\hline
16 байт &(128 бит) & Кратная 16 байтам  &\\\hline
\end{tabularx}
\end{table}
% \bigskip

По умолчанию в~C++ как размер простых типов, так и~величина, которой кратен адрес начала такой переменной "--- величина выравнивания (кроме $long~double$) соответствуют этим значениям.
% а~адрес начала переменной соответствующего типа кратен его размеру.

Десятибайтовый тип $long~double$ может иметь размер ($sizeof$) как 16, так и~12 байт; в~последнем случае он выравнивается на 4~байта (а~компиляторы из коллекции Microsoft Visual~Studio полагают $long~double = double$, таким образом и~размер, и~величина выравнивания там равны~8).


\item Обход %большого количества 
последовательно расположенных элементов в~порядке возрастания адресов выполняется быстрее, чем в~обратном.

\end{enumerate}



\subsubsection{Поля структур}

Структуры и~объекты в~C++ сочетают в~себе несколько в~общем случае разнородных компонент (полей), расположенных в~определённом порядке.
Доступ к~отдельным полям структуры на ЯВУ осуществляется по имени.
При обработке на языке ассемблера придётся использовать смещение поля относительно начала структуры, которое будет зависеть не только от состава структуры, но и~от компилятора и~его настроек. 

Обычно поля следуют в~порядке объявления и~начало поля %типа $T$ 
кратно некоторой величине, значение которой для конкретного поля/типа, а~также текущей версии и~настроек в~GCC можно получить с~помощью оператора \lstinline!__alignof__! (синтаксис аналогичен \lstinline$sizeof$).
При этом между началом одного поля и~концом предыдущего может образоваться промежуток, также промежуток может образоваться после последнего элемента структуры.
Соответственно, размер структуры может быть больше суммы размеров её полей; также размер структуры может меняться от перестановки полей между собой.
% При описании структур и~

% неверно
% По умолчанию на x86 максимальное значение кратности выравнивания (часто называемое просто выравниванием) равно~4. 
% В~этом случае данные размера 4~байта и~более выравниваются на~4~байта, то есть адрес начала такой переменной или поля будет кратен~4.
% Двухбайтовые данные выравниваются на~2, однобайтовые "--- на~1~байт.

{
% Уменьшить
Изменить
максимальную кратность выравнивания (часто называемую просто выравниванием) в~GCC можно с~помощью флага компиляции~\lstinline$-fpack-struct[=n]$.
Также GCC для совместимости с~компиляторами Microsoft поддерживает набор директив препроцессора \lstinline$#pragma pack$, позволяющих задать различную кратность выравнивания для различных определений типов:
\sloppy

}

% https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Structure-Packing-Pragmas.html
\begin{itemize}
\item \lstinline$#pragma pack(n)$ %simply sets the new alignment.
просто устанавливает новое значение выравнивания;

\item \lstinline$#pragma pack()$ %sets the alignment to the one that was in effect when compilation started (see also command-line option -fpack-struct[=n] see Code Gen Options).
возвращает выравнивание по умолчанию (возможно, заданное~\lstinline$-fpack-struct[=n]$);

\item \lstinline$#pragma pack(push[,n])$ %pushes the current alignment setting on an internal stack and then optionally sets the new alignment.
сохраняет текущее выравнивание во внутреннем стеке и,~при заданном~$n$, устанавливает новое значение

\item \lstinline$#pragma pack(pop)$ %restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and finalized by a single #pragma pack(pop). 
восстанавливает выравнивание из вершины внутреннего стека (и~удаляет эту запись оттуда).
\end{itemize}


Рассмотрим расположение полей и~размер структур при различных настройках выравнивания (листинг~\ref{lst:asm:alg:pack}).

\begin{lstlisting}[style=lstsmall, caption={Структуры при различных значениях выравнивания}, label=lst:asm:alg:pack]
const int N = 10;
struct TSomeStruct
{
    char Tag;    
    int  Val;
} 
s1, a1[N];

#pragma pack (push, 1)
struct TSqueezedStruct
{
    char Tag;    
    int  Val;
} 
s2, a2[N];

#pragma pack (pop)
struct TAnotherStruct
{
    char Tag;    
    int  Val;
}
s3, a3[N];

TSqueezedStruct s20, a20[N];

#define PRINT(I) cout << reinterpret_cast<char *>(&s##I.Tag) \
    - reinterpret_cast<char *>(&s##I) << " " \
 << reinterpret_cast<char *>(&s##I.Val) \
    - reinterpret_cast<char *>(&s##I) \
 << " "<< sizeof(s##I) << " " << sizeof(a##I) << endl;

PRINT(1)	// 0 4 8 80
PRINT(2)	// 0 1 5 50
PRINT(3)	// 0 4 8 80
PRINT(20)	// 0 1 5 50
\end{lstlisting}

Первое поле~$Tag$ всегда имеет нулевое смещение.
Второе поле~$Val$ для структур~$s1$ и~$s3$ (выравнивание по умолчанию) смещено на четыре байта, так как адрес переменной типа~$int$ для наилучшей производительности должен быть кратен~4.
В~структурах~$s2$ и~$s20$ "--- при максимальной кратности выравнивания~1 "--- поле~$Val$ следует непосредственно за~$Tag$.
Следует отметить, что настройки выравнивания задаются при определении типа~$TSqueezedStruct$, а~не конкретных переменных~$s2$ и~$s20$.

Следует также отметить, что в~массиве элементы всегда следуют друг за другом без промежутков. 

На практике
не рекомендуется 
% уменьшать кратность выравнивания, 
изменять настройки выравнивания (особенно директивой \lstinline$#pragma pack$, %позволяющей получить несовместимый результат без изменения описания
приводящей к~несовместимости одинаково описанных структур), 
так как это может замедлить работу программы или даже нарушить её работоспособность.

При необходимости записи структуры в~файл для избавления от дыр неопределённого размера лучше воспользоваться покомпонентной записью.

Для придания размеру дыр определённости необходимо по возможности описывать поля структуры в~таком порядке (и,~возможно, добавить ещё несколько неиспользуемых полей), чтобы границы между полями независимо от настроек выравнивания совпадали с~рекомендуемыми значениями таблицы~\ref{tab:alg:struct-align-size}.


\subsubsection{Обращение к~полю структуры}

% Для обращения к~полю структуры необходимо знать адрес структуры и~смещение нужного поля.
Адрес поля структуры равен сумме  адреса структуры~$base$ и~смещения нужного поля~$displacement$.
Для обращения к~полю структуры необходимо разыменовать его адрес~$*\big(base + displacement\big)$.

Это соответствует косвенной адресации
с~двумя компонентами "--- базой~$base$  и~смещением $displacement$, что в~GAS обозначается~\lstinline!displacement(base)!.

% \subsection{Обращение к~элементу структуры}

% struct TSomeStruct
% {
%     char Tag;
%     int  Val;
% } s;

В~листинге~\ref{lst:asm:alg:struct-4} показана инициализация полей~$Tag$ и~$Val$  структуры $TSomeStruct$, описанной в~листинге~\ref{lst:asm:alg:pack}.

\begin{lstlisting}[caption={Инициализация структуры с~выравниванием на 4~байта}, label=lst:asm:alg:struct-4]
TSomeStruct s;
asm
(
"movb $'a', (%[S])\n"
"movl $13, 4(%[S])\n"
:
:[S]"r"(&s)
: "memory"
);
cout << s.Tag << " " << s.Val << endl;
\end{lstlisting}

Вывод программы показывает корректность инициализации
\begin{lstlisting}[numbers=none]
a 13
\end{lstlisting}


% \subsubsection{Обращение к~элементу структуры (переносимый код)}


Так как расположение полей зависит от настроек компиляции, более надёжно передавать смещения полей как параметры вставки (листинг~\ref{lst:asm:alg:struct-f}).

\begin{lstlisting}[caption={Инициализация  структуры с~неизвестным выравниванием}, label=lst:asm:alg:struct-f]
asm
(
"movb $'a', %c[tag_disp](%[S])\n"
"movl $13,  %c[val_disp](%[S])\n"
:
:[S]"r"(&s),
 [tag_disp]"i"(reinterpret_cast<char *>(&s.Tag) 
    - reinterpret_cast<char *>(&s)),
 [val_disp]"i"(reinterpret_cast<char *>(&s.Val) 
    - reinterpret_cast<char *>(&s))
: "memory"
);
\end{lstlisting}


Полученный код не зависит от настроек выравнивания, но очень тяжело читается.

Если код оформляется не как ассемблерная вставка, а~как функция, принимающая структуру, описанную на C++,
необходимо 
либо передавать смещения полей как параметры функции и~рассчитывать адреса вручную (что сильно замедлит выполнение),
либо задаться конкретными значениями (возможно, при помощи макросов препроцессора),
либо, что лучше всего, описывать структуру таким образом, чтобы при любых настройках выравнивания дыры между полями отсутствовали и~смещения полей не менялись.
\begin{lstlisting}[caption={Структура, выравненная вручную}, label=lst:asm:alg:robust]
struct TRobustStruct
{
    char Tag;    
    char dummy[3]; // неиспользуемые поля
    int  Val;
};
\end{lstlisting}
Листинг \ref{lst:asm:alg:robust} показывает подобное описание.

% \nsection{Контрольные вопросы}
% \epigraph{\begin{stanza}И~со свечкой искали они, и~с~умом,\\
% С~упованьем и~крепкой дубиной,\\
% Понижением акций грозили притом\\
% И~пленяли улыбкой невинной.\\
% \end{stanza}
% }
% {\Snark}


 
\addquestion {Какая команда передаёт управление подпрограмме?}
\addquestion {Какая команда возвращает управление вызывающей программе?}
\addquestion {Что такое адрес возврата?}


\addquestion{Какие~вы знаете соглашения о~вызове?}
% \addquestion{Как подключить к~проекту используемой вами IDE модуль на ассемблере?}
\addquestion{Как импортировать ассемблерную функцию в~проект на C++?}



\addquestion{Как, согласно ЕСПД, изображается блок «терминатор»?}
\addquestion{Как, согласно ЕСПД, изображается блок «процесс»?}
\addquestion{Как, согласно ЕСПД, изображается блок «решение»?}


\addquestion{Как располагаются в~памяти элементы массива?}
\addquestion{Как найти размер массива, зная размер элемента и~их количество?}


\addquestion{Что такое выравнивание полей структуры?}
\addquestion{Зачем нужно выравнивание данных?}




\printquestions







