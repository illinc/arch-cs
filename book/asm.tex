
% \chapter{Уровень архитектуры команд линейки x86}


\chapter{Программирование на языке ассемблера}
\epigraph{\begin{stanza}[0mm]
Есть великая правда у тех, кем хранится завет\\
Но для тех, кто им стал, нет завета и истины нет.\\
\end{stanza}}{С. Калугин}
\label{sec:asm}
\index{Синтаксис!AT\&T}

% Для архитектуры x86 разработано множество трансляторов ассемблера, каждый из которых описывает свой язык.

Данное пособие описывает программирование на языке GNU Assembler (GAS) для архитектуры x86
с~использованием традиционного синтаксиса AT\&T.

Если не указано иное,
примеры соответствуют тридцатидвухбитной платформе.
Вызовы функций описываются в~соответствии с~тридцатидвухбитным соглашением cdecl и~без учёта искажения имён (см. раздел~\ref{sec:calling-functions}).

\section{Особенности GNU Assembler}
\epigraph{\begin{stanza}
А~тот, кто сторожит баржу, спесив \\
И~вообще не святой;\\
Но тот, кто сторожит баржу, красив \\
Неземной красотой.\\
\end{stanza}}
{\Aquarium}
\label{sec:asm-gas}

G%NU Assembler
AS, как и~его предок, ассемблер Unix as,
% Ассемблер Unix as (его версия из коллекции GCC назывется gas) 
использует так называемый синтаксис AT\&T System V/386, часто называемый просто синтаксисом AT\&T или синтаксисом GAS~\cite{Assembler-fsf}.

\index{Синтаксис!Intel}
Также для процессоров семейства Intel x86 часто используется  синтаксис, предложенный фирмой Intel.
Основными отличиями синтаксиса Intel от  AT\&T считаются обратный порядок операндов, другие обозначения адресации  и~невозможность явного указания разрядности операции.
Менее известно различие в~мнемонических обозначениях команд.
Современные версии ассемблера GAS  поддерживают оба варианта синтаксиса.

Основными недостатками синтаксиса Intel является неоднозначность и~трудность чтения инструкций.
Кроме того, синтаксис Intel используется только для процессоров Intel или совместимых с~ними.

Синтаксис AT\&T иногда называется кроссплатформенным, так как GCC и, соответственно, GAS  реализован для множества различных архитектур.
Полной кроссплатформенности при использовании языка ассемблера достичь невозможно, 
так как у~каждой платформы свой набор %команд и~регистров, % и~особенностей,
команд, регистров и~методов адресации,
но использование %универсального синтаксиса облегчает %\чтение программ
схожего синтаксиса
переход между ними.

Также инструкции, записанные в~соответствии с~синтаксисом AT\&T, легче читаются (кроме косвенной адресации).


% \footnote{Использованы материалы:
% GCC-Inline-Assembly-HOWTO, << ссылка в~inline
% Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А. << ниже
% Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
% X86 Assembly/GAS Syntax << вики
% }

\subsection{Общие правила}
% \epigraph{\begin{stanza}
% Держали камни в ладонях:\\
% Яшму и оникс; хрусталь, чтобы лучше видеть.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}
 Итак, попался. А теперь что делать?
\end{stanza}}
{О.\,Арефьева}

Так как GAS в~основном используется на одном из этапов компиляции программы на %языке высокого уровня, о 
C/C++, 
многие синтаксические конструкции GAS и~C/C++ совпадают.

В~программе могут использоваться латинские буквы, цифры, %символы \lstinline!%, $, *, ., —!
а~также нижнее подчёркивание и~точка.
% 
Допустимые пробельные символы "--- пробел и~табуляция;
они могут сочетаться в~любом порядке.
Перевод строки является разделителем операторов.

Допускаются многострочные комментарии  /* в~стиле C */
и~однострочные // в~стиле C++.
% Также поддерживается устаревший 
% #<не выражение> устаревший
Также для различных платформ поддерживаются платформоспецифичные виды однострочных комментариев.

Оператор ассемблера целиком размещается на одной строке.
В~начале строки может быть одна или несколько меток, заканчивающихся двоеточием.
% Перед оператором может быть метка.
Если первый символ оператора "--- точка, то это "--- директива ассемблера (первая строка листинга~\ref{lst:asm:directive:instruction}).
Набор директив в~основном совпадает для всех архитектур.
\begin{lstlisting}[caption=Директива и~команда, label=lst:asm:directive:instruction]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}
Пустой оператор может состоять только из пробельных символом или быть пустой строкой (вторая строка).
Оператор, начинающийся с~буквы, представляет собой мнемоническое обозначение машинной команды,
за которым при необходимости следуют операнды, разделённые запятыми (третья строка листинга~\ref{lst:asm:directive:instruction}).
% Оператор оканчивается переводом строки или точкой с~запятой.

Строковые литералы ограничиваются двойными кавычками, экранирующим символом является обратный слеш «\textbackslash»,
спецсимволы кодируются аналогично C/C++.
Числовые литералы также описываются аналогично C/C++.





\subsection{Основные директивы}
% \epigraph{\begin{stanza}
% Что нам подвластно? Гранитные поля,\\
% Птицы из пепла, шары из хрусталя.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}
Не танцевать же мы на танцы ходим!
% Так слово за слово "--- и выучишься мату.
\end{stanza}}
{О.\,Арефьева}
Директива ассемблера не соответствует никакой машинной команде.
Рассмотрим несколько наиболее употребительных директив; их можно разбить на несколько классов.

\subsubsection{Директивы определения сегмента}

Как было описано в~разделе~\ref{sec:mem-segments}, код программы и~различные виды данных должны располагаться в~различных диапазонах адресного пространства.
По историческим причинам эти диапазоны называются сегментами (соответствующие фрагменты исходного кода "--- секциями).
Начало содержимого того или иного сегмента в~исходном ассемблерном коде отмечается специальными директивами.

С~начала файла до первой директивы располагается сегмент кода.
Указать продолжение сегмента кода можно директивой \termin{.text}.

Сегмент данных открывается директивой \termin{.data}.
В~принципе, описание статических данных в~сегменте кода не вызовет ошибки, но такие данные будет невозможно модифицировать, так как сегмент кода защищён от изменений.
% 
% Те глобальные и~статические переменные, которые не были инициализированы при объявлении,
% отделяются  в~специальный \termin{сегмент BSS.}
% % \termin{.bss}

Для сегментов стека и~кучи нет соответствующих секций, они заполняются динамически в~процессе выполнения программы.

\subsubsection{Директивы определения данных}

В~сегменте \termin{.data} статические данные описываются также с~помощью  директив.

После директивы определения данных указывается литерал подходящего типа или несколько литералов, перечисленных через запятую.
В~памяти соответственно  резервируется одна или несколько ячеек соответствующего размера, которые инициализируются указанными значениями.

Для того, чтобы дать адресу ячейки имя, перед соответствующим определением необходимо поставить метку
(листинг~\ref{lst:asm:directive:data}).
\begin{lstlisting}[caption=Определение статических данных, label=lst:asm:directive:data]
foo: .long 0, 1, 2
bar: .double -8.7
\end{lstlisting}
Важно помнить, что ассемблер, в~отличие от языков высокого уровня, не является типизированным.
Таким образом, если, в~частности, 
по адресу $bar$ расположено  восьмибайтовое значение двойной точности~$-8,7$,
а~программист обратится к~нему как к~числу одинарной точности (четыре байта), это не вызовет ошибки, но прочитанное значение будет другим.

Для инициализации памяти целыми значениями различного размера используются следующие директивы:
\termin{.byte} %одно или несколько выражений, разделённых запятыми
"--- однобайтовое (восьмибитное) целое,
\termin{.short}
% \termin{.short .half }
"--- %двухбайтовое,
шестнадцатибитное,
% \termin{.int (.long)}
% "--- четырёхбайтовое,
\termin{.long} 
"--- тридцатидвухбитное,
\termin{.quad}
"--- шестидесятичетырёхбитное. %восьмибайтовое 
Размер и~порядок байтов определяются платформой;  приведены размеры для x86 (они же наиболее распространённые).
Также существуют директивы  \termin{.word} и~\termin{.int}, для x86 %эквивалентные .short и~.long 
определяющие шестнадцати- и~тридцатидвухбитные целые
соответственно.
%  H8/500. However, on this platform the `.int' and `.word' directives generate 16-bit numbers.
% On the Sparc, the .word directive produces 32 bit values, instead of the 16 bit values it produces on many other machines. 
 
Значения с~плавающей запятой одинарной (32 бита) и~двойной (64 бита) точности описываются директивами
\termin{.float
(.single)}
и~\termin{.double}. %одно или несколько вещественных значений, разделённых запятыми

Для инициализации памяти строковыми константами различного вида используются следующие директивы.
Функции стандартной библиотеки C используют строки, завершающиеся нулём; 
их можно описать директивой
\termin{.string (.asciz)} (листинг~\ref{lst:asm:directive:asciz}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки, завершающейся нулём}, label=lst:asm:directive:asciz]
msg: .string "Hello, world!\n"
\end{lstlisting}
Если после директивы указывается несколько строковых литералов через запятую, завершающий ноль добавляется после каждого.

Строка без завершающего нуля
 описывается директивой
\termin{.ascii} (листинг~\ref{lst:asm:directive:ascii}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки без завершающего нуля}, label=lst:asm:directive:ascii]
msg:
.ascii "Hello, world!\n"
len = . - msg // символу len присваивается длина строки
\end{lstlisting}
Для обработки подобных строк нужно знать их длину (её нельзя определить, анализируя содержимое памяти%, так как строка 
).
Для этого используется специальный символ «.» "--- адрес текущего оператора (в~том числе ячейки с~данными).
% Строки без завершающего нуля используются, в~частности

Директивы определения данных точно так же сработают и~будучи размещёнными в~сегменте кода (.text или неименованная секция в~начале программы),
но такое размещение будет ошибкой.
Если данные попадут во фрагмент кода, который выполняется, они будут интерпретированы как команды, что, скорее всего, приведёт к~сбою при декорировании.
Даже если данные находятся в~той части кода, которая не получает управления, их будет невозможно модифицировать.

\subsubsection{Прочие}

Парные директивы
\termin{.rept $\ldots$ .endr} соответствуют повторению фрагмента между ними,
в~частности
\begin{lstlisting}[caption=Директива .rept, label=lst:asm:directive:rept]
.rept 4   
.long 0   
.endr     
\end{lstlisting}
интерпретируется как четырёхкратное повторение оператора \lstinline!.long 0!:
\begin{lstlisting}[caption=Эквивалентное описание данных без использования .rept, label=lst:asm:directive:rept-result]
.long 0
.long 0
.long 0
.long 0
\end{lstlisting}
Директивы .rept $\ldots$ .endr могут применяться и~к~командам. 
При этом происходит именно многократное дублирование  фрагмента кода в~исполняемом файле, а~не циклическое повторение одной и~той же его копии.

\termin{.globl (.global)}
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает символ  доступным из других модулей.
\begin{lstlisting}[caption=Описание символа $main$ как доступного компоновщику, label=lst:asm:directive:global]
.globl main
\end{lstlisting}

Парные директивы
\termin{.func  $\ldots$  .endfunc} включают в~исполняемый файл отладочную информацию о~функции (только при сборке в~отладочном режиме).


\subsection{Порядок операндов}
\epigraph{\begin{stanza}
    Он, пол сменив, сменил и потолок!
\end{stanza}}
{О.\,Арефьева}


В~GAS принят порядок записи операндов слева направо, следуя европейскому направлению письма.
% В~отличие от синтаксиса Intel, 
Соответственно, инструкция GAS обычно имеет вид
% , приведённый в~листинге~\ref{lst:asm:instruction-common-source-destination}.
% [caption=Источник и~приёмник команды, label=lst:asm:instruction-common-source-destination]
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.

Для команд с~тремя операндами (один из них в~x86 "--- всегда непосредственное значение) вначале записывается непосредственное значение, затем источник, затем приёмник.
\begin{lstlisting}
mnemonic immediate, source, destination
\end{lstlisting} 
% [caption={Источник, приёмник и~непосредственный операнд команды}, label=lst:asm:instruction-common-source-destination-imm]

Если среди операндов нет приёмника (в~частности, команды %\lstinline!bound!, \lstinline!invlpga! и~команды 
с~двумя непосредственными операндами, такие как \lstinline!enter!), 
порядок в~AT\&T совпадает с~порядком, указанным в~документации Intel~\cite{Assembler-fsf}.
%  AT&T and Intel syntax use the opposite order for source and destination operands. Intel ‘add eax, 4’ is ‘addl $4, %eax’. The ‘source, dest’ convention is maintained for compatibility with previous Unix assemblers. Note that ‘bound’, ‘invlpga’, and instructions with 2 immediate operands, such as the ‘enter’ instruction, do not have reversed order. i386-Bugs. 

При этом, если команда принимает операнды в~регистрах или памяти, но не модифицирует их (в~частности, команды сравнения~\lstinline!cmp! или~выделения бита \lstinline!bt!), %это не значит, что у~неё нет приёмника.
в~большинстве случаев один из операндов всё равно считается приёмником.
% причём 
Каждая из приведённых команд входит в~семейство, %схожих команд, большая часть которых 
большая часть команд которого
модифицирует этот операнд.
 
В~частности, рассмотрим одну из наиболее употребительных мнемоник ассемблера "--- команду пересылки (копирования) \lstinline!mov!.
Она соответствует оператору присваивания языков высокого уровня.
Её операнды "--- источник и~приёмник.
В~синтаксисе Intel пересылка $dest = src$ имела бы вид \lstinline!mov dest, src!; в~используемом в~данном пособии синтаксисе AT\&T она имеет вид \lstinline!mov src, dest!.
% 
Например, команда \lstinline!movb $0x05, %al! помещает значение~5 в~регистр~$al$.

\subsection{Адресация операндов}
% \epigraph{
% %      - Хорошо, - сказал я. - Я~тоже задам  последовательность  вопросов  о
% % местоположении.
% %      - Задавай, задавай, - пробормотал Чапаев.
% %      - Начнем по порядку. 
% "--* Вот вы расчёсываете лошадь. А~где находится  эта лошадь?
% %      Чапаев посмотрел на меня с~изумлением.
% %      - Ты что, Петька, совсем охренел?
% %      - Прошу прощения?
% 
%       "--* Вот она.
% }{В.\,Пелевин}

\epigraph{

"--* Где, "--- спрашивает, "--- ты живёшь?

"--* Ступай, "--- говорит, "--- прямо, повороти направо. Тут~будет пень большой. Ты разбегись да треснись башкой. Как искры из глаз посыплются "--- тут меня и~увидишь...
}{П.\,Бажов}



\index{Адресация!виды}
\label{sec:addressing}


Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
В~разделе~\ref{sec:addressing:common} были описаны различные виды адресации.
% Каждому из них соответствует об
Рассмотрим обозначения, принятые в~GAS для методов адресации явно передаваемых параметров команд x86.

% % Данные могут адресоваться различными способами.
% Для %них 
% явно передаваемых параметров
% доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная}\index{Адресация!непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).

Непосредственные операнды отмечаются префиксом~\lstinline!$!.
% 
Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая}\index{Адресация!прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды.

Операнды, описываемые статическим адресом в~памяти, не имеют префикса.
% 
Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n!~(значение глобальной переменной $n$).

\item \termin{Регистровая}\index{Адресация!регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;

Операнды в~регистрах отмечаются префиксом~\lstinline!%!.
% 
Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!.

\item \termin{Косвенно-регистровая (косвенная)}\index{Адресация!косвенная} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).


%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров.

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}


В~языке ассемблера x86 конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
\begin{equation}
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% *\big({Base} + scalar\,multiplier \cdot {Index} + Displacement\big)
*\big({base} + scalar\,multiplier \cdot {index} + displacement\big)
\end{equation}
где $base$ и~$index$ "--- регистры (32-разрядные для соответствующей платформы), $displacement$ "--- целое число (смещение), $scalar\,multiplier$ "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется $scalar\,multiplier = 1$, вместо остальных пропущенных параметров  используется~$0$).

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS имеет вид
\begin{lstlisting}
displacement(base, index, scalar multiplier)
\end{lstlisting} 
% [caption={Формат описания адреса в~памяти}, label=lst:asm:pointer-common]
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
Таким образом, прямая адресация в~принципе может рассматриваться как частный случай косвенной,
когда  оба регистра и~масштабный коэффициент опущены вместе со скобками.

}

Например, следующая команда использует все четыре параметра и~загружает 
% в~$a$ значение  $*\big(bp - 4 + (d \cdot 4)\big)$
в~$A$ значение  $*\big(bp+ D \cdot 4 - 4 \big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dest! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера).
\begin{lstlisting}
movl  -4(%ebp, %edx, 4), %eax	// eax = *(ebp + 4edx - 4)
\end{lstlisting} 
% [caption={Расчёт $A = *(bp+ 4D - 4) $}]
Чаще используются сокращённые варианты адресации, когда указывается только часть параметров.

Если используется только параметр~$base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает %значение $*C$ 
четырёхбайтовое значение по адресу~$C$
в~регистр $D$.
\begin{lstlisting}
movl  (%ecx), %edx	// edx = *ecx
\end{lstlisting} 

С~параметрами~$base$ и~$displacement$ получим $*\big(base + displacement\big)$, что соответствует обращению к~полю структуры ($base$ "--- адрес структуры, константа~$displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса $bp - 4$)
в~регистр $A$.
\begin{lstlisting}
movl  -4(%ebp), %eax	// eax = *(ebp - 4)
\end{lstlisting} 
При передаче параметров функции через стек обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека~$sp$.
% 
На вершине стека, то есть по адресу $*sp =$\lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

 

При использовании всех параметров, кроме $displacement$, получим $*\big(base + scalar\,multiplier \cdot {index}\big)$, что соответствует обращению к~элементу массива.
Действительно, адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
он может быть масштабным коэффициентом ($scalar\,multiplier$)
и~к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(base + index \cdot scalar\,multiplier\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! %обычно 
равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~$C$, а~индекс "--- в~$si$, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Соответственно, запись~$M[i]$ в~регистр~$A$ будет выглядеть следующим образом:
\begin{lstlisting}
movl (%ecx, %esi, 4), %eax  // eax = *(ecx + 4esi) = C[si]
\end{lstlisting} 


% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 


\subsection{Размер операндов команды}
\epigraph{\begin{stanza}
    Из вредности на красный свет не ходит!
\end{stanza}}
{О.\,Арефьева}
\label{sec:att-suffixes}

Большая часть мнемоник соответствует не одной команде уровня архитектуры команд, а~целому семейству однотипных команд, которые выполняют одни и~те же действия над операндами различных размеров и, соответственно, имеют разные коды.

Размер операндов маркируется суффиксом,
добавляемым к~базовой форме мнемоники;
например,
копирование  (базовая форма команды "--- \lstinline$mov$) из~$edx$ в~$eax$ (размер операндов $long$) записывается как
\lstinline!movl %edx, %eax!.
Суффиксы перечислены в~таблице~\ref{tab:asm-suffixes}.

\begin{table}[!ht]
\caption{Суффиксы размера операндов}
\label{tab:asm-suffixes}

\noindent\begin{tabularx}{\linewidth}{|c|L|L|}
\hline
\thead{Суффикс} & \thead{Целые} & \thead{Вещественные} \\\hline
    b & byte (8  бит) &\\\hline
    s & short (16  бит) & single (32 бит) \\\hline
    w & word (16  бит) &\\\hline
    l & long (32  бит) & double (64 бит) \\\hline
    q & quad (64  бит) &\\\hline
    t & & ten bytes (80 бит) \\\hline
%     o & octuple (128 бит)&\\\hline
\end{tabularx}
\end{table}
Необходимо отметить, что для целочисленных команд и~команд обработки вещественных чисел одни  и~те же суффиксы означают различную разрядность.
Некоторые суффиксы допустимы только для одного семейства команд.
Для целочисленных команд суффиксы~\lstinline!s! и~\lstinline!w! обозначают 16-битное целое и~в~целом  равноправны
(для команды \lstinline!mov! используется только~\lstinline!w!, так как существует другая команда с~базовой формой \lstinline!movs!).

У~команд с~операндами разных размеров указывается два суффикса.
Порядок суффиксов, как и~порядок операндов "--- слева направо (от источника к~приёмнику).
Так, копирование целого числа со знаковым расширением (базовая форма команды "--- \lstinline$movs$) из~$al$ в~$edx$ выглядит как
\lstinline!movsbl %al, %edx!.
% в синтаксисе AT&T означает "расширить знак от %al к %edx". Таким образом возможны суффиксы `bl' (от byte к long), `bw' (от byte к word) и `wl' (от word к long). 
% http://www.opennet.ru/docs/RUS/gas/gas-8.html
Возможны двойные суффиксы \lstinline'bl' (от $byte$ к~$long$), \lstinline'bw' (от $byte$ к~$word$) и~\lstinline'wl' (от $word$ к~$long$) и~так далее.
Суффикс~\lstinline!s! не используется как компонент составного суффикса.

% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  %размер может быть определён по регистровому операнду.
GAS определяет размер по  регистровому операнду.
% Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
Такое поведение несовместимо с~оригинальным ассемблером AT\&T Unix, который предполагает, что отсутствие суффикса означает размер операнда $long$.
Эта несовместимость не влияет на компиляцию с~ЯВУ, так как компиляторы всегда выставляют суффиксы размера~\cite{Assembler-fsf}.

Если размер не удалось определить по операндам (то есть используются непосредственные и~в~памяти),
по умолчанию принимается размер $long$ (32 бита).
% Отсутствие суффикса чаще всего не вызывает ошибки компиляции,
Такая ситуация не всегда вызывает ошибку компиляции,
но %в~некоторых случаях (
при обработке чисел с~плавающей запятой, находящихся в~памяти, приводит к~странному результату, так как по умолчанию используется операнд одинарной точности.


\subsection{Мнемоники}
\epigraph{\begin{stanza}
    Нет, я людей практически не ем...
\end{stanza}}
{О.\,Арефьева}
\label{sec:att-mnemonic}

Первоначальные мнемонические обозначений команд процессора предлагаются
% предложена 
его разработчиками в~документации, описывающей набор команд.
В~дальнейшем ассемблеры в~основном используют именно их.
Большая часть мнемоник GAS (их базовые формы) также совпадает с~документацией Intel.

Тем не менее, часть обозначений различается.
В~частности, отличаются базовые формы команд копирования со знаковым расширением ($movs$ в~GAS, $movsx$ в~Intel)
и~копирования с~беззнаковым расширением  ($movz$ в~GAS, $movzx$ в~Intel).

% Кроме того, 
Синтаксис AT\&T предлагает для команд расширения (их неявным аргументом всегда является регистр~$A$) обозначения, построенные по схеме $cStD$ (convert $S$ to $D$), 
где $S$ "--- суффикс размера источника, $D$ "---  суффикс размера или обозначение расположения (в~случае расширения в~пару регистров) приёмника.
В~документации Intel приведены другие обозначения: они построены по схеме $cSD$ или $cSDe$ и~используют другие обозначения размера (раздел~\ref{sec:asm-conversion-A}).
% https://sourceware.org/binutils/docs/as/i386_002dMnemonics.html
% The Intel-syntax conversion instructions
% 
%  ‘cbtw’   ‘cbw’ — sign-extend byte in ‘%al’ to word in ‘%ax’,
%  ‘cwtl’   ‘cwde’ — sign-extend word in ‘%ax’ to long in ‘%eax’,
%  ‘cwtd’   ‘cwd’ — sign-extend word in ‘%ax’ to long in ‘%dx:%ax’,
%  ‘cltd’   ‘cdq’ — sign-extend dword in ‘%eax’ to quad in ‘%edx:%eax’,
%  ‘cltq’   ‘cdqe’ — sign-extend dword in ‘%eax’ to quad in ‘%rax’ (x86-64 only),
%  ‘cqto’   ‘cqo’ — sign-extend quad in ‘%rax’ to octuple in ‘%rdx:%rax’ (x86-64 only), 
% 
% are called ‘cbtw’, ‘cwtl’, ‘cwtd’, ‘cltd’, ‘cltq’, and ‘cqto’ in AT&T naming. as accepts either naming for these instructions. 
GAS поддерживает как вариант AT\&T, так и~вариант Intel.

Для несимметричных арифметических команд обработки чисел с~плавающей точкой (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
GAS использует те же мнемоники, что и~Intel, но при этом реализует качественно иное поведение %(подробнее в~разделе).
(раздел~\ref{sec:fpu-trouble-with-fsub}).

\subsection{Префиксы}
\epigraph{\begin{stanza}
%     Чудесны рифмы в Ваших одностишьях…
        Инструкция к ёлке: «товар несъедобен».
\end{stanza}}
{О.\,Арефьева}

Как уже было сказано, регистры и~непосредственные операнды обозначаются специальными префиксами.
Для ассемблера x86 имена {регистров} начинаются с~\lstinline!%!,
% (\lstinline!%eax!, \lstinline!%dl!);
% 
а~непосредственные значения (константы) отмечаются префиксом \lstinline!$!.
% , например,
% \lstinline!addl $5, %eax!
% (добавить константу 5 к~регистру $A$).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных. Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Префикс непосредственного операнда~\lstinline!$! указывается перед префиксом системы счисления (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!).

% Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

% \index{Адресация!непосредственная}
% \index{Адресация!прямая}
% Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
% \lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
% команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

% \paragraph{Вычисление адреса}
% 
% Вычисление адреса с~одновременным разыменованием
% $$
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% $$
% в~соответствии с~синтаксисом~AT\&T имеет вид
% {
% \lstset{language=}
% % There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
% \begin{lstlisting}
% displacement(base, offset, scalar multiplier)
% \end{lstlisting} 
% 
% где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% % в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% % где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% 
% В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% % \lstinline![base + displacement + offset * scalar multiplier]!.
% \begin{lstlisting}
% [base + displacement + offset * scalar multiplier]
% \end{lstlisting} 



% \subsection{Сравнение синтаксиса AT\&T и~Intel}
% \epigraph{\begin{stanza}
%     Ой, не тому угрозы ты отправил!
% \end{stanza}}
% {О.\,Арефьева}
% 
% % Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% % % 
% % % Синтаксис AT&T немного 
% % отличается от синтаксиса Intel, который используется, например, MASM. 
% % %
% % Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.
% 
% \cite{linux_parallel,}
% 
% % Рассмотрим 
% Сравним 
% \termin{AT\&T}
% 
% \begin{lstlisting}[numbers=none]
% movl $42, %eax
% 
% movl $0x10, %ebx
% 
% 
% lea  -0x30(%rcx,%rax,8), %eax
% movl (%ebx), %eax
% 
% movl $0xCCCCCCCC, %ecx
% 
% 
% movl 0xCCCCCCCC, %ecx
% \end{lstlisting}
% 
% 
% % -4(%ebp), Intel:  [ebp - 4]
% {} \termin{Intel}
% 
% \begin{lstlisting}[numbers=none]
% mov eax, 42
% 
% mov ebx, 10h
% mov ebx, 0x10 ; masm
% 
% lea eax, [rcx+rax*8-0x30]
% mov eax, dword ptr [ebx]
% 
% mov ecx, 0xCCCCCCCC   
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; masm}@*/
% mov ecx, ds:[0xCCCCCCCC]
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; nasm}@*/
% \end{lstlisting}



\section{Структура программы на ассемблере}
\epigraph{\begin{stanza}Так скажем «Банзай», и~Бог с~ней, с~твердью;\\
Все, что прошло "--- сдадим в~утиль.\\
А~здесь у~нас в~центре циклона "---\\
Снежные львы и~полный штиль.\\
\end{stanza}}
{\Aquarium}
\label{sec:asm-main}

% Исполняемый файл обязательно содержит

Программа обязательно должна включать точку входа "--- адрес, с~которого начинается её выполнение.
По умолчанию %компоновщик
линкер GCC ищет точку входа по имени  $\_start$.
% (здесь нижнее подчёркивание "--- часть имени без учёта искажения имён компилятором). 
Для программ на C/C++ по адресу $\_start$ находится стартовый код библиотеки stdlib, который, в~частности, инициализирует все используемые библиотекой ресурсы и~вызывает так называемую головную функцию $main()$.
После этого  программа выполняется по определённому алгоритму (в~частности, с~помощью цикла обработки сообщений можно реализовать событийно-ориентированную модель)
и~при определённых обстоятельствах должна корректно завершать  свою работу.
\index{main()}

Минимальная программа 
% включает точку входа (многие библиотеки определяют стартовую функцию, которая )
запускается
и~немедленно завершает  работу.
% Соответственно
Также в~учебных целях часто описывается программа, выводящая на экран приветствие «Hello, world!».

\subsection{Программирование с~использованием stdlib}
\epigraph{\begin{limerick}
    Жила-была дама приятная,\\
    На вид совершенно квадратная.\\
    Кто бы с ней ни встречался,\\
    От души восхищался:\\
    «До чего эта дама приятная!»
\end{limerick}
}
{\Lear}

По умолчанию в~GCC программа (как на языке C/C++, так и~на языке ассемблера) собирается с~поддержкой стандартной библиотеки stdlib.
Соответственно, стартовой (главной) функцией программы является $int~main(int~argc,$ $char~*argv[])$.
%  $int~main(int, char *[])$

% \section{Точка входа на ассемблере и~использование stdlib}

% Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.
Стартовая функция $main()$ может находиться как в~модуле на языке C/C++, так и~в~ассемблерном модуле.

\subsubsection{Минимальная программа с~использованием stdlib}

% Минимальная программа 
Приведём код минимальной программы на ассемблере GAS
с~использованием стандартной библиотеки stdlib (листинг~\ref{lst:asm:minmain}).
\begin{lstlisting}[caption=Минимальная программа с~использованием stdlib, label=lst:asm:minmain]
.globl main // точка входа (stdlib)
main:
     xor %eax, %eax // A ^= A, то есть A = 0
     ret // return A
\end{lstlisting}
Команда ret, в~отличие от оператора return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах (раздел~\ref{sec:calling-functions}) всегда подразумевается в~регистре~$A$.
Для тридцатидвухбитного кода это \lstinline!%eax!, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр \lstinline!%eax!.
В~данном случае это делается при помощи побитового исключающего «или».
Эта команда компактнее %\lstinline!!
явного копирования нуля в~регистр и~выполняется быстрее.

Параметры $argc$ и~$argv$ располагаются в~соответствии с~используемом соглашением о~вызове,
то есть находятся в~стеке для тридцатидвухбитных систем и~в~регистрах для шестидесятичетырёхбитных.

Эквивалент данной программы на С++  выглядит следующим образом.
\begin{lstlisting}[caption=Минимальная программа с~использованием stdlib (C++), label=lst:asm:minmain-cpp]
int main()
{
    return 0;
}
\end{lstlisting}

\subsubsection{Приветствие миру}

\index{Команды!call}
\index{Команды!push}

Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции \lstinline!printf! библиотеки stdlib
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие (C++)}, label=lst:asmmain:printf-cpp]
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на тридцатидвухбитном ассемблере выглядит следующим образом (листинг~\ref{lst:asmmain:printf-asm}).
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие}, label=lst:asmmain:printf-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    xor %eax, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются (но в~некоторых версиях Microsoft Windows могут дополняться префиксом, как описано в~разделе~\ref{sec:mangling}). 

Параметры функции \lstinline!printf! в~соответствии с~соглашением cdecl передаются через стек (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).
Так как нам не нужно извлечённое из стека значение, команду \lstinline!popl %eax! можно заменить изменением значения указателя стека~\lstinline!addl $4, %esp!.
Эта команда быстрее и~к~тому же не требует приёмника для сохранения неиспользуемого %вычищаемого из стека 
значения.

Так как для вывода приветствия не используются возможности форматированного вывода, вместо  $printf()$ можно использовать более простую функцию~$puts()$.
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие с~помощью puts}, label=lst:asmmain:printf-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call puts
    addl $4, %esp	// Вычищаем параметр из стека
    xor %eax, %eax
    ret
\end{lstlisting}



\subsubsection{Форматированный вывод}

Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}[caption={Программа, выводящая на экран два числа (C++)}, label=lst:asmmain:printf-cpp-params]
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению cdecl эти параметры передаются в~обратном порядке (то есть на вершине стека оказывается первый):
\begin{lstlisting}[caption={Программа, выводящая на экран два числа}, label=lst:asmmain:printf-asm-params]
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  xor %eax, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~$sp$, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности,~$A$) меняется (раздел~\ref{sec:calling-conventions}).
% Список регистров, которые могут изменяться подпрограммой, подробнее рассмотрен в~разделе~\ref
Если в~таких регистрах хранятся данные вызывающей программы, их надо сохранить перед вызовом функции.




\subsection{Программирование без stdlib}
\epigraph{\begin{limerick}
Старичок так следил за осанкой,\\
что питался лишь только овсянкой.\\
Но однажды съел лишку,\\
положив в~неё мышку,\\
И~серьёзно испортил осанку.\\
\end{limerick}
}
{\Lear}

Минимальная программа с~stdlib (листинг~\ref{lst:asm:minmain}) после ассемблирования занимает 4704 байт.
% % [caption=min.S]
% \begin{lstlisting}
% .globl main // точка входа (stdlib)
% main:
%      xorl %eax,%eax // EAX ^= EAX, то есть EAX = 0
%      ret // return EAX
% \end{lstlisting}
% % Сборка (полученный файл включает stdlib и~занимает %4.6 Кб "--- 
% % 4704 байт)
% % \begin{lstlisting}[language=Bash]
% % $ gcc -o min min.S
% % \end{lstlisting}
% % Сборка с~stdlib: 
% \lstinline!gcc -o min min.S!
В~этот размер входят библиотечные функции, обеспечивающие обработку параметров, вызов стартовой функции~$main()$
и~завершение программы после возврата управления из $main()$.

Отключить использование stdlib при сборке позволяет ключ~\lstinline!-nostdlib!.
В~этом случае взаимодействие с~операционной системой, в~том числе завершение программы, необходимо осуществлять с~помощью системных вызовов.

Точкой входа в~этом случае будет непосредственно метка $\_start$.
% После неё можно вручную вызвать $main()$ и~обработать возвращаемое ей значение.

Каждая операционная система имеет свой набор %системных вызовов
функций
и~свой способ их вызова.
В~большинстве операционных системные вызовы осуществляются с~помощью программных прерываний.
При этом, если в~GNU/Linux, BSD и~FreeDOS системные вызовы хорошо документированы,
в~Microsoft Windows как механизм их вызова, так и~набор функций постоянно меняются и~не документированы.
Вместо прямых системных вызовов под Microsoft Windows предлагается использовать функции библиотеки Windows API.
% Сборка без stdlib (полученный файл занимает 600 байт)
% \begin{lstlisting}[language=Bash]
% $ gcc -o nsmin  nsmin.S  -nostdlib
% \end{lstlisting}

В~GNU/Linux к~функциям операционной системы можно обратиться с~помощью прерывания \hex{0x80}.
% int 0x80, \lstinline!%eax! "--- номер функции
Номер функции указывается в~регистре~$A$.
% до 6 аргументов: \lstinline!%ebx!, \lstinline!%ecx!, \lstinline!%edx!, \lstinline!%esi!, \lstinline!%edi! и~\lstinline!%ebp!
Вызов может принимать до шести аргументов в~регистрах $B, C, D, si, di, bp$.
Если требуется передать семь значений или больше, они объединяются в~структуру, адрес которой передаётся в~$B$.


\subsubsection{Минимальная программа без stdlib}
% Мне ничего не нужно и ничего не жаль, 
% Голым и безоружным взлетаю вдаль

Рассмотрим
минимальную программу, не использующую функции stdlib (в~том числе $main()$) для GNU/Linux. % (600 байт)
Сразу после запуска она должна завершиться с~кодом~0.
Для завершения программы используется системный вызов с~кодом~1 "--- $sys\_exit()$.
Её единственный параметр "--- код возврата.
\begin{lstlisting}[caption=Минимальная программа без stdlib, label=lst:asm:minstart]
.globl _start
_start: // точка входа 
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}
% Сборка без~stdlib: 
% \lstinline!gcc -o min min.S -nostdlib!
Если код \ref{lst:asm:minstart} сохранён как файл~\lstinline!nsmin.S!,
собрать его без стандартной библиотеки можно командой:
\begin{lstlisting}[language=Bash]
$ gcc -o nsmin  nsmin.S  -nostdlib
\end{lstlisting}
полученный исполняемый файл %не  включает stdlib и~
занимает 600 байт.

% Эквивалент на С++
% \begin{lstlisting}
% int main(int argc, char* argv[]){
%     return 0;
% }
% \end{lstlisting}

\subsubsection{Приветствие миру}


Для вывода строки на экран ядром~Linux используется системный вызов с~кодом~4 "--- $sys\_write()$.
Он предназначен для записи в~файл;
требует трёх параметров "--- дескриптор файла, указатель на начало записываемых данных и~длина этих данных в~байтах.
Согласно концепции Unix всё есть файл;
для вывода на экран используется специальный дескриптор 1 ($stdout$).



\begin{lstlisting}[caption={Вывод приветствия при помощи системных вызовов Linux}, label=lst:asmmain:syscall-asm]
.data
    msg:
    .ascii "Hello, world!\n"
    len = . - msg // символу len присваивается длина строки
.global _start // точка входа в программу
_start:
    movl $4, %eax // системный вызов №4 — sys_write
    movl $1, %ebx // поток №1 — stdout
    movl $msg, %ecx // указатель на выводимую строку
    movl $len, %edx // длина строки
    int $0x80 // вызов ядра
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}






\section{Основные команды}
\epigraph{
ЭТО не работает на восьмиразрядных машинах.
}{\ProgFolk}
\label{sec:asm-commands}



Основной набор команд x86 включает команды обработки целых чисел и~разнообразные команды управления вычислениями.
Полный список команд приведён в~первом томе руководства разработчика программного обеспечения для архитектур Intel 64 и~IA-32~\cite{intelBasic}, а~подробное описание "--- во втором~\cite{intelInstructionSet}.

Структура команды такова, что
если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что %$src$ и~$dest$ 
операнды могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.

Если не указано иное, используются следующие обозначения.
Операнд, принимающий значение (приёмник) 
может быть обозначен либо как~$dest$, если он может быть регистром или переменной в~памяти,
либо как~$dreg$ или $dmem$, если он может быть соответственно только регистром или только в~памяти.
% обозначается как~$dest$, неизменяемый операнд (источник) может быть обозначен как $src$, $arg$ или иным образом.
% $src$ "--- регистр, переменная в~памяти или непосредственное значение, $dest$ и~$arg$ "--- регистры или переменные в~памяти,
% $imm$ "--- непосредственно адресуемая константа, $mem$ "--- переменная в~памяти, $reg$ "--- регистр.
Неизменяемый операнд (источник) может быть обозначен как $src$ (регистр, переменная в~памяти или непосредственное значение),
$srm$ (регистр или переменная в~памяти), $sreg$ (регистр), $smem$ (переменная в~памяти).
% Неизменя
Непосредственно адресуемая константа обозначается как $imm$.

Для большинства команд
источник и~приёмник должны быть одного размера,
Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
% При необходимости в~обозначении операнда указывается конкретная разрядность (\texttt{reg8, reg16, reg32, reg64} и~т.\,п.).


\subsection{Общие команды}
\label{sec:asm-commandsintro}
\epigraph{
\begin{stanza}[0mm]
I like to move it, move it,\\
She like to move it, move it,\\
We like to move it, move it,\\
We like to move it!\\
\end{stanza}
}{Reel 2 Real}

\index{Команды!nop}
\index{Команды!mov}
\index{Команды!lea}
\index{Команды!push}
\index{Команды!pop}
\index{Команды!call}
\index{Команды!ret}

В~таблице~\ref{tab:asm-common-list} приведены некоторые наиболее употребительные команды x86-совместимых процессоров.%
\index{Команды!пересылки}%

\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-common.tex}

\end{table}

Наверное, самой популярной командой является команда пересылки %(move)
% \lstinline!mov источник, приёмник! 
% "--- присваивание \lstinline!приёмник = источник!
\lstinline!mov src, dest! "--- аналог оператора присваивания $dest = src$ языков высокого уровня.
Рассмотрим некоторые примеры её работы:
\begin{lstlisting}[numbers=none]
movl $4, %eax	// eax = 4
movb $42, %al	// al = 42
movl %eax, (%esi)	// *esi = eax
movl %eax, 4(%esi)	// *(esi+4 байта) = eax
movl $some_var, %eax	// eax = &some_var
movl $some_var+4, %eax	// eax = &some_var+4 байта
movl some_var, %eax	// eax = some_var
movl %eax, foo	// foo = eax
\end{lstlisting}

Аналогом оператора получения адреса является команда \lstinline!lea!.
Если \lstinline!mov smem, dreg! загружает в~регистр~$dreg$ значение по адресу~$smem$, 
то  \lstinline!lea smem, dreg! загружает в~$dreg$ адрес~$smem$.

Например, следующая команда 
% использует все четыре параметра косвенной адресации и~
загружает в~$A$ значение  
$*\big(bp + 4D  - 4\big)$,
используя косвенную адресацию "--- вычисление адреса из четырёх компонент с~разыменованием:
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
% (команда \lstinline!mov src, dest! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}[numbers=none]
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда %\lstinline!lea src, dest! 
\lstinline!lea! 
загружает в~приёмник адрес источника, что компенсирует разыменование, то есть команда
\begin{lstlisting}[numbers=none]
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~$A$ значение  
$bp + 4D  - 4$.

Команда вычисления адреса~\lstinline!lea! часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем %команда беззнакового умножения~\lstinline!mul!:
команды умножения~\lstinline!mul/imul!:
\begin{lstlisting}[numbers=none]
leal    8(,%eax,4), %eax    // A = A*4 + 8   
leal    (%eax,%eax,2), %eax // A = A*2 + A = A*3
\end{lstlisting} 


\subsubsection{Работа со стеком}

Для работы со стеком предназначены в~основном команды \lstinline!push! и ~\lstinline!pop!.
Они работают только с операндами размером 4 или 2 байта, то есть указатель вершины стека всегда выравнен на 2 байта (его начальное значение делается двоично-круглым).
В~GNU/Linux стек по соглашению выравнен по $long$ (на 4~байта).


% \lstinline!push источник! \\
Команда \lstinline!push src! помещает источник в~стек.
При этом указатель стека~$sp$ уменьшается на размер источника.

Таким образом, если попытаться смоделировать работу команды \lstinline!push! при помощи команды пересылки, 
то, в~частности
% \lstinline!pushl %eax! эквивалентна
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(eax)
% movl %eax, (%esp)// *esp = %eax
% \end{lstlisting}
% Здесь суффиксы 
\lstinline!pushl $13! (здесь суффикс~$l = long$ необходим, так как разрядность операнда невозможно определить без явного указания) 
эквивалентна последовательному уменьшению~$sp$ и~записи значения в~память:
\begin{lstlisting}[numbers=none]
sub  $4, %esp	 // esp -= sizeof(long)
movl $13, (%esp) // *esp = 13
\end{lstlisting}
% \begin{lstlisting}[numbers=none]
% pushl foo
% \end{lstlisting}
% \lstinline!pushl foo! эквивалентно
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(int)
% movl foo, %eax	// eax= foo
% movl %eax, (%esp)// *esp = eax
% \end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки неэффективна, так как она и~выполняется медленнее, чем~\lstinline!push!, и~занимает больше места в~памяти.
Тем не менее, %часто встречается задача 
иногда необходимо зарезервировать в~стеке место для локальных переменных, начальное значение которых пока неизвестно.
В~этом случае можно воспользоваться командой~\lstinline!sub $size, %esp!.



Команда~\lstinline!pop dest!
"--- извлечение значения из стека и~помещение его в~приёмник~$dest$ "---
увеличивает указатель стека~$sp$  на размер приёмника.

Таким образом, \lstinline!popl %eax! можно также выполнить с~помощью команд
\begin{lstlisting}
movl (%esp), %eax // eax = *esp
add  $4, %esp     // esp += sizeof(int)
\end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки здесь так же менее эффективна, чем~\lstinline!pop!.
При этом отдельная команда~\lstinline!add $size, %esp! для удаления элемента или набора элементов из стека «в~никуда»
используется очень часто.
Она быстрее, чем однократный вызов~\lstinline!pop!, так как не обращается к~памяти; короче множественного вызова~\lstinline!pop!,
а~также не требует указания приёмника.
%множественного 
% \lstinline!popl foo! эквивалентно
% \begin{lstlisting}
% movl (%esp), %eax // eax = *esp
% movl %eax, foo	// foo = eax
% addl $4, %esp	// esp += sizeof(int)
% \end{lstlisting}



\subsubsection{Вызов и~возврат}

Вызов подпрограммы в~ассемблере выполняется командой \lstinline!call!.
Эта команда имеет один операнд "--- адрес подпрограммы в~памяти.
\begin{lstlisting}
...
  movl $10, %eax
  call foo
  // теперь %eax == 15
...
foo:
  addl $5, %eax
  ret
 \end{lstlisting}
Команда \lstinline!call foo! сохраняет указатель команд в~стеке,
управление передаётся $foo$.
% 
Возврат из подпрограммы выполняется командой 
\lstinline!ret!
"--- управление передаётся адресу, снятому со~стека.

% При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
% На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше $sp$, то есть первый параметр равен \lstinline!4(%esp)!.
% % \begin{lstlisting}[numbers=none]
% % 4(%esp)   // *(ESP+4)
% % \end{lstlisting} 
% Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее.


\subsection{Команды обнуления регистра}
% \epigraph{\begin{limerick}
%     Жил один господин из Ливорно,\\
%     Он вкушал только крошки и зёрна,\\
%     Их клюя по привычке,\\
%     Как прочие птички\\
%     На лужках и аллеях Ливорно.\\
% \end{limerick}
% }
% {\Lear}
\epigraph{\begin{stanza}
Но он побрил лицо лифтом,\\
Он вышел в январь;\\
Он сосал бирюзу и ел кусками янтарь.
\end{stanza}}
{\Aquarium}
% https://habrahabr.ru/post/183462/
% • XOR REG,REG
% • SUB REG,REG
% • PXOR/VPXOR XMMREG,XMMREG
% • PSUBB/W/D/Q XMMREG,XMMREG
% • VPSUBB/W/D/Q XMMREG,XMMREG
% • XORPS/PD XMMREG,XMMREG
% • VXORPS/PD YMMREG, YMMREG
% Более подробно – в Intel® 64 and IA-32 Architectures Optimization Reference Manual, страница 43. 
Исторически для обнуления регистров использовались команды побитового исключающего «или» с~одинаковыми операндами~\lstinline!xor %reg, %reg! и~вычитания регистра из самого себя~\lstinline!sub %reg, %reg!,
так как они выполнялись быстрее команды пересылки \lstinline!mov $0, %reg!, а~также занимали меньше места.
Зависимость по данным в~ранних моделях процессора не имела значения, так как вычисления не были конвейеризированы.

После введения конвейера традиция обнуления регистров командами \lstinline!xor! и~\lstinline!sub! сохранилась.
Поэтому в~современных моделях процессоров команды обнуления регистров (zero idioms) распознаются при декодировании 
и~выполняются как не имеющие зависимостей по данным.

% Начиная с~Pentiun~4, 
Таким образом, сейчас руководство по оптимизации Intel~\cite{intelOptimization} снова рекомендует использовать для обнуления регистров общего назначения команды:
\begin{lstlisting}
xor %reg, %reg
sub %reg, %reg
\end{lstlisting}
Для регистров расширения XMM распознаются следующие команды обнуления:
\begin{lstlisting}
xorps/pd  %xmmreg,  %xmmreg
pxor  %xmmreg,  %xmmreg
subps/pd  %xmmreg,  %xmmreg
psubb/w/d/q  %xmmreg,  %xmmreg
\end{lstlisting}
Для некоторых архитектур используются и~другие  команды обнуления регистров расширения X/Y/ZMM~\cite{intelOptimization}.

При этом команды \lstinline!xor! и~\lstinline!sub!, не распознающиеся как zero idioms, выполняются медленнее из-за зависимости по данным
(даже если результатом будет ноль).

% GENERAL OPTIMIZATION GUIDELINES
% 3-26
% 3.5.1.8  
% Clearing Registers and Dependency Breaking Idioms
% Code sequences that modifies partial register can ex
% perience some delay in its dependency chain, but 
% can be avoided by using dependency breaking idioms.
% In processors based on Intel Core microarchitecture, a number of instructions can help clear execution 
% dependency when software uses these instruction to clear register content to zero. The instructions 
% include:
% XOR REG, REG
% SUB REG, REG
% XORPS/PD XMMREG, XMMREG
% PXOR XMMREG, XMMREG
% SUBPS/PD XMMREG, XMMREG
% PSUBB/W/D/Q XMMREG, XMMREG
% In processors based on Intel microarchitecture code name Sandy Bridge, the instruction listed above plus 
% equivalent AVX counter parts are also zero idioms that can be used to break dependency chains. Further-
% more, they do not consume an issue port or an execut
% ion unit. So using zero id
% ioms are preferable than 
% moving 0’s into the register. The AVX equivalent zero idioms are:
% VXORPS/PD XMMREG, XMMREG
% VXORPS/PD YMMREG, YMMREG
% VPXOR XMMREG, XMMREG
% VSUBPS/PD XMMREG, XMMREG
% VSUBPS/PD YMMREG, YMMREG
% VPSUBB/W/D/Q XMMREG, XMMREG
% In Intel Core Solo and Intel Core Duo processors, the XO


\subsection{Команды целочисленной арифметики
% Основные арифметические команды
}
\index{Команды!арифметические}%
\epigraph{\begin{stanza}
Те, кто рисует нас, рисуют красным на сером.\\
Цвета как цвета, но я говорю о другом,\\
Если бы я умел это, я нарисовал бы тебя\\
Там, где зелёные деревья и золото на голубом. \\
\end{stanza}
}{\Aquarium}

Из-за ограниченного количества операндов в~системе команд x86 практически нет привычных по языкам высокого уровня неразрушающих арифметических операторов.
% Вместо них используются
Один из операндов, как правило, используется и~как исходное данное, и~как ячейка для записи результата.
В~частности, аналогом ассемблерной команды сложения \lstinline!add src, dest! в~C++ будет не оператор «плюс», не изменяющий свои операнды ($dest = src_1 + src_2$), а~оператор «${+}{=}$» ($dest~ {+}{=} ~src$, то есть $dest = dest+src$).

Некоторые команды, предназначенные для обработки целых чисел, перечислены в~таблице~\ref{tab:ar-command-list}.
% Некоторые команды целочисленной арифметики перечислены в~таблице~\ref{tab:ar-command-list}.


\begin{table}[p]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar.tex}

\endgroup
\end{table}

\subsubsection{Команды сложения и~вычитания}

К~этой группе, кроме собственно сложения и~вычитания, относятся также команды инкремента, декремента и~изменения знака.

Как было сказано в~разделе~\ref{sec:digits-negcodes}, представление отрицательных чисел выбиралось так, чтобы 
знаковые  числа можно было складывать и~вычитать с~помощью беззнакового сумматора.
Соответственно, операции сложения и~вычитания не делятся на знаковые и~беззнаковые.
% Каждая из них выставляет как флаг знак
Команды из группы сложения и вычитания выставляют значения  
% флагов $OF, SF, ZF, AF, PF, CF,$ 
всех шести флагов состояния
соответственно результату,
так что программист, понимая, какого рода числа он обрабатывает, может выбрать для анализа нужные флаги.
% \begin{description}
% \item[CF] беззнаковое переполнение  (перенос из~старшего разряда)
% \item[ZF] результат равен нулю
% \item[SF] старший (знаковый) бит результата
% \item[OF] знаковое переполнение (перенос в~старший разряд, но не из него или наоборот)
% \end{description}

% Источник и~приёмник должны быть одного размера.
% Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
% Более длинные числа 
Числа, разрядность которых превышает разрядность системы,
при необходимости можно складывать и~вычитать по частям.
Для этого вначале младшие части обрабатываются командами \lstinline!add/sub!, затем~к~остальным в~порядке возрастания адресов "---  \lstinline!adc/sbb!, учитывающие перенос из младшей части.
Части могут иметь любую разрядность (в~частности, шестибайтовые целые можно разбить на две части "---  четыре и~два байта или на шесть однобайтовых), но логичнее использовать четырёхбайтовые части на тридцатидвухбитной системе и~восьмибайтовые "--- на шестидесятичетырёхбитной.

\subsubsection{Вычисление линейной комбинации регистров}
\index{Команды!lea}

Также для арифметических вычислений используется команда \lstinline!lea!, которая, в~соответствии с~возможностями косвенной адресации,
может рассчитать выражение~$r1 + \gamma\cdot r2 + \delta$ (может быть опущен любой из регистров и~любая из констант).
Команда \lstinline!lea! предназначена для манипуляций с~беззнаковыми данными (указателями),
но %в~том самом распространённом случае, когда 
смещение $\delta$ интерпретируется как знаковое.
Так как
разрядность $r1$ и~$r2$ совпадает с~разрядностью $dreg$, результат совпадает со знаковым.

\subsubsection{Команды умножения и~деления}
Самые старые команды умножения рассчитывают произведение заданного множителя~$srm$ на неявный операнд "--- регистр $A$ той же разрядности, что и~$srm$.
Разрядность произведения при этом вдвое больше разрядности множителей, так что младшая  половина $A\cdot srm$ помещается в~регистр~$A$ на место неявного множителя,
а~старшая "--- в~регистр~$D$ той же разрядности.
Исключением является случай с~восьмибитными множителями "--- так как на момент появления команд умножения уже существовали шестнадцатибитные регистры,
результат $al\cdot srm$ размещается в~$ax$ (таблица~\ref{tab:ar-command-muldiv}).
Старшая половина результата отличается для знаковой и~беззнаковой интерпретации множителей, так что существуют две команды описанного действия "--- \lstinline!mul! для беззнакового умножения и~\lstinline!imul! для знакового.
% Если старшую половину можно отбросить,
% % (она равна $0$ для \lstinline!mul! и~состоит только из копий знака для~\lstinline!imul!)
% сбрасываются оба флага~$CF$ и~$OF$,
% если в~старшей половине есть значащие биты, $CF$ и~$OF$ оба взводятся.
\begin{table}[!ht]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar-muldiv.tex}

\endgroup
\end{table}

Введённая позже команда \lstinline!imul srm, dreg! рассчитывает только младшую половину произведения, а~она совпадает для знаковых и~беззнаковых чисел.
Таким образом, 
% \lstinline!imul srm, dreg! "--- умножение
двухоперандную форму команды~\lstinline!imul! можно использовать и~для знакового, и~для беззнакового умножения.

Трёхоперандная форма \lstinline!imul imm, srm, dreg! также рассчитывает только младшую половину произведения,
но перед этим константа \lstinline!imm! при необходимости расширяется.
Данная форма
соответствует двум опкодам "--- с~константой \lstinline!imm!, разрядность которой соответствует разрядности источника и~приёмника
(в~этом случае расширение не требуется)
и~с~восьмибитной константой \lstinline!imm8!~\cite{intelInstructionSet}.
Во втором случае случае \lstinline!imm8! расширяется как знаковое, поэтому трёхоперандную форму~\lstinline!imul! следует считать командой знакового умножения.

% Как двух-, так и~трёхоперандная форма 
Если произведение помещается в~младшей половине произведения, 
все формы команд \lstinline!mul/imul!
сбрасывают оба флага~$CF$ и~$OF$.
Если в~старшей половине есть значащие биты (для двух- и~трёхоперандной форм~\lstinline!imul! это значит, что результат некорректен),
оба этих флага взводятся~\cite{asmworld}.
Значения флагов нуля и~знака не определены~\cite{club155}.

Для %обратной операции "--- 
деления существуют только однооперандная форма.
Делимое (неявный операнд) всегда вдвое больше делителя (явного операнда~$srm$)
и~располагается в~паре регистров $D:A$ (старшая половина "--- в~$D$, младшая "--- в~$A$), кроме случая восьмибитного делителя  (таблица~\ref{tab:ar-command-muldiv}).
Необходимо помнить об этом и~корректно инициализировать регистр~$D$ перед делением.

Таким образом, команды  деления обратны однооперандной форме умножения.
Соответственно, деление также будет беззнаковым (\lstinline!div!) и~знаковым (\lstinline!idiv!).


После деления $D:A$ на $srm$ частное помещается на место младшей половины делимого (в~$A$), остаток "--- на место старшей половины (в~$D$).
Если старшая половина делимого содержит значащие биты, возможна ситуация, когда частное не помещается  в~отведённом для него регистре.
Соответственно, результат деления будет некорректным.


Умножение и~деление на $2^{times}$ ($times$ трактуется как беззнаковое число) может также быть выполнено с~помощью битовых сдвигов (раздел~\ref{sec:asm-bitwise}).

\subsubsection{Расширение целых чисел}
\label{sec:asm-conversion-A}

Также к~командам целочисленной арифметики можно отнести команды расширения (таблица~\ref{tab:ext-command-list}).


\begin{table}[!ht]
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ext.tex}

\endgroup
\end{table}

Современная система команд x86 включает два вида команд, которые используются для расширения "--- пересылка из источника малой разрядности в~приёмник большей
и~удвоение разрядности неявного операнда~в~регистре~$A$.

Существует две команды пересылки с~расширением "--- \lstinline!movz! для беззнакового расширения (дополнения нулями)
и~\lstinline!movs! для знакового  (дополнения знаковым битом).

% Приёмник $dreg$ может быть  только регистром, источник $srm$ может быть регистром или переменной в~памяти, размер $srm$ меньше~$dreg$.


При пересылке возможно увеличение разрядности более чем в~два раза, поэтому, если %хотя бы один операнд
источник находится в~памяти, для команды обязательно нужно указывать два суффикса (раздел~\ref{sec:att-suffixes}).

Также существует набор команд для удвоения разрядности неявного операнда в~регистре~$A$
(таблица~\ref{tab:asm-conversion}).

\begin{table}[!ht]
\caption{Мнемоники команд знакового расширения~$A$}
\label{tab:asm-conversion}
\small

\noindent\begin{tabularx}{\linewidth}{|c|cCC|cCC|}
\hline
\multirow{2}{*}{\thead{Размер}}	& \multicolumn{3}{c|}{Расширение в~регистр~$A$}	&	\multicolumn{3}{c|}{Расширение в~пару~$D:A$}	\\
\cline{2-7}
% \thead{Размер} & \thead{Действие} & \thead{Intel} & \thead{GAS} & \thead{Действие} &\thead{Intel} & \thead{GAS} \\\hline
		& \thead{Действие} & \thead{Intel} & \thead{AT\&T} & \thead{Действие} &\thead{Intel} & \thead{AT\&T} \\\hline
$8\to16$	&	$al\to ax$	& cbw 	& cbtw	&	\multicolumn{3}{c|}{---}	\\\hline
$16\to32$	&	$ax\to eax$	& cwde 	& cwtl	&	$ax\to dx:ax$		& cwd 	& cwtd	\\\hline
$32\to64$	&	$eax\to rax$	& cdqe 	& cltq	&	$eax\to edx:eax$	& cdq 	& cltd	\\\hline
$64\to128$	&	\multicolumn{3}{c|}{---}	&	$rax\to rdx:rax$	& cqo 	& cqto	\\\hline
\end{tabularx}
\end{table}

Практически для всех случаев есть две команды "--- расширение %младшей части 
$A$ до $A$ вдвое большей разрядности 
и~расширение~$A$ до пары $D:A$.
Последний вариант необходимо  использовать перед командами, использующими пару регистров~$D:A$ как источник, в~частности, командами деления $(D:A)/srm$.

Для команд удвоения разрядности регистра~$A$ есть два набора мнемоник "--- исторически используемые в~ассемблере Unix и~предложенные Intel.
Мнемоники  AT\&T для команд удвоения разрядности регистра~$A$ строятся по  схеме $cStD$ (convert $S$ to $D$),
где~$S$ "--- размер источника, $D$ "--- размер приёмника или символ~$d$ для пары регистров (кроме \lstinline!cqto!).
Мнемоники Intel построены по одной из двух схем "--- $cSD$  или $cSDe$. 
Исторически на шестнадцатибитных машинах первыми доступными вариантами удвоения были $al \to ax$ и~$ax \to dx:ax$,  так что они получили имена без суффикса~$e$.
В~дальнейшем суффикс $e$ использовался для расширения $A \to A$, а~расширение $A \to D:A$ выполняется командой без суффикса.
Для команд удвоения разрядности $A$ GAS поддерживает оба набора мнемоник, перечисленные в~таблице~\ref{tab:asm-conversion}.


Увеличить разрядность неявного операнда~$A$ более чем в~два раза с~помощью команд таблицы~\ref{tab:asm-conversion} можно только последовательным применением нескольких команд удвоения.

Все команды удвоения разрядности~$A$ выполняют знаковое расширение.


Беззнаковое расширение $A \to D:A$ может быть выполнено явным обнулением регистра~$D$.
% В~случае расширения $A \to A$ можно обнулить $$

% Все команды расширения имеют различные мнемоники для синтаксиса AT\&T и~синтаксиса~Intel (раздел~\ref{sec:att-mnemonic}).

% Команды пересылки с~расширением в~синтаксисе Intel имеют дополнительный суффикс~\lstinline!x!.
% В~GAS 

% Мнемоники Intel "--- по схеме $cSD$ или $cSDe$.


% \FloatBarrier

\subsection{Битовые операции}
\epigraph{\begin{stanza}[0mm]
Она может двигать,\\
Она может двигать собой,\\
В полный рост "---\\
Она знает толк в полный рост
\end{stanza}
}{\Aquarium}
\label{sec:asm-bitwise}

Некоторые команды, предназначенные для обработки битовых строк, перечислены в~таблице~\ref{tab:bit-command-list}.

\begin{table}[p]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-bit.tex}

\end{table}

Система команд x86 включает поразрядные логические операции, все описанные в~разделе~\ref{sec:bitwise} битовые сдвиги, а~также команды выделения бита по номеру.

Команды битового сдвига принимают два операнда: сдвигаемое значение $dest$ и~беззнаковое количество сдвигов~$times$.
Количество~$times$ может быть непосредственным значением или регистром~$cl$, причём даже в~шестидесятичетырёхбитных системах используется только младшие~шесть его бит (в~тридцатидвухбитных "--- пять).
\pagebreak[3]

При $times=1$ происходит сдвиг в~указанную сторону на один бит.
% При этом с~одного конца $dest$ освобождается ячейка, а
% один бит выходит за г
Значение бита, вышедшего за разрядную сетку, после выполнения команды заносится в~$CF$.
Освободившаяся с~другого конца $dest$ ячейка инициализируется в~соответствии с~видом сдвига.

При $times > 1$ однобитовый сдвиг повторяется $times$ раз.

Знаковый и~беззнаковый сдвиги используется для быстрого умножения и~деления на степени двойки.
% 
Сдвиги вправо эквивалентны соответственно знаковому или беззнаковому делению на $2^{times}$.
В~случае однобитового сдвига (деления на два) остаток попадает в~$CF$.
Для б\'{о}льших значений сдвига остаток не вычисляется.

Сдвиг влево эквивалентен умножению на $2^{times}$, если результат умножения помещается в~$dest$. Если не помещается, старшая часть произведения теряется.

Кроме того, с~помощью  команд семейства \lstinline!btX! можно выделить отдельный бит числа.
Эти команды принимают два операнда "--- число-приёмник, один бит которого будет скопирован в~флаг~$CF$ и~затем изменён,
и~номер бита $idx$ "--- непосредственное значение или регистр.
Для младшего бита $idx=0$.
% При выполнении команды \lstinline!btX! значение бита  с~указанным номером заносится в~флаг~$CF$, 
% после чего этому биту числа присваивается новое значение.
Одна из команд семейства, \lstinline!bt!, не изменяет значение битов в~числе, но для единообразия её  операнд, из которого выделяется бит, также считается приёмником.

% \FloatBarrier




\subsection{Флаги}
\epigraph{\begin{stanza}[0ex]
I can talk with you,\\
I can walk with you,\\
\hspace{\stanzaoddindent}All throughout your life;\\
Stay with you, smile on you,\\
\hspace{\stanzaoddindent}Light in your fire.\\
\end{stanza}}
{\Aquarium}
% \subsubsection{Установка, сохранение и~восстановление флагов}
% \subsubsection{Флаги}
\label{sec:asm-flags}
\index{Флаги!установка}


Все арифметические команды устанавливают по результатам вычислений  флаги состояния.

% Команды группы сложения/вычитания устанавливают све шесть 
Команды группы сложения/вычитания выставляют все шесть флагов состояния $CF, PF, AF, ZF, SF, OF$ в~соответствии с~результатом:
\begin{itemize}
\item флаг нуля~$ZF$, если результат равен нулю;
\item флаг переноса (беззнакового переполнения)~$CF$ в~случае переноса/заёма за пределы разрядной сетки (беззнакового переполнения);
\item флаг знака~$SF$, если старший (знаковый) бит результата равен 1;
\item флаг знакового переполнения~$OF$, если произошло знаковое переполнение (перенос/заём из знакового бита, но не за пределы разрядной сетки, или наоборот);
\item флаг чётности $PF$, если количество единиц в~младшем байте результата чётно;
\item флаг вспомогательного переноса $AF$, если в~младшем байте был перенос между тетрадами.
\end{itemize}
При этом \lstinline!add $-1, dest! и~\lstinline!sub $1, dest! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит ($OF=0$); при вычитании единицы из нуля возникает заём из старшего бита  ($OF=1$).

Побитовые команды (\lstinline!and, or, xor!) выставляют флаги $SF, ZF$ и~$PF$ в~соответствии с~результатом аналогично группе сложения/вычитания,
флаги переноса и~знакового переполнения сбрасываются: $CF = OF = 0$.
Значение флага~$AF$ не определено.

Команды умножения выставляют флаги $CF=OF$ в~зависимости от того, выходит ли результат за разрядность множителей.
Значение остальных флагов не определено.
После команд деления все шесть флагов имеют неопределённое значение.

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
\index{Команды!сравнения}
Это:
\begin{itemize}
\item \lstinline!cmp! "--- то же самое, что и~\lstinline!sub! (группа сложения/вычитания), но операнд-приёмник не изменяется (используется для сравнения целых чисел);
\item \lstinline!test! "--- то же самое, что и~\lstinline!and! (группа побитовых операций), но операнд-приёмник не изменяется (используется для сравнения битовых строк).
\end{itemize}

Основной набор инструкций x86 не содержит команд для обработки и,~в~частности, сравнения вещественных чисел.
Предназначенные для этого инструкции сравнения относятся к~набору команд FPU (раздел~\ref{sec:fpu-cmp}), но могут взаимодействовать с~регистром~$flags$.
Вещественные числа можно сравнить командой \lstinline!fcom! и~подобными ей.
% Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
% Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~$flags$ (вручную или автоматически "--- в~зависимости от используемой команды сравнения) таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел:
$ZF$ указывает на равенство, $CF$ "--- на $dest<src$; кроме того, в~$PF$ копируется флаг несравнимости операндов. 
% , так что для команды .
% флаг $ZF$ соответствует нулевой 


 
Кроме того,  флаги можно установить или сбросить вручную 
с~помощью специальных команд или загрузив изменённый регистр~$flags$
(таблица~\ref{tab:flags-command-list}).
\begin{table}[!ht]
\small
\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/instr-flags.tex}
\end{table}


% Кроме того, 
Младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить для анализа в~регистр $ah$ командой~\lstinline!lahf! \ethm{(Load Flags into AH Register).} 
Обратная операция выполняется командой~\lstinline!sahf! \ethm{(Store AH into Flags).}
% 
Регистр $flags/eflags$ можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно.
% (таблица~\ref{tab:flags-command-list}).
При загрузке флагов из~$ah$ или стека зарезервированные биты не загружаются в~$flags$.




\subsection{Условные операторы}
\label{sec:asm-cc}
\epigraph{\begin{stanza}
Я~могу быть бессмысленным,\\
Выбрать пути не те,\\
Но есть смелая истина\\
В~широте-долготе.\\
\end{stanza}}
{О.\,Арефьева}

% Как было указано в~разделе~\ref{sec:flags}, 
Существует несколько семейств команд, действие которых определяется значением флагов состояния в~регистре~$flags$.
Это команды условного перехода \lstinline!jCC!, 
условной установки байта \lstinline!setCC! и~условной пересылки~\lstinline!cmovCC! и~\lstinline!fcmovCC!.
% (таблица~\ref{tab:cc-command-list}).
% 
% % Команды условного ветвления %\lstinline!jCC, setCC, loopCC!,
% % \lstinline!jCC!, 
% % условной установки байта \lstinline!setCC! и~условной пересылки~\lstinline!cmovCC! используют один или несколько флагов состояния, проверяя различные условия (таблица~\ref{tab:cc-command-list}).
% 
% \begin{table}[!ht]
% \caption{Условные команды}
% \label{tab:cc-command-list}
% 
% \small
% \def\normalsize{\small}
% \begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
% \hline
% \normalfont\thead{Команда} & \thead{Действие} 
% \\\hline
% jCC label	&	Переход по адресу $label$, если %установлено сочетание флагов 
% верно условие $CC$ (таблица~\ref{tab:jmp-command-list}) 	\\\hline
% setCC dest	&	Установка байта $dest = 1$, если %установлено сочетание флагов 
% верно  $CC$, и~$dest=0$ иначе	
% % 
% % $dest$ может быть однобайтовым регистром или переменной в~памяти
% \\\hline
% cmovCC src, dest	&	Присваивание $dest = src$, если %установлено сочетание флагов $CC$	\\\hline
% верно  $CC$ \\\hline
% fcmovCC \%st(i), \%st(0) & %Условная пересылка регистров~FPU 
% Присваивание  регистров~FPU  $st(0) = st(i)$, если %установлено сочетание флагов $CC$	\\\hline
% верно  $CC$
% (таблица~\ref{tab:fpu-fst-list}) \\\hline
% \end{tabularx}
% \end{table}

% \FloatBarrier

Команда~\lstinline!fcmovCC! относится к~набору команд FPU и~описана также в~разделе~\ref{sec:fcmovCC} (таблица~\ref{tab:fpu-fst-list}), но условие~$CC$ определяется значением регистра~$flags$,
а~не собственного регистра состояния~FPU.
% Соответственно,~\lstinline!fcmovCC! рассматривается в~данном разделе 

Мнемоники таких команд состоят из двух частей "--- общего для всех команд семейства обозначения действия (\lstinline!j! от \ethm{jump,} \lstinline!set! и~т.\,п.)
и~обозначения условия~$CC$.
Условие не может быть произвольным.
Существует определённый набор обозначений~$CC$, каждому из которых соответствует некоторое состояние флагов в~регистре $flags$ "--- условие.


\subsubsection{Условия}


Рассмотрим доступные варианты условий, их обозначения и~связь с~арифметическими операциями (таблица~\ref{tab:cc-list}). 


\begin{table}[p]
\small
\def\normalsize{\small}
\renewcommand\theadfont{\bfseries\footnotesize}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\att}[1]{{\emph{\textcolor{clGas}{\hfill #1}}}}

\newcolumntype{E}{m{0.71\linewidth}}%
% \newcolumntype{E}{l}%

\singlespacing
\renewcommand{\arraystretch}{1.2}

\LTXtable{\textwidth}{book/tables/cc-list.tex}

\end{table}

Каждое из условий 
имеет некоторое буквенное обозначение~$CC$, приведённое в~первом столбце.
Одно и~то же условие может обозначаться по-разному, в~частности, «меньше или равно» "--- \lstinline!le! и~«не больше» "--- \lstinline!ng!,
но машинный код в~таких случаях одинаков.
Различные обозначения одного условия помещены в~одну ячейку таблицы и~разделяются косой чертой.

Мнемоники одного семейства с~разными условиями, в~частности, \lstinline!e! и~\lstinline!l!, ассемблируются в~разные машинные коды.


% соответствует некоторому 
Условие складывается из некоторой комбинации флагов состояния в~регистре $flags$,
указанной во втором столбце.
% 
Эти флаги определяются результатом последней  команды.
% Большинство из них выставляется только командами группы сложения/вычитания, в~частности, часто используемыми для реализации цикла командами \lstinline!inc/dec!.
% В~частности, 
% Команды группы сложения/вычитания (в~частности, часто используемыми для реализации цикла командами \lstinline!inc/dec!) выставляют все шесть флагов в~соответствии с~результатом.
% Команды умножения выставляют флаги $CF=OF$ в~зависимости от того, выходит ли результат за разрядность множителей.
% Побитовые команды выставляют флаги $SF, ZF$ и~$PF$ в~соответствии с~результатом.
% 
Различные виды арифметических команд  выставляют их в~соответствии с~полученным результатом.
В~частности, команды группы сложения/вычитания (включая часто используемые для реализации цикла команды \lstinline!inc/dec!)
изменяют все шесть флагов состояния;
побитовые команды "---  флаги $SF, ZF$ и~$PF$.
В~третьем столбце таблицы указаны свойства результата, приводящие к~подобному сочетанию флагов.


% \FloatBarrier

Часто перед условной командой вызывается команда сравнения \lstinline!cmp src, dest!, выставляющая флаги аналогично команде  \lstinline!sub src, dest! (то есть её результатом будет $dest-src$), но не изменяющая $dest$.
В~четвёртом столбце указаны соотношения между $dest$ и~$src$ для каждого условия.
Большинство обозначений условий образовано именно от них.


% Тем не менее
% \pagebreak[3]

Для беззнаковых операндов~$dest$ и~$src$ признаком отрицательности результата~$dest-src$ (то есть соотношения~$dest<src$)
будет заём в~старший бит при вычитании, то есть беззнаковое переполнение~$CF=1$.
Равенство операндов достигается при $dest-src=0$, что отмечается флагом нуля $ZF=1$.
Соответственно, $dest>src$ может быть, если $dest \not< src$ и~при этом $dest \neq src$, то есть $CF=ZF=0$.
Таким образом, любое соотношение между беззнаковыми операндами можно выразить через флаги~$CF$ и~$ZF$.

Чтобы отличить условия знакового и~беззнакового сравнения,
для беззнакового % сравнения
вместо термина «меньше» часто используется термин «ниже» \ethm{(below),} вместо «больше» "--- «выше» \ethm{(above).} 

Для знаковых %чисел отрицательность 
арифметических операций
знак результата невозможно определить только по знаковому биту (флагу $SF$), так как этот бит может быть искажён знаковым переполнением.
То есть если знак равен единице ($SF=1$), но в~процессе вычислений произошло знаковое переполнение ($OF=1$), то знаковый бит неверен и~результат на самом деле %неотрицателен
положителен.
Таким образом, результат будет отрицательным в~двух случаях: 
$\footnotesize
\left\{
\begin{array}{@{\,}l}
SF = 1\\
OF = 0
\end{array}
\right.
$ 
(знаковый бит "--- единица и~переполнения не было)
и~$\footnotesize
\left\{
\begin{array}{@{\,}l}
SF = 0\\
OF = 1
\end{array}
\right.
$
(было переполнение и~знаковый бит "--- ноль).
Обычно это условие записывается в~виде~$SF \neq OF$.
Соответственно, при~$SF=OF$ результат неотрицателен.

% Соответствующие обозначения 

% Кроме \lstinline!cmp!

% Флаг переноса~$CF$ используется многими командами «не по назначению»,
% поэтому, кроме обозначений \lstinline!b/nae! и nb/ae

% \FloatBarrier

% Условия для команд 
После сравнения вещественных чисел %и~выгрузки 
флаг вещественной несравнимости выгружается в~бит~$PF$ регистра~$flags$,
поэтому для команд условной пересылки вещественных чисел (и~только для них) условие $PF=1$ записывается как~\lstinline!u!.



\subsubsection{Условные и~безусловные переходы}
\index{Флаги!проверка}

% \footnote{Использованы: 
% http://asmworld.ru/spravochnik-komand/jcond/,
% http://unixwiz.net/techtips/x86-jumps.html
% }

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода~\cite{asmworld}.

В~таблице~\ref{tab:jmp-command-list} приведены эти команды.
\index{Команды!передачи управления}

\begin{table}[!ht]
\caption{Команды передачи управления}
\label{tab:jmp-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
jmp label	&	{Безусловный переход ($goto$)}
\\\hline
jCC label	&	Переход по адресу $label$, если верно условие $CC$ (%таблица~\ref{tab:cc-list}, 
кроме \texttt{u} и~\texttt{nu}) 	
\\\hline
\end{tabularx}
\end{table}


Безусловный переход \lstinline!jmp!
% \begin{lstlisting}
%   jmp label
% \end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу $label$.

Команды условного перехода~\lstinline!jCC!
% \begin{lstlisting}
%   jCC label
% \end{lstlisting}
передают адресу $label$ при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~регистре $flags$).
Если условие не выполнено,  \lstinline!jCC! не делает ничего,  и~выполняется команда, следующая за \lstinline!jCC! по тексту программы.

Условие~$CC$ может быть любым из перечисленных в~таблице~\ref{tab:cc-list}, кроме \texttt{u} и~\texttt{nu} (но могут использоваться \texttt{p/pe} и~\texttt{np/po}).
В~частности, команда \lstinline!jnae label! \ethm{(jump if not above or equal)} передаст управление на метку~$label$ в~случае~\mbox{$CF=1$.}
Если перед командой условного перехода выполнялась команда \lstinline!cmp src, dest!, управление будет передано на метку~$label$ в~случае, если~$dest \not\geqslant src$ как беззнаковые числа.

Это условие эквивалентно $dest < src$.
Действительно, команды \lstinline!jnae! и~\lstinline!jb! \ethm{(jump if below)} имеют один и~тот же опкод. Также этот опкод соответствует мнемонике~\lstinline!jc! \ethm{(jump if carry).}

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

% В~следующей таблице 
% В~таблице~\ref{tab:jmp-command-list}
% приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.

% \begingroup
% \small
% \def\normalsize{\small}
% \renewcommand\theadfont{\bfseries\footnotesize}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% % \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% % \newcolumntype{H}{>{\raggedright\arraybackslash}X}
% \providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
% \providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}
% 
% \newcolumntype{E}{m{0.7\linewidth}}%
% 
% \singlespacing
% 
% \LTXtable{\textwidth}{book/tables/jmp-list.tex}
% 
% \endgroup


Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop!, псевдоцикла с~анализом флага нуля \lstinline!loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если регистр $cx/ecx$ равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop label! эквивалентна  командам \lstinline!dec %ecx; jz label!, при этом \lstinline!loop! не меняет флаги $flags$. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только $cx/ecx$, но и~флаг нуля $ZF$ (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{@{\,}l}
cx\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{@{\,}l}
cx\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).

Эти команды были введены в~набор  8086 для получения более компактного кода (однобайтовая инструкция \lstinline!loop! заменяет связку двух однобайтовых \lstinline!dec+jz!) и~экономии дорогой памяти.
При этом пара инструкций \lstinline!dec+jz! выполняется быстрее \lstinline!loop!~\cite{agner_fog_optimizing_assembly}, легче читается и~позволяет организовывать вложенные циклы.
В~настоящее время оптимизация направлена на ускорение, соответственно,
использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать.

% Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода~\cite{agner_fog_optimizing_assembly}.
% % \footnote{Optimizing subroutines in assembly 
% % language.
% % An optimization guide for x86 platforms. 
% % By Agner Fog. Technical University of Denmark. }.

\subsubsection{Условная пересылка}
\index{Флаги!проверка}
\index{Команды!условной пересылки}

Для каждого условия~$CC$, кроме команды условного перехода \lstinline!jCC!,
% Для каждой команды условного перехода \lstinline!jCC! 
существует команда условной пересылки \lstinline!cmovCC src, dest!, выполняющая присваивание $dest = src$, если соответствующее условие верно.

В~таблице~\ref{tab:mov-command-list} показаны различные команды безусловной и~условной пересылки.

\begin{table}[!ht]
\caption{Команды пересылки данных}
\label{tab:mov-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
mov src, dest	&	Присваивание $dest = src$ %, $src$ "---  непосредственное значение, регистр или память одного размера с~$dest$
% $src \in \{imm, mem, reg\}, dest \in \{mem, reg\}$
\\\hline
\begin{tabular}{@{}l@{}}
movs srm, dreg\\movz srm, dreg
\end{tabular}	&	Присваивание $dreg = srm$ с~расширением %, $src$ "---  регистр или память 
% $src \in \{imm, mem, reg\}, dest \in \{mem, reg\}$
\\\hline
cmovCC srm, dreg	&	Присваивание $dreg = srm$, если верно  $CC$ (%таблица~\ref{tab:cc-list}, 
кроме \texttt{u} и~\texttt{nu}) \\\hline
fcmovCC \%st(i), \%st(0) & Присваивание  регистров~FPU  $st(0) = st(i)$, если верно  $CC$
 (\texttt{e, ne, b/nae, be/na, ae/nb, a/nbe,} \texttt{u} и~\texttt{nu})
\\\hline
\end{tabularx}
\end{table}


Команды условной пересылки не полностью аналогичны \lstinline!mov!: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

Для флагов, которые могут быть установлены командами сравнения FPU ($ZF, CF, PF$) существует также команда условной пересылки в~стеке FPU из $st(i)$ в~$st(0)$
\lstinline!fcmovCC  %st(i), %st(0)! (раздел \ref{sec:fcmovCC}, таблица~\ref{tab:fpu-mov-list}).



\subsubsection{Установка байта по условию}
\index{Флаги!проверка}
\index{Команды!установки байта}

Для каждого условия~$CC$
% Для каждой команды условного перехода jCC 
существует команда установки байта по условию \lstinline!setCC dest8!, выполняющая присваивание $dest8 = 1$, если соответствующее условие верно, и~$dest8 = 0$ иначе.

% \section{Установка флагов}

Приёмник $dest8$ может быть как регистром, так и~переменной в~памяти, но только однобайтовыми.





\input{book/fragments/fpu}








\input{book/fragments/alg}


\addquestion{Какой порядок операндов принят в~синтаксисе AT\&T?}

\addquestion {Какая команда передаёт управление подпрограмме?}
\addquestion {Какая команда возвращает управление вызывающей программе?}
\addquestion {Что такое адрес возврата?}

% \addquestion Знаковой или беззнаковой является операция инкремента?




% \addquestion{Какие вы знаете регистры общего назначения?}
\addquestion{Какие вы знаете команды ассемблера x86?}
% \addquestion{Какие вы знаете флаги?}
\addquestion{Какие регистры используются в~сопроцессоре для хранения операндов?}
\addquestion{Какие команды используются для выполнения арифметических операций над вещественными числами?}



\addquestion{Какие команды используются для выполнения тригонометрических операций?}
\addquestion{Какие команды используются для сравнения вещественных чисел?}
\addquestion{Какие флаги регистра $flags$ содержат результат сравнения вещественных чисел?}


\addquestion{Какие вы знаете команды передачи управления?}
\addquestion{Какие вы знаете команды условной пересылки?}
\addquestion{Как, согласно ЕСПД, изображается блок «терминатор»?}
\addquestion{Как, согласно ЕСПД, изображается блок «процесс»?}
\addquestion{Как, согласно ЕСПД, изображается блок «решение»?}


\addquestion{Как располагаются в~памяти элементы массива?}
\addquestion{Как найти размер массива, зная размер элемента и~их количество?}


\addquestion{Что такое выравнивание полей структуры?}
\addquestion{Зачем нужно выравнивание данных?}




\printquestions







