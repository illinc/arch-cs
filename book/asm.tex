

\chapter{Программирование на языке Ассемблера}
\epigraph{\begin{stanza}[0mm]
Есть великая правда у тех, кем хранится завет\\
Но для тех, кто им стал, нет завета и истины нет.\\
\end{stanza}}{С. Калугин}
% \label{sec:asm}

% Идеология и~ритм
Некоторые приёмы
программирования на ассемблере существенно отличаются от используемых в~языках высокого уровня.
При этом GNU Assembler является неотъемлемой частью процесса компиляции этих языков, в~первую очередь "--- C/C++. 
Соответственно, структура программы на GNU Assembler аналогична C/C++,
кроме того, полностью доступна стандартная библиотека stdlib.
Данная глава показывает как возможную связь программ на C/C++ и~ассемблере, так и~различия в~реализации алгоритмов.

Если не указано иное,
примеры соответствуют тридцатидвухбитной платформе.
Вызовы функций описываются в~соответствии с~тридцатидвухбитным соглашением cdecl и~без учёта искажения имён (см. раздел~\ref{sec:calling-functions}).




\section{Структура программы на ассемблере}
\epigraph{\begin{stanza}Так скажем «Банзай», и~Бог с~ней, с~твердью;\\
Все, что прошло "--- сдадим в~утиль.\\
А~здесь у~нас в~центре циклона "---\\
Снежные львы и~полный штиль.\\
\end{stanza}}
{\Aquarium}
\label{sec:asm-main}

% Исполняемый файл обязательно содержит

Программа обязательно должна включать точку входа "--- адрес, с~которого начинается её выполнение.
По умолчанию %компоновщик
компоновщик GCC ищет точку входа по имени  $\_start$.
% (здесь нижнее подчёркивание "--- часть имени без учёта искажения имён компилятором). 
Для программ на C/C++ по адресу $\_start$ находится стартовый код библиотеки stdlib, который, в~частности, инициализирует все используемые библиотекой ресурсы и~вызывает так называемую головную функцию $main()$.
После этого  программа выполняется по определённому алгоритму (в~частности, с~помощью цикла обработки сообщений можно реализовать событийно-ориентированную модель)
и~при определённых обстоятельствах должна корректно завершать  свою работу.
\index{main()}%

Минимальная программа 
% включает точку входа (многие библиотеки определяют стартовую функцию, которая )
запускается
и~немедленно завершает  работу.
% Соответственно
Также в~учебных целях часто описывается программа, выводящая на экран приветствие «Hello, world!».

\subsection{Программирование с~использованием stdlib}
\epigraph{\begin{limerick}
    Жила-была дама приятная,\\
    На вид совершенно квадратная.\\
    Кто бы с ней ни встречался,\\
    От души восхищался:\\
    «До чего эта дама приятная!»
\end{limerick}
}
{\Lear}

По умолчанию в~GCC программа (как на языке C/C++, так и~на языке ассемблера) собирается с~поддержкой стандартной библиотеки stdlib.
Соответственно, стартовой (главной) функцией программы является $int~main(int~argc,$ $char~*argv[])$.
%  $int~main(int, char *[])$

% \section{Точка входа на ассемблере и~использование stdlib}

% Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.
Стартовая функция $main()$ может находиться как в~модуле на языке C/C++, так и~в~ассемблерном модуле.

\subsubsection{Минимальная программа с~использованием stdlib}

% Минимальная программа 
Приведём код минимальной программы на ассемблере GAS
с~использованием стандартной библиотеки stdlib (листинг~\ref{lst:asm:minmain}).
\begin{lstlisting}[caption=Минимальная программа с~использованием stdlib, label=lst:asm:minmain]
.globl main // головная функция (stdlib)
main:
     xor %eax, %eax // A ^= A, то есть A = 0
     ret // return A
\end{lstlisting}
Команда \texttt{ret}, в~отличие от оператора C++ return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах (раздел~\ref{sec:calling-functions}) всегда подразумевается в~регистре~$A$.
Для тридцатидвухбитного кода это $eax$, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр~$eax$.
В~данном случае это делается при помощи побитового исключающего «или».
\index{Команды!xor}%
\index{Команды!обнуления регистра}%
Эта команда компактнее %\lstinline!!
явного копирования нуля в~регистр и~выполняется быстрее.

Параметры $argc$ и~$argv$ располагаются в~соответствии с~используемом соглашением о~вызове,
то есть находятся в~стеке\index{Стек} для тридцатидвухбитных систем и~в~регистрах для шестидесятичетырёхбитных.

Эквивалент программы~\ref{lst:asm:minmain} на С++  выглядит следующим образом.
\begin{lstlisting}[caption=Минимальная программа с~использованием stdlib (C++), label=lst:asm:minmain-cpp]
int main()
{
    return 0;
}
\end{lstlisting}

% Головная функция $main()$ здесь завершается с~кодом~0 сразу после запуска, 
% Параметры $argc$ и~$argv$ здесь не используются и,~как позволяет
% стандарт, опущены.
Неиспользуемые параметры $main()$ стандарт позволяет опустить.

\subsubsection{Приветствие миру}

\index{Команды!call}%
\index{Команды!push}%
\index{Команды!pop}%

Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции $printf()$ библиотеки stdlib (листинг~\ref{lst:asmmain:printf-cpp})
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие (C++)}, label=lst:asmmain:printf-cpp]
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на тридцатидвухбитном ассемблере выглядит следующим образом (листинг~\ref{lst:asmmain:printf-asm}).
\begin{lstlisting}[caption={Программа, выводящая на экран приветствие}, label=lst:asmmain:printf-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    xor %eax, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются (но в~некоторых версиях Microsoft Windows могут дополняться префиксом, как описано в~разделе~\ref{sec:mangling}). 

Параметры функции $printf()$ в~соответствии с~соглашением cdecl передаются через стек\index{Стек} (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).
\index{Команды!add}%
Так как нам не нужно извлечённое из стека значение, команду \lstinline!popl %eax! можно заменить изменением значения указателя стека~\lstinline!addl $4, %esp!.
Эта команда быстрее и~к~тому же не требует приёмника для сохранения неиспользуемого %вычищаемого из стека 
значения.

Так как для вывода приветствия не используются все возможности  $printf()$, вместо неё можно использовать более простую функцию~$puts()$.
\begin{lstlisting}[caption={Программа, выводящая приветствие с~помощью $puts()$}, label=lst:asmmain:puts-asm]
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call puts
    addl $4, %esp	// Вычищаем параметр из стека
    xor %eax, %eax
    ret
\end{lstlisting}



\subsubsection{Форматированный вывод}

Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}[caption={Программа, выводящая на экран два числа (C++)}, label=lst:asmmain:printf-cpp-params]
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению cdecl эти параметры передаются в~обратном порядке (то есть на вершине стека\index{Стек} оказывается первый):
\begin{lstlisting}[caption={Программа, выводящая на экран два числа}, label=lst:asmmain:printf-asm-params]
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  xor %eax, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~$sp$, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности,~$A$) меняется (раздел~\ref{sec:calling-conventions}).
% Список регистров, которые могут изменяться подпрограммой, подробнее рассмотрен в~разделе~\ref
Если в~таких регистрах хранятся данные вызывающей программы, их надо сохранить перед вызовом функции.




\subsection{Программирование без stdlib}
\epigraph{\begin{limerick}
Старичок так следил за осанкой,\\
что питался лишь только овсянкой.\\
Но однажды съел лишку,\\
положив в~неё мышку,\\
И~серьёзно испортил осанку.\\
\end{limerick}
}
{\Lear}

Минимальная программа с~stdlib (листинг~\ref{lst:asm:minmain}) после ассемблирования занимает 4704 байт.
% % [caption=min.S]
% \begin{lstlisting}
% .globl main // точка входа (stdlib)
% main:
%      xorl %eax,%eax // EAX ^= EAX, то есть EAX = 0
%      ret // return EAX
% \end{lstlisting}
% % Сборка (полученный файл включает stdlib и~занимает %4.6 Кб "--- 
% % 4704 байт)
% % \begin{lstlisting}[language=Bash]
% % $ gcc -o min min.S
% % \end{lstlisting}
% % Сборка с~stdlib: 
% \lstinline!gcc -o min min.S!
В~этот размер входят библиотечные функции, обеспечивающие обработку параметров, вызов стартовой функции~$main()$
и~завершение программы после возврата управления из $main()$.

Отключить использование stdlib при сборке позволяет ключ~\lstinline!-nostdlib!.
В~этом случае взаимодействие с~операционной системой, в~том числе завершение программы, необходимо осуществлять напрямую, с~помощью системных вызовов.\index{Системные вызовы}%

Точкой входа в~этом случае будет непосредственно метка $\_start$.
% После неё можно вручную вызвать $main()$ и~обработать возвращаемое ей значение.

Каждая операционная система имеет свой набор %системных вызовов
функций
и~свой способ их вызова.
В~большинстве тридцатидвухбитных операционных систем системные вызовы осуществляются с~помощью программных прерываний.
При этом, если в~GNU/Linux, BSD и~FreeDOS системные вызовы хорошо документированы,
то в~Microsoft Windows как механизм их вызова, так и~набор функций постоянно меняются и~%не документированы.
скрыты от прикладного программиста.
Вместо прямых системных вызовов под Microsoft Windows предлагается использовать функции библиотеки Windows API.
% Сборка без stdlib (полученный файл занимает 600 байт)
% \begin{lstlisting}[language=Bash]
% $ gcc -o nsmin  nsmin.S  -nostdlib
% \end{lstlisting}
\index{Системные вызовы}%

В~GNU/Linux к~функциям операционной системы в~тридцатидвухбитном режиме можно обратиться с~помощью прерывания \hex{0x80}.
% int 0x80, \lstinline!%eax! "--- номер функции
Номер функции указывается в~регистре~$eax$.
% до 6 аргументов: \lstinline!%ebx!, \lstinline!%ecx!, \lstinline!%edx!, \lstinline!%esi!, \lstinline!%edi! и~\lstinline!%ebp!
Вызов может принимать до шести аргументов в~регистрах $ebx, ecx, edx, esi, edi, ebp$.
% Если требуется передать семь значений или больше, они объединяются в~структуру, адрес которой передаётся в~$ebx$.
\index{Системные вызовы}%


\subsubsection{Минимальная программа без stdlib}
% Мне ничего не нужно и ничего не жаль, 
% Голым и безоружным взлетаю вдаль

\index{Команды!int}%
Рассмотрим
минимальную программу, не использующую функции stdlib (в~том числе $main()$) для GNU/Linux. % (600 байт)
Сразу после запуска она должна завершиться с~кодом~0.
Для завершения программы используется системный вызов с~кодом~1 "--- $sys\_exit()$.
\index{Системные вызовы}%
Его единственный параметр "--- код возврата.
\begin{lstlisting}[caption=Минимальная программа без stdlib, label=lst:asm:minstart]
.globl _start
_start: // точка входа 
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}
% Сборка без~stdlib: 
% \lstinline!gcc -o min min.S -nostdlib!
Если код \ref{lst:asm:minstart} сохранён как файл~\lstinline!nsmin.S!,
собрать его без стандартной библиотеки можно командой:
\begin{lstlisting}[language=Bash]
$ gcc -o nsmin  nsmin.S  -nostdlib
\end{lstlisting}
полученный исполняемый файл %не  включает stdlib и~
занимает 600 байт.

% Эквивалент на С++
% \begin{lstlisting}
% int main(int argc, char* argv[]){
%     return 0;
% }
% \end{lstlisting}

\subsubsection{Приветствие миру}


Для вывода строки на экран ядром~Linux используется системный вызов с~кодом~4 "--- $sys\_write()$.
Он предназначен для записи в~файл;
требует трёх параметров "--- дескриптор файла, указатель на начало записываемых данных и~длина этих данных в~байтах.
Согласно концепции Unix всё есть файл;
для вывода на экран используется специальный дескриптор 1 ($stdout$).
\index{Системные вызовы}%



\begin{lstlisting}[caption={Вывод приветствия при помощи системных вызовов Linux}, label=lst:asmmain:syscall-asm]
.data
    msg:
    .ascii "Hello, world!\n"
    len = . - msg // символу len присваивается длина строки
.global _start // точка входа в программу
_start:
    movl $4, %eax // системный вызов №4 — sys_write
    movl $1, %ebx // поток №1 — stdout
    movl $msg, %ecx // указатель на выводимую строку
    movl $len, %edx // длина строки
    int $0x80 // вызов ядра
    movl $1, %eax // системный вызов №1 — sys_exit
    xorl %ebx, %ebx // выход с кодом 0
    int $0x80 // вызов ядра
\end{lstlisting}

Для вывода более сложных данных, в~частности, чисел, необходимо вручную сформировать в~программе выводимую в~файл $stdout$ строку.
% Написание подобных обёрток
Такой код, предназначенный для взаимодействия с~системными вызовами, займёт существенный объём, так что в~итоге выигрыш от неиспользования stdlib может оказаться несущественным.
\index{Системные вызовы}%



\input{book/fragments/func}









\subsection{Системные вызовы}
\index{Системные вызовы}%



\epigraph{
\begin{stanza}[0mm]
И дракон прочёл, наклоняя\\
Взоры к смертному в первый раз:\\
"--- Есть, владыка, нить золотая,\\
Что связует тебя и нас.\\
\end{stanza}
}{Н.\,C.\,Гумилёв}



Системный вызов (system call) "--- обращение прикладной программы к~ядру операционной системы для выполнения какой-либо операции.
В~принципе, системные вызовы соответствуют определению подпрограмм, но, так как ядро системы работает в~привилегированном режиме,
нельзя давать программе возможность передать управление на произвольный фрагмент кода ядра.
Соответственно, количество функций, выполняемых ядром, ограничено. %ядром операционной системы.
% так что 
Сами эти функции, как правило, пронумерованы 
% и~описаны в~документации.
и~для обращения к~ним необходим номер, а~не адрес.
Кроме того, для системных вызовов используются другие соглашения% о~вызове
; в~частности, вместо \lstinline!call!/\lstinline!ret! применяются другие команды вызова и~возврата%, позволяющие указать номер
.
\index{Команды!call}%
\index{Команды!ret}%

Для обращения к~ядру используются следующие способы:
\begin{enumerate}

\item Программное прерывание (команда \lstinline!int!) %/\lstinline!iret!
\index{Команды!int}%
 "--- этот способ доступен на всех x86-совместимых системах.
%  
Как правило, для вызова всех функций ядра используется какой-то один номер прерывания, 
а~номер самой функции передаётся через один из регистров.



\item 
% Начиная с~Pentium II, доступна предложенная Intel команда \lstinline!sysenter!, %/sysexit (Intel)
% ускоряющая обращение к~ядру.
Быстрый вызов ядра в~тридцатидвухбитном режиме выполняется командой \lstinline!sysenter!.
\index{Команды!sysenter}%

% В~шестидесятичетырёхбитном режиме использование \lstinline!sysenter! невозможно.

\item 
% Для быстрого обращения к~функциям ядра  в~шестидесятичетырёхбитном режиме применяется команда \lstinline!syscall!, %/sysret 
% (AMD, 64-битный режим Intel);
% предложенная AMD.
Быстрый вызов в~шестидесятичетырёхбитном режиме "--- командой \lstinline!syscall!.
\index{Команды!syscall}%

\end{enumerate}

% Таким образом, каждое 

\subsubsection{Системные вызовы различных ОС}
% \epigraph{
% "--- Просвещенья Дух! "--- возвысил голос Фантом. "--- Если ты будешь говорить с нами, стукни один раз!
% 
% "--- Плюх! "--- раздалось в ответ.
% 
% "--- А если не будешь, стукни два раза, "--- брякнул Гаргантюа.
% 
% "--- Плюх-плюх!
% }{Жвалевский/Мытько}
\index{Системные вызовы}%

Как и~для функций, соглашение о~вызовах описывает команду вызова, а~также передачу параметров и~возврат значения.
% , а~также правила использования регистров.
% 
Ядра~различных операционных систем %по-разному 
поддерживают различные соглашения.
\begin{itemize}

\item к~ядру Linux на платформе x86 можно обратиться по программному прерыванию \lstinline!int 0x80!,
на x86-64 "--- с~помощью команды \lstinline!syscall!,
номер функции и~параметры передаются в~регистрах;
\index{Команды!int}%
\index{Команды!syscall}%

\item BSD на x86 также использует  \lstinline!int 0x80!, номер функции в~регистре $eax$, параметры в~стеке;

\item FreeDOS предоставляет большую часть функций через \lstinline!int 0x21!, также используются \lstinline!int 0x20! (завершение программы), \lstinline!int 0x29! (печать символа), \lstinline!int 0x2E! (выполнение команды).
\end{itemize}

В~большинстве операционных систем функции, выполняемые ядром, документированы и~могут быть напрямую вызваны прикладной программой.
Операционная система Microsoft Windows, напротив, скрывает их и~меняет от версии к~версии как сами функции, так и~механизм их вызова.
Прикладным программам предлагается использовать обёртки для обёрток над обёртками системных вызовов ядра Windows "--- функции Windows API из разделяемых библиотек.

Тем не менее, в~различных источниках сообщается, что линейка
% \begin{itemize}
% \item 
Microsoft Windows NT/2000/XP/2003/Vista  использует прерывание \lstinline!int 0x2E!,
% \item 
а~в~Microsoft Windows XP/7/8  для обращения к~ядру используется команда \lstinline!sysenter! в~тридцатидвухбитной версии и~\lstinline!syscall! в~шестидесятичетырёхбитной.
% \end{itemize}
\index{Команды!int}%
\index{Команды!sysenter}%
\index{Команды!syscall}%

\subsubsection{Системные вызовы Linux}
% \epigraph{\begin{stanza}
% По пояс в траве босыми ногами\\
% Вот мы пришли, мы танцуем с богами.
% \end{stanza}
% }{\Aquarium}
\index{Системные вызовы}%

% \subsubsection{Параметры системных вызовов Linux}

Для обращения к~ядру Linux в~тридцатидвухбитном режиме используется вызов программного прерывания
% прерывание 
\lstinline!int 0x80!,
\index{Команды!int}%
при этом в~регистре $eax$ должен быть  номер функции.
% 
В~частности, номеру~$1$ соответствует вызов $sys\_exit()$, 
% 1 "--- 
% exit, %\hfill
% \lstinline!%ebx! "--- код завершения
% 
$2$ "--- $sys\_fork()$,
% 
$3$ "--- $sys\_read()$,
% 
$4$ "--- $sys\_write()$ и~т.\,д.
% \\
% ...

Системный вызов принимает 
до шести аргументов в~регистрах $ebx$, $ecx$, $edx$, $esi$, $edi$, $ebp$.
В~частности, при завершении программы системным вызовом $sys\_exit()$ ($eax=1$) в~$ebx$ должен находиться единственный параметр этого вызова "--- код завершения программы.
% 
Если требуется передать функции ядра от семи параметров и~выше, из них формируется структура, адрес которой передаётся в~$ebx$.

Результат помещается в~$eax$.

В~шестидесятичетырёхбитном режиме обращение к~ядру Linux выполняется командой \lstinline!syscall!.
\index{Команды!syscall}%
Номер вызова также должен быть в~регистре $rax$, но сами номера иные, чем для тридцатидвухбитного ядра:
$0$ "--- $sys\_read()$,
$1$ "--- $sys\_write()$,
$2$ "--- $sys\_open()$,
$3$ "--- $sys\_close()$ и~т.\,д.

Параметры передаются в~регистрах $rdi$,	$rsi$,	$rdx$,	$r10$,	$r8$,	$r9$.

Возвращаемое системным вызовом значение помещается в~$rax$.




\input{book/fragments/alg}
% 
\addquestion {Какая команда передаёт управление подпрограмме?}
\addquestion {Какая команда возвращает управление вызывающей программе?}
\addquestion {Что такое адрес возврата?}


\addquestion{Как, согласно ЕСПД, изображается блок «терминатор»?}
\addquestion{Как, согласно ЕСПД, изображается блок «процесс»?}
\addquestion{Как, согласно ЕСПД, изображается блок «решение»?}


\addquestion{Как располагаются в~памяти элементы массива?}
\addquestion{Как найти размер массива, зная размер элемента и~их количество?}


\addquestion{Что такое выравнивание полей структуры?}
\addquestion{Зачем нужно выравнивание данных?}




\printquestions







