
\chapter{Представление данных}
\epigraph{
\begin{stanza}[0mm]
А~для низкой жизни были числа,\\
Как домашний, подъярёмный скот,\\
Потому, что все оттенки смысла\\
Умное число передаёт.\\
\end{stanza}
}{Н.\,C.\,Гумилёв}

Пифагорейцы в~VI--IV веках до н.\,э. считали числа первоосновой мира.
В~настоящее время этот принцип воплощается на практике "--- всё больше информации переходит в~цифровой формат, то есть описывается при помощи чисел.
Числа же в~свою очередь представляются в~вычислительных системах при помощи специальных кодов в~виде набора нулей  и~единиц.

\section{Качественные и~количественные данные} 
\epigraph{
Всё  познаваемое  имеет  число.  Ибо  без  него  невозможно  ничего  ни  понять,  ни  познать.
}{Филолай}

% таблицы, числа

% http://producm.ru/books/books_statistic/book16/p4/
% Статистические методы – это методы анализа данных, причем обычно достаточно большого количества данных. Статистические данные могут иметь различную природу.Исторически самыми ранними были два вида данных – сведения о числе объектов, удовлетворяющих тем или иным условиям, и числовые результаты измерений.

% Две основные категории используемых на практике данных "---
Данные делятся на две основные группы "---
% качественные и~количественные 
количественные и~качественные.
% данные.
% 
% Количественные данные называются так потому, что представляют собой, как правило, информацию,
% \termin{Количественные} данные 
% "---  записи значений каких-либо величин (элемен­ты мультимедийных данных и~т.\,д.).
К~\termin{количественным} данным относятся в~основном либо сведения о~числе объектов, удовлетворяющих тем или иным условиям, либо числовые результаты измерений.
Для таких данных имеют смысл базовые арифметические действия "--- сложение, вычитание, умножение на число или другую величину подходящей размерности.
Именно для описания количественных данных изначально и~появилось само понятие числа.

% Двум классам количественных данных соответствуют два основных типа чисел.
Для %описания
подсчёта количества объектов (яблок, землекопов и~т.\,д.) используются \termin{натуральные числа:} $1, 2, 3,...$
Множество натуральных чисел $\{1, 2, 3, ...\}$ обычно обозначается как~$\Naturalset$.

Ноль не используется при счёте, поэтому не %включается в
считается натуральным числом.
Тем не менее, часто удобно рассматривать множество $\Naturalset \cup \{0\} = \{0, 1, 2, 3, ...\}$.
Оно обозначается $\Naturalset_0$.
В~некоторых зарубежных источниках именно $\Naturalset_0$ называется множеством натуральных чисел, но в~отечественной литературе, как и~в~значительной части зарубежной, принято %другое определение.
определение из предыдущего абзаца, не включающее ноль. %~$0$.
Универсальное название элементов $\Naturalset_0$ 
"--- неотрицательные целые числа, также их часто называют \termin{беззнаковыми} целыми числами.

Для описания некоторых величин требуются отрицательные числа ($-1$, $-2$, $-3, ...$). Множество, включающее натуральные числа, противоположные им отрицательные и~ноль, называется множеством целых чисел~$\Integerset$. В~противоположность беззнаковым (неотрицательным) величинам те, которые могут принимать как положительные, так и~отрицательные значения, называются \termin{знаковыми.}


Результаты измерений большей части величин (длина, путь, масса, время и~т.\,д.) невозможно представить в~виде целых чисел, знаковых или беззнаковых.
Соответствующие им \termin{вещественные} числа (%$0,5, 0,7, 0,33(3)
в~частности, $\frac{1}{3}, \sqrt{2}, \pi, e%, 2\frac{2}{3}
$) 
образуют множество~$\Realset$.

Числа и, соответственно, количественные данные лучше всего подходят для обработки с~помощью вычислительных систем.
Таким образом, чтобы ввести и~использовать какую-то информацию в~вычислительной системе, эту информацию необходимо представить в~виде числа или набора чисел.

% \termin{Качественные} данные "--- указатели на символы внутри таблиц или на ветви алгоритма (буквы, цифры, ноты, символы шахматных фигур, карточных мастей и~т.\,д.). 

\termin{Качественные} данные представляют собой, как правило, элементы (символы), несравнимые между собой или цепочки (строки) подобных символов.
В~частности, к~качественным данным относятся цвет, %буква, нота
буквы, цифры, ноты, символы шахматных фигур, карточных мастей и~т.\,д.
Множество всех возможных символов называется алфавитом. 

% % http://statistica.ru/glossary/general/poryadkovye-dannye/
% Иногда из качественных данных выделяют порядковые "--- их значения можно упорядочивать, сравнивать друг с~другом, но нельзя складывать, вычитать и~т.\,д.
% Интервал между такими значениями невозможно выразить количественно.
% % Тяжесть состояния больного при поступлении в клинику (тяжёлое, средней тяжести,…) степень ожога (1,2,3 или 4) – пример качественных порядковых признаков.

% Тем не менее, 
Для обработки  с~помощью вычислительных систем качественные данные также необходимо представить в~виде чисел.
% Так как компьютер способен обрабатывать только количественные 
% Порядковым данным 
% Для этого используются кодовые таблицы.
Чтобы сделать это,
% Вначале %из символов алфавита состав
символы качественных данных упорядочиваются, 
затем каждому символу сопоставляется его порядковый номер в~списке "--- код символа, беззнаковое целое число.
Полученное соответствие называется \termin{кодовой таблицей}.

Наиболее известны кодовые таблицы, сопоставляющие коды знакам письменных языков "--- цифрам, буквам кириллицы, латиницы, знакам препинания и~т.\,д. (чаще всего под термином «символ» подразумевается именно знак письменности).
В~частности, старейшая из принятых в~настоящее время кодовая таблица ASCII (American Standard Code for Interchange of Information) описывает цифры, строчные и~заглавные буквы латиницы, некоторое количество знаков препинания и~специальных символов (так называемые ASCII-символы) и~сопоставляет им коды в~диапазоне от~$0$ до~$127$~\cite{asciitable}.
Все более современные кодовые таблицы, включающие кириллицу и~другие национальные знаки, описывает ASCII-символы этими же кодами.
% Соответствие ASCII-символов ASCII-кодам 

Кодовая таблица ASCII
настолько прочно закрепилась в~информационных технологиях, что такие языки, как C/C++, вообще не делают различия между ASCII-символом и~его кодом: тип $char$ является одновременно и~символьным, и~коротким целым.
При этом представление символов не из таблицы ASCII, в~частности, кириллицы, может быть различным в~разных реализациях.

Сейчас для представления различных национальных алфавитов чаще всего используется кодовая таблица Unicode, сопоставляющая кириллице коды от 1024 до 1279 (обычно коды Unicode записывают в~шестнадцатеричном виде "--- от \hex{0400} до \hex{04FF}).
% На большинстве платформ байт включает восемь бит, то есть не может представлять число, большее 255.
% Таким образом, коды русских букв невозможно представить в~виде одного такого байта.
Для того, чтобы %корректно записать эти  представления 
представление буквы кириллицы в~памяти компьютера не могло совпасть с~представлением последовательности из нескольких ASCII-символов,
используются различные \termin{кодировки} Unicode.
Наиболее распространённая из них "--- UTF-8 "--- записывает кириллические буквы в~виде двух байтов, включающих, кроме собственно кода, ещё и~служебную информацию.
Соответственно, кириллица, представленная в~UTF-8, занимает диапазон \hex{D080} до \hex{D19F}.



\section{История чисел} 

\epigraph{\begin{stanza}
«Этот палец загнём, а~другой отогнём...\\
Что-то плохо сгибается палец;\\
Вижу, выхода нет "--- не сойдётся ответ», "---\\
И~заплакал несчастный страдалец.\\
\end{stanza}}
{\Snark}

% непозиционные СС, позиционные, абак. Модулярная арифметика: Алмаз, троичная арифметика: Сетунь

% http://dic.academic.ru/dic.nsf/ruwiki/4992
\termin{Система счисления} "--- %символический метод записи чисел, 
это
представление чисел с~помощью специальных письменных знаков "--- цифр.

% Старейшее счётное устройство "--- пальца на руках.
Старейшая система представления чисел "--- единичная, когда при счёте каждому объекту сопоставляют
% объекты подсчитывали, загибая по одному пальцу или  
один счётный предмет или символ "--- загибают палец, передвигают бусину чёток, ставят галочку на бумаге или зарубку на доске.
Таким образом, чтобы записать  число $N$, нужно поставить $N$ галочек или зарубок.
Значение счётного предмета или знака при этом не зависит от его положения и~всегда равно единице.
Этот громоздкий способ записи
подходит только для небольших %количеств подсчитываемых предметов.
натуральных чисел.
% чисел.

Для подсчёта большого количества объектов естественно %объединять их в~
разбивать их на
группы одного размера и~подсчитывать уже эти группы.
Размер такой группы называется \termin{основанием} системы счисления.

% Элементы такого представления
% Основание 
Даже в~единичной системе обычно используется группировка по какому-либо основанию.
В~чётках через определённое количество бусин вставляется отличная размером или цветом;
% естественные счётные предметы "--- 
пальцы рук естественным путём сгруппированы по~$5$ и~$10$, фаланги "--- по $12$ (на всех пальцах одной руки, исключая большой), $15$ (включая большой), $24$ (на двух руках, исключая большие пальцы) и~$30$.
% Сейчас, когда количество чего-либо отмечается чёрточками на доске, каждый десяток %или дюжина ($12$) 
% таких черт обычно перечёркивается горизонтальной линией.


Исторически чаще всего использовались основания, равные~$10$ (по числу пальцев на  руках) или $12$ (по числу фаланг пальцев одной руки, кроме большого "--- он используется для указания на текущую фалангу-цифру).
Системы счисления с~такими основаниями называются соответственно десятичной и~двенадцатиричной.
Некоторыми народами использовались также  %$8$
восьмеричная система счисления (по суставам пальцев одной руки, кроме большого) и~%$9$.
даже девятиричная.
Сейчас общепринятой в~быту является десятичная система счисления.
% , в~вычислительной технике "--- двоичная

Группировка счётных знаков позволяет нагляднее представить относительно большие числа, но единичная запись всё равно будет громоздкой.
Для сокращения длины логично записывать  число не объектов, а~групп и~при этом как-то различать записи «$N$ объектов» и~«$N$ групп объектов».
Простейшее решение "--- ввести для группы, например, десятка, специальный счётный знак.


Подобная запись использовалась, в~частности, в~Древнем Египте.
Там
% В~Древнем Египте %для записи чисел 
была принята десятичная система, при этом
использовались различные знаки для записи единиц ($|$), десятков ($\cap$), сотен и~так далее.
% (рис.~\ref{ris:digits-egypt}). %, тысяч, десятков тысяч и~миллиона.
% Для записи, в~частности, 
Например, для записи
числа
% $129 = 1\cdot100 + 2\cdot10 + 9\cdot1$ был необходим один знак, обозначающий сотню, два знака десятков и~девять знаков единицы.
$29 = 2\cdot10 + 9\cdot1$ были необходимы два знака десятков и~девять знаков единицы: 
% $\cap\cap|||||||||$.
$\scriptsize\begin{array}{c@{~}c}
\cap&||||\\[-1.5ex]
\cap&|||||\\
\end{array}$.
Порядок записи этих знаков не был чётко определён.


% \begin{illustration}
% 
% \caption{Древнеегипетские цифры}
% \label{ris:digits-egypt}
% \end{illustration}
% 
% Вначале (справа, так как писать было принято справа налево) ставились палочки по числу единиц, затем дуги по числу десятков и~т.\,д.
% Значение числа
Таким образом,
значение счётного знака зависело только от его формы, но не от его положения относительно других знаков.
% Соответственно,
% При сложении 
Такие системы счисления называются непозиционными.

В~Древнем Риме
применялась смешанная система счисления "--- пятично-десятичная.
% Счётные знаки 
Специальные знаки существовали для единиц (\RN{I}, схематичное изображение пальца), пятёрок (\RN{V}, напоминающая руку с~отставленным большим пальцем), десяток (\RN{X}, две руки), $50$, $100$ и т.\,д.


% \begin{illustration}
% 
% \caption{Римские цифры}
% \label{ris:digits-egypt}
% \end{illustration}

Значение цифры зависело от того, находилась ли она справа от более крупной цифры (в~этом случае их значения складывались) или слева %от цифры более высокого порядка 
(в~этом случае меньшее значение вычиталось из большего).
% Справа записывались единицы
В~частности,
% $129 = 1\cdot100 + 2\cdot10 + 9 = 1\cdot100 + 2\cdot10 + 10-1 = \RN{CXXIX}$,
% $131 = 1\cdot100 + 3\cdot10 + 1 = \RN{CXXXI}$.
$29 = 2\cdot10 + 9 = 2\cdot10 + 10-1 = \RN{XXIX}$,
$31 = 3\cdot10 + 1 = \RN{XXXI}$.
Таким образом, значение счётного знака зависит и~от его формы, и~от его положения относительно других знаков, 
но при этом, например, единица и~десяток обозначаются при помощи принципиально разных символов.
Такая система счисления называется смешанной.


Римская запись сложна, почти так же громоздка, как египетская и,~кроме, того, неоднозначна "--- %в~частности, 
например, число $4$ записывалось и~как~$\RN{IIII}~(4\cdot 1)$, и~как~$\RN{IV}~(5- 1)$.
Существуют различные виды римской записи, позволяющие либо %упростить алгоритм записи и~
сократить длину числа% (в~частности, )
, либо убрать неоднозначность, но не то и~другое сразу.


В~Индии была придумана позиционная запись, в~которой использовались различные счётные знаки для %$1, 2, 3, $
всех чисел от~единицы до~девяти, а~также впервые возникло специальное обозначение для нуля.
% Наибольшую популярность получила индийская система записи чисел.
% Из-за 
Для подобной записи числа, как и~в~египетской системе, разбивается на сумму некоторого числа единиц, десятков и~т.\,д.,
причём для записи количества единиц и~десятков будет использован один и~тот же набор цифр. 
Значение цифры определяется её положением в~записи;
такая система счисления называется \termin{позиционной.}
Десятичная позиционная запись была перенята у~индийцев арабами, а~затем распространилась повсеместно.
Начертание счётных знаков со временем превратилось в~так называемые арабские цифры, которые сейчас привычны нам с~детства, как и~позиционная система записи: $2\cdot10 + 9\cdot1 = 29$.

В~настоящее в~быту  повсеместно используется именно десятичная позиционная запись.
% 
% Наиболее известное
На десятичной позиционной системе основано наиболее совершенное из простых счётных устройств "---
русские счёты.
Ряд спиц в~них соответствует позициям, десять костяшек на каждой спице "--- цифрам.

% Механические счётные машины, 
Первая механическая суммирующая машина "--- Паскалина "--- 
% построенная Блезом Паскалем на основе связанных зубчатых колёс, 
также была построена на основе десятичной позиционной записи%
, несмотря на то, что использовалась для финансовых расчётов в~принятой тогда недесятичной денежной системе.
Каждому десятичному разряду соответствовало одно зубчатое колесо, на которое были нанесены цифры от~$0$ до~$9$.
Поворачиваясь от $9$ к~$0$, колесо сдвигало следующее за ним, формируя перенос.


Десятичная позиционная система счисления использовалась в~механических калькуляторах,
арифмометрах, разностной машине Бэббиджа, весившей более трёх тонн, 
а~также в~его же  проекте аналитической  машины, не реализованном из-за  из-за своих габаритов и~высокой стоимости.
% и~арифмометрах,
% выполнявших сложение, вычитание, умножение и~деление вводимых оператором чисел;
% % Более совершенная %механическое счётное устройство "--- 
% а~также в~разностной машине Бэббиджа, позволившей %частично автоматизировать 
% вычислять значения многочленов.
% Разностная машина, построенная  Бэббиджем, 
% весила более трёх тонн.
% % и~разностной машине Бэббиджа (3 тонны).
% Проект аналитической машины Бэббиджа, ставшей идейным прототипом современных ЭВМ, также подразумевал десятичную систему счисления.
% К~сожалению, эта машина так и не была построена из-за своих габаритов и~высокой стоимости.
% 
Даже много позже в~первой электронной (то есть построенная на вакуумных лампах) вычислительной машине "--- ЭНИАК %на основе вакуумных ламп 
"--- использовалась десятичная система, 
% http://evmhistory.ru/history/eniac.html
из-за чего размеры ЭНИАК превысили размеры более поздних %и~более мо
ламповых вычислительных машин.


% Двоичная система "--- Лейбниц.

% http://wiki.livid.pp.ru/students/cs/lectures/1.html
% В~механической счётной машине Z1 Конрада Цузе (1938 г.) была использована уже двоичная система счисления.
% Это позволило существенно уменьшить размеры устройства.
% Усовершенствованный вариант вычислителя Цузе, Z2 на основе телеграфных реле (1939),  закрепил использование двоичной логики "--- реле может находиться только в~двух состояниях "--- оно открыто либо закрыто.

При этом, как уже было сказано, основание системы счисления, равное десяти, было популярным, но не единственным.
% % Некоторые народы испрльзовали двенадцатиричную систему.
% http://www.eipiphiny.org/books/history-of-binary.pdf
% раньше!
% Считается, что впервые двоичную систему счисления предложил
% % http://kfcmtf.upol.cz/uploads/Dvorak/Caramuel080702.indd-1.pdf
% испанский математик Хуан Карамуэль и Лобковиц~\cite{JuanCaramuelLobkowitz}.
В~\ToRomanEmpire{16}--\ToRomanEmpire{17} вв. различные учёные рассматривали двоичную, троичную и~т.\,д. системы счисления и~их свойства~\cite{history-of-binary,JuanCaramuelLobkowitz}.
Лейбниц %в~своих публикациях представлял двоичную систему как мистическую ?, 
видел в~двоичной системе мистическое отражение реальности,
но не рекомендовал использовать её на практике для вычислений
% Эти идеи достаточно долго 
(знаменитый арифмометр Лейбница был основан на десятичной системе).
% Даже первая электронная вычислительная машина "--- ЭНИАК на основе вакуумных ламп "--- использовал десятичную систему, 
% % http://evmhistory.ru/history/eniac.html
% из-за чего его размеры превысили размеры более поздних ламповых вычислительных машин.

% https://3dnews.ru/263541
Первая реально  построенная вычислительная машина Z1 была механической и~была создана в~Германии Конрадом Цузе.
% Конрад Цузе использовал идеи Бэббиджа, при этом вес Z1 "--- всего 500 кг.
Идеи Цузе были поразительно схожи с~планами Бэббиджа (несмотря на независимую работу) и~теми, что позже будут реализованы фон Нейманом.
При этом Z1 помещалась в~гостиной Цузе, а~её составил всего 500 кг. %, то есть гораздо меньше.
% 
% Таким образом, Z1 была более чем на порядок компактнее, чем  слабой разностной десятичной  машины, построенной Бэббиджем.
% не говоря уже %о~сопоставимой с~Z1 аналитической машине.
% о~нереализованном проекте  аналитической  машины Бэббиджа.
Такая компактность была достигнута %Цузе 
% Это было достигнуто
за счёт использования другой позиционной системы счисления "--- \termin{двоичной.} 
% которая обладает большей экономичностью записи~\cite{fominSS}, чем десятичная.
Для ввода-вывода в~Z1 было реализовано двоично-десятичное преобразование.
% Ввод-вывод осуществлялся с~помо
Усовершенствованный вариант вычислителя Цузе, электромеханический Z2 на основе телеграфных реле,  закрепил использование двоичной логики "--- реле может находиться только в~двух состояниях "--- оно либо открыто, либо закрыто.
Используемые в~последующих вычислительных машинах вакуумные лампы, а~затем транзисторы также могли находиться  в~двух состояниях.
Таким образом, в~настоящее время двоичная позиционная система применяется в~электронике повсеместно.




% троичная арифметика: Сетунь
Но двоичная система не является самой экономичной. 
Теоретически оптимальной является систем счисления по основанию~$e$, а~из натуральных оснований наиболее экономичным является~$3$~\cite{fominSS}.
Троичная ЭВМ "--- Сетунь была разработана в~МГУ, выпускалась серийно и~оказалась весьма эффективной.
Но, так как для построения троичных логических элементов использовалась двоичная элементная база (транзисторы), существенно уменьшить габариты и~стоимость за счёт экономичности основания системы счисления не удалось, так что в~дальнейшем от троичной логики надолго отказались.
Тем не менее, недавно о~ней снова  пришлось вспомнить:  элементы квантовых компьютеров могут принимать как раз три значения.


% Модулярная арифметика: Алмаз
Кроме позиционных систем счисления, в~вычислительной технике использовались и~оригинальные системы счисления.
% Например,
Наиболее интересной представляется система остаточных классов, %также известная как 
или модулярная арифметика "--- представление числа~$x$ в~виде последовательности 
% набора 
остатков от деления $x$ на набор взаимно простых чисел $p_1, p_2,... p_n$:
$$
x = (x \Mod p_1,~ x \Mod p_2,... ~ x \Mod p_n)
$$
Согласно китайской теореме об остатках, такое представление единственно для $x \in [0, P)$, где $P = p_1\cdot p_2\cdot...\cdot p_n$.

% Реализация 
% В~модулярной арифметике умножение реализуется с~той же скоростью, что и~сложение.
% malashevich-mod-epos
Для вычисления суммы (или произведения) двух чисел, представленных подобным образом, достаточно сложить (или перемножить) каждую пару  соответственных остатков.
При этом действия с~различными парами остатков можно выполнять параллельно, так как действия выполняются независимо друг от друга. 

При использовании небольших  $p_1, p_2,... p_n$ возможно 
% Малая разрядность остатков обеспечивает возможность реализации табличной арифметики, при которой 
вместо вычисления результата операции 
% каждый раз в память машины заранее помещается таблица готовых значений. 
воспользоваться предварительно вычисленной таблицей.
Таким образом, любая операция при %такой табличной арифметике и
соответствующей конвейеризации будет  выполняться за один машинный такт.
% для сколь угодно большого числа
%  ( количество разрядов в котором зависит лишь от конструкции машины ). Это позволяет чрезвычайно эффективно выполнять некоторые распространенные классы задач , сводящихся к сложению , умножению и возведению в степень многоразрядных чисел . 

Первым модулярным компьютером была чехословацкая ЭВМ Эпос, позже в~СССР разрабатывалась серия модулярных ЭВМ.
% , наиболее известными из  Т-340А и К-340А.
% Эти компьютеры обладали не только высоким быстродействием, но и~надёжностью.
Наиболее известная советская модулярная ЭВМ, К-340А, используется до сих пор из-за своей поразительной надёжности и~быстродействия~\cite{malashevich-mod-epos, malashevich-mod-almaz}.
% https://www.itweek.ru/themes/detail.php?ID=69856
% благодаря своей высочайшей надёжности и~уникальным характеристикам
%ЭВМ К-340А до сих пор (2004 г., 40 лет!!!) находятся в эксплуатации, демонстрируя значительно более высокую живучесть, чем работающие рядом с ними другие, современные электронные системы
В~настоящее время на модулярной арифметике основаны многие специализированные процессоры, предназначенные для обработки сигналов в~режиме реального времени.

Программная реализация модулярной арифметики в~настоящее время используется для ускорения вычислений в~криптографии.


\section{Позиционные системы счисления} 
\epigraph{
Человек, который дружит с~тиранами, подобен камешку при вычислении, значение его бывает иной раз большое, иной "--- малое. 
}{приписывается Сократу}
% http://journal-shkolniku.ru/istoriya-cifr.html

\epigraph{
"--*  Сегодня нам на доукомплектование прибыло 28 танков. Их нужно распределить по 7 ротам. Я~посчитал, на каждую роту получается по 13 танков. 
% К~утру должны быть распределены. Всем понятно?

"--* Товарищ полковник, мне что-то непонятно. 
% Как 28 танков распределить на 7 рот по 13 в~каждую? У~меня что-то не сходится.

"--*  Ладно, лейтенант, тебе простительно, ты недавно из училища, считать не умеешь. Сейчас научу. \\ 28~делим на~7. 8~разделить на~7, 1~и~1~в~остатке. Пишем «1». Осталось~21. 21:7 = 3. Пишем «3». Видишь, получается~13.
}{Из анекдота}
% http://aspav-sp.livejournal.com/50011.html

% идея

Все позиционные системы счисления строятся по одному общему принципу. 
Выбирается некоторое натуральное число $N > 1$ "--- основание системы счисления, и~каждое число $X \in \Naturalset_0$ представляется в~виде комбинации его степеней с~коэффициентами, принимающими значения от~$0$ до $N-1$, т.\,е. в виде
\begin{equation}
\label{eq:digits:position-exponentiation}
X = x_0 + x_1\cdot N + \ldots + x_k\cdot N^k
\end{equation}
где
$0\leqslant x_i < N$ "--- целые.
Такое разложение существует и единственно для каждого $X \in \Naturalset_0$.


Далее число $X$ сокращённо записывается в~виде $x_k ... x_1 x_0$.
% Коэффициент при 
% позиция 
% В~позиционных системах счисления 
% число представляется в~виде последовательности специальных символов "--- цифр, не 
% 
% целого неотрицательного числа
% 
% цифры записываются в~определённом порядке, и,~как правило, не разделяются никаким символом.
% В~
Для того, чтобы отличать это представление от сокращённой записи умножения $x_k \cdot ... \cdot x_1\cdot  x_0$, над позиционной записью может быть проведена горизонтальная черта; % (как правило это используется, если разряды о).
основание системы счисления~$N$ может быть указано в~виде нижнего индекса, таким образом:
\begin{equation}
\label{eq:digits:position-exponentiation-def}
X = x_0 + x_1\cdot N + \ldots + x_k\cdot N^k = \overline{x_k \ldots x_1 x_0}_N
\end{equation}
Если позиционность представления и~основание системы очевидны из контекста, эти обозначения могут опускаться.
Так, запись $13$ для позиционного десятичного представления числа «тринадцать» будет, скорее всего, прочитана правильно, 
как  и~\hex{0400-04FF} для позиционного шестнадцатеричного представления диапазона кодов Unicode.


Каждому возможному значению $x_i$, от~$0$ до~$N-1$, соответствует специальный знак "--- цифра.
% 
% Если основание системы~$N$ не превышает~$10$, 
Для записи значений, не превышающих девяти, 
используются привычные нам знаки $0...9$.
Если необходимо записать одной цифрой значение~«десять», для этого обычно используется знак~$\mathrm{A}$,
одиннадцать записывается как~$\mathrm{B}$ и~так далее.


Таким образом, в~часто используемой в~информационных технологиях шестнадцатеричной системе счисления 
числа записываются с~помощью шестнадцати цифр: $\hex{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.}$
Знаки $\hex{A\ldots F}$ в~этом контексте называются именно цифрами, а~не буквами, и~качественно ничем не отличаются от знаков $\hex{0...9}$.
% 
% Современная запись 
В~двенадцатиричной системе используется двенадцать цифр: $\hex{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B.}$
\begin{equation*}
13_{10} = 11_{12} = \hex{D}_{16}
\end{equation*}

Величина, обозначаемая цифрой в~записи числа, зависит от её позиции (разряда).
Разряды числа, в~отличие от текста, записываются по-арабски "--- справа налево.
Цифра, записываемая крайней справа, обозначает количество единиц (младший радряд), вторая справа в~десятичной системе обозначает количество десятков, в~двенадцатиричной "--- количество дюжин и~т.\,д.
Крайний слева разряд %соответствует максимальной степени основания, на которую
называется старшим.
\begin{equation*}
\begin{array}{c}
12345_{10} = 5\cdot10^0 + 4\cdot10^1 + 3\cdot10^2 + 2\cdot10^3 + 1\cdot10^4
\end{array}
\end{equation*}
Иногда разряды числа нумеруются, но порядок нумерации в~различных источниках не совпадает.
Младший разряд обозначается иногда как первый (так сложилось исторически), иногда как нулевой (так как $1 = N^0$).
В~некоторых источниках разряды чисел фиксированной ширины (например, регистров) вообще нумеруются от старшего к~младшему, по направлению текста.


В~любой позиционной системе счисления ноль записывается как~$0$, единица "--- как~$1$.
Основание этой системы счисления всегда записывается в~виде~$10$.

\subsection{Перевод %натуральных чисел 
между позиционными системами счисления}

В~общем случае
для перевода натуральных чисел между системами счисления используется деление с~остатком.
Действительно, сгруппируем в~\eqref{eq:digits:position-exponentiation} все члены, куда входит $N$ в~степени, большей~$1$:
\begin{equation}
\label{eq:digits:position-exponentiation-0brace}
X 
= x_0 + \big(x_1\cdot N + \ldots + x_k\cdot N^k\big)
\end{equation}
вынесем за скобки~$N$ и~обозначим оставшееся %в~скобках 
значение как~$X_1$:
\begin{equation}
\label{eq:digits:position-exponentiation-0}
X 
=x_0 + \underbrace{\big(x_1 + \ldots + x_k\cdot N^{k-1}\big)}_{X_1}\cdot N
=x_0 + {X_1}\cdot N,
\end{equation}
где $x_0$ и~$X_1$ "--- целые неотрицательные числа, причём $0\leqslant x_0 < N$.
Таким образом, младшая цифра $x_0$ числа $X$ в~$N$-ичной системе счисления "--- остаток от целочисленного деления $X$ на $N$,
также в~процессе этого деления мы получим частное, равное~$X_1$.
% а~$X_1$ "--- частное этого деления.
Так как в~соответствии с~\eqref{eq:digits:position-exponentiation-0} 
\begin{equation}
X_1 =x_1 + x_2\cdot N + \ldots + x_k\cdot N^{k-1},
\end{equation}
следующую цифру $x_1$ можно найти как остаток от деления $X_1$ на~$N$ и~так далее.


Если необходимо перевести число из системы счисления по произвольному основанию $N$
в~ту систему счисления, которая используется в~расчётах (при расчётах вручную это обычно десятичная система), это можно сделать, используя определение~\eqref{eq:digits:position-exponentiation-def}:
\begin{equation*}
\begin{array}{c}
12345_{12} = 5\cdot12^0 + 4\cdot12^1 + 3\cdot12^2 + 2\cdot12^3 + 1\cdot12^4  = 24677_{10}
\\
101_{2} = 1\cdot2^0 + 0\cdot2^1 + 1\cdot2^2 = 5_{10}
\\
1A_{16} = 10\cdot16^0 + 1\cdot16^1 = 26_{10}
\end{array}
\end{equation*}
Компьютер оперирует %в~основном 
с~данными, представленными в~двоичной системе, таким образом, при вводе десятичных данных необходимое преобразование также можно выполнить по~\eqref{eq:digits:position-exponentiation-def}:
\begin{equation*}
\begin{array}{c}
13_{10} = 11\cdot1010^0 + 1\cdot1010^1 = 11 + 1010 = 1101
\end{array}
\end{equation*}
Впрочем, десятично-двоичное преобразование уже реализовано в~библиотеке ввода-вывода любого языка высокого уровня %, и~вручную подобные расчёты 
и~выполняется неявно для программиста и тем более для пользователя.

Если число необходимо перевести из~системы счисления по основанию $N$ в~систему по основанию~$N^k, k \in \Naturalset$ или наоборот, то также нет необходимости в~сложных вычислениях.
В~этом случае существует взаимно однозначное соответствие между группой из $k$ разрядов в~системе по основанию $N$ и~одним разрядом в~системе по основанию~$N^k$,
что будет подробнее рассмотрено ниже на примере двоичной, восьмеричной и~шестнадцатеричной систем.

\subsection{Экономичность системы счисления}

С~точки зрения математики, все позиционные системы счисления равнозначны.
Но, как показывает практика,  вычислительные системы, обрабатывающие данные в~двоичной системе, более просто устроены и,~соответственно, имеют меньшие габариты, чем десятичные (при сопоставимых возможностях).
Это связано с~таким свойством, как экономичность, или компактность системы счисления. % (само понятие экономичности приписывается фон Нейману).
Считается, что понятие экономичности введено фон Нейманом.

% Экономичность системы счисления определяется следующим образом.
Рассмотрим сравнительную экономичность двоичной и~десятичной систем на следующем примере~\cite{fominSS}.
В~десятичной системе для представления $10^3$ чисел от $0$ до~$999$ используется три разряда, каждый из которых %может находиться в~десяти различных состояниях,
помещает одну из десяти различных цифр,
то есть всего используется $30$  цифр.
В~двоичной системе из тех же $30$ цифр можно составить $15$ разрядов, каждый из которых хранит ноль или единицу.
Таким образом, всего можно представить $2^{15} = 32\,768$ различных чисел
"--- более чем на порядок больше, чем в~десятичной.
% Это и~позволило реализовать Z1  и~машин Бэббиджа. 

Обобщая эти рассуждения, можно оценить количество $E_n(N)$ различных чисел, представимых в~системе счисления по основанию $N$ с~помощью $n$ цифр:
\begin{equation}
\label{eq:digits-position-compact}
E_n(N) = N ^ {\frac{n}{N}}
\end{equation}
% В~троичной системе получаем 10 разрядов по три цифры, то есть $3^{10} = 59\,049$ чисел.
% В~четверичной системе из 30  цифр нельзя составить целое число разрядов по четыре цифры, но, обобщив способ вычисления, мы получим $4^{\frac{15}{2}} = 2^{15} = 32\,768$, то есть эффективность четверичной системы равна эффективности двоичной.
% 
% Пятеричная система даст уже шесть разрядов по пять цифр, то есть всего $5^{6} = 15\,625$ чисел.
% При дальнейшем возрастании основания эффективность будет падать дальше.
% 
% В~десятичной системе для представления $10^6$ чисел от $0$ до~$999999$ используется шесть разрядов, каждый из которых 
% помещает одну из десяти различных цифр,
% то есть всего используется 60  цифр.
% В~двоичной системе из тех же 60 цифр можно составить 30 разрядов, каждый из которых хранит ноль или единицу.
% Таким образом, всего можно представить $2^{30} = $ различных чисел.

Хотя на практике используются только натуральные основания систем счисления, \eqref{eq:digits-position-compact} можно распространить и~на вещественные положительные $N$.
На рис.~\ref{ris:digits-ternary-optimal} представлена зависимость $E_n(N)$ для трёх значений количества цифр~$n$.

\begin{illustration}

\begin{tikzpicture}    [line cap=round,line join=round,x=5ex,y=5ex]
\begin{axis}[/pgf/number format/use comma,/pgf/number format/1000 sep={},
xlabel=$N$,
ylabel=$E_n(N)$, %$N ^ {\frac{n}{N}}$,
height=0.4\linewidth,
width=\linewidth,
grid=major,
axis x line=middle,
axis y line=middle,
% every axis plot/.append style={graphline},
% yticklabel=\pgfmathprintnumber{\tick},
% scaled y ticks=base 10:2,
y tick label style={/pgf/number format/.cd,%
          scaled y ticks = false,
          set thousands separator={},
          fixed},
ytick={1,2,4,6,...,18},
extra x ticks={2.71828},
extra x tick labels={$e$},
% xmin=0,xmax=12.5,  
% ymin=0,ymax=19,  
% xlabel style={xshift=-0.2em},
]
 \pgfplotsset{
 tick label style={font=\footnotesize},
 label style={font=\footnotesize},
 legend style={font=\footnotesize}
}
 \pgfplotsinvokeforeach{4,6,8}
 {
  \addplot[mark=none,domain=0.1:12.5,samples=120, very thick, smooth]     {exp(#1/x*ln(x))} node [pos=1-8/#1/#1, above, sloped] {{$n={#1}$}};
  \addplot[mark=*] coordinates {(e,exp(#1/e)};
 };
\end{axis} 
\end{tikzpicture}

\caption{Эффективность систем счисления}
\label{ris:digits-ternary-optimal}
\end{illustration}

Как видно из  рис.~\ref{ris:digits-ternary-optimal}, количество используемых цифр~$n$ не влияет на то, какая из систем счисления более экономична, от него зависит только выраженность пика: чем большее количество цифр используется, тем больше разрыв между различными системами.
Для всех значений~$n$
двоичная система существенно превосходит десятичную, но отнюдь не является самой эффективной.
Максимум $E_n(N)$ находится в~точке $N=e=2,71828...$, что можно доказать дифференцированием \eqref{eq:digits-position-compact}.
Из натуральных $N$ наибольшее значение  достигается при  $N=3$, то есть троичная система ещё экономичнее двоичной.
Далее  эффективность снижается с~ростом $N$:
четверичная система так же экономична, как и~двоичная; 
при $N>4$ экономичность плавно снижается и~асимптотически
стремится к~единице.

Также можно заметить, что для всех $n$ получаем $E_n(1) = 1$. 
Действительно (хотя единичная система не является в~полной мере позиционной и,~соответственно, не может однозначно рассматриваться как частный случай \eqref{eq:digits-position-compact}): в~единичной системе с~помощью $n$ цифр можно записать только одно число "--- оно равно $n$.

Таким образом, наиболее эффективной должна быть вычислительная машина, построенная с~использованием троичной системы счисления.
% менее эффективна двоичная система.
% Четверичная 
Двоичная система, использование которой связано с~тем, что большинство существующих электронных компонентов может находиться только в~двух состояниях, также относительно эффективна.


\subsection{Представление вещественных чисел в~позиционных системах счисления}

Знак числа показывается нецифровым символом «$+$» или «$-$» перед числом.

Простые дроби $\frac{m}{n}$.

$N$-ичные дроби.


\subsection{Перевод вещественных чисел между позиционными системами счисления}



% \section{Двоичное представление неотрицательных целых чисел} 
\section{Двоичное представление беззнаковых целых чисел} 
% \section{Представление беззнаковых целых чисел в~вычислительных системах} 
\label{sec:digits-binnatural}
\epigraph{

"--*  Что общего между Хэллоуином и~Рождеством?

"--*  Каждый программист знает: 31 oct = 25 dec
}{\ProgFolk}

% целые, 2, 8, 16, перевод


% В~настоящее время в~вычислительной технике повсеместно используется двоичная позиционная система, то есть
% \begin{itemize}
% \item 
% \end{itemize}
% В~связи с~тем, что большинство существующих электронных компонентов может находиться только в~двух состояниях, которые обычно обозначаются как $0$ и~$1$,
Для представления беззнаковых целых чисел в~вычислительной технике используется  позиционная система счисления по основанию $2$, в~которой используется всего две цифры "--- $0$ и~$1$.
\begin{equation}
\label{eq:digits:binary-exponentiation-def}
X = x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k = \overline{(x_k \ldots x_1 x_0)}_2, ~~x_i \in \{0,1\}
\end{equation}
например,
\begin{equation*}
\label{eq:digits:binary-exponentiation-sample}
109_{10} = 1 + 0\cdot 2 + 1\cdot 4 + 1\cdot 8 + 0\cdot 16 + 1\cdot 32 + 1\cdot 64 = 1101101_2.
\end{equation*}

Каждому двоичному разряду (биту, от binary digit) числа,  соответствует одна элементарная ячейка памяти, которая может находиться в~одном из двух состояний.
Эти состояния обычно также  обозначаются как $0$ и~$1$.
% так что значение ячейки равно соответствующему разряду числа.


Количество таких ячеек в~числе не может быть произвольным "--- оно определяется особенностями вычислительной системы
и~всегда кратно определённому числу, называемому размером байта.
Число минимально возможного размера, соответственно, называется \termin{байтом}.
В~настоящее время байт обычно содержит $8$ разрядов (бит), иногда "--- $16$, другие значения встречаются реже.
% Целые числа могут обычно содержать 2, 4, 8 байтов

Ячейка памяти не может быть пуста "--- в~ней содержится либо~$0$, либо~$1$. 
В~частности, хотя двоичное представление десятичного числа $109$ %как 
содержит семь цифр ($1101101$), 
записать в~восьмибитный байт можно только восемь ($01101101$).

% Такое представление называется натуральным двоичным кодом, так как оно,
Такая запись называется натуральным двоичным кодом (binary, сокращённо $bin$), так как она, 
с~одной стороны, используется для натуральных чисел (и ещё для нуля), а с~другой "--- является наиболее естественным их представлением.

Добавленный нулевой старший бит соответствует в~разложении числа слагаемому $0\cdot128 = 0$, то есть не влияет на значение числа.
% Старший бит занят незначащим нулём, который часто опускают на письме.
Таким образом, ноль в~старшем разряде (ведущий ноль) для числа в~натуральном двоичном коде является \termin{незначащим} и~часто опускается на письме.

% Из-за ограниченного количества разрядов, которые могут обрабатываться за процессором, разрядность чисел ограничена.
Минимальное число, которое можно записать в~восьми битах натуральным двоичным кодом "--- ноль ($0000\,0000$), максимальное "--- $255$ ($1111\,1111$).
В~общем случае $N$ битами можно записать числа от~$0$ до~$2^N$.

\subsection{Восьмеричное и~шестнадцатеричное представление}

% Хотя двоичная система экономичнее десятичной, 
Двоичная запись даже относительно небольших чисел выглядит очень громоздко и~трудно читается человеком.
Обычно для ввода-вывода используется десятичная запись, но в~некоторых случаях это неприемлемо.
% В~частности, права доступа Unix ...

Для того, чтобы придать числам компактный вид и~при этом сохранить их двоичную структуру, используются восьмеричная (octal, $oct$) и~шестнадцатеричная  (hexadecimal, $hex$) системы счисления.
Так как основания этих систем являются степенью двойки (то есть основания исходной системы),
нет необходимости в~сложных вычислениях.

Рассмотрим двоичную запись некоторого числа в~форме~\eqref{eq:digits:binary-exponentiation-def}, сгруппируем слагаемые по тройкам (если число разрядов не кратно трём, дополним число справа одним или двумя незначащими нулями) и~вынесем общий множитель за скобки:
\begin{equation}
\label{eq:digits:binary-2to8}
\begin{array}{c}
X =
\overline{(x_k \ldots x_1 x_0)}_2 =
% x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k = 
\\[1.5ex]
= \underbrace{x_0 + x_1\cdot 2 + x_2\cdot 2^2} + \underbrace{x_3\cdot 2^3 + x_4\cdot 2^4 + x_5\cdot 2^5} + 
\\
+\ldots +\underbrace{x_{3i}\cdot 2^{3i} +x_{3i+1}\cdot 2^{3i+1} + x_{3i+2}\cdot 2^{3i+2}}  + \ldots  = 
\\[2ex]
=(x_0 + x_1\cdot 2 + x_2\cdot 2^2) + (x_3  + x_4\cdot 2 + x_5\cdot 2^2)\cdot2^3 +
\\
+\ldots + (x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 2^2)\cdot 2^{3i} + \ldots
\end{array}
\end{equation}
Так как двоичные цифры %$x_i \in \{0,1\}$, 
% лежат в~диапазоне $0 \leqslant x_i \leqslant 1$,
могут принимать только значения~$0$ и~$1$,
значение внутри каждой скобки целое, неотрицательное и~не превышает семи:
\begin{equation}
\label{eq:digits:binary-2to8-onedigit}
0=
0 + 0\cdot 2 + 0\cdot 2^2 \leqslant
x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 2^2 
\leqslant 1 + 1\cdot 2 + 1\cdot 2^2 = 7
\end{equation}
коэффициенты при скобках имеют вид $2^{3i} = {(2^3)}^i = 8^i$.
Таким образом, получаем позиционную восьмеричную запись:
\begin{equation}
\label{eq:digits:binary-2to8-8}
\begin{array}{c}
X = 
(x_0 + x_1\cdot 2 + x_2\cdot 4) + (x_3  + x_4\cdot 2 + x_5\cdot 4)\cdot 8 +
\\
+\ldots + (x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 4)\cdot 8^{i} + \ldots =
\\[1.5ex]
= \widetilde{x_0} + \widetilde{x_1}\cdot 8 + \ldots + \widetilde{x_i}\cdot 8^i, ~~\widetilde{x_i} \in \{0, 1, 2,\ldots 7\}
\end{array}
\end{equation}
где $\widetilde{x_i} = x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 4$.

% Практически
На практике для перевода двоичной записи в~восьмеричную достаточно разбить разряды на тройки и~затем заменить каждую тройку двоичных цифр одной восьмеричной (таблица~\ref{tab:digits-bin2oct}):
\begin{equation}
1101010_{2} = 001\,101\,010_{2} = 152_8
\end{equation}
для обратного преобразования каждая восьмеричная цифра заменяется тремя двоичными:
\begin{equation}
234_8 = 010\,011\,100_{2} = 10011100_2
\end{equation}


\begin{table}[!ht]

\caption{Соответствие двоичных триад восьмеричным цифрам}
\label{tab:digits-bin2oct}

% \renewcommand{\arraystretch}{1.5}
\begin{tabularx}{1\linewidth}{l|RRRRRRRR}
\hline
$bin$&$000$ & $001$ & $010$ &  $011$  & $100$ & $101$ & $110$ & $111$ \\
$oct$&$0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$  \\\hline

\end{tabularx}
\end{table}

Восьмеричное представление чисел используется, в~частности, для записи прав доступа в~Unix.

Аналогично,
для перевода из двоичной системы в~шестнадцатеричную разряды необходимо группировать по четыре, так как $16 = 2^4$:
\begin{equation}
\label{eq:digits:binary-2to16}
\begin{array}{@{}c@{}}
X =
\overline{(x_k \ldots x_1 x_0)}_2 =
% x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k = 
\\[1.5ex]
= \underbrace{x_0 + x_1\cdot 2 + x_2\cdot 2^2 + x_3\cdot 2^3} + \underbrace{x_4\cdot 2^4 + x_5\cdot 2^5 + x_6 \cdot 2^6 + x_7 \cdot 2^7} + 
\\
+\ldots +\underbrace{x_{4i}\cdot 2^{4i} +x_{4i+1}\cdot 2^{4i+1} + x_{4i+2}\cdot 2^{4i+2}+ x_{4i+3}\cdot 2^{4i+3}}  + \ldots  = 
\\[2ex]
=(x_0 + x_1\cdot 2 + x_2\cdot 2^2 + x_3\cdot 2^3) + (x_4  + x_5\cdot 2 + x_6\cdot 2^2 + x_7 \cdot 2^3)\cdot2^4 +
\\
+\ldots + (x_{4i} + x_{4i+1}\cdot 2 + x_{4i+2}\cdot 2^2 +x_{4i+3}\cdot 2^{3})\cdot 2^{4i} + \ldots =
\\[1.5ex]
=(x_0 + x_1\cdot 2 + x_2\cdot 4 + x_3\cdot 8) + (x_4  + x_5\cdot 2 + x_6\cdot 4 + x_7 \cdot 8)\cdot 16 +
\\
+\ldots + (x_{4i} + x_{4i+1}\cdot 2 + x_{4i+2}\cdot 4 +x_{4i+3}\cdot 8)\cdot 16^{i} + \ldots =
\\[1.5ex]
= \widetilde{x_0} + \widetilde{x_1}\cdot 16 + \ldots + \widetilde{x_i}\cdot 16^i, ~~\widetilde{x_i} \in \{\hex{0, 1, 2,\ldots F}\}
\end{array}
\end{equation}
четыре двоичных разряда (тетрада) заменяются одним шестнадцатеричным (таблица~\ref{tab:digits-bin2hex})
\begin{equation}
1101010_{2} = 0110\,1010_{2} = 6A_{16}
\end{equation}
и~наоборот
\begin{equation}
\hex{2B3}_{16} = 0010\,1011\,0011_{2} = 001010110011_2
\end{equation}

\begin{table}[!ht]

\caption{Соответствие двоичных тетрад шестнадцатеричным цифрам}
\label{tab:digits-bin2hex}

% \renewcommand{\arraystretch}{1.5}
\begin{tabularx}{1\linewidth}{l|RRRRRRRR}
\hline
% $\overline{x_{4i}x_{4i+1}x_{4i+2}x_{4i+3}}$
$bin$&$0000$ & $0001$ & $0010$ &  $0011$  & $0100$ & $0101$ & $0110$ & $0111$ \\
% $\widetilde{x_i}$
$hex$&\hex{0} & \hex{1} & \hex{2} & \hex{3} & \hex{4} & \hex{5} & \hex{6} & \hex{7}  \\\hline

$bin$&$1000$ & $1001$ & $1010$ &  $1011$ & $1100$ & $1101$ & $1110$ & $1111$ \\
$hex$&\hex{8} & \hex{9} & \hex{A} & \hex{B}  & \hex{C} & \hex{D} & \hex{E} & \hex{F} \\\hline

\end{tabularx}
\end{table}

Шестнадцатеричное представление используется чаще, 
так как типичный байт (восемь бит) представляется двумя шестнадцатеричными цифрами.
Часто двоичный код разделяют на тетрады просто для читабельности.


Так как восьмеричная и~шестнадцатеричная системы счисления обычно используются для более компактной записи двоичного кода, а~не как самостоятельные позиционные системы, они традиционно применяются только для беззнаковых целых чисел.
Для более сложных структур данных под шестнадцатеричным представлением подразумевается шестнадцатеричное представление двоичного содержимого памяти, а~не самих данных.
Так, запись $-1 = \hex{FFFF\,FFFF}$ обозначает, что значение $-1$ представляется в~памяти двоичным кодом $1111\,1111\,1111\,1111\,1111\,1111\,1111\,1111$, что в~шестнадцатеричном виде соответствует \hex{FFFF\,FFFF}.

В~частности, функции форматированного ввода-вывода стандартной библиотеки C++ (семейства $scanf$ и~$printf$) предоставляют два спецификатора для десятичного представления "--- десятичное знаковое \lstinline!%d! и~десятичное беззнаковое \lstinline!%u! представления, но шестнадцатеричное представление возможно только беззнаковое.


% \section{Двоичная арифметика в~вычислительных системах} 
\section{Беззнаковая арифметика в~вычислительных системах} 
\epigraph{Митрофан (вычисляя, шепчет).

% ...
Единожды ноль "--- ноль. Единожды ноль "--- ноль.

Нуль да нуль "--- нуль. Один да один... (Задумался.)
}{Д.\,И.\,Фонвизин}

% сложение/вычитание, умножение/деление

% Как правило, вычислительные системы используют двоичную

% Принцип 
Из-за единообразного представления чисел в~позиционных системах счисления 
арифметические действия во всех таких системах выполняется по одному и~тому же алгоритму.
Соответственно, %принцип двоичных  вычислений не отличается от привычного нам десятичного 
сложение, вычитание, умножение и~деление натуральных чисел, записанных в~двоичной системе, выполняется по привычной нам схеме «в~столбик»,
с~одним отличием: $1+1 = 10$.
% Есть только два отличия: во-первых, из-за основания, равного двум, %получаем 
% $1+1=10$;
% во-вторых, из-за ограниченной разрядности.

Арифметика в~вычислительных системах 
двоична и~%
имеет ещё одно отличие от ручных вычислений, кроме основания системы счисления "--- ограниченность.
Производя вычисления вручную, можно потенциально обрабатывать сколь угодно большие числа.
Узел ЭВМ, предназначенный для выполнения арифметических действий, имеет фиксированную разрядность.
В~частности, $N$-разрядный сумматор "--- узел, выполняющий сложение "--- обрабатывает операнды, состоящие из~$N$ разрядов и~формирует результат также длины~$N$;
и~возможна ситуация, когда операнды арифметической операции попадают в~допустимый диапазон, а~её результат "--- уже нет.


Большинство современных процессоров семейства x86 имеет наборы команд %(и~соответствующие устройства) 
для \mbox{$N=8_{10}$,} $N=16_{10}$, $N=32_{10}$ и~$N=64_{10}$.
% Для простоты рассмотрим восьмиразрядные операции.
Для наглядности %рассмотрим 
все арифметические операции
будут рассматриваться
на примере $N=8_{10}$.
% Оба операнда, как и~результат сложения "--- восьмиразрядные.


% Рассмотрим двоичную арифметику

\subsection{Сложение и~вычитание}

Сложение %, как и~в~любой позиционной системе,  
производится поразрядно, начиная с~младшего  разряда.
Если сумма младших разрядов равна или превышает $10$, возникает \termin{перенос в~старший разряд.}

\tikzstyle{arythm-picture} = [baseline, outer xsep = 0ex, inner xsep = 0.1ex, node distance = 0ex]
\tikzstyle{arythm-matrix} = [matrix of math nodes, nodes in empty cells,
%     row sep=-\pgflinewidth, column sep=-\pgflinewidth, %нужно, чтобы не удваивалась обводка
    nodes={outer sep=0ex, inner xsep=0ex, inner ysep=0.4ex, minimum width = \digitwidth, text height=\heightof{0}, text depth=\depthof{0}},
%     row 1/.style={nodes={scale=0.5}}, %row 3/.style={bottomrule}
%     row 4/.style={inner ysep=0.5ex}
]
\tikzstyle{arythm-carry} = [scale=0.5]

\newlength{\rulerowsep}
\setlength{\rulerowsep}{0.4ex}

\newcommand{\drawrulerow}[2][1]
{
  \tikzmath{int \ytopcell, \ybottomcell, \xstartcell;
    \ytopcell=#2; \ybottomcell=\ytopcell + 1; \xstartcell = #1;
    let \topcell = m-\ytopcell-\xstartcell;
    let \bottomcell = m-\ybottomcell-\xstartcell;
    };
  \coordinate (lineleft) at ($0.6*(\topcell.south west)+0.4*(\bottomcell.north west)$); %(m-3-1.south west);
  \draw (lineleft) -- (lineleft-|m.east);
}

% \newcommand{\longAdd}[1]
% {
% }

\newenvironment{tikzlongsum}
{
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, row 1/.style={nodes={arythm-carry}}, %row 4/.style={nodes={outer ysep=\rulerowsep}}
  ]
}
{
% \coordinate (lineleft) at ($0.6*(m-3-1.south west)+0.4*(m-4-1.north west)$); %(m-3-1.south west);
% \draw (lineleft) -- (lineleft-|m.east);
\drawrulerow{3}
\end{tikzpicture}
}

Рассмотрим сложение двух чисел, представленных в~двоичном виде.
При сложении младших разрядов получаем $1 + 1 = 10$, то есть младший разряд суммы равен~$0$, а~к~более старшему разряду добавляется единица переноса (перенос показан мелким шрифтом над первым слагаемым).
Соответственно, для второго разряда получаем уже $1+1+1 = 11$ "--- единица в~соответствующем разряде суммы и~единица переноса "--- и~так далее:
% \begin{equation}
% \label{eq:digits-binadd-0}
% \begin{tikzpicture}[arythm-picture]
% \matrix (m) [arythm-matrix, row 1/.style={nodes={arythm-carry}}]
% {
% 1& & & & &1&1& \\
%  &1&0&1&0&0&1&1\\
%  &1&0&0&1&0&1&1\\[\rulerowsep]
% 1&0&0&1&1&1&1&0\\
% };
% \coordinate (lineleft) at ($0.6*(m-3-1.south west)+0.4*(m-4-1.north west)$); %(m-3-1.south west);
% \draw (lineleft) -- (lineleft-|m.east);
% 
% \node[left = of m-2-2.south west] {$+$};
% \end{tikzpicture}
% ~~~~
% (83_{10} + 75_{10} = 158_{10})
% \end{equation}
\begin{equation}
\label{eq:digits-binadd-a+b}
\begin{tikzlongsum}
{
 & & & &1&1& \\
1&0&1&0&0&1&1\\
 & & &1&0&1&1\\[\rulerowsep]
1&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
(83_{10} + 11_{10} = 94_{10})
\end{equation}
% В~результате получаем 
В~скобках показано десятичное представление слагаемых и~суммы.


% % В~примере \eqref{eq:digits-binadd-0} каждое из слагаемых занимает семь бит, а~сумма "--- восемь за счёт переноса из старшего разряда.
% % Длина суммы не может превышать длину слагаемых более чем на один разряд:
% Если при сложении старших разрядов возникнет перенос,  сумма будет длиннее слагаемых на один разряд:
% % (перенос из старшего разряда).
% \begin{equation}
% \label{eq:digits-binadd-0}
% \begin{tikzpicture}[arythm-picture]
% \matrix (m) [arythm-matrix, row 1/.style={nodes={arythm-carry}}]
% {
% 1&1&1&1&1&1&1& \\
%  &1&1&1&1&1&1&1\\
%  &1&1&1&1&1&1&1\\[\rulerowsep]
% 1&1&1&1&1&1&1&0\\
% };
% \coordinate (lineleft) at ($0.6*(m-3-1.south west)+0.4*(m-4-1.north west)$); %(m-3-1.south west);
% \draw (lineleft) -- (lineleft-|m.east);
% 
% \node[left = of m-2-2.south west] {$+$};
% \end{tikzpicture}
% ~~~~
% (127_{10} + 127_{10} = 254_{10})
% \end{equation}


% Ещё одна особенность 
Как уже было сказано, одной из особенностей
арифметики вычислительных систем %добавляет ограниченная разрядность чисел
является ограниченный диапазон представимых чисел.
% Возможна ситуация, когда операнды арифметической операции попадают в~допустимый диапазон, а~её результат "--- уже нет.
% Ограниченные размеры чисел добавляют ещё одну особенность арифметике в~вычислительных системах "---
% результаты некоторых
% В~таких случаях 
% Рассмотрим сложение чисел ограниченной разрядности на примере восьмиразрядных слагаемых.
% 
% Процессор не может обрабатывать числа %сколь угодно большой
% произвольной разрядности.
Все операции в~ЭВМ выполняется над числами фиксированной длины~$N$ (в~данном разделе рассматривается случай $N=8_{10}$).
% % , то есть %оба операнда
% % все обрабатываемые числа имеют длину~$N$
% % % Большинство современных процессоров является 64-разрядными, то есть может выполнять операции с~числами размером от байта (обычно занимающего восемь бит) до 64.

В~этом случае пример \eqref{eq:digits-binadd-a+b} корректнее было бы записать в~виде
\begin{equation}
\label{eq:digits-binadd-a+b-8}
\begin{tikzlongsum}
{
 & & & & &1&1& \\
0&1&0&1&0&0&1&1\\
0&0&0&0&1&0&1&1\\[\rulerowsep]
0&1&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
(83_{10} + 11_{10} = 94_{10})
\end{equation}
так как ни один из разрядов числа не может быть пуст.
Но такая запись тяжело читается, поэтому незначащие нули часто опускают.


Пусть необходимо прибавить к~максимальному представимому числу (для восьми разрядов это $1111\,1111=255_{10}$) единицу.
% Корректный результат данной операции равен $256_{10}$ и~не может быть представлен натуральным двоичным кодом в~восьми разрядах.
Сумма младших разрядов слагаемых даст ноль в~младшем разряде и~единицу переноса ($1+1=10$); 
сумма единицы переноса и~вторых разрядов слагаемых "--- ноль во втором разряде и~единицу переноса ($1+1+0=10$)
и~так далее.
Сумма старших (восьмых) разрядов тоже также даст ноль в~старшем (восьмом) разряде результата и~единицу переноса в~девятый разряд результата ($1+1+0=10$),
так что в~неограниченной арифметике (в~частности, при ручном расчёте) получилось бы
\begin{equation}
\label{eq:digits-binadd-ff+1-9}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 & & & & & & & &1\\[\rulerowsep]
1&0&0&0&0&0&0&0&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
~~~~
(255_{10} + 1_{10} = 256_{10})
\end{equation}
но у~восьмибитного результата нет девятого разряда "--- поэтому фактический результат будет равен нулю.
Такая ситуация называется \termin{беззнаковым переполнением.}
Бит переноса в~несуществующий разряд результата сохраняется в~специальной ячейке, называемой \termin{флагом переноса} (%Carry, в~архитектуре 
$CF$ "--- Carry flag).
\begin{equation}
\label{eq:digits-binadd-ff+1}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 & & & & & & & &1\\[\rulerowsep]
 &0&0&0&0&0&0&0&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
% ~~~~
% \begin{tikzlongsum}
% {
% 1&1&1&1&1&1&1&1&1\\
%  &1&1&1&1&1&1&1&1\\
%  & & & & & & & &1\\[\rulerowsep]
% |[draw]|1
%  &0&0&0&0&0&0&0&0\\
% };
% \node[left = of m-2-2.south west] {$+$};
% \end{tikzlongsum}
~~~~
(255_{10} + 1_{10} = 0_{10})
~~~~
CF = 1
\end{equation}
В~общем случае в~$N$-битной арифметике $(2^N - 1) + 1 = 0$, при этом $CF=1$.

Флаг переноса не является частью числа, куда записывается результат.
Конструктивно ячейка~$CF$ принадлежит сумматору и,~если подряд выполняется несколько операций, каждая из них будет перезаписывать $CF$ новым значением.

Если размер суммы не превышает %восьми
$N$ разрядов, всё делается аналогично неограниченной арифметике и~флаг переноса $CF$ равен нулю.
\begin{equation}
\label{eq:digits-binadd-a+b-9E}
\begin{tikzlongsum}
{
1& & & & &1&1& \\
0&1&0&1&0&0&1&1\\
0&1&0&0&1&0&1&1\\[\rulerowsep]
1&0&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
(83_{10} + 75_{10} = 158_{10})
~~~~
CF = 0
\end{equation}

Одного разряда для флага переноса достаточно.
Даже при сложении двух максимально возможных восьмибитных беззнаковых значений возникает перенос в~девятый, но не в~десятый разряд:
\begin{equation}
\label{eq:digits-binadd-ff+ff}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 &1&1&1&1&1&1&1&1\\[\rulerowsep]
 &1&1&1&1&1&1&1&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
~~~~
(255_{10} + 255_{10} = 254_{10})
~~~~
CF = 1
\end{equation}

Таким образом, в~ЭВМ реализована циклическая двоичная арифметика: при сложении операндов $a$ и~$b$ разрядности~$N$ результат фактически равен~$(a+b) \Mod 2^N$.
Программист может %учесть этот флаг %и~реализовать сложение больших чисел 
% вручную.
% узнать о~переносе из старшего разряда, анализируя флаг переноса.
определить корректность результата, анализируя флаг переноса из старшего разряда~$CF$.

Вычитание выполняется, как и~сложение, %в~столбик 
поразрядно.
При необходимости выполняется заём из старшего разряда:
\begin{equation}
\label{eq:digits-binadd-a-b}
\begin{tikzlongsum}
{
\centerdot&\centerdot&\centerdot%\bullet
     & & & & \\
1&0&0&0&0&1&1\\
 & & &1&0&0&1\\[\rulerowsep]
 &1&1&1&0&1&0\\
};
\node[left = of m-2-1.south west] {$-$};
\end{tikzlongsum}
~~~~
(67_{10} - 9_{10} = 58_{10})
\end{equation}
В~случае, когда уменьшаемое меньше вычитаемого, возможен заём из несуществующего девятого разряда.
Такая ситуация также отмечается  единичным значением флага переноса $CF$:
\begin{equation}
\label{eq:digits-binadd-a-b-neg}
\begin{tikzlongsum}
{
\centerdot&\centerdot
 & & & &\centerdot&\centerdot& & \\
 &0&0&0&0&1&0&0&1\\
 &0&1&0&0&0&0&1&1\\[\rulerowsep]
 &1&1&0&0&0&1&1&0\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
~~~~
(9_{10} - 67_{10} = 198_{10})
~~~~
CF = 1
\end{equation}
Как можно заметить, в~неограниченной арифметике $58_{10} + 198_{10} = 256_{10}$.

Таким образом, вычитание, реализованное в~ЭВМ, также циклическое:
разность  $a$ и~$b$ разрядности~$N$  равна~$(a-b) \Mod 2^N$, где под знаком <<$-$>> подразумевается вычитание в~неограниченной арифметике.
Здесь остаток \mbox{$(a-b) \Mod 2^N$} всегда неотрицателен (то есть вычисляется по правилам математики, а~не C++).
Корректность результата можно определить, анализируя флаг~$CF$, показывающий также заём в~старший разряд.

В~частности,
\begin{equation}
\label{eq:digits-binadd-0-1}
\begin{tikzlongsum}
{
\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot& \\
 &0&0&0&0&0&0&0&0\\
 & & & & & & & &1\\[\rulerowsep]
 &1&1&1&1&1&1&1&1\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
~~~~
(0_{10} - 1_{10} = 255_{10})
~~~~
CF = 1
\end{equation}

\subsection{Умножение и~деление}


При умножении двух чисел первый множитель последовательно умножается на каждый разряд второго множителя и~сдвигается %в~сторону старших разрядов
влево на соответствующее количество разрядов (что соответствует умножению на~$10$, то есть на два).
Затем результаты складываются:
\begin{equation}
\label{eq:digits-binmul-axb}
% \begin{tikzpicture}[arythm-picture]
% \matrix (m) [arythm-matrix, row 3/.style={nodes={arythm-carry}}]
% {
%  & & &1&0&1&0&0&1&1\\
%  & & & & & &1&0&1&1\\[\rulerowsep]
%  &1&1&1&1&1&1&1& & \\
%  & & &1&0&1&0&0&1&1\\
%  & &1&0&1&0&0&1&1& \\
%  &0&0&0&0&0&0&0& & \\
% 1&0&1&0&0&1&1& & & \\[\rulerowsep]
% 1&1&1&0&0&1&0&0&0&1\\
% };
% \drawrulerow[3]{2}
% \drawrulerow[1]{7}
% 
% \node[left = of m-1-4.south west] {$\times$};
% \end{tikzpicture}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix]
{
 & & &1&0&1&0&0&1&1\\
 & & & & & &1&0&1&1\\[\rulerowsep]
 & & &1&0&1&0&0&1&1\\
 & &1&0&1&0&0&1&1& \\
 &0&0&0&0&0&0&0& & \\
1&0&1&0&0&1&1& & & \\[\rulerowsep]
1&1&1&0&0&1&0&0&0&1\\
};
\drawrulerow[3]{2}
\drawrulerow[1]{6}
\node[left = of m-1-4.south west] {$\times$};
\end{tikzpicture}
~~~~
(83_{10} \cdot 11_{10} = 913_{10})
\end{equation}
Как видно из \eqref{eq:digits-binmul-axb}, разрядность произведения может превысить разрядность множителей более чем на один бит.
Поэтому %самые старые 
большинство команд умножения  процессоров семейства x86, работающие с~операндами размера~$N$, возвращают результат размера~$2N$.

Действительно, рассмотрим умножение двух максимально возможных восьмибитных беззнаковых значений.
В умножении столбиком, как правило, переносы между разрядами не записываются, а~запоминаются, но в~данном примере ввиду его громоздкости перенос %в~десятичной форме
показан мелким шрифтом в~следующей строке после множителей.
Для наглядности столбцы, соответствующие тетрадам произведения, отделены пробелами.
\begin{equation}
\label{eq:digits-binmul-ffxff}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, row 3/.style={nodes={arythm-carry}}]
{
 & & & &[0.5ex] & & & &[0.5ex]1&1&1&1&[0.5ex]1&1&1&1\\
 & & & & & & & &1&1&1&1&1&1&1&1\\[\rulerowsep]
1&2&3&4&5&6&7&7&6&5&4&3&2&1& & \\
 & & & & & & & &1&1&1&1&1&1&1&1\\
 & & & & & & &1&1&1&1&1&1&1&1& \\
 & & & & & &1&1&1&1&1&1&1&1& & \\
 & & & & &1&1&1&1&1&1&1&1& & & \\
 & & & &1&1&1&1&1&1&1&1& & & & \\
 & & &1&1&1&1&1&1&1&1& & & & & \\
 & &1&1&1&1&1&1&1&1& & & & & & \\
 &1&1&1&1&1&1&1&1& & & & & & & \\[\rulerowsep]
1&1&1&1&1&1&1&0&0&0&0&0&0&0&0&1\\
};
\drawrulerow[8]{2}
\drawrulerow[1]{11}

\node[left = of m-1-9.south west] {$\times$};
\end{tikzpicture}
~~~~
(255_{10} \cdot 255_{10} = 65025_{10})
\end{equation}
Таким образом, для произведения двух восьмибитных множителей достаточно шестнадцати разрядов.

% Если рассматривать только $N$ разрядов произведения 


\newcommand{\drawclinerow}[3][1]
{
  \tikzmath{int \ytopcell, \ybottomcell, \xstartcell, \xendcell;
    \ytopcell=#1; \ybottomcell=\ytopcell + 1; 
    \xstartcell = #2;
    \xendcell = #3;
    let \topcellstart = m-\ytopcell-\xstartcell;
    let \bottomcellstart = m-\ybottomcell-\xstartcell;
    let \topcellend = m-\ytopcell-\xendcell;
    let \bottomcellend = m-\ybottomcell-\xendcell;
    };
  \draw ($0.6*(\topcellstart.south west)+0.4*(\bottomcellstart.north west)$)
     -- ($0.6*(\topcellend.south east)+0.4*(\bottomcellend.north east)$);
}

Деление также выполняется по классической схеме:
\begin{equation}
\label{eq:digits-bindiv-a/b}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix]
{
1&0&1&0&0&1&1	&[1ex]	1&0&1&1\\
 &1&0&1&1& & 	& 	1&1&1& \\[\rulerowsep]
 &1&0&0&1&1\\
 & &1&0&1&1& & \\[\rulerowsep]
 & &1&0&0&0&1 \\
 & & &1&0&1&1& & \\[\rulerowsep]
 & & & &1&1&0& & \\
};
\draw ($0.5*(m-1-7.north east) + 0.5*(m-1-8.north west)$) -- coordinate (lineleft) ($0.5*(m-2-7.south east) + 0.5*(m-2-8.south west)$);
\draw (lineleft) -- (lineleft-|m.east);

\node[left = of m-1-1.south west] {$-$};
\drawclinerow[2]{1}{5}

\node[left = of m-3-2.south west] {$-$};
\drawclinerow[4]{2}{6}

\node[left = of m-5-3.south west] {$-$};
\drawclinerow[6]{3}{7}

\end{tikzpicture}
~~~~
(83_{10} / 11_{10} = 7_{10}~\text{и~$6_{10}$ в~остатке})
\end{equation}
Так как деление обратно умножению,
большинство команд деления процессоров семейства x86 для делителя и~частного размера~$N$ используют делимое  размера~$2N$.
%  и~возвращают результат размера~$N$





\section{Представление отрицательных чисел}
\label{sec:digits-negcodes}
\epigraph{
Никакие законы природы не изменятся, если все заряды в~мире изменить на обратные и~одновременно произвести зеркальное отражение...

Но и~эта симметрия оказалась неточной.
}{А.\,Б.\,Мигдал}
% http://physiclib.ru/books/item/f00/s00/z0000024/st014.shtml

% Часто неотрицательных чисел недостаточно для решения задачи.
% Необходимо использовать целые числа со знаком.

Натуральный двоичный код позволяет кодировать только неотрицательные числа.
При этом в~некоторых задачах необходимы целые числа со знаком.
% Но, так как память компьютера состоит только из битов, которые принимают
В~ячейках памяти нельзя непосредственно сохранить знак числа, так что знаковые и,~в~частности, отрицательные числа необходимо представить в~виде комбинации нулей и~единиц.

Рассмотрим различные способы кодирования знаковых чисел на восьми разрядах.
Всего в~восьмиразрядную ячейку можно записать $256$ различных комбинаций нулей и~единиц.
Каждой из этих комбинаций соответствует некоторое неотрицательное число в~натуральном двоичном коде (первые три столбца таблицы~\ref{tab:digits-neg-code}).
Для кодирования знаковых чисел необходимо поставить в~соответствие каждой комбинации новое число, причём около половины из~этих чисел должны быть отрицательными.




\begin{table}[!ht]

\caption{Различные способы представления знаковых чисел}
\label{tab:digits-neg-code}

\colorlet{csMarker}{yellow!50}


\begingroup
% % \makeatletter
% \renewcommand\theadlong[1]{\multicolumn{1}{@{}S{0.16\linewidth}@{}}{{\tiny\bfseries #1\par
% \vspace*{-1\baselineskip}
% \strut
% }}}
% % \renewcommand\theadlong[1]{\text{{#1}}}
% % \makeatother
% 
% % \renewcommand{\arraystretch}{1.05}
% \newcolumntype{Y}{>{$}S{0.14\linewidth}<{$}}
% \makeatletter
% \renewcommand\theadlong[1]{\multicolumn{1}{|@{}c@{}|}{{#1}}}
% \renewcommand\theadlong[1]{\text{{#1}}}
% \makeatother
% \begin{tabularx}{1\linewidth}{r>{$}S{0.1\linewidth}<{$}>{\columncolor{csMarker}}YYYYY@{\hspace{4em}}}
% % \hline
% & {\llap{\tiny\bfseries Беззнаковое}} 
% & \theadlong{Дополнительный код (доп. до 2)} 
% 		  & \theadlong{Обратный код (доп. до 1)}
% 				& \theadlong{Значение со знаком}
% 						& \theadlong{Код с~избытком~8}\\\hline
% % \text{Беззнаковое}
% % & \text{Дополнительный код (доп. до 2)} 
% % 		  & \text{Значение со знаком}
% % 				& \text{Обратный код (доп. до 1)}
% % 				\\\hline
% 0000 & 0 &	0  &	+0 	&	+0 	&	-8		\\%\hline
% 0001 & 1 &	+1 &	+1	 &	+1	&	-7		\\%\hline
% 0010 & 2 &	+2 &	+2	 &	+2	&	-6		\\%\hline
% 0011 & 3 &	+3 &	+3	 &	+3	&	-5		\\\hline
% 0100 & 4 &	+4 &	+4	 &	+4	&	-4		\\%\hline
% 0101 & 5 &	+5 &	+5	 &	+5	&	-3		\\%\hline
% 0110 & 6 &	+6 &	+6	 &	+6	&	-2		\\%\hline
% 0111 & 7 &	+7 &	+7	 &	+7	&	-1		\\\hline
% 1000 & 8 &	-8 &	-7	&	-0	&	0		\\%\hline
% 1001 & 9 &	-7 &	-6	&	-1	&	+1		\\%\hline
% 1010 & 10 &	-6 &	-5	&	-2	&	+2		\\%\hline
% 1011 & 11 &	-5 &	-4	&	-3	&	+3		\\\hline
% 1100 & 12 &	-4 &	-3	&	-4	&	+4		\\%\hline
% 1101 & 13 &	-3 &	-2	&	-5	&	+5		\\%\hline
% 1110 & 14 &	-2 &	-1	&	-6	&	+6		\\%\hline
% 1111 & 15 &	-1 &	-0	&	-7	&	+7		\\\hline
% 
% 
% \end{tabularx}


% \begin{tabularx}{1\linewidth}{r>{$}S{0.1\linewidth}<{$}>{\columncolor{csMarker}}YYYYY@{\hspace{4em}}}
% % \hline
% &\theadlong{Беззнаковая интерпретация}
% & \theadlong{Дополнительный код (доп. до 2)} 
% 		  & \theadlong{Обратный код (доп. до 1)}
% 				& \theadlong{Значение со знаком}
% 						& \theadlong{Код с~избытком~128}\\\hline
% 0000\,0000 & 0 &	0  &	+0 	&	+0 	&	-128		\\%\hline
% 0000\,0001 & 1 &	+1 &	+1	 &	+1	&	-127		\\%\hline
% 0000\,0010 & 2 &	+2 &	+2	 &	+2	&	-126		\\%\hline
% \multicolumn{5}{c}{...}\\
% 0111\,1110 & 126 &	+126 &	+126	 &	+126	&	-2		\\%\hline
% 0111\,1111 & 127 &	+127 &	+127	 &	+127	&	-1		\\\hline
% 1000\,0000 & 128 &	-128 &	-127	&	-0	&	0		\\%\hline
% 1000\,0001 & 129 &	-127 &	-126	&	-1	&	+1		\\%\hline
% 1000\,0010 & 130 &	-126 &	-125	&	-2	&	+2		\\%\hline
% \multicolumn{5}{c}{...}\\
% 1111\,1110 & 254 &	-2 &	-1	&	-126	&	+126		\\%\hline
% 1111\,1111 & 255 &	-1 &	-0	&	-127	&	+127		\\\hline
% \end{tabularx}

\renewcommand\theadfont{\bfseries\small}
\newcommand{\tdhead}[1]{\multicolumn{1}{c}{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}
\begin{tabularx}{1\linewidth}{rrc|R<{\hspace{1em}\strut}RR}
% \hline
\multicolumn{3}{c|}{ \theadlong{Двоичный код~$u$}} & \multicolumn{3}{c}{ \theadlong{Декодированное значение~$x$}}  \\\hline
$u_{10}$&$u_{16}$&$u_{2}$
				& \tdhead{Величина\\со знаком}
					& \tdhead{Код \\с~избытком~128}
& %\multicolumn{1}{c}
\tdhead{Дополнительный код\\(дополнение до 2)} 	\\\hline
 $0$   &	\hex{00}	&$0000\,0000$ &	$+0$ 	&	$-128$	&	$0$		\\%\hline
 $1$   &	\hex{01}	&$0000\,0001$ &	$+1$	&	$-127$	&	$+1$		\\%\hline
 $2$   &	\hex{02}	&$0000\,0010$ &	$+2$	&	$-126$	&	$+2$		\\%\hline
$\ldots$&	$\ldots$	&$\ldots$     &	$\ldots$&	$\ldots$&	$\ldots$	\\
 $125$ &	\hex{7D}	&$0111\,1101$ &	$+125$	&	$-3$	&	$+125$		\\%\hline
 $126$ &	\hex{7E}	&$0111\,1110$ &	$+126$	&	$-2$	&	$+126$		\\%\hline
 $127$ &	\hex{7F}	&$0111\,1111$ &	$+127$	&	$-1$	&	$+127$		\\\hline
 $128$ &	\hex{80}	&$1000\,0000$ &	$-0$	&	$0$	&	$-128$		\\%\hline
 $129$ &	\hex{81}	&$1000\,0001$ &	$-1$	&	$+1$	&	$-127$		\\%\hline
 $130$ &	\hex{82}	&$1000\,0010$ &	$-2$	&	$+2$	&	$-126$		\\%\hline
$\ldots$&	$\ldots$	&$\ldots$     &	$\ldots$&	$\ldots$&	$\ldots$	\\
 $253$ &	\hex{FD}	&$1111\,1101$ &	$-125$	&	$+125$	&	$-3$		\\%\hline
 $254$ &	\hex{FE}	&$1111\,1110$ &	$-126$	&	$+126$	&	$-2$		\\%\hline
 $255$ &	\hex{FF}	&$1111\,1111$ &	$-127$	&	$+127$	&	$-1$		\\\hline
\end{tabularx}

\endgroup
\end{table}


К~представлению знаковых чисел можно сформулировать следующие пожелания:
\begin{itemize}
\item код должен позволять представить 
с~помощью $N$ битов
% числа в~диапазоне около $-\frac{N}{2}$ до  $+\frac{N}{2}$;
все целые числа некоторого диапазона %$\nu_1 \leqslant x \leqslant \nu_2$.
$x \in [\nu_1, \nu_2]$.
Представимый диапазон $[\nu_1, \nu_2]$ должен включать ноль и~примерно равное количество положительных и~отрицательных чисел;

\item представление неотрицательных чисел должно совпадать с~их натуральным двоичным кодом;
\item сложение и~вычитание должно выполняться с~помощью того же сумматора, что и~сложение и~вычитание неотрицательных чисел.
% (во многих ранних ЭВМ не было  команд умножения и~деления).
\end{itemize}

\subsection{Величина со знаком}
Наиболее очевидный способ "--- выделить один бит (обычно старший) для хранения знака, а~в~оставшихся хранить абсолютную величину (модуль) числа (столбец «Величина со~знаком» таблицы~\ref{tab:digits-neg-code}).
Такой код легко читается человеком и~для неотрицательных чисел совпадает с~натуральным,
но сложение таких чисел потребует большого числа дополнительных действий (в~случае слагаемых одного знака модули будут складываться, для разных знаков "--- вычитаться).

Кроме того, данный код включает два нуля: $+0$, совпадающий с~беззнаковым нулём, и~$-0$ "--- с~единичным знаковым битом и~нулевым модулем.

\subsection{Код с~избытком}

Также можно задать некоторую константу $\xi$ и~поставить в~соответствие числу $x$ значение $x+\xi$.
% Натуральный код  $x+\xi$ для $x$ будет называться кодом с~избытком $\xi$.
После этого к~полученному значению $x+\xi$ применяется беззнаковое кодирование.
Соответственно,
\begin{equation}
\label{eq:digits-codes-izb}
x = u -\xi,
\end{equation}
где $u$ "--- код, $x$ "--- закодированное значение.

Подобный код позволяет представить числа в~диапазоне $\left[-\xi, 2^{N}-\xi-1 \right]$
и~называется кодом с~избытком~$\xi$.
В~частности, запись года двумя цифрами "--- код с~избытком~$\xi=-2000$.

В~пятом столбце таблицы~\ref{tab:digits-neg-code} показан код с~избытком~$128$.

В~данном коде присутствует только один ноль, но его код не равен $0000\,0000$; %беззнаковому нулю
кроме того, положительные числа кодируются не натуральным кодом.

Для сложения и~вычитания чисел, представленных в~коде с~избытком, можно воспользоваться беззнаковым сумматором, но понадобится коррекция полученного результата.
В~частности, сложение двух чисел с~избытком  $\xi$ даст результат с~избытком $2\xi$, так что необходимо вычесть $\xi$.
Таким образом, сложение или вычитание таких чисел требует двух операций сложения/вычитания.

В~настоящее время представление в~виде величины со знаком или кода с~избытком %практически 
не используется для внутреннего представления в~вычислительных системах; 
тем не менее, обе эти идеи используются для представления вещественных чисел.

Также кодирование с~избытком используется в~специальной аппаратуре или для передачи данных по каналам связи, если диапазон данных невелик, но заведомо несимметричен относительно нуля
(в~частности, год или температура в~помещении в~градусах Цельсия).


\subsection{Дополнительный код}

% И~наконец, можно для положительных чисел использовать натуральный двоичный код, а~отрицательные значения $-x$  закодировать как результат вычитания $0-x$, то есть, с~учётом цикличности сложения и~вычитания в~ЭВМ, как $2^N - x$.
% 
% Сложение и~вычитание знаковых чисел в~дополнительном коде выполняется беззнаковым сумматором за один шаг.


Для того, чтобы записывать ноль и~положительное число $x$ натуральным двоичным (прямым) кодом и~при этом иметь возможность %складывать и~вычитать
пользоваться для знаковых чисел беззнаковым сумматором без коррекции результата, 
необходимо записывать отрицательное число $-x$ тем кодом, который получается в~результате беззнакового вычитания $0-x$ (с~учётом цикличности сложения и~вычитания в~ЭВМ беззнаковое представление этого кода $2^N - x$).
% \begin{equation}
% \label{eq:digits-codes-dop}
% decode_s(\hi) = 
% \left\{
% \begin{array}{ll}
% x, & x < 2^N - x\\
% 0-x, & \\
% \end{array}
% \right.
% \end{equation}

Такой код называется дополнительным (или дополнением до двух) и~представлен в~последнем столбце таблицы~\ref{tab:digits-neg-code}.
В~таблице видно, что 
с~помощью восьми двоичных разрядов можно представить
\begin{itemize}
\item одно значение нуля ($0 = -0 = 0000\,0000$);
\item положительные значения от~$1$ до~$127$, представленные в~натуральном двоичном коде,
% , с~нулевым старшим битом;
которым соответствуют коды от~$0000\,0001$ до~$0111\,1111$;
\item соответствующие им отрицательные значения от~$-1$ до~$-127$
% с~единичным старшим битом.
% Таким образом, старший бит нуля и~положительных чисел равен нулю, старший бит отрицательных чисел "--- единице.
% \item код $128$,
"--- коды от~$1111\,1111$ ($0-1$) до~$1000\,0001$ ($0-127$);
\end{itemize}
Старший бит называется знаковым, так как у~нуля и~положительных чисел он равен нулю, у~отрицательных "--- единице.
Соответственно, код $1000\,0000$, который можно в~принципе трактовать и~как~$128$, и~как~$0-128=-128$, считается кодом отрицательного числа $-128$.

% восьмиразрядные коды можно интерпретировать следующим образом:
% \begin{itemize}
% \item одно значение нуля ($0 = -0 = 0000\,0000$);
% \item положительные значения от~$1$ до~$127$, представленные в~натуральном двоичном коде;
% % , с~нулевым старшим битом;
% "--- коды от~$0000\,0001$ до~$0111\,1111$
% \item соответствующие им отрицательные значения от~$-1$ до~$-127$;
% % с~единичным старшим битом.
% % Таким образом, старший бит нуля и~положительных чисел равен нулю, старший бит отрицательных чисел "--- единице.
% % \item код $128$,
% \end{itemize}

Таким образом, дополнительный код позволяет представить с~помощью~$N$ разрядов целые числа в~диапазоне~$\left[-2^{N-1}, 2^{N-1}-1\right]$.

Дополнительный код неотрицательных чисел совпадает с~прямым (натуральным).

Для перевода отрицательного числа $-x$ на практике используется %не вычитание $0-x = 2^N-x$, а~
следующая схема.
Преобразуем $0-x$ с~учётом ассоциативности и~коммутативности циклического вычитания:
\begin{equation}
-x = 0-x = (-1 - x) +1.
\end{equation}
С~учётом того, что дополнительный код $-1$ состоит из единиц во всех разрядах, $-1 - x$ "--- это инверсия всех битов $x$.
Соответственно, дополнительный код $-x$ может быть рассчитан как $\lnot x+1$, где $\lnot x$ "--- побитовое отрицание (инверсия битов) натурального двоичного представления абсолютной величины числа  $x$.


Именно в~дополнительном коде представлены отрицательные числа в~современных вычислительных системах.
При этом нет способа, анализируя двоичный код, в~частности, $1111\,1111$, понять, кодирует ли он беззнаковое число~$255$ или знаковое~$-1$ (или и~вовсе %является частью 
что-то иное).
Программист должен сам помнить, что именно было записано в~данную ячейку, и~применять соответствующие команды для обработки и~вывода.
При программировании на %типизированном 
языке высокого уровня (в~частности, C++) данную информацию хранит компилятор, но %программист может преобразовать
при присваивании переменных различного типа значения могут интерпретироваться по-разному.


\subsection{Знаковая арифметика}

Дополнительный код построен таким образом, что операции с~беззнаковым переполнением получают смысл.

В~частности, примеры~\eqref{eq:digits-binadd-ff+1} и~\eqref{eq:digits-binadd-ff+ff} являются корректными операциями сложения, если рассматривать операнды и~результат как знаковые:
\begin{equation}
\label{eq:digits-binadd-ff+1-dop}
\begin{array}{r@{\hspace{2em}}rcl}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 & & & & & & & &1\\[\rulerowsep]
 &0&0&0&0&0&0&0&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
&
% \left(
% \begin{tikzlongsum}
% {
% \\
% -&1\\
% +&1\\[\rulerowsep]
%  &0\\
% };
% \node[left = of m-2-1.south west] {$+$};
% \end{tikzlongsum}
% \right)
% \left(
-1_{10} + 1_{10} &=& 0_{10}
% \right)
\\
% \end{equation}
% \begin{equation}
% \label{eq:digits-binadd-ff+ff}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 &1&1&1&1&1&1&1&1\\[\rulerowsep]
 &1&1&1&1&1&1&1&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
&
% (
-1_{10} + (-1_{10}) &=& -2_{10}
% )
\end{array}
\end{equation}
Корректными станут и~операции вычитания большего числа из меньшего в~\eqref{eq:digits-binadd-a-b-neg} и~\eqref{eq:digits-binadd-0-1}:
\begin{equation}
\label{eq:digits-binadd-a-b-neg-dop}
\begin{array}{r@{\hspace{2em}}rcl}
\begin{tikzlongsum}
{
\centerdot&\centerdot
 & & & &\centerdot&\centerdot& & \\
 &0&0&0&0&1&0&0&1\\
 &0&1&0&0&0&0&1&1\\[\rulerowsep]
 &1&1&0&0&0&1&1&0\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
&
9_{10} - 67_{10} &=& -58_{10}
\\
\begin{tikzlongsum}
{
\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot& \\
 &0&0&0&0&0&0&0&0\\
 & & & & & & & &1\\[\rulerowsep]
 &1&1&1&1&1&1&1&1\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
&
0_{10} - 1_{10} &=& -1_{10}
\end{array}
\end{equation}
Операции~\eqref{eq:digits-binadd-a+b} и~\eqref{eq:digits-binadd-a-b}, где и~операнды, и~результат неотрицательны и~не превышают~$127_{10}$,
корректны и~при знаковой, и~при беззнаковой трактовке.

Если беззнаковая операция корректна (переполнения не было), но результат превышает максимально возможное знаковое положительное число (для восьми бит~$127_{10}$), то при знаковой интерпретации результат перестаёт быть правильным.
Например, в~\eqref{eq:digits-binadd-a+b-9E}
\begin{equation}
\label{eq:digits-binadd-a+b-9E-dop-err}
\begin{tikzlongsum}
{
1& & & & &1&1& \\
0&1&0&1&0&0&1&1\\
0&1&0&0&1&0&1&1\\[\rulerowsep]
1&0&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
83_{10} + 75_{10} = -98_{10}
\end{equation}
В~\eqref{eq:digits-binadd-a+b-9E-dop-err}, в~отличие от~\eqref{eq:digits-binadd-ff+1-dop} и~\eqref{eq:digits-binadd-a-b-neg-dop}, есть перенос в~старший (знаковый) разряд, но нет переноса из него в~несуществующий девятый разряд.
Возможна ситуация, когда, наоборот, сумма двух отрицательных чисел имеет ноль в~знаковом разряде:
\begin{equation}
\label{eq:digits-binadd-a+b-0-dop-err}
\begin{tikzlongsum}
{
1& & & & & &1&1& \\
 &1&0&0&1&0&0&1&1\\
 &1&1&0&0&1&0&1&1\\[\rulerowsep]
 &0&1&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
-109_{10} + (-53_{10}) = +94_{10}
\end{equation}
Здесь не было переноса в~знаковый разряд, но есть перенос из него.

Подобная ситуация называется \termin{знаковым переполнением.}

Таким образом, сложение и~вычитание знаковых чисел, представленных в~дополнительном коде, может выполняться таким же образом, как и~беззнаковых чисел.
При этом для проверки корректности результата %не имеет смысла 
нужно анализировать не перенос/заём в~несуществующий разряд (флаг переноса~$CF$),
а~знаковое переполнение "--- комбинацию переноса/заёма в~знаковый разряд и~переноса/заёма из знакового разряда в~несуществующий.

Наличие знакового переполнения также отражается специальным флагом "--- флагом переполнения ($OF$, Overflow flag).

Соответственно, команды сложения и~вычитания не разделяются на знаковые и~беззнаковые.
По~результатам выполнения 
устанавливается значение как флага переноса (беззнакового переполнения),
так и~флага знакового переполнения.



% Как правило
% Команды сложения и~вычитания
% процессоров семейства x86, 

Умножение отрицательных чисел по беззнаковой схеме, показанное, в~частности, в~\eqref{eq:digits-binmul-ffxff}, явно некорректно "--- результат получается также отрицательным.
Это связано с~тем, что при сложении частичных произведений
% смещённых произведений первого множителя на одну цифру второго 
подразумевалось, что пустые ячейки "--- это пропущенные незначащие нули.
Но ведущий ноль в~дополнительном коде обозначает положительное число, поэтому во~всех пустых ячейках необходимо разместить {единицы:}
\begin{equation}
\label{eq:digits-binmul-ffxff-dop}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, row 3/.style={nodes={arythm-carry}}]
{
\ldots&[0.5ex]1&1&1&1&[0.5ex]1&1&1&1&[0.5ex]1&1&1&1\\
\ldots&1&1&1&1&1&1&1&1&1&1&1&1\\[\rulerowsep]
&\mathrm{A}&9&8&7&6&5&4&3&2&1& & \\
\ldots&1&1&1&1&1&1&1&1&1&1&1&1\\
\ldots&1&1&1&1&1&1&1&1&1&1&1& \\
\ldots&1&1&1&1&1&1&1&1&1&1& & \\
\ldots&1&1&1&1&1&1&1&1&1& & & \\
\ldots&1&1&1&1&1&1&1&1& & & & \\
\ldots&1&1&1&1&1&1&1& & & & & \\
\ldots&1&1&1&1&1&1& & & & & & \\
\ldots&1&1&1&1&1& & & & & & & \\
\ldots&1&1&1&1& & & & & & & & \\
\ldots&1&1&1& & & & & & & & & \\
\ldots&1&1& & & & & & & & & & \\
\ldots&1& & & & & & & & & & & \\[\rulerowsep]
\ldots&0&0&0&0&0&0&0&0&0&0&0&1\\
};
\drawrulerow{2}
\drawrulerow{15}

\node[left = of m-1-1.south west] {$\times$};
\end{tikzpicture}
~~~~
(-1_{10}) \cdot (-1_{10}) = 1_{10}
\end{equation}
Таким образом, %в~тех вычислительных системах, где
знаковое и~беззнаковое умножение (и,~соответственно, деление)
осуществляется разными командами.



\section{Битовые операции}
\epigraph{\begin{limerick}
Жил один долгожитель в Пергаме,\\
Он Гомера читал вверх ногами.\\
До того дочитался,\\
Что ослаб, зашатался\\
И свалился с утёса в Пергаме.\\
\end{limerick}
}
{\Lear}

Битовые операции "--- операции, производимые над цепочками битов.

Существует три основных класса битовых операций:
\begin{itemize}
\item поразрядные операции (not, and, or, xor);
% \item Арифметические.
\item операции расширения (увеличения разрядности);

\item сдвиги.

\end{itemize}

\subsection{Поразрядные операции}

Поразрядные операции применяются к~каждому разряду операнда (для унарных операций)
или к~каждой паре соответствующих разрядов операндов (для бинарных операций)
независимо от соседних разрядов.
% Результат 
% и~не влияет на соседние

Так как один двоичный разряд может принимать только два значения,
которые можно трактовать как «ложь» и~«истина»,
набор поразрядных операций обычно включает все логические операции (таблица~\ref{tab:digits-bit-logic}).

\begin{table}[!ht]
\caption{Логические операции над разрядами}
\label{tab:digits-bit-logic}

\newcolumntype{Y}{>{$}C<{$}}
\newcolumntype{y}{>{$}c<{$}}
% \newcolumntype{Z}{>{\columncolor{csMarker}}Y}
\begin{tabularx}{1\linewidth}{yy|Y|YYY}
~~a~~ 	&	~~b~~ 	&	\lnot a ~(\NOT, !)	& a \land b ~(\AND, {\And\!\!})& a \lor b ~(\OR, |) & a \oplus b ~(\XOR, \Xor)\\\hline
0 	&	0 	&\multirow{2}{*}{$1$}	&0         	&	0         &	0\\
0 	&	1 	&			&0         	&	1         &	1\\\hline
1 	&	0 	&\multirow{2}{*}{$0$}	&0         	&	1         &	1\\
1 	&	1 	&			&1         	&	1         &	0\\\hline
\end{tabularx}
\end{table}

Для поразрядных операций применяются различные обозначения, наиболее популярные из них показаны в~шапке таблицы~\ref{tab:digits-bit-logic}.
В~последующих примерах используются обозначения, принятые в~языке C++ ($\Not, \And\!\!, \Or, \Xor$).

% Значения разрядов~$0$ и~$1$ трактуются соответственно как «ложь» и~«истина».
% Операции применяются к~
Результат в~каждом разряде рассчитывается независимо от соседних (отсутствует перенос между разрядами).
Разрядность результата соответствует разрядности операндов, для бинарных операций разрядность обоих операндов должна быть одинаковой.
% 
Поразрядные операции не могут быть знаковыми или беззнаковыми:
обработка старшего бита не отличается от остальных.

Таким образом, поразрядное отрицание (битовая инверсия, дополнение до единицы) "--- это унарная операция, где к~каждому разряду единственного операнда применяется логическое отрицание:
\begin{equation}
\Not 2_{10} = \Not 0000\,0010 = 1111\,1101
\end{equation}
Полученное значение можно трактовать как $-3_{10}$, если интерпретировать результат как знаковый,
либо как $253_{10}$, если интерпретировать его как беззнаковый.
Ни одно из этих двух значений здесь не будет «правильным» или «ошибочным».

При этом необходимо помнить, что если операнд $2_{10}$ имеет б\'{о}льшую разрядность (и, соответственно, включает больше ведущих нулей), 
то и~результат будет содержать больше ведущих единиц.
Соответственно, в~случае разрядности~$N$ значение $\Not 2_{10}$ в~знаковой интерпретации будет иметь значение~$-3_{10}$,
а~в~беззнаковой "--- $(2^N-3)_{10}$.


Поразрядное «и» (конъюнкция) "--- бинарная операция, к~каждой паре разрядов операндов применяется логическое «и»:
\begin{equation}
3_{10} \And 5_{10} = 0000\,0011 \And 0000\,0101 = 0000\,0001 = 1_{10}
\end{equation}
разряд результата равен нулю, если хотя бы один операнд содержит ноль в~соответствующем разряде.


Поразрядное «или» (дизъюнкция) "--- бинарная операция, к~каждой паре разрядов операндов применяется логическое «или»:
\begin{equation}
3_{10} \Or 5_{10} = 0000\,0011 \Or 0000\,0101 = 0000\,0111 = 7_{10}
\end{equation}
разряд результата равен единице, если хотя бы один операнд содержит единицу в~соответствующем разряде.

Поразрядное исключающее «или» (также называется сложением по модулю два, но, в~отличие от арифметической операции сложения, нет переноса между разрядами) "--- бинарная операция, к~каждой паре разрядов операндов применяется исключающее «или»:
\begin{equation}
3_{10} \Xor 5_{10} = 0000\,0011 \Xor 0000\,0101 = 1111\,0110 = -10_{10} = 246_{10}
\end{equation}
разряд результата равен единице, если один и~только один операнд содержит единицу в~соответствующем разряде.
% разряд результата равен нулю, если в~соответствующих разрядах операндов содержатся два нуля или две единицы.

Так как для одного разряда $\forall b \in \{0, 1\}:~ 1 \oplus b = \lnot b$, для чисел любой разрядности верно $\forall x:~ (-1) \Xor x = \Not x$.

\subsection{Расширение целых чисел}

Часто необходимо увеличить разрядность числа, сохранив его значение.
В~C++ подобное происходит, в~частности, при присваивании переменных разного размера:
\begin{lstlisting}
int i;
short int s = -1;
i = s;
\end{lstlisting}

Операция увеличения разрядности называется расширением $n$-разрядного числа $x$ до $m$ разрядов ($m>n$).

Младшие $n$ разрядов результата совпадают с~расширяемым значением~$x$, 
старшие $m-n$ должны быть как-то инициализированы.

Существует две операции расширения, по-разному инициализирующие расширяемую часть:
\begin{itemize}
\item беззнаковое расширение "--- расширяемая часть заполняется нулями (такая операция сохраняет значение беззнаковой интерпретации~$x$);

\item знаковое расширение "--- расширяемая часть заполняется значением знакового бита (сохраняет значение знаковой интерпретации~$x$).

\end{itemize}

В~таблице~\ref{tab:digits-extend-signed-unsigned} показаны примеры знакового и~беззнакового расширения восьмибитных чисел до шестнадцати бит.

\begin{table}[!ht]

% \newcommand{\extendSigned}{Знаковое расширение~$x$ до 16 бит}
% \newcommand{\extendUnsigned}{Беззнаковое расширение~$x$ до 16 бит}
% \newcommand{\extendSigned}{$x \xrightarrow[\text{знаковое}]{} 16$ бит}
% \newcommand{\extendUnsigned}{$x \xrightarrow[\text{беззнаковое}]{} 16$ бит}
\newcommand{\extendSigned}{$x \xrightarrow{\text{знаковое}} 16$ бит}
\newcommand{\extendUnsigned}{$x \xrightarrow{\text{беззнаковое}} 16$ бит}
 

\caption{Знаковое и~беззнаковое расширение}
\label{tab:digits-extend-signed-unsigned}

\begin{tabularx}{1\linewidth}{r|rRRR}
Значение	&	$bin$				&	$hex$		&	$dec_\text{знак}$	&	$dec_\text{беззн}$	\\\hline
$x$ (8 бит)	&	$0000\,0000$			&	\hex{00}	&	$0$	&	$0$	\\
\extendUnsigned	&	$0000\,0000\,0000\,0000$	&	\hex{0000}	&	$0$	&	$0$	\\
\extendSigned	&	$0000\,0000\,0000\,0000$	&	\hex{0000}	&	$0$	&	$0$	\\\hline

$x$ (8 бит)	&	$0000\,0001$			&	\hex{01}	&	$1$	&	$1$	\\
\extendUnsigned	&	$0000\,0000\,0000\,0001$	&	\hex{0001}	&	$1$	&	$1$	\\
\extendSigned	&	$0000\,0000\,0000\,0001$	&	\hex{0001}	&	$1$	&	$1$	\\\hline

$x$ (8 бит)	&	$0000\,1111$			&	\hex{0F}	&	$15$	&	$15$	\\
\extendUnsigned	&	$0000\,0000\,0000\,1111$	&	\hex{000F}	&	$15$	&	$15$	\\
\extendSigned	&	$0000\,0000\,0000\,1111$	&	\hex{000F}	&	$15$	&	$15$	\\\hline

$x$ (8 бит)	&	$1000\,0000$			&	\hex{80}	&	$-128$	&	$128$	\\
\extendUnsigned	&	$0000\,0000\,1000\,0000$	&	\hex{0080}	&	$128$	&	$128$	\\
\extendSigned	&	$1111\,1111\,1000\,0000$	&	\hex{FF80}	&	$-128$	&	$65\,408$	\\\hline

$x$ (8 бит)	&	$1111\,1111$			&	\hex{FF}	&	$-1$	&	$255$	\\
\extendUnsigned	&	$0000\,0000\,1111\,1111$	&	\hex{00FF}	&	$255$	&	$255$	\\
\extendSigned	&	$1111\,1111\,1111\,1111$	&	\hex{FFFF}	&	$-1$	&	$65\,535$	\\\hline

\end{tabularx}

\end{table}

Каждая строка таблицы соответствует одному значению (цепочке битов).
Во втором столбце показано его двоичное представление,
в~третьем "--- шестнадцатеричное,
в~четвёртом "--- десятичное представление его знаковой интерпретации,
в~пятом "--- десятичное представление беззнаковой интерпретации.


Видно, что для неотрицательных чисел знаковое и~беззнаковое расширение выполняется одинаково.

\subsection{Битовые сдвиги}

\begin{tabularx}{1\linewidth}{@{}ccL@{}}
\includegraphics[height=0.25\linewidth,valign=c]{shr}&
\includegraphics[height=0.25\linewidth,valign=c]{sar}&
Деление на 2 с~остатком
\end{tabularx}


\hfill
\begin{tabular}{@{}cl@{}}
\includegraphics[height=0.25\linewidth,valign=c]{shl-sal}&
Умножение на 2
\end{tabular}








\subsection{Циклические сдвиги}
% \subsubsection{Логический сдвиг влево}
\renewcommand{\tabularxcolumn}[1]{m{#1}}

\begin{tabularx}{1\linewidth}{@{}cL@{}}
\includegraphics[height=0.25\linewidth,valign=c]{ror-rol}&
Простой циклический сдвиг
\end{tabularx}

\begin{tabularx}{1\linewidth}{@{}cL@{}}
\includegraphics[height=0.25\linewidth,valign=c]{rcr-rcl}&
Циклический сдвиг через флаг переноса
\end{tabularx}



% % % \section{Знаковая арифметика в~вычислительных системах} 




\section{Представление вещественных чисел} 
\epigraph{
$i$. Be rational!

$\pi$. Get real!
}{\MathFolk}


идея, перевод целой и~дробной частей, вещественные с~фиксированной запятой, с~плавающей, мантисса и~порядок
\index{Представление данных!вещественных!с~фиксированной запятой}
\index{Представление данных!вещественных!с~плавающей запятой}


$$
x = (-1)^{\sigma} \cdot 2^{\epsilon} \cdot \mu
$$

\index{Представление данных!вещественных!расширенной точности}
\index{Представление данных!вещественных!двойной точности}
\index{Представление данных!вещественных!одинарной точности}

Вещественные числа, согласно стандарту двоичной арифметики с~плавающей точкой IEEE 754~\cite{ieeeFloat1985rus, ieeeFloat2008},
представляются в~виде знака, экспоненты (порядка) и~мантиссы
(рис.~\ref{ris:ieee754_1}).


% Это представление основано на двоичной экспоненциальной форме вещественного числа $F$, то есть:
Число $F$ представляется в~двоичной экспоненциальной форме "--- в~виде произведения трёх компонент:
\begin{itemize}
\item знак ($+1$ или $-1$);
\item двойка в~некоторой степени~$\epsilon$, называемой \emph{порядком}, или экспонентой; %(порядок "--- зна);
% (для записи очень маленьких чисел порядок должен быть отрицательным);
\item \emph{мантиссы $\mu$} "--- двоичной дроби $1 \leqslant \mu <2$, то есть $\mu = 1,\beta_1\beta_2\beta_3\ldots\beta_n$, где $\beta_i$ "--- двоичный разряд.
\end{itemize}
$$
F = (-1)^{\sigma} \cdot 2^{\epsilon} \cdot \mu
% \big( 1,\beta_1\beta_2\beta_3\ldots\beta_n \big)
$$
В~такой форме можно представить любое конечное число, кроме нуля.

Старший бит (S) "--- бит знака, если $S=0$ "--- число положительное, если $S=1$ "--- число отрицательное.
Следующие $b$ бит отводятся под  порядок, смещённый на $2^{b-1} - 1$ (то есть 
знаковое значение порядка представляется не дополнительным кодом, а~кодом с~избытком:
% для отр
порядок~$0$ представляется числом $2^{b-1} - 1$,
% отрицательные порядки представляются малыми беззнаковыми числами
порядок~$-2^{b-1}+1$ "--- нулём%
).
% S - бит знака, если S=0 - положительное число; S=1 - отрицательное число
% E - смещенная экспонента двоичного числа;
% exp2 = E - (2(b-1) - 1) - экспонента двоичного нормализованного числа с плавающей точкой
% (2(b-1) -1) - заданное смещение экспоненты (в 32-битном ieee754 оно равно +127 см.выше)
Оставшиеся $n$ бит кодируют $M$ остаток мантиссы двоичного нормализованного числа с плавающей точкой (мантиссу без ведущей единицы).

Таким образом, значение вещественного числа (рис.~\ref{ris:ieee754_1}) для всех комбинаций битов, кроме исключительных (таблица~\ref{tab:ieee754-singular})   вычисляется по формуле:
\begin{illustration}
\includegraphics[width=\approvedImageWidth]{ieee754_1}
\caption{Представление числа в формате IEEE 754}
\label{ris:ieee754_1}
\end{illustration}
$$
F = (-1)^S \cdot 2^{E - 2^{b-1} + 1} \cdot \left( 1 + \dfrac{M}{2^n}\right)
$$

\begin{table}

\caption{Исключительные значения представления IEEE 754}
\label{tab:ieee754-singular}
\begin{tabular}%{l>{$}l<{$}}
{ll}
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+0} & $+0$\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-0} & $-0$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754den} & денормализованные числа \\
\\\hline
\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+inf} & $+\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-inf} & $-\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754nan} & $NaN$ (нечисла) \\
\end{tabular}
\end{table}

% Денормализованные числа. Это числа, мантиссы которых лежат в диапазоне 0.1 <= M <1.

Денормализованные числа находятся ближе к нулю, чем наименьшие по модулю нормализованные. 
% Их мантиссы (при минимально возможном по)
% 
% Денормализованные числа как бы разбивают минимальный разряд нормализованного числа на некоторое подмножество. Сделано так потому, что в технической практике чаще встречаются величины близкие к нулю. 

Стандарт %двоичной арифметики с~плавающей точкой
IEEE 754-2008 описывает
%  \begin{itemize}
% \item 
три двоичных вещественных формата разрядностью 32, 64, и 128 бита. %;
% \item два двоично-десятичных формата "--- 64 и~128 бита.
% \end{itemize}
% 
Более старый вариант этого стандарта    IEEE 754-1985 определяет также формат с~двойной расширенной точностью (double-extended precision) $\geqslant$ 79 бит. % (обычно используют 80 бит).

\begin{illustration}
\includegraphics[width=\wideImageWidth]{ieee754_32}\\
a)\\

\includegraphics[width=\wideImageWidth]{ieee754_64}\\
б)
\caption{Формат чисел а) одинарной (single-precision, 32 бита)  и~б) двойной точности (double-precision, 64 бита)}
\label{ris:ieee754_32}
\end{illustration}





\nsection{Контрольные вопросы}

\begin{enumerate}
% \item Какие вы знаете единицы измерения информации?

\item Какие способы представления беззнаковых чисел используются в~ЭВМ?
\item Какие способы представления знаковых чисел используются в~ЭВМ?
\item Какие логические и~битовые операции вы~знаете?

% \item Какие способы представления вещественных чисел используются в~ЭВМ?
\end{enumerate}
