\tikzstyle{arythm-picture} = [baseline, outer xsep = 0ex, inner xsep = 0.1ex, node distance = 0ex]
\tikzstyle{arythm-node} = [outer sep=0ex, inner xsep=0ex, inner ysep=0.4ex, minimum width = \digitwidth, text height=\heightof{0}, text depth=\depthof{0}]
\tikzstyle{arythm-matrix} = [matrix of math nodes, nodes in empty cells,
%     row sep=-\pgflinewidth, column sep=-\pgflinewidth, %нужно, чтобы не удваивалась обводка
    nodes={arythm-node},
%     row 1/.style={nodes={scale=0.5}}, %row 3/.style={bottomrule}
%     row 4/.style={inner ysep=0.5ex}
]
\tikzstyle{arythm-carry} = [scale=0.5]

\newlength{\rulerowsep}
\setlength{\rulerowsep}{0.4ex}

\newcommand{\drawrulerow}[2][1]
{
  \tikzmath{int \ytopcell, \ybottomcell, \xstartcell;
    \ytopcell=#2; \ybottomcell=\ytopcell + 1; \xstartcell = #1;
    let \topcell = m-\ytopcell-\xstartcell;
    let \bottomcell = m-\ybottomcell-\xstartcell;
    };
  \coordinate (lineleft) at ($0.6*(\topcell.south west)+0.4*(\bottomcell.north west)$); %(m-3-1.south west);
  \draw (lineleft) -- (lineleft-|m.east);
}

% \newcommand{\longAdd}[1]
% {
% }

\newenvironment{tikzlongsum}
{
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, row 1/.style={nodes={arythm-carry}}, %row 4/.style={nodes={outer ysep=\rulerowsep}}
  ]
}
{
% \coordinate (lineleft) at ($0.6*(m-3-1.south west)+0.4*(m-4-1.north west)$); %(m-3-1.south west);
% \draw (lineleft) -- (lineleft-|m.east);
\drawrulerow{3}
\end{tikzpicture}
}


\newcommand{\drawclinerow}[3][1]
{
  \tikzmath{int \ytopcell, \ybottomcell, \xstartcell, \xendcell;
    \ytopcell=#1; \ybottomcell=\ytopcell + 1; 
    \xstartcell = #2;
    \xendcell = #3;
    let \topcellstart = m-\ytopcell-\xstartcell;
    let \bottomcellstart = m-\ybottomcell-\xstartcell;
    let \topcellend = m-\ytopcell-\xendcell;
    let \bottomcellend = m-\ybottomcell-\xendcell;
    };
  \draw ($0.6*(\topcellstart.south west)+0.4*(\bottomcellstart.north west)$)
     -- ($0.6*(\topcellend.south east)+0.4*(\bottomcellend.north east)$);
}



\chapter{Представление данных}
\epigraph{
\begin{stanza}[0mm]
А~для низкой жизни были числа,\\
Как домашний, подъярёмный скот,\\
Потому, что все оттенки смысла\\
Умное число передаёт.\\
\end{stanza}
}{Н.\,C.\,Гумилёв}

Пифагорейцы в~VI--IV веках до н.\,э. считали числа первоосновой мира.
В~настоящее время этот принцип воплощается на практике "--- всё больше информации переходит в~цифровой формат, то есть описывается при помощи чисел.
Числа же в~свою очередь представляются в~вычислительных системах при помощи специальных кодов в~виде набора нулей  и~единиц.

\section{Качественные и~количественные данные} 
\index{Данные!качественные}
\epigraph{
Всё  познаваемое  имеет  число.  Ибо  без  него  невозможно  ничего  ни  понять,  ни  познать.
}{Филолай}
\addquestion{Чем различаются качественные и~количественные данные?}

% таблицы, числа

% http://producm.ru/books/books_statistic/book16/p4/
% Статистические методы – это методы анализа данных, причём обычно достаточно большого количества данных. Статистические данные могут иметь различную природу.Исторически самыми ранними были два вида данных – сведения о числе объектов, удовлетворяющих тем или иным условиям, и числовые результаты измерений.

% Две основные категории используемых на практике данных "---
Данные делятся на две основные группы "---
% качественные и~количественные 
количественные и~качественные.
% данные.
% 
% Количественные данные называются так потому, что представляют собой, как правило, информацию,
% \termin{Количественные} данные 
% "---  записи значений каких-либо величин (элемен­ты мультимедийных данных и~т.\,д.).
К~\termin{количественным} данным относятся в~основном либо сведения о~числе объектов, удовлетворяющих тем или иным условиям, либо числовые результаты измерений.
Для таких данных имеют смысл базовые арифметические действия "--- сложение, вычитание, умножение на число или другую величину подходящей размерности.
Именно для описания количественных данных изначально и~появилось само понятие числа.

% Двум классам количественных данных соответствуют два основных типа чисел.
Для %описания
подсчёта количества объектов (яблок, землекопов и~т.\,д.) используются \termin{натуральные числа:} $1, 2, 3,\ldots$
Множество натуральных чисел $\{1, 2, 3, \ldots\}$ обычно обозначается как~$\Naturalset$.

Ноль не используется при счёте, поэтому не %включается в
считается натуральным числом.
Тем не менее, часто удобно рассматривать множество $\Naturalset \cup \{0\} = \{0, 1, 2, 3, \ldots\}$.
Оно обозначается $\Naturalset_0$.
В~некоторых зарубежных источниках именно $\Naturalset_0$ называется множеством натуральных чисел, но в~отечественной литературе, как и~в~значительной части зарубежной, принято %другое определение.
определение из предыдущего абзаца, не включающее ноль. %~$0$.
Универсальное название элементов $\Naturalset_0$ 
"--- неотрицательные целые числа, также их часто называют \termin{беззнаковыми} целыми числами.

Для описания некоторых величин требуются отрицательные числа ($-1$, $-2$, $-3, \ldots$). Множество, включающее натуральные числа, противоположные им отрицательные и~ноль, называется множеством целых чисел~$\Integerset$. В~противоположность беззнаковым (неотрицательным) величинам те, которые могут принимать как положительные, так и~отрицательные значения, называются \termin{знаковыми.}


Результаты измерений большей части величин (длина, путь, масса, время и~т.\,д.) невозможно представить в~виде целых чисел, знаковых или беззнаковых.
Соответствующие им \termin{вещественные} числа (%$0,5, 0,7, 0,33(3)
в~частности, $\frac{1}{3}, \sqrt{2}, \pi, e%, 2\frac{2}{3}
$) 
образуют множество~$\Realset$.

Числа и, соответственно, количественные данные лучше всего подходят для обработки с~помощью вычислительных систем.
Таким образом, чтобы ввести и~использовать какую-то информацию в~вычислительной системе, эту информацию необходимо представить в~виде числа или набора чисел.

% \termin{Качественные} данные "--- указатели на символы внутри таблиц или на ветви алгоритма (буквы, цифры, ноты, символы шахматных фигур, карточных мастей и~т.\,д.). 

\termin{Качественные} данные представляют собой, как правило, элементы (символы), несравнимые между собой или цепочки (строки) подобных символов.
В~частности, к~качественным данным относятся цвет, %буква, нота
буквы, цифры, ноты, символы шахматных фигур, карточных мастей и~т.\,д.
Множество всех возможных символов называется алфавитом. 

% % http://statistica.ru/glossary/general/poryadkovye-dannye/
% Иногда из качественных данных выделяют порядковые "--- их значения можно упорядочивать, сравнивать друг с~другом, но нельзя складывать, вычитать и~т.\,д.
% Интервал между такими значениями невозможно выразить количественно.
% % Тяжесть состояния больного при поступлении в клинику (тяжёлое, средней тяжести,…) степень ожога (1,2,3 или 4) – пример качественных порядковых признаков.

% Тем не менее, 
Для обработки  с~помощью вычислительных систем качественные данные также необходимо представить в~виде чисел.
% Так как компьютер способен обрабатывать только количественные 
% Порядковым данным 
% Для этого используются кодовые таблицы.
Чтобы сделать это,
% Вначале %из символов алфавита состав
символы качественных данных упорядочиваются, 
затем каждому символу сопоставляется его порядковый номер в~списке "--- код символа, беззнаковое целое число.
Полученное соответствие называется \termin{кодовой таблицей}.

Наиболее известны кодовые таблицы, сопоставляющие коды знакам письменных языков "--- цифрам, буквам кириллицы, латиницы, знакам препинания и~т.\,д. (чаще всего под термином «символ» подразумевается именно знак письменности).
В~частности, старейшая из принятых в~настоящее время кодовая таблица ASCII (American Standard Code for Interchange of Information) описывает цифры, строчные и~заглавные буквы латиницы, некоторое количество знаков препинания и~специальных символов (так называемые ASCII-символы) и~сопоставляет им коды в~диапазоне от~$0$ до~$127$~\cite{asciitable}.
Все более современные кодовые таблицы, включающие кириллицу и~другие национальные знаки, описывает ASCII-символы этими же кодами.
% Соответствие ASCII-символов ASCII-кодам 

Кодовая таблица ASCII
настолько прочно закрепилась в~информационных технологиях, что такие языки, как C/C++, вообще не делают различия между ASCII-символом и~его кодом: тип $char$ является одновременно и~символьным, и~коротким целым.
При этом представление символов не из таблицы ASCII, в~частности, кириллицы, может быть различным в~разных реализациях.

Сейчас для представления различных национальных алфавитов чаще всего используется кодовая таблица Unicode, сопоставляющая кириллице коды от 1024 до 1279 (обычно коды Unicode записывают в~шестнадцатеричном виде "--- от \hex{0400} до \hex{04FF}).
% На большинстве платформ байт включает восемь бит, то есть не может представлять число, большее 255.
% Таким образом, коды русских букв невозможно представить в~виде одного такого байта.
Для того, чтобы %корректно записать эти  представления 
представление буквы кириллицы в~памяти компьютера не могло совпасть с~представлением последовательности из нескольких ASCII-символов,
используются различные \termin{кодировки} Unicode.
Наиболее распространённая из них "--- UTF-8 "--- записывает  символ в~виде цепочки байтов, включающих, кроме собственно кода, ещё и~служебную информацию.
Соответственно, кириллица, представленная в~UTF-8, занимает диапазон от \hex{D080} до \hex{D19F}, так что кириллические буквы занимают два байта.



\section{История чисел} 

\epigraph{\begin{stanza}
«Этот палец загнём, а~другой отогнём...\\
Что-то плохо сгибается палец;\\
Вижу, выхода нет "--- не сойдётся ответ», "---\\
И~заплакал несчастный страдалец.\\
\end{stanza}}
{\Snark}

% непозиционные СС, позиционные, абак. Модулярная арифметика: Алмаз, троичная арифметика: Сетунь

% http://dic.academic.ru/dic.nsf/ruwiki/4992
\termin{Система счисления} "--- %символический метод записи чисел, 
это
представление чисел с~помощью специальных письменных знаков "--- цифр.

% Старейшее счётное устройство "--- пальца на руках.
Старейшая система представления чисел "--- единичная, когда при счёте каждому объекту сопоставляют
% объекты подсчитывали, загибая по одному пальцу или  
один счётный предмет или символ "--- загибают палец, передвигают бусину чёток, ставят галочку на бумаге или зарубку на доске.
Таким образом, чтобы записать  число $N$, нужно поставить $N$ галочек или зарубок.
Значение счётного предмета или знака при этом не зависит от его положения и~всегда равно единице.
Этот громоздкий способ записи
подходит только для небольших %количеств подсчитываемых предметов.
натуральных чисел.
% чисел.

Для подсчёта большого количества объектов естественно %объединять их в~
разбивать их на
группы одного размера и~подсчитывать уже эти группы.
Размер такой группы называется \termin{основанием} системы счисления.

% Элементы такого представления
% Основание 
Даже в~единичной системе обычно используется группировка по какому-либо основанию.
В~чётках через определённое количество бусин вставляется отличная размером или цветом;
% естественные счётные предметы "--- 
пальцы рук естественным путём сгруппированы по~$5$ и~$10$, фаланги "--- по $12$ (на всех пальцах одной руки, исключая большой), $15$ (включая большой), $24$ (на двух руках, исключая большие пальцы) и~$30$.
% Сейчас, когда количество чего-либо отмечается чёрточками на доске, каждый десяток %или дюжина ($12$) 
% таких черт обычно перечёркивается горизонтальной линией.


Исторически чаще всего использовались основания, равные~$10$ (по числу пальцев на  руках) или $12$ (по числу фаланг пальцев одной руки, кроме большого "--- он используется для указания на текущую фалангу-цифру).
Системы счисления с~такими основаниями называются соответственно десятичной и~двенадцатеричной.
Некоторыми народами использовались также  %$8$
восьмеричная система счисления (по суставам пальцев одной руки, кроме большого) и~%$9$.
даже девятеричная.
Сейчас общепринятой в~быту является десятичная система счисления.
% , в~вычислительной технике "--- двоичная

Группировка счётных знаков позволяет нагляднее представить относительно большие числа, но единичная запись всё равно будет громоздкой.
Для сокращения длины логично записывать  число не объектов, а~групп и~при этом как-то различать записи «$N$ объектов» и~«$N$ групп объектов».
Простейшее решение "--- ввести для группы, например, десятка, специальный счётный знак.


Подобная запись использовалась, в~частности, в~Древнем Египте.
Там
% В~Древнем Египте %для записи чисел 
была принята десятичная система, при этом
использовались различные знаки для записи единиц ($|$), десятков ($\cap$), сотен и~так далее.
% (рис.~\ref{ris:digits-egypt}). %, тысяч, десятков тысяч и~миллиона.
% Для записи, в~частности, 
Например, для записи
числа
% $129 = 1\cdot100 + 2\cdot10 + 9\cdot1$ был необходим один знак, обозначающий сотню, два знака десятков и~девять знаков единицы.
$29 = 2\cdot10 + 9\cdot1$ были необходимы два знака десятков и~девять знаков единицы: 
% $\cap\cap|||||||||$.
$\scriptsize\begin{array}{c@{~}c}
\cap&||||\\[-1.5ex]
\cap&|||||\\
\end{array}$.
Порядок записи этих знаков не был чётко определён.


% \begin{illustration}
% 
% \caption{Древнеегипетские цифры}
% \label{ris:digits-egypt}
% \end{illustration}
% 
% Вначале (справа, так как писать было принято справа налево) ставились палочки по числу единиц, затем дуги по числу десятков и~т.\,д.
% Значение числа
Таким образом,
значение счётного знака зависело только от его формы, но не от его положения относительно других знаков.
% Соответственно,
% При сложении 
Такие системы счисления называются непозиционными.

В~Древнем Риме
применялась смешанная система счисления "--- пятично-десятичная.
% Счётные знаки 
Специальные знаки существовали для единиц (\RN{I}, схематичное изображение пальца), пятёрок (\RN{V}, напоминающая руку с~отставленным большим пальцем), десяток (\RN{X}, две руки), $50$, $100$ и т.\,д.


% \begin{illustration}
% 
% \caption{Римские цифры}
% \label{ris:digits-egypt}
% \end{illustration}

Значение цифры зависело от того, находилась ли она справа от более крупной цифры (в~этом случае их значения складывались) или слева %от цифры более высокого порядка 
(в~этом случае меньшее значение вычиталось из большего).
% Справа записывались единицы
В~частности,
% $129 = 1\cdot100 + 2\cdot10 + 9 = 1\cdot100 + 2\cdot10 + 10-1 = \RN{CXXIX}$,
% $131 = 1\cdot100 + 3\cdot10 + 1 = \RN{CXXXI}$.
$29 = 2\cdot10 + 9 = 2\cdot10 + 10-1 = \RN{XXIX}$,
$31 = 3\cdot10 + 1 = \RN{XXXI}$.
Таким образом, значение счётного знака зависит и~от его формы, и~от его положения относительно других знаков, 
но при этом, например, единица и~десяток обозначаются при помощи принципиально разных символов.
Такая система счисления называется смешанной.


Римская запись сложна, почти так же громоздка, как египетская и,~кроме, того, неоднозначна "--- %в~частности, 
например, число $4$ записывалось и~как~$\RN{IIII}~(4\cdot 1)$, и~как~$\RN{IV}~(5- 1)$.
Существуют различные виды римской записи, позволяющие либо %упростить алгоритм записи и~
сократить длину числа% (в~частности, )
, либо убрать неоднозначность, но не то и~другое сразу.


В~Индии была придумана позиционная запись, в~которой использовались различные счётные знаки для %$1, 2, 3, $
всех чисел от~единицы до~девяти, а~также впервые возникло специальное обозначение для нуля.
% Наибольшую популярность получила индийская система записи чисел.
% Из-за 
Для подобной записи числа, как и~в~египетской системе, разбивается на сумму некоторого числа единиц, десятков и~т.\,д.,
причём для записи количества единиц и~десятков будет использован один и~тот же набор цифр. 
Значение цифры определяется её положением в~записи;
такая система счисления называется \termin{позиционной.}
Десятичная позиционная запись была перенята у~индийцев арабами, а~затем распространилась повсеместно.
Начертание счётных знаков со временем превратилось в~так называемые арабские цифры, которые сейчас привычны нам с~детства, как и~позиционная система записи: $2\cdot10 + 9\cdot1 = 29$.

В~настоящее в~быту  повсеместно используется именно десятичная позиционная запись.
% 
% Наиболее известное
На десятичной позиционной системе основано наиболее совершенное из простых счётных устройств "---
русские счёты.
Ряд спиц в~них соответствует позициям, десять костяшек на каждой спице "--- цифрам.

% Механические счётные машины, 
Первая механическая суммирующая машина "--- Паскалина "--- 
% построенная Блезом Паскалем на основе связанных зубчатых колёс, 
также была построена на основе десятичной позиционной записи%
, несмотря на то, что использовалась для финансовых расчётов в~принятой тогда недесятичной денежной системе.
Каждому десятичному разряду соответствовало одно зубчатое колесо, на которое были нанесены цифры от~$0$ до~$9$.
Поворачиваясь от $9$ к~$0$, колесо сдвигало следующее за ним, формируя перенос.


Десятичная позиционная система счисления использовалась в~механических калькуляторах,
арифмометрах, разностной машине Бэббиджа, весившей более трёх тонн, 
а~также в~его же  проекте аналитической  машины, не реализованном из-за  из-за своих габаритов и~высокой стоимости.
% и~арифмометрах,
% выполнявших сложение, вычитание, умножение и~деление вводимых оператором чисел;
% % Более совершенная %механическое счётное устройство "--- 
% а~также в~разностной машине Бэббиджа, позволившей %частично автоматизировать 
% вычислять значения многочленов.
% Разностная машина, построенная  Бэббиджем, 
% весила более трёх тонн.
% % и~разностной машине Бэббиджа (3 тонны).
% Проект аналитической машины Бэббиджа, ставшей идейным прототипом современных ЭВМ, также подразумевал десятичную систему счисления.
% К~сожалению, эта машина так и не была построена из-за своих габаритов и~высокой стоимости.
% 
Даже много позже в~первой электронной (то есть построенная на вакуумных лампах) вычислительной машине "--- ЭНИАК %на основе вакуумных ламп 
"--- использовалась десятичная система, 
% http://evmhistory.ru/history/eniac.html
из-за чего размеры ЭНИАК превысили размеры более поздних %и~более мо
ламповых вычислительных машин.


% Двоичная система "--- Лейбниц.

% http://wiki.livid.pp.ru/students/cs/lectures/1.html
% В~механической счётной машине Z1 Конрада Цузе (1938 г.) была использована уже двоичная система счисления.
% Это позволило существенно уменьшить размеры устройства.
% Усовершенствованный вариант вычислителя Цузе, Z2 на основе телеграфных реле (1939),  закрепил использование двоичной логики "--- реле может находиться только в~двух состояниях "--- оно открыто либо закрыто.

При этом, как уже было сказано, основание системы счисления, равное десяти, было популярным, но не единственным.
% % Некоторые народы испрльзовали двенадцатеричную систему.
% http://www.eipiphiny.org/books/history-of-binary.pdf
% раньше!
% Считается, что впервые двоичную систему счисления предложил
% % http://kfcmtf.upol.cz/uploads/Dvorak/Caramuel080702.indd-1.pdf
% испанский математик Хуан Карамуэль и Лобковиц~\cite{JuanCaramuelLobkowitz}.
В~\ToRomanEmpire{16}--\ToRomanEmpire{17} вв. различные учёные рассматривали двоичную, троичную и~т.\,д. системы счисления и~их свойства~\cite{history-of-binary,JuanCaramuelLobkowitz}.
Лейбниц %в~своих публикациях представлял двоичную систему как мистическую ?, 
видел в~двоичной системе мистическое отражение реальности,
но не рекомендовал использовать её на практике для вычислений
% Эти идеи достаточно долго 
(знаменитый арифмометр Лейбница был основан на десятичной системе).
% Даже первая электронная вычислительная машина "--- ЭНИАК на основе вакуумных ламп "--- использовал десятичную систему, 
% % http://evmhistory.ru/history/eniac.html
% из-за чего его размеры превысили размеры более поздних ламповых вычислительных машин.

% https://3dnews.ru/263541
Первая реально  построенная вычислительная машина Z1 была механической и~была создана в~Германии Конрадом Цузе.
% Конрад Цузе использовал идеи Бэббиджа, при этом вес Z1 "--- всего 500 кг.
Идеи Цузе были поразительно схожи с~планами Бэббиджа (несмотря на независимую работу) и~теми, что позже будут реализованы фон Нейманом.
При этом Z1 помещалась в~гостиной Цузе, а~её составил всего 500 кг. %, то есть гораздо меньше.
% 
% Таким образом, Z1 была более чем на порядок компактнее, чем  слабой разностной десятичной  машины, построенной Бэббиджем.
% не говоря уже %о~сопоставимой с~Z1 аналитической машине.
% о~нереализованном проекте  аналитической  машины Бэббиджа.
Такая компактность была достигнута %Цузе 
% Это было достигнуто
за счёт использования другой позиционной системы счисления "--- \termin{двоичной.} 
% которая обладает большей экономичностью записи~\cite{fominSS}, чем десятичная.
Для ввода-вывода в~Z1 было реализовано двоично-десятичное преобразование.
% Ввод-вывод осуществлялся с~помо
Усовершенствованный вариант вычислителя Цузе, электромеханический Z2 на основе телеграфных реле,  закрепил использование двоичной логики "--- реле может находиться только в~двух состояниях "--- оно либо открыто, либо закрыто.
Используемые в~последующих вычислительных машинах вакуумные лампы, а~затем транзисторы также могли находиться  в~двух состояниях.
Таким образом, в~настоящее время двоичная позиционная система применяется в~электронике повсеместно.
\index{Представление данных!натуральных!экономичность}




% троичная арифметика: Сетунь
Но двоичная система не является самой экономичной. 
Теоретически оптимальной является систем счисления по основанию~$e$, а~из натуральных оснований наиболее экономичным является~$3$~\cite{fominSS}.
\index{Представление данных!натуральных!троичное}
Троичная ЭВМ "--- Сетунь была разработана в~МГУ, выпускалась серийно и~оказалась весьма эффективной.
Но, так как для построения троичных логических элементов использовалась двоичная элементная база (транзисторы), существенно уменьшить габариты и~стоимость за счёт экономичности основания системы счисления не удалось, так что в~дальнейшем от троичной логики надолго отказались.
Тем не менее, недавно о~ней снова  пришлось вспомнить:  элементы квантовых компьютеров могут принимать как раз три значения.


% Модулярная арифметика: Алмаз
\index{Представление данных!натуральных!модулярное}
Кроме позиционных систем счисления, в~вычислительной технике использовались и~оригинальные системы счисления.
% Например,
Наиболее интересной представляется система остаточных классов, %также известная как 
или модулярная арифметика "--- представление числа~$x$ в~виде последовательности 
% набора 
остатков от деления $x$ на набор взаимно простых чисел $p_1, p_2,\ldots p_n$.
$$
x = (x \Mod p_1,~ x \Mod p_2,\ldots ~ x \Mod p_n)
$$
% Согласно китайской теореме об остатках, такое представление единственно для $x \in [0, P)$, где $P = p_1\cdot p_2\cdot\ldots\cdot p_n$.
% 
Такое представление позволяет выполнять умножение с~той же скоростью, что и~сложение.
% % malashevich-mod-epos
% Для вычисления суммы (или произведения) двух чисел, представленных подобным образом, достаточно сложить (или перемножить) каждую пару  соответственных остатков.
% При этом действия с~различными парами остатков можно выполнять параллельно, так как действия выполняются независимо друг от друга. 
% 
% При использовании небольших  $p_1, p_2,\ldots p_n$ возможно 
% % Малая разрядность остатков обеспечивает возможность реализации табличной арифметики, при которой 
% вместо вычисления результата операции 
% % каждый раз в память машины заранее помещается таблица готовых значений. 
% воспользоваться предварительно вычисленной таблицей.
% Таким образом, любая операция при %такой табличной арифметике и
% соответствующей конвейеризации будет  выполняться за один машинный такт.
% % для сколь угодно большого числа
% %  ( количество разрядов в котором зависит лишь от конструкции машины ). Это позволяет чрезвычайно эффективно выполнять некоторые распространенные классы задач , сводящихся к сложению , умножению и возведению в степень многоразрядных чисел . 

Первым модулярным компьютером была чехословацкая ЭВМ Эпос, позже в~СССР разрабатывалась серия модулярных ЭВМ.
% , наиболее известными из  Т-340А и К-340А.
% Эти компьютеры обладали не только высоким быстродействием, но и~надёжностью.
Наиболее известная советская модулярная ЭВМ, К-340А, используется до сих пор из-за своей поразительной надёжности и~быстродействия~\cite{malashevich-mod-epos, malashevich-mod-almaz}.
% https://www.itweek.ru/themes/detail.php?ID=69856
% благодаря своей высочайшей надёжности и~уникальным характеристикам
%ЭВМ К-340А до сих пор (2004 г., 40 лет!!!) находятся в эксплуатации, демонстрируя значительно более высокую живучесть, чем работающие рядом с ними другие, современные электронные системы
В~настоящее время на модулярной арифметике основаны многие специализированные процессоры, предназначенные для обработки сигналов в~режиме реального времени.

Программная реализация модулярной арифметики в~настоящее время используется для ускорения вычислений в~криптографии.


\section{Позиционные системы счисления} 
\index{Представление данных!натуральных!позиционное}
\epigraph{
Человек, который дружит с~тиранами, подобен камешку при вычислении, значение его бывает иной раз большое, иной "--- малое. 
}{приписывается Сократу}
% http://journal-shkolniku.ru/istoriya-cifr.html


% идея

Все позиционные системы счисления строятся по одному общему принципу. 
Выбирается некоторое натуральное число $N > 1$ "--- основание системы счисления, и~каждое число $X \in \Naturalset_0$ представляется в~виде комбинации его степеней с~коэффициентами, принимающими значения от~$0$ до $N-1$, т.\,е. в виде
\begin{equation}
\label{eq:digits:position-exponentiation}
X = x_0 + x_1\cdot N + \ldots + x_k\cdot N^k
\end{equation}
где
$0\leqslant x_i < N$ "--- целые.
Такое разложение существует и единственно для каждого $X \in \Naturalset_0$.


Далее число $X$ сокращённо записывается в~виде $x_k \ldots x_1 x_0$.
% Коэффициент при 
% позиция 
% В~позиционных системах счисления 
% число представляется в~виде последовательности специальных символов "--- цифр, не 
% 
% целого неотрицательного числа
% 
% цифры записываются в~определённом порядке, и,~как правило, не разделяются никаким символом.
% В~
Для того, чтобы отличать это представление от сокращённой записи умножения $x_k \cdot \ldots \cdot x_1\cdot  x_0$, над позиционной записью может быть проведена горизонтальная черта; % (как правило это используется, если разряды о).
основание системы счисления~$N$ может быть указано в~виде нижнего индекса, таким образом:
\begin{equation}
\label{eq:digits:position-exponentiation-def}
% X = x_0 + x_1\cdot N + \ldots + x_k\cdot N^k = \overline{x_k \ldots x_1 x_0}_N
X =  x_k\cdot N^k + \ldots + x_1\cdot N + x_0= \overline{x_k \ldots x_1 x_0}_N
\end{equation}
Если позиционность представления и~основание системы очевидны из контекста, эти обозначения могут опускаться.
Так, запись $13$ для позиционного десятичного представления числа «тринадцать» будет, скорее всего, прочитана правильно, 
как  и~\hex{0400-04FF} для позиционного шестнадцатеричного представления диапазона кодов Unicode.


Каждому возможному значению $x_i$, от~$0$ до~$N-1$, соответствует специальный знак "--- цифра.
% 
% Если основание системы~$N$ не превышает~$10$, 
Для записи значений, не превышающих девяти, 
используются привычные нам знаки $0\ldots9$.
Если необходимо записать одной цифрой значение~«десять», для этого обычно используется знак~$\mathrm{A}$,
одиннадцать записывается как~$\mathrm{B}$ и~так далее.
% Если необходимо записать одной цифрой значение~«десять», для этого обычно используется знак~\digitA,
% одиннадцать записывается как~\digitB{} и~так далее.


Таким образом, в~часто используемой в~информационных технологиях шестнадцатеричной системе счисления 
числа записываются с~помощью шестнадцати цифр: $\hex{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.}$
Знаки $\hex{A\ldots F}$ в~этом контексте называются именно цифрами, а~не буквами, и~качественно ничем не отличаются от знаков $\hex{0\ldots9}$.
% 
% Современная запись 
В~двенадцатеричной системе используется двенадцать цифр: $\hex{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B.}$
\begin{equation*}
13_{10} = 11_{12} = \hex{D}_{16}
\end{equation*}

Величина, обозначаемая цифрой в~записи числа, зависит от её позиции (разряда).
Разряды числа, в~отличие от текста, записываются по-арабски "--- справа налево.
Цифра, записываемая крайней справа, обозначает количество единиц (младший радряд), вторая справа в~десятичной системе обозначает количество десятков, в~двенадцатеричной "--- количество дюжин и~т.\,д.
Крайний слева разряд %соответствует максимальной степени основания, на которую
называется старшим.
\begin{equation*}
\begin{array}{c}
12345_{10} = 5\cdot10^0 + 4\cdot10^1 + 3\cdot10^2 + 2\cdot10^3 + 1\cdot10^4
\end{array}
\end{equation*}
Иногда разряды числа нумеруются, но порядок нумерации в~различных источниках не совпадает.
Младший разряд обозначается иногда как первый (так сложилось исторически), иногда как нулевой (так как $1 = N^0$).
В~некоторых источниках разряды чисел фиксированной ширины (например, регистров) вообще нумеруются от старшего к~младшему, по направлению текста.


В~любой позиционной системе счисления ноль записывается как~$0$, единица "--- как~$1$.
Основание этой системы счисления всегда записывается в~виде~$10$.


\subsection{Перевод натуральных чисел 
между позиционными системами счисления}
\index{Представление данных!натуральных!перевод}
\epigraph{

"--*  Что общего между Хэллоуином и~Рождеством?

"--*  Каждый программист знает: 31 oct = 25 dec
}{\ProgFolk}

В~общем случае
для перевода натуральных чисел между системами счисления используется деление с~остатком.
Действительно, сгруппируем в~\eqref{eq:digits:position-exponentiation} все члены, куда входит $N$ в~степени, большей~$1$:
\begin{equation}
\label{eq:digits:position-exponentiation-0brace}
X 
= x_0 + \big(x_1\cdot N + \ldots + x_k\cdot N^k\big)
\end{equation}
вынесем за скобки~$N$ и~обозначим оставшееся %в~скобках 
значение как~$X_1$:
\begin{equation}
\label{eq:digits:position-exponentiation-0}
X 
=x_0 + \underbrace{\big(x_1 + \ldots + x_k\cdot N^{k-1}\big)}_{X_1}\cdot N
=x_0 + {X_1}\cdot N,
\end{equation}
где $x_0$ и~$X_1$ "--- целые неотрицательные числа, причём $0\leqslant x_0 < N$.
Таким образом, младшая цифра $x_0$ числа $X$ в~$N$-ичной системе счисления "--- остаток от целочисленного деления $X$ на $N$,
также в~процессе этого деления мы получим частное, равное~$X_1$.
% а~$X_1$ "--- частное этого деления.
Так как в~соответствии с~\eqref{eq:digits:position-exponentiation-0} 
\begin{equation}
X_1 =x_1 + x_2\cdot N + \ldots + x_k\cdot N^{k-1},
\end{equation}
следующую цифру $x_1$ можно найти как остаток от деления $X_1$ на~$N$ и~так далее:
\begin{equation}
\left.
\begin{array}{rcrcr}
266 &=& 22 \cdot 12 &+& 2\\
22 &=& 1\cdot 12 &+&10\\
1 &=& 0\cdot 12 &+&1
\end{array}
\right\}
~~~
266_{10} = 1\digitA2_{12}.
\end{equation}


Если необходимо перевести число из системы счисления по произвольному основанию $N$
в~ту систему счисления, которая используется в~расчётах (при расчётах вручную это обычно десятичная система), это можно сделать, используя определение~\eqref{eq:digits:position-exponentiation-def}:
\begin{equation*}
\begin{array}{c}
12345_{12} = 5\cdot12^0 + 4\cdot12^1 + 3\cdot12^2 + 2\cdot12^3 + 1\cdot12^4  = 24677_{10}
\\
101_{2} = 1\cdot2^0 + 0\cdot2^1 + 1\cdot2^2 = 5_{10}
\\
\hex{1A}_{16} = 10\cdot16^0 + 1\cdot16^1 = 26_{10}
\end{array}
\end{equation*}
Компьютер оперирует %в~основном 
с~данными, представленными в~двоичной системе, таким образом, при вводе десятичных данных необходимое преобразование также можно выполнить по~\eqref{eq:digits:position-exponentiation-def}:
\begin{equation*}
\begin{array}{c}
13_{10} = 11\cdot1010^0 + 1\cdot1010^1 = 11 + 1010 = 1101
\end{array}
\end{equation*}
Впрочем, десятично-двоичное преобразование уже реализовано в~библиотеке ввода-вывода любого языка высокого уровня %, и~вручную подобные расчёты 
и~выполняется неявно для программиста и тем более для пользователя.

Если число необходимо перевести из~системы счисления по основанию $N$ в~систему по основанию~$N^k, k \in \Naturalset$ или наоборот, то также нет необходимости в~сложных вычислениях.
В~этом случае существует взаимно однозначное соответствие между группой из $k$ разрядов в~системе по основанию $N$ и~одним разрядом в~системе по основанию~$N^k$,
что будет подробнее рассмотрено ниже на примере двоичной, восьмеричной и~шестнадцатеричной систем.

\subsection{Экономичность системы счисления}
\index{Представление данных!натуральных!экономичность}
\epigraph{\begin{limerick}
    Некий отрок, бродя по овражку,\\
    Подобрал небольшую дворняжку.\\
    Лишь немного спустя,\\
    Осознал он, грустя,\\
    Что большую он сделал промашку.
   \end{limerick}
}
{\Lear} 

С~точки зрения математики, все позиционные системы счисления равнозначны.
Но, как показывает практика,  вычислительные системы, обрабатывающие данные в~двоичной системе, более просто устроены и,~соответственно, имеют меньшие габариты, чем десятичные (при сопоставимых возможностях).
Это связано с~таким свойством, как экономичность, или компактность системы счисления. % (само понятие экономичности приписывается фон Нейману).
Считается, что понятие экономичности введено фон Нейманом.

% Экономичность системы счисления определяется следующим образом.
Рассмотрим сравнительную экономичность двоичной и~десятичной систем на следующем примере~\cite{fominSS}.
В~десятичной системе для представления $10^3$ чисел от $0$ до~$999$ используется три разряда, каждый из которых %может находиться в~десяти различных состояниях,
помещает одну из десяти различных цифр,
то есть всего используется $30$  цифр.
В~двоичной системе из тех же $30$ цифр можно составить $15$ разрядов, каждый из которых хранит ноль или единицу.
Таким образом, всего можно представить $2^{15} = 32\,768$ различных чисел
"--- более чем на порядок больше, чем в~десятичной.
% Это и~позволило реализовать Z1  и~машин Бэббиджа. 

Обобщая эти рассуждения, можно оценить количество $E_n(N)$ различных чисел, представимых в~системе счисления по основанию $N$ с~помощью $n$ цифр:
\begin{equation}
\label{eq:digits-position-compact}
E_n(N) = N ^ {\frac{n}{N}}
\end{equation}
% В~троичной системе получаем 10 разрядов по три цифры, то есть $3^{10} = 59\,049$ чисел.
% В~четверичной системе из 30  цифр нельзя составить целое число разрядов по четыре цифры, но, обобщив способ вычисления, мы получим $4^{\frac{15}{2}} = 2^{15} = 32\,768$, то есть эффективность четверичной системы равна эффективности двоичной.
% 
% Пятеричная система даст уже шесть разрядов по пять цифр, то есть всего $5^{6} = 15\,625$ чисел.
% При дальнейшем возрастании основания эффективность будет падать дальше.
% 
% В~десятичной системе для представления $10^6$ чисел от $0$ до~$999999$ используется шесть разрядов, каждый из которых 
% помещает одну из десяти различных цифр,
% то есть всего используется 60  цифр.
% В~двоичной системе из тех же 60 цифр можно составить 30 разрядов, каждый из которых хранит ноль или единицу.
% Таким образом, всего можно представить $2^{30} = $ различных чисел.

Хотя на практике используются только натуральные основания систем счисления, \eqref{eq:digits-position-compact} можно распространить и~на вещественные положительные $N$.
На рис.~\ref{ris:digits-ternary-optimal} представлена зависимость $E_n(N)$ для трёх значений количества цифр~$n$.

\begin{illustration}

\begin{tikzpicture}    [line cap=round,line join=round,x=5ex,y=5ex]
\begin{axis}[/pgf/number format/use comma,/pgf/number format/1000 sep={},
xlabel=$N$,
ylabel=$E_n(N)$, %$N ^ {\frac{n}{N}}$,
height=0.4\linewidth,
width=\linewidth,
grid=major,
axis x line=middle,
axis y line=middle,
% every axis plot/.append style={graphline},
% yticklabel=\pgfmathprintnumber{\tick},
% scaled y ticks=base 10:2,
y tick label style={/pgf/number format/.cd,%
          scaled y ticks = false,
          set thousands separator={},
          fixed},
ytick={1,2,4,6,...,18},
extra x ticks={2.71828},
extra x tick labels={$e$},
% xmin=0,xmax=12.5,  
% ymin=0,ymax=19,  
% xlabel style={xshift=-0.2em},
]
 \pgfplotsset{
 tick label style={font=\footnotesize},
 label style={font=\footnotesize},
 legend style={font=\footnotesize}
}
 \pgfplotsinvokeforeach{4,6,8}
 {
  \addplot[mark=none,domain=0.1:12.5,samples=120, very thick, smooth]     {exp(#1/x*ln(x))} node [pos=1-8/#1/#1, above, sloped] {{$n={#1}$}};
  \addplot[mark=*] coordinates {(e,exp(#1/e)};
 };
\end{axis} 
\end{tikzpicture}

\caption{Эффективность систем счисления}
\label{ris:digits-ternary-optimal}
\end{illustration}

Как видно из  рис.~\ref{ris:digits-ternary-optimal}, количество используемых цифр~$n$ не влияет на то, какая из систем счисления более экономична, от него зависит только выраженность пика: чем большее количество цифр используется, тем больше разрыв между различными системами.
Для всех значений~$n$
двоичная система существенно превосходит десятичную, но отнюдь не является самой эффективной.
Максимум $E_n(N)$ находится в~точке $N=e=2,71828\ldots$, что можно доказать дифференцированием \eqref{eq:digits-position-compact}.
Из натуральных $N$ наибольшее значение  достигается при  $N=3$, то есть троичная система ещё экономичнее двоичной.
Далее  эффективность снижается с~ростом $N$:
четверичная система так же экономична, как и~двоичная; 
при $N>4$ экономичность плавно снижается и~асимптотически
стремится к~единице.

Также можно заметить, что для всех $n$ получаем $E_n(1) = 1$. 
Действительно (хотя единичная система не является в~полной мере позиционной и,~соответственно, не может однозначно рассматриваться как частный случай \eqref{eq:digits-position-compact}): в~единичной системе с~помощью $n$ цифр можно записать только одно число "--- оно равно $n$.

Таким образом, наиболее эффективной должна быть вычислительная машина, построенная с~использованием троичной системы счисления.
% менее эффективна двоичная система.
% Четверичная 
Двоичная система, использование которой связано с~тем, что большинство существующих электронных компонентов может находиться только в~двух состояниях, также относительно эффективна.


% \subsection{Представление вещественных чисел в~позиционных системах счисления}
\subsection{Нецифровые символы в~представлении чисел}
\index{Представление данных!нецифровые символы}
\epigraph{
\begin{stanza}[0mm]
И~орёл не взмахивал крылами, \\
Звёзды жались в~ужасе к~луне, \\
Если, точно розовое пламя, \\
Слово проплывало в~вышине.
\end{stanza}
}{Н.\,C.\,Гумилёв}

% Кроме цифр, %в~позиционной 
% для записи чисел используются и~другие символы;
% в~частности, знак  показывается символом $+$ или $-$,  который ставится перед абсолютной величиной числа, представляемой в~виде~\eqref{eq:digits:position-exponentiation-def}; 
% в~записи вещественных чисел дробная часть отличается от целой запятой или (в~западной традиции) точкой.

В позиционной системе счисления по основанию~$N$ с~помощью цифр можно записать любое число из~$\Naturalset_0$.
% 
Но, как было сказано выше, для представления некоторых данных недостаточно неотрицательных целых чисел.
В~этих случаях %, кроме позиционной записи, 
используются %другие 
формы записи, 
% включающие   для различных компонент числа позиционное представление в~некоторой системе счисления
% и~символы, дополнящие позиционную запись "--- нецифровые символы.
включающие 
% компоненты  числа, записанные  в~некоторой позиционной системе счисления,
% % и~символы, показывающие взаимодействие компонент  "--- нецифровые символы.
% % а~также дополнительные (нецифровые) символы.
% а~также 
дополнительные символы, не являющиеся цифрами.

% Знак числа показывается нецифровым символом «$+$» или «$-$» перед числом.
\index{Данные!знак}
В частности,
отрицательные числа маркируются нецифровым символом «$-$», после которого записывается абсолютная величина (модуль) числа в~используемой системой счисления.
Соответственно, перед значением положительного числа может быть поставлен символ $+$, но он часто опускается:
\begin{equation}
\label{eq:digits:pos-neg-symbol}
\begin{array}{ccccccccccccccccc}
-1_{10} &=& -1_2 &=& -1_{12}\\
+2_{10} &=& +10_2 &=& +2_{12} &=& 2_{12}\\
-11_{10} &=& -1011_2 &=& -\digitA_{12}
\end{array}
\end{equation}


\index{Данные!простые дроби}
Простые дроби $\frac{m}{n}$ %в~любой позиционной системе счисления 
представляются своими числителем и~знаменателем, разделёнными горизонтальной чертой:
\begin{equation}
\label{eq:digits:pos-frac-symbol}
\begin{array}{ccccccccccccccccc}
\left(\dfrac{3}{4}\right)_{10} &=& \left(\dfrac{11}{100}\right)_{2} &=& \left(\dfrac{3}{4}\right)_{12} \\[3ex]
\left(\dfrac{12}{5}\right)_{10} &=& \left(\dfrac{1100}{101}\right)_{2} &=& \left(\dfrac{10}{5}\right)_{12} \\[3ex]
\left(\dfrac{100}{49}\right)_{10} &=& \left(\dfrac{1100100}{110001}\right)_{2} &=& \left(\dfrac{84}{41}\right)_{12} \\
\end{array}
\end{equation}

Но не все вещественные числа можно представить в~виде отношения двух натуральных;
кроме того, работать с~таким представлением не всегда удобно.

В~этих случаях используется расширение позиционного представления на случай вещественных чисел.
Для разделения целой и~дробной частей
% в~этом случае также используется нецифровой символ "--- запятая или (в~западной традиции) точка.
% Для их разделения 
также
используется нецифровой символ.
В~российской традиции это запятая, в~западной "--- точка.


\subsection{Позиционное представление вещественных чисел}
\label{sec:digits-real-pos}
\index{Представление данных!вещественных!позиционное}
\epigraph{
\begin{stanza}
Где после дождичка в четверг,\\
Устав от суеты,\\
Грустит простой английский клерк,\\
Любуясь на хвосты.
\end{stanza}
}{\Lear}

% $N$-ичные дроби.
\index{Данные!позиционные дроби}
% \index{Представление данных!вещественных!позиционное}
Хотя определение позиционного представления по основанию $N$~\eqref{eq:digits:position-exponentiation-def} изначально давалось для натуральных чисел, его можно расширить, введя отрицательные степени $\frac{1}{N}$, $\frac{1}{N^2}$ и~так далее:
\begin{equation}
\label{eq:digits:position-exponentiation-realsweaexsdd}
\begin{array}{c}
X =  x_k\cdot N^k + \ldots + x_1\cdot N^1 + x_0\cdot N^0 + x_{-1}\cdot N^{-1} + \ldots + x_{-\ell}\cdot N^{-\ell} + \ldots = \\[2ex]
= x_k\cdot N^k + \ldots + x_1\cdot N + x_0 + \dfrac{x_{-1}}{N} + \ldots + \dfrac{x_{-\ell}}{ N^{\ell}} + \ldots = \\[2ex]
= \overline{x_k \ldots x_1 x_0,x_{-1}\ldots x_{-\ell}\ldots}_N, ~~ 0\leqslant x_i < N ~\text{"--- целые}
\end{array}
\end{equation}
Коэффициенты $x_i$ (цифры) записываются в~порядке убывания степени $N$; 
между коэффициентами при $N^0$ и~при $N^{-1}$ ставится запятая.
В~форме~\eqref{eq:digits:position-exponentiation-realsweaexsdd} ($N$-ичной дроби) можно представить любое неотрицательное вещественное число $X$% (причём единственным образом 1 = 0.(F))
, но не всегда это можно сделать с~помощью конечного количества знаков.

В~случае $N=10$ получаем привычные десятичные дроби,
а~запятая (или, в~западной традиции, точка), отделяющая целую часть от дробной, называется десятичным разделителем.


Сгруппируем члены~\eqref{eq:digits:position-exponentiation-realsweaexsdd}:
% Рассмотрим представление~\eqref{eq:digits:position-exponentiation-realsweaexsdd} для $X\geqslant 0$:
\begin{equation}
\label{eq:digits:position-exponentiation-real-intfrac}
\begin{array}{c}
X =  \underbrace{\left(x_k\cdot N^k + \ldots + x_1\cdot N + x_0\right)}_{\lfloor X\rfloor} + \underbrace{\left(x_{-1}\cdot N^{-1} + \ldots + x_{-\ell}\cdot N^{-\ell} + \ldots \right)}_{\{X\}} = \\
= \lfloor X\rfloor + \{X\}
\end{array}
\end{equation}
получаем разделение числа $X$ на целую и~дробную часть: $\lfloor X\rfloor$ "--- целое неотрицательное число (сумма целых неотрицательных слагаемых), и~$\{X\} \in [0,1]$:
\begin{equation}
\label{eq:digits:position-exponentiation-real-frac}
\begin{array}{c}
0= 0\cdot N^{-1} + \ldots + 0\cdot N^{-\ell} + \ldots  \leqslant \{X\} \leqslant\\
\leqslant (N-1)\cdot N^{-1} + \ldots + (N-1)\cdot N^{-\ell} + \ldots = 1
\end{array}
\end{equation}
если рассматривать только конечные дроби, то $\{X\} \in [0,1)$.

% Таким образом, %возможны
Для нуля и~неотрицательных нецелых чисел представление~\eqref{eq:digits:position-exponentiation-realsweaexsdd} единственно,
натуральные могут быть представлены в~двух формах, например
\begin{equation}
\label{eq:digits:pos-frac-twins}
\begin{array}{c}
2_{10} = 1,999\ldots_{10} = 10_{2} = 1,111\ldots_{2} = 2_{12} = 1,%\mathrm{BBB}
\digitB\digitB\digitB\ldots_{12}
\end{array}
\end{equation}
канонической (а~если есть какие-то ограничения на длину дробной части "--- единственной) формой записи натуральных чисел является запись с~нулевой дробной частью.

Таким образом, для представления числа $X \in [0, +\infty)$ в~каноническом виде~\eqref{eq:digits:position-exponentiation-realsweaexsdd}
необходимо разделить его на целую часть $\lfloor X\rfloor \in \Naturalset_0$,
которая затем записывается в~позиционной форме~\eqref{eq:digits:position-exponentiation-def} уже описанным способом,
и~дробную часть $\{X\} \in [0,1)$, которую надо представить в~виде:
\begin{equation}
\label{eq:digits:position-exponentiation-real-frac-pos}
\{X\} = {x_{-1}\cdot N^{-1} + \ldots + x_{-\ell}\cdot N^{-\ell} + \ldots }
\end{equation}
после чего представления целой и~дробной частей записываются рядом.
% Для их разделения используется нецифровой символ.
% В~российской традиции это запятая, в~западной "--- точка.
Для их разделения используется соответствующий нецифровой символ "--- запятая или (в~западной традиции) точка.

Рассмотрим геометрическую интерпретацию позиционной записи дробной части в~виде~\eqref{eq:digits:position-exponentiation-real-frac-pos}.
Представим диапазон $[0,1)$ как полуинтервал на числовой оси (рис.~\ref{fig:digits-real-convert-frac}).
Края этого полуинтервала, показанные двумя вертикальными линиями "--- $0$ и~$1$ "--- одинаково записываются в~любой позиционной системе счисления.

\begin{illustration}

% \newcommand{\yticklevel}{0}

\newcommand{\xtick}[1]{
  \draw[tickline] ($(0,0.1)+(#1,\yticklevel)$) -- ($(0,-0.1)+(#1,\yticklevel)$);
}
% \newcommand{\coordxtick}[1]{
%   \draw[tickline] ($(0,0.1)+#1$) -- ($(0,-0.1)+#1$);
% }

\resizebox{1\linewidth}{!}{
\begin{tikzpicture}[y=20mm, x=\linewidth]
  \tikzmath{
    \yticklevel=0;
  }
\draw (0,0) -- (1,0);
% \tikzstyle{redvalue}=[red]
\tikzstyle{redvalue}=[]
\tikzstyle{grayvalue}=[]

\tikzstyle{tickline}=[very thick]
\xtick{1}

\foreach \x in {0,1,...,9} {
  \tikzstyle{tickline}=[very thick]
  \xtick{0.\x}
%   \node at (0.\x5, 0.5) {$\x$};
  \tikzmath{
    \xs = 0.1*\x;
    \xe = \xs + 0.1;
    \inangle=90;
  }
  \draw (\xs,\yticklevel)  to[out=\inangle,in=180-\inangle] node [sloped,above] (dectick) {$\x$} (\xe,\yticklevel);

  \tikzstyle{tickline}=[]

%   \xtick{0.1\x}	
%   \node[scale=0.4] at (0.1\x5, -0.2) {$\x$};
  \tikzmath{
    \xs = 0.1 + 0.01*\x;
    \xe = \xs + 0.01;
%     \xcontrols = 0.5*(\xs+\xe);
    \cc = 0.2;
    \xcontrolsa = (1-\cc)*\xs + \cc*\xe);
    \xcontrolsb = \cc*\xs + (1-\cc)*\xe);
    \ycontrols = \yticklevel - 0.2;
    \inangle=-90;
  }
%   \draw (\xs,\yticklevel)  to[out=\inangle,in=180-\inangle] node [sloped,below,scale=0.4] {$\x$} (\xe,\yticklevel);
%   \draw (\xs,\yticklevel)     .. controls (\xcontrols,\ycontrols)  .. node [sloped,below,scale=0.4] {$\x$} (\xe,\yticklevel);
  \draw (\xs,\yticklevel) .. controls (\xcontrolsa,\ycontrols) and (\xcontrolsb, \ycontrols)  .. node [sloped,below,scale=0.4] {$\x$} (\xe,\yticklevel);

  \xtick{0.13\x}	
}

\coordinate  (msg) at (0.135,0);
\tikzstyle{tickline}=[]

\node[redvalue] (msgdeclabel) at ([yshift=-12mm]msg) {$0,135$};
\coordinate[below=4mm of msgdeclabel.south] (decsouth);
% \draw[redvalue] ([yshift=+8mm]msg)--(msgdeclabel);
\draw[redvalue] (dectick.north-|msgdeclabel)--(msgdeclabel);


% 0,00100010101
% \moveyticklevel[-2]
  \tikzmath{
    \yticklevel=\yticklevel-2.2;
  }
  \draw (0,\yticklevel) -- (1,\yticklevel);
  \xtick{1}	 

\foreach \begn/\len/\inangle/\fontscale/\nodepos in {
0/0.5/60/1/above, 0/0.25/-60/0.8/below, 
0/0.125/30/0.6/above, 0.125/0.0625/-30/0.4/below, 
0.125/.03125/0/0.2/above} {
  \foreach \x/\xe in {0/1,1/2} {
    \tikzmath{
      \xs = \begn +\len*\x; % \len — длина тика, а не полуинтервала
      \xe = \xs + \len;
    }
    \draw (\xs,\yticklevel)  to[out=\inangle,in=180-\inangle] node [sloped,\nodepos,scale=\fontscale] {$\x$} (\xe,\yticklevel);
    \xtick{\xs}	 
  }
}

  
\tikzmath{
  \ylabellevel=\yticklevel-1.2;
}
\node[redvalue,anchor=base] (msgbin) at (0.135,\ylabellevel) {$0,00100\ldots$};
% \draw[redvalue] (msgdeclabel)--(msgbin);

% \node[grayvalue] (n0) at (0,-1) {$0$};
% \node[grayvalue] (n1) at (1,-1) {$1$};
% \draw[grayvalue] (0,0)--(n0)--(0,\yticklevel);
% \draw[grayvalue] (1,0)--(n1)--(1,\yticklevel);
% \node[grayvalue,anchor=base] (n0) at (0,-3.2) {$0$};
% \node[grayvalue,anchor=base] (n1) at (1,-3.2) {$1$};
% \node[grayvalue] (d0) at (n0|-msgdeclabel) {$0$};
% \node[grayvalue] (d1) at (n1|-msgdeclabel) {$1$};
\coordinate (n0) at (0,\ylabellevel);
\coordinate (n1) at (1,\ylabellevel);

% \draw[grayvalue] (0,0)--(d0)--(0,\yticklevel)--(n0);
% \draw[grayvalue] (1,0)--(d1)--(1,\yticklevel)--(n1);

% \node[left=of n0] {$bin$};
% \node[left=of d0] {$dec$};
\coordinate (zero) at (-0.01,0);
\draw [decorate,decoration={brace,amplitude=10pt},xshift=-4pt,yshift=0pt]
(zero|-decsouth) -- (zero|-dectick.north)
node [black,midway,xshift=-4ex] {$dec$};

\draw [decorate,decoration={brace,amplitude=10pt},xshift=-4pt,yshift=0pt]
(zero|-msgbin.south)--(zero|-decsouth)
node [black,midway,xshift=-4ex] {$bin$};


\node[below=of msgbin, redvalue,anchor=base] (msgsym) {$\{X\}$};
\node[grayvalue,anchor=base] (s0) at (n0|-msgsym.base) {$0$};
\node[grayvalue,anchor=base] (s1) at (n1|-msgsym.base) {$1$};

% \draw[grayvalue] (0,0)--(d0)--(0,\yticklevel)--(n0)--(s0);
% \draw[grayvalue] (1,0)--(d1)--(1,\yticklevel)--(n1)--(s1);
\draw[redvalue] (msgdeclabel)--(msgbin)--(msgsym);

\draw[grayvalue] (0,0)--(s0);
\draw[grayvalue] (1,0)--(s1);

\end{tikzpicture}
}

\caption{Геометрическая интерпретация позиционного представления дробной части в~различных системах счисления}
\label{fig:digits-real-convert-frac}
\end{illustration}


Каждому значению из диапазона  $[0,1)$ соответствует одна точка полуинтервала, причём её положение не зависит от используемой системы счисления.
% Вертикальная линия внутри полуинтервала, отмеченная внизу как $\{X\}$ "--- значение, которое требуется представить в~форме~\eqref{eq:digits:position-exponentiation-real-frac-pos}.
Значение~$\{X\}$, которое требуется представить в~форме~\eqref{eq:digits:position-exponentiation-real-frac-pos},
показано вертикальной линией внутри полуинтервала.


Первое слагаемое~\eqref{eq:digits:position-exponentiation-real-frac-pos}, то есть $\frac{x_{-1}}{N}$, можно проиллюстрировать разбиением полуинтервала
на~$N$ равных полуинтервалов $[\frac{n}{N},\frac{n+1}{N})$, где $n$ принимает значения от $0$ до $N-1$.
На рис.~\ref{fig:digits-real-convert-frac} показано такое разбиение для $N=10$ (вверху) и~$N=2$ (внизу).
Значение $n$ для каждого полуинтервала записано на дуге, проведённой над этим полуинтервалом.
Соответственно, первая цифра в~позиционной записи~$\{X\}$ соответствует тому полуинтервалу, которому принадлежит точка~$\{X\}$.
Для значения, показанного на рис.~\ref{fig:digits-real-convert-frac}, это~$1$ в~десятичной системе счисления и~$0$ "--- в~двоичной.

Вторая цифра получается делением полученного полуинтервала на~$N$ ещё меньших 
% (для двоичной системы показаны дугами и~цифрами под осью, для десятичной "--- только цифрами).
(показаны дугами и~цифрами под осью).
Для показанного на рисунке значения получаем~$3$ в~десятичной системе счисления и~$0$ "--- в~двоичной.

% Третье и~п разбиение в~десятичной системе настолько мелко

Дальнейшее разбиение полуинтервалов (на рисунке показано только для двоичной системы) приводит к~десятичной записи $0,135$ и~двоичной $0,00100\ldots$ %.


\subsubsection{Перевод простых дробей в~позиционные}

Перевод простой дроби в~вид~\eqref{eq:digits:position-exponentiation-realsweaexsdd} можно выполнить делением в~столбик.
Рассмотрим представление одной третьей в~различных позиционных системах счисления.

В~двоичной системе потребуется разделить $1_2$ на $11_2$:
\begin{equation}
\label{eq:digits-bindiv-1/3-2}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, 
column 1/.style={nodes={arythm-node, text width=\digitcommawidth, text badly ragged}},
% column 8/.style={nodes={arythm-node, text width=4\digitwidth, text badly ragged, align=right]}}
% column 10/.style={nodes={outer sep=-1ex, inner xsep=-1ex, minimum width = 0ex,red}} не замена, а дополнение стиля?
column 10/.style={nodes={minimum width = 0ex}}
]
{
1,&0&0&0&0&0&0\ldots		&[1ex]	1&1\\
0 & & & & & &\phantom{0\ldots}	& 	 &0&,&0&1&0&1&\ldots \\[\rulerowsep]
1 &0\\
0 &0\\[\rulerowsep]
1 &0&0\\
  &1&1\\[\rulerowsep]
  & &1&0\\
  & &0&0&\\[\rulerowsep]
  & &1&0&0\\
  & & &1&1\\[\rulerowsep]
  & & & &1&\text{\rlap{$\ldots$}} \\
%   & & & &\text{\rlap{$\cdots$}} \\
};
\draw ($0.5*(m-1-7.north east) + 0.5*(m-1-8.north west)$) -- coordinate (lineleft) ($0.5*(m-2-7.south east) + 0.5*(m-2-8.south west)$);
\draw (lineleft) -- (lineleft-|m.east);

\node[left = of m-1-1.south west] {$-$};
\drawclinerow[2]{1}{1}

\node[left = of m-3-1.south west] {$-$};
\drawclinerow[4]{1}{2}

\node[left = of m-5-1.south west] {$-$};
\drawclinerow[6]{1}{3}

\node[left = of m-7-3.south west] {$-$};
\drawclinerow[8]{3}{4}

\node[left = of m-9-3.south west] {$-$};
\drawclinerow[10]{3}{5}

\foreach \b in {1, ..., 4}
{
  \tikzmath{int \bit, \yb, \ye, \xb, \xe;
    \bit = \b;
%     \yb = 2; 
    \xb = 10 + \bit;
    \xe = 1 + \bit;
    \ye = 2 + 2*\bit;
    };
  \path[blockarrow] (m-2-\xb) |- (m-\ye-\xe);
}
\end{tikzpicture}
\dfrac{1}{11}=0,0101\ldots=0,(01)
\end{equation}
деление будет бесконечным, причём после первого повторения частичного остатка процесс будет повторяться.
Таким образом, одна треть в~двоичной системе представляется как бесконечная двоичная дробь $0,(01)$.

В~двенадцатеричной системе делим $1_{12}$ на $3_{12}$:
\begin{equation}
\label{eq:digits-bindiv-1/3-2}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, 
column 1/.style={nodes={arythm-node, text width=\digitcommawidth, text badly ragged}},
column 5/.style={nodes={minimum width = 0ex}}
]
{
1,&0&0\ldots		&[1ex]	3\\
0 & &\phantom{0\ldots}	& 	0&,&4\\[\rulerowsep]
1 &0\\
1 &0\\[\rulerowsep]
  &0\\
};
\draw ($0.5*(m-1-3.north east) + 0.5*(m-1-4.north west)$) -- coordinate (lineleft) ($0.5*(m-2-3.south east) + 0.5*(m-2-4.south west)$);
\draw (lineleft) -- (lineleft-|m.east);

\node[left = of m-1-1.south west] {$-$};
\drawclinerow[2]{1}{1}

\node[left = of m-3-1.south west] {$-$};
\drawclinerow[4]{1}{2}
\end{tikzpicture}
~~~~
\dfrac{1}{3}=0,4
\end{equation}
так как $\frac{1}{3}=\frac{4}{12}$, получаем конечную двенадцатеричную дробь $0,4$.

Вообще, дробь конечна, если простые делители знаменателя простой дроби входят в~число делителей основания системы счисления.
Таким образом, чтобы число представлялось конечной двенадцатеричной дробью,  знаменатель должен быть произведением произвольного количества двоек и~троек;
чтобы дробь была конечной в~десятичной системе "--- двоек и~пятёрок;
а~в~двоичной системе конечными будут только те дроби, знаменатель которых является степенью двойки.



\subsubsection{Перевод вещественных чисел между позиционными системами счисления}


Процесс перевода вещественного числа $X \in \Realset$ в~систему счисления по основанию~$N$
включает шесть стадий:


\begin{enumerate}
\item 
Знак числа отделяется от абсолютной величины:
\begin{equation}
\label{eq:digits-real-convert-sign}
X = \pm |X|
\end{equation}

% Число делится на знак, целую и~дробную части: \\
% {$x = (-1)^s\cdot\Big(\big\lfloor |x| \big\rfloor +  \big\{ |x| \big\}\Big)$.} %,  \{ x \} \in [0; 1)$

\item Абсолютная величина разделяется на целую и~дробную части:
\begin{equation}
\label{eq:digits-real-convert-int-frac}
|X| =  \Big\lfloor |X| \Big\rfloor +  \Big\{ |X| \Big\},
\end{equation}
где $\Big\lfloor |X| \Big\rfloor \in \Naturalset_0,  \Big\{ |X| \Big\} \in [0; 1)$.


\item 
Целая часть абсолютной величины числа раскладывается на сумму неотрицательных степеней основания~$N$:
\begin{equation}
\label{eq:digits-real-convert-int}
\Big\lfloor |X| \Big\rfloor = a_0 + a_1 N + a_2 N^2 + \ldots + a_k N^k, ~~ a_i \in \{0, 1, \ldots, N-1\}.
\end{equation}
Для нахождение коэффициентов $a_i$ используется деление с~остатком, как говорилось ранее.

\item 
Дробная часть раскладывается  на сумму отрицательных степеней~$N$ {(возможно, бесконечную):}
\begin{equation}
\label{eq:digits-real-convert-frac}
\Big\{|X| \Big\} =
\dfrac{b_1}{N} + \dfrac{b_2}{N^2}  + \dfrac{b_3}{N^3}+ \ldots,~~ b_i \in \{0, 1, \ldots, N-1\}.
\end{equation}

\item 
% Неотрицательное вещественное число 
Абсолютная величина числа
записывается как последовательность  коэффициентов~$a_i$ и~$b_i$, расположенных по убыванию степени (коэффициенты при отрицательных степенях отделяются запятой):
\begin{equation}
\label{eq:digits-real-convert-int-frac-digits}
|X| = \overline{a_k \ldots a_2 a_1 a_0,b_1 b_2 b_3 \ldots}
\end{equation}

\item 
Перед записью \eqref{eq:digits-real-convert-int-frac-digits} ставится знак  «$+$» или «$-$», определённый на первой стадии (знак «$+$» может быть опущен).

\end{enumerate}
% 
% Очередную цифру %\emph{целого неотрицательного} числа 
% \termin{целой части}
% можно определить \emph{делением с~остатком} на $n$:
% 
% $\overline{a_k\ldotsa_2 a_1 a_0}  = n \cdot \overline{a_k\ldotsa_2 a_1} + a_0, $\hfill$0 \leqslant a_0 <n$

% \item 

Рассмотрим процесс перевода дробной части $\Big\{ |X| \Big\} \in [0, 1)$ в~вид~\eqref{eq:digits-real-convert-frac} подробнее.
Если цифры целой части получались путём последовательного деления её с~остатком на основание системы,
то 
очередную цифру %\emph{вещественного числа из $[0; 1)$} 
{дробной части}
можно определить \emph{умножением} на $N$:
\begin{equation}
\begin{array}{c}
\Big\{ |X| \Big\} \cdot N =
\overline{0,b_1 b_2 b_3 \ldots} \cdot N =\\[2ex]
= \Big( \dfrac{b_1}{N} + \dfrac{b_2}{N^2}  + \dfrac{b_3}{N^3}+ \ldots \Big)\cdot N 
= b_1 + \dfrac{b_2}{N}  + \dfrac{b_3}{N^2} + \ldots  =\\[2ex]
= \overline{b_1,b_2 b_3 \ldots}
= b_1 + \overline{0,b_2 b_3 \ldots}\\
%   0 \leqslant b_1 <N, ~~ \overline{0,b_2 b_3 \ldots} \in [0; 1)
\end{array}
\end{equation}
Таким образом, после умножения  $\Big\{ |X| \Big\} \in [0, 1)$ на~$N$ получаем значение в~диапазоне $[0, N)$.
Его целая часть "--- $b_1$, первая цифра $\Big\{ |X| \Big\}$ после запятой.
Дробная часть $\overline{0,b_2 b_3 \ldots}$ лежит в~диапазоне $[0, 1)$.
Умножая её на~$N$, можно найти вторую цифру после запятой и~так далее.

Таким образом, последовательность цифр $b_i$ можно получить по следующей итерационной схеме:
\begin{equation}
\left\{
\begin{array}{rcc}
b_i = \Big\lfloor X_{i-i}\cdot N \Big\rfloor\\
X_i = \Big\{ X_{i-i}\cdot N \Big\}\\
\end{array}
\right.,
\end{equation}
где $X_0 = \Big\{ |X| \Big\}$.

В~таблице~\ref{tab:digits-0.135-dec2bin} показан процесс перевода значения $X_0 =  0,135_{10}$ в~двоичную систему счисления.
Порядковый номер действия~$i$ соответствует позиции полученной цифры после запятой.
Сама полученная цифра~$b_i$ (целая часть результата действия) показана жирным шрифтом.

\begin{table}[!ht]
\caption{Перевод $0,135_{10}$ в~двоичную систему счисления}
\label{tab:digits-0.135-dec2bin}
\def\newsetcounter #1=#2
{%
  \newcounter{#1}%
  \setcounter{#1}{#2}%
}
\newsetcounter i=0
\newsetcounter j=8
\newsetcounter k=16
\renewcommand{\next}[1]{\addtocounter{#1}{1}\arabic{#1}}

\renewcommand\theadfont{\bfseries\small}
\newcommand{\hno}{
%  \begin{array}{c}
%     \text{\theadfont №}\\[-2ex]\text{\theadfont п/п}
%   \end{array}
i
}
% \newcommand{\hopline}{
%  \multicolumn{3}{c|}{\text{\theadfont Действие}}
% }
\newcommand{\hop}{
 \multicolumn{3}{c|}{\text{\theadfont Действие}}
}
% $\begin{array}{c@{}|@{~}lll|@{}}
% \hno&\hop\\\hline
% \nexti& 0,135 \cdot 2 &=& \mathbf{0},270 \\
% \nexti& 0,270 \cdot 2 &=& \mathbf{0},540 \\
% \nexti& 0,540 \cdot 2 &=& \mathbf{1},080 \\
% \nexti& 0,080 \cdot 2 &=& \mathbf{0},160 \\
% \nexti& 0,160 \cdot 2 &=& \mathbf{0},320 \\
% \nexti& 0,320 \cdot 2 &=& \mathbf{0},640 \\
% \nexti& 0,640 \cdot 2 &=& \mathbf{1},280 \\
% \nexti& 0,280 \cdot 2 &=& \mathbf{0},560 \\
% \end{array}$
% $\begin{array}{@{}c@{}|@{~}lll|@{}}
% \hno&\hop\\\hline
% \nexti& 0,560 \cdot 2 &=& \mathbf{1},120 \\
% \nexti& 0,120 \cdot 2 &=& \mathbf{0},240 \\
% \nexti& 0,240 \cdot 2 &=& \mathbf{0},480 \\
% \nexti& 0,480 \cdot 2 &=& \mathbf{0},960 \\
% \nexti& 0,960 \cdot 2 &=& \mathbf{1},920 \\
% \nexti& 0,920 \cdot 2 &=& \mathbf{1},840 \\
% \nexti& 0,840 \cdot 2 &=& \mathbf{1},680 \\
% \nexti& 0,680 \cdot 2 &=& \mathbf{1},360 \\
% \end{array}$
% $\begin{array}{@{}c@{}|@{~}lll}
% \hno&\hop\\\hline
% \nexti& 0,360 \cdot 2 &=& \mathbf{0},720 \\
% \nexti& 0,720 \cdot 2 &=& \mathbf{1},440 \\
% \nexti& 0,440 \cdot 2 &=& \mathbf{0},880 \\
% \nexti& 0,880 \cdot 2 &=& \mathbf{1},760 \\
% \nexti& 0,760 \cdot 2 &=& \mathbf{1},520 \\
% \nexti& 0,520 \cdot 2 &=& \mathbf{1},040 \\
% \nexti& 0,040 \cdot 2 &=& \mathbf{0},080 \\
% \nexti& 0,080 \cdot 2 &=& \mathbf{0},160 \\
% 
% \end{array}$

$$
% \begin{array}{|@{}c@{}|@{~}lll|@{}c@{}|@{~}lll|@{}c@{}|@{~}lll|}
\begin{array}{|c|lll|c|lll|c|lll|}
\hline
\hno&\hop&	\hno&\hop&	\hno&\hop	\\\hline
\next{i}& 0,135 \cdot 2 &=& \mathbf{0},270 &\next{j}& 0,560 \cdot 2 &=& \mathbf{1},120 &\next{k}& 0,360 \cdot 2 &=& \mathbf{0},720 \\
\next{i}& 0,270 \cdot 2 &=& \mathbf{0},540 &\next{j}& 0,120 \cdot 2 &=& \mathbf{0},240 &\next{k}& 0,720 \cdot 2 &=& \mathbf{1},440 \\
\next{i}& 0,540 \cdot 2 &=& \mathbf{1},080 &\next{j}& 0,240 \cdot 2 &=& \mathbf{0},480 &\next{k}& 0,440 \cdot 2 &=& \mathbf{0},880 \\
\next{i}& 0,080 \cdot 2 &=& \mathbf{0},160 &\next{j}& 0,480 \cdot 2 &=& \mathbf{0},960 &\next{k}& 0,880 \cdot 2 &=& \mathbf{1},760 \\
\next{i}& 0,160 \cdot 2 &=& \mathbf{0},320 &\next{j}& 0,960 \cdot 2 &=& \mathbf{1},920 &\next{k}& 0,760 \cdot 2 &=& \mathbf{1},520 \\
\next{i}& 0,320 \cdot 2 &=& \mathbf{0},640 &\next{j}& 0,920 \cdot 2 &=& \mathbf{1},840 &\next{k}& 0,520 \cdot 2 &=& \mathbf{1},040 \\
\next{i}& 0,640 \cdot 2 &=& \mathbf{1},280 &\next{j}& 0,840 \cdot 2 &=& \mathbf{1},680 &\next{k}& 0,040 \cdot 2 &=& \mathbf{0},080 \\
\next{i}& 0,280 \cdot 2 &=& \mathbf{0},560 &\next{j}& 0,680 \cdot 2 &=& \mathbf{1},360 &\next{k}& 0,080 \cdot 2 &=& \mathbf{0},160 \\
\hline
\end{array}
$$

\end{table}

На двадцать четвёртом шаге результат совпал с~полученным на четвёртом шаге.
Так как следующий шаг полностью определяется результатом предыдущего,
далее процесс повторится, и~получается бесконечная периодическая дробь:
\begin{equation}
0,135_{10} = 0,001(00010100011110101110)_2
\end{equation}
Таким образом, $X_0 = 0,135_{10}$ невозможно точно представить конечной двоичной дробью.

Рассмотрим приближённое значение $\widetilde{X_0} = 0,001000101_2$ и~переведём его обратно в~десятичную систему.
Все действия выполняются аналогично приведённым ранее  "--- на каждом шаге выполняется масштабирование в~$10_{10}=1010_2$ раз (таблица~\ref{tab:digits-0.135-bin2dec}).
Полученная на каждом шаге цифра~$b_i$ выделена жирным шрифтом и~для наглядности продублирована в~десятичном виде в~последнем столбце.

\begin{table}[!ht]
\caption{Перевод $0,001000101_2$ в~десятичную систему счисления}
\label{tab:digits-0.135-bin2dec}
% \def\newsetcounter #1=#2
% {%
%   \newcounter{#1}%
%   \setcounter{#1}{#2}%
% }
% \newsetcounter i=0
\setcounter{i}{0}
\renewcommand{\next}[1]{\addtocounter{#1}{1}\arabic{#1}}

\renewcommand\theadfont{\bfseries\small}
\newcommand{\hno}{
%  \begin{array}{c}
%     \text{\theadfont №}\\[-2ex]\text{\theadfont п/п}
%   \end{array}
i
}
\newcommand{\hop}{
 \multicolumn{5}{c|}{\text{\theadfont Действие}}
}

$$
\begin{array}{|c|l@{\cdot}rcr@{,}l|c|}
\hline
\hno&\hop	&(b_i)_{10}\\\hline
\next{i}& 0,001000101 	& 1010 &=& \mathbf{1}&01011001	& 1	\\
\next{i}& 0,01011001 	& 1010 &=& \mathbf{11}&0111101	& 3	\\
\next{i}& 0,0111101 	& 1010 &=& \mathbf{100}&110001	& 4	\\
\next{i}& 0,110001 	& 1010 &=& \mathbf{111}&10101	& 7	\\
\next{i}& 0,10101 	& 1010 &=& \mathbf{110}&1001 	& 6	\\
\next{i}& 0,1001 	& 1010 &=& \mathbf{101}&101 	& 5	\\
\next{i}& 0,101 	& 1010 &=& \mathbf{110}&01 	& 6	\\
\next{i}& 0,01 		& 1010 &=& \mathbf{10}&1 	& 2	\\
\next{i}& 0,1 		& 1010 &=& \mathbf{101}&0	& 5	\\
\hline
\end{array}
$$

\end{table}

На девятом шаге получаем нулевую дробную часть, то есть $\widetilde{X_0} = 0,001000101_2$ представляется конечной десятичной дробью:
\begin{equation}
\widetilde{X_0} = 0,001000101_2 = 0,134765625_{10}
\end{equation}
При округлении до трёх десятичных разрядов получаем исходное значение $X_0 = 0,135_{10}$.

% По определению позиционной записи:
% 
% $0,001000101_2 ~=~ \dfrac{1}{2^3} + \dfrac{1}{2^7} + \dfrac{1}{2^9}  ~=~ \dfrac{1}{8} + \dfrac{1}{128} + \dfrac{1}{512}  ~=$
% 
% $ = 0,134765625_{10}$ 






% \section{Двоичное представление неотрицательных целых чисел} 
\section{Двоичное представление беззнаковых целых чисел} 
% \section{Представление беззнаковых целых чисел в~вычислительных системах} 
\label{sec:digits-binnatural}
\index{Представление данных!натуральных!двоичное}

\epigraph{
Но да будет слово ваше: «да, да»; «нет, нет»; а~что сверх этого, то от лукавого.
}{Мф. 5:37}
\addquestion{Какие способы представления беззнаковых чисел используются в~ЭВМ?}


% целые, 2, 8, 16, перевод


% Как правило, вычислительные системы используют двоичную
В~настоящее время в~вычислительных системах повсеместно используются
элементы, которые могут находиться в~двух различных состояниях. % "--- $0$ и~$1$.
Соответственно, используется 
позиционная система счисления по основанию~$2$, в~которой используется всего две цифры "--- $0$ и~$1$
% двоичное представление данных 
(без нецифровых символов, так что работа с~отрицательными и~вещественными числами будет рассмотрена отдельно).
% % % Также наличие всего двух состояний не позволяет кодировать нецифровые символы, так что представление отрицательных и~вещественных чисел будет рассмотрено отдельно.
% 
% Для представления беззнаковых целых чисел в~вычислительной технике используется  позиционная система счисления по основанию $2$, в~которой используется всего две цифры "--- $0$ и~$1$.
\begin{equation}
\label{eq:digits:binary-exponentiation-def}
X = x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k = \overline{(x_k \ldots x_1 x_0)}_2, ~~x_i \in \{0,1\}
\end{equation}
например,
\begin{equation*}
\label{eq:digits:binary-exponentiation-sample}
109_{10} = 1 + 0\cdot 2 + 1\cdot 4 + 1\cdot 8 + 0\cdot 16 + 1\cdot 32 + 1\cdot 64 = 1101101_2.
\end{equation*}

Каждому двоичному разряду (биту, от binary digit) числа,  соответствует одна элементарная ячейка памяти, которая может находиться в~одном из двух состояний.
Эти состояния обычно также  обозначаются как $0$ и~$1$.
% так что значение ячейки равно соответствующему разряду числа.


Количество таких ячеек в~числе не может быть произвольным "--- оно определяется особенностями вычислительной системы
и~всегда кратно определённому числу, называемому размером байта.
Число минимально возможного размера, соответственно, называется \termin{байтом}.
В~настоящее время байт обычно содержит $8$ разрядов (бит), иногда "--- $16$, другие значения встречаются реже.
% Целые числа могут обычно содержать 2, 4, 8 байтов

Ячейка памяти не может быть пуста "--- в~ней содержится либо~$0$, либо~$1$. 
В~частности, хотя двоичное представление десятичного числа $109$ %как 
содержит семь цифр ($1101101$), 
записать в~восьмибитный байт можно только восемь ($01101101$).

% Такое представление называется натуральным двоичным кодом, так как оно,
Такая запись называется натуральным двоичным кодом (binary, сокращённо $bin$), так как она, 
с~одной стороны, используется для натуральных чисел (и ещё для нуля), а с~другой "--- является наиболее естественным их представлением.

Добавленный нулевой старший бит соответствует в~разложении числа слагаемому $0\cdot128 = 0$, то есть не влияет на значение числа.
% Старший бит занят незначащим нулём, который часто опускают на письме.
Таким образом, ноль в~старшем разряде (ведущий ноль) для числа в~натуральном двоичном коде является \termin{незначащим} и~часто опускается на письме.

% Из-за ограниченного количества разрядов, которые могут обрабатываться за процессором, разрядность чисел ограничена.
Минимальное число, которое можно записать в~восьми битах натуральным двоичным кодом "--- ноль ($0000\,0000$), максимальное "--- $255$ ($1111\,1111$).
В~общем случае $N$ битами можно записать числа от~$0$ до~$2^N$.

\subsection{Восьмеричное и~шестнадцатеричное представление}
\index{Представление данных!натуральных!восьмеричное}
\epigraph{\begin{limerick}
    Сухопарый старик из Болгарии\\
    Был других стариков сухопарее.\\
    Его прямо на стуле\\
    Рулоном свернули "---\\
    И хранили в чулане в Болгарии.
\end{limerick}
}
{\Lear}
% Хотя двоичная система экономичнее десятичной, 
Двоичная запись даже относительно небольших чисел выглядит очень громоздко и~трудно читается человеком.
Обычно для ввода-вывода используется десятичная запись, но в~некоторых случаях это неприемлемо.
% В~частности, права доступа Unix ...

Для того, чтобы придать числам компактный вид и~при этом сохранить их двоичную структуру, используются восьмеричная (octal, $oct$) и~шестнадцатеричная  (hexadecimal, $hex$) системы счисления.
Так как основания этих систем являются степенью двойки (то есть основания исходной системы),
нет необходимости в~сложных вычислениях.

\index{Представление данных!натуральных!восьмеричное}
Рассмотрим двоичную запись некоторого числа в~форме~\eqref{eq:digits:binary-exponentiation-def}, сгруппируем слагаемые по тройкам (если число разрядов не кратно трём, дополним число справа одним или двумя незначащими нулями) и~вынесем общий множитель за скобки:
\begin{equation}
\label{eq:digits:binary-2to8}
\begin{array}{c}
X =
\overline{(x_k \ldots x_1 x_0)}_2 =
% x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k = 
\\[1.5ex]
= \underbrace{x_0 + x_1\cdot 2 + x_2\cdot 2^2} + \underbrace{x_3\cdot 2^3 + x_4\cdot 2^4 + x_5\cdot 2^5} + 
\\
+\ldots +\underbrace{x_{3i}\cdot 2^{3i} +x_{3i+1}\cdot 2^{3i+1} + x_{3i+2}\cdot 2^{3i+2}}  + \ldots  = 
\\[2ex]
=(x_0 + x_1\cdot 2 + x_2\cdot 2^2) + (x_3  + x_4\cdot 2 + x_5\cdot 2^2)\cdot2^3 +
\\
+\ldots + (x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 2^2)\cdot 2^{3i} + \ldots
\end{array}
\end{equation}
Так как двоичные цифры %$x_i \in \{0,1\}$, 
% лежат в~диапазоне $0 \leqslant x_i \leqslant 1$,
могут принимать только значения~$0$ и~$1$,
значение внутри каждой скобки целое, неотрицательное и~не превышает семи:
\begin{equation}
\label{eq:digits:binary-2to8-onedigit}
0=
0 + 0\cdot 2 + 0\cdot 2^2 \leqslant
x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 2^2 
\leqslant 1 + 1\cdot 2 + 1\cdot 2^2 = 7
\end{equation}
коэффициенты при скобках имеют вид $2^{3i} = {(2^3)}^i = 8^i$.
Таким образом, получаем позиционную восьмеричную запись:
\begin{equation}
\label{eq:digits:binary-2to8-8}
\begin{array}{c}
X = 
(x_0 + x_1\cdot 2 + x_2\cdot 4) + (x_3  + x_4\cdot 2 + x_5\cdot 4)\cdot 8 +
\\
+\ldots + (x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 4)\cdot 8^{i} + \ldots =
\\[1.5ex]
= \widetilde{x_0} + \widetilde{x_1}\cdot 8 + \ldots + \widetilde{x_i}\cdot 8^i, ~~\widetilde{x_i} \in \{0, 1, 2,\ldots 7\}
\end{array}
\end{equation}
где $\widetilde{x_i} = x_{3i} + x_{3i+1}\cdot 2 + x_{3i+2}\cdot 4$.

% Практически
На практике для перевода двоичной записи в~восьмеричную достаточно разбить разряды на тройки и~затем заменить каждую тройку двоичных цифр одной восьмеричной (таблица~\ref{tab:digits-bin2oct}):
\begin{equation}
1101010_{2} = 001\,101\,010_{2} = 152_8
\end{equation}
для обратного преобразования каждая восьмеричная цифра заменяется тремя двоичными:
\begin{equation}
234_8 = 010\,011\,100_{2} = 10011100_2
\end{equation}


\begin{table}[!ht]

\caption{Соответствие двоичных триад восьмеричным цифрам}
\label{tab:digits-bin2oct}

% \renewcommand{\arraystretch}{1.5}
\begin{tabularx}{1\linewidth}{l|RRRRRRRR}
\hline
$bin$&$000$ & $001$ & $010$ &  $011$  & $100$ & $101$ & $110$ & $111$ \\
$oct$&$0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$  \\\hline

\end{tabularx}
\end{table}

Восьмеричное представление чисел используется, в~частности, для записи прав доступа в~Unix.

\index{Представление данных!натуральных!шестнадцатеричное}
Аналогично,
для перевода из двоичной системы в~шестнадцатеричную разряды необходимо группировать по четыре, так как $16 = 2^4$:
\begin{equation}
\label{eq:digits:binary-2to16}
\begin{array}{@{}c@{}}
X =
\overline{(x_k \ldots x_1 x_0)}_2 =
% x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k = 
\\[1.5ex]
= \underbrace{x_0 + x_1\cdot 2 + x_2\cdot 2^2 + x_3\cdot 2^3} + \underbrace{x_4\cdot 2^4 + x_5\cdot 2^5 + x_6 \cdot 2^6 + x_7 \cdot 2^7} + 
\\
+\ldots +\underbrace{x_{4i}\cdot 2^{4i} +x_{4i+1}\cdot 2^{4i+1} + x_{4i+2}\cdot 2^{4i+2}+ x_{4i+3}\cdot 2^{4i+3}}  + \ldots  = 
\\[2ex]
=(x_0 + x_1\cdot 2 + x_2\cdot 2^2 + x_3\cdot 2^3) + (x_4  + x_5\cdot 2 + x_6\cdot 2^2 + x_7 \cdot 2^3)\cdot2^4 +
\\
+\ldots + (x_{4i} + x_{4i+1}\cdot 2 + x_{4i+2}\cdot 2^2 +x_{4i+3}\cdot 2^{3})\cdot 2^{4i} + \ldots =
\\[1.5ex]
=(x_0 + x_1\cdot 2 + x_2\cdot 4 + x_3\cdot 8) + (x_4  + x_5\cdot 2 + x_6\cdot 4 + x_7 \cdot 8)\cdot 16 +
\\
+\ldots + (x_{4i} + x_{4i+1}\cdot 2 + x_{4i+2}\cdot 4 +x_{4i+3}\cdot 8)\cdot 16^{i} + \ldots =
\\[1.5ex]
= \widetilde{x_0} + \widetilde{x_1}\cdot 16 + \ldots + \widetilde{x_i}\cdot 16^i, ~~\widetilde{x_i} \in \{\hex{0, 1, 2,\ldots F}\}
\end{array}
\end{equation}
четыре двоичных разряда (тетрада) заменяются одним шестнадцатеричным (таблица~\ref{tab:digits-bin2hex})
\begin{equation}
1101010_{2} = 0110\,1010_{2} = 6A_{16}
\end{equation}
и~наоборот
\begin{equation}
\hex{2B3}_{16} = 0010\,1011\,0011_{2} = 001010110011_2
\end{equation}

\begin{table}[!ht]

\caption{Соответствие двоичных тетрад шестнадцатеричным цифрам}
\label{tab:digits-bin2hex}

% \renewcommand{\arraystretch}{1.5}
\begin{tabularx}{1\linewidth}{l|RRRRRRRR}
\hline
% $\overline{x_{4i}x_{4i+1}x_{4i+2}x_{4i+3}}$
$bin$&$0000$ & $0001$ & $0010$ &  $0011$  & $0100$ & $0101$ & $0110$ & $0111$ \\
% $\widetilde{x_i}$
$hex$&\hex{0} & \hex{1} & \hex{2} & \hex{3} & \hex{4} & \hex{5} & \hex{6} & \hex{7}  \\\hline

$bin$&$1000$ & $1001$ & $1010$ &  $1011$ & $1100$ & $1101$ & $1110$ & $1111$ \\
$hex$&\hex{8} & \hex{9} & \hex{A} & \hex{B}  & \hex{C} & \hex{D} & \hex{E} & \hex{F} \\\hline

\end{tabularx}
\end{table}

Шестнадцатеричное представление используется чаще, 
так как типичный байт (восемь бит) представляется двумя шестнадцатеричными цифрами.
Часто двоичный код разделяют на тетрады просто для читабельности.


Так как восьмеричная и~шестнадцатеричная системы счисления обычно используются для более компактной записи двоичного кода (содержимого памяти, в~котором не используются нецифровые символы), а~не как самостоятельные позиционные системы,  они традиционно применяются только для беззнаковых целых чисел.
Для более сложных структур данных под шестнадцатеричным представлением подразумевается шестнадцатеричное представление двоичного содержимого памяти, а~не самих данных.
% и,~соответственно, не используют нецифровых символов.
Так, запись $-1 = \hex{FFFF\,FFFF}$ обозначает, что значение $-1$ представляется в~памяти двоичным кодом $1111\,1111\,1111\,1111\,1111\,1111\,1111\,1111$, что в~шестнадцатеричном виде соответствует \hex{FFFF\,FFFF}.

В~частности, функции форматированного ввода-вывода стандартной библиотеки C++ (семейства $scanf$ и~$printf$) предоставляют два спецификатора для десятичного представления "--- десятичное знаковое \lstinline!%d! и~десятичное беззнаковое \lstinline!%u! представления, но шестнадцатеричное представление возможно только беззнаковое.


% \section{Двоичная арифметика в~вычислительных системах} 
\subsection{Беззнаковая арифметика в~вычислительных системах} 
\index{Представление данных!натуральных!арифметика}
\epigraph{Митрофан (вычисляя, шепчет).

% ...
Единожды ноль "--- ноль. Единожды ноль "--- ноль.

Нуль да нуль "--- нуль. Один да один... (Задумался.)
}{Д.\,И.\,Фонвизин}

% сложение/вычитание, умножение/деление
%и~двоичная арифметика.
% Кроме того,  

% Принцип 
Из-за единообразного представления чисел в~позиционных системах счисления 
арифметические действия во всех таких системах выполняется по одному и~тому же алгоритму.
Соответственно, %принцип двоичных  вычислений не отличается от привычного нам десятичного 
сложение, вычитание, умножение и~деление натуральных чисел, записанных в~двоичной системе, выполняется по привычной нам схеме «в~столбик»,
с~одним отличием: $1+1 = 10$.
% Есть только два отличия: во-первых, из-за основания, равного двум, %получаем 
% $1+1=10$;
% во-вторых, из-за ограниченной разрядности.

Арифметика в~вычислительных системах 
% двоична и~%
имеет ещё одно отличие от ручных вычислений, кроме основания системы счисления "--- ограниченность.
Производя вычисления вручную, можно потенциально обрабатывать сколь угодно большие числа.
Узел ЭВМ, предназначенный для выполнения арифметических действий, имеет фиксированную разрядность.
В~частности, $N$-разрядный сумматор "--- узел, выполняющий сложение "--- обрабатывает операнды, состоящие из~$N$ разрядов и~формирует результат также длины~$N$;
и~возможна ситуация, когда операнды арифметической операции попадают в~допустимый диапазон, а~её результат "--- уже нет.


Большинство современных процессоров семейства x86 имеет наборы команд %(и~соответствующие устройства) 
для \mbox{$N=8_{10}$,} $N=16_{10}$, $N=32_{10}$ и~$N=64_{10}$.
% Для простоты рассмотрим восьмиразрядные операции.
Для наглядности %рассмотрим 
все арифметические операции
будут рассматриваться
на примере $N=8_{10}$.
% Оба операнда, как и~результат сложения "--- восьмиразрядные.


% Рассмотрим двоичную арифметику

\subsubsection{Сложение и~вычитание}
\index{Представление данных!натуральных!сложение}

Сложение %, как и~в~любой позиционной системе,  
производится поразрядно, начиная с~младшего  разряда.
Если сумма младших разрядов равна или превышает $10$, возникает \termin{перенос в~старший разряд.}


Рассмотрим сложение двух чисел, представленных в~двоичном виде.
При сложении младших разрядов получаем $1 + 1 = 10$, то есть младший разряд суммы равен~$0$, а~к~более старшему разряду добавляется единица переноса (перенос показан мелким шрифтом над первым слагаемым).
Соответственно, для второго разряда получаем уже $1+1+1 = 11$ "--- единица в~соответствующем разряде суммы и~единица переноса "--- и~так далее:
% \begin{equation}
% \label{eq:digits-binadd-0}
% \begin{tikzpicture}[arythm-picture]
% \matrix (m) [arythm-matrix, row 1/.style={nodes={arythm-carry}}]
% {
% 1& & & & &1&1& \\
%  &1&0&1&0&0&1&1\\
%  &1&0&0&1&0&1&1\\[\rulerowsep]
% 1&0&0&1&1&1&1&0\\
% };
% \coordinate (lineleft) at ($0.6*(m-3-1.south west)+0.4*(m-4-1.north west)$); %(m-3-1.south west);
% \draw (lineleft) -- (lineleft-|m.east);
% 
% \node[left = of m-2-2.south west] {$+$};
% \end{tikzpicture}
% ~~~~
% (83_{10} + 75_{10} = 158_{10})
% \end{equation}
\begin{equation}
\label{eq:digits-binadd-a+b}
\begin{tikzlongsum}
{
 & & & &1&1& \\
1&0&1&0&0&1&1\\
 & & &1&0&1&1\\[\rulerowsep]
1&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
(83_{10} + 11_{10} = 94_{10})
\end{equation}
% В~результате получаем 
В~скобках показано десятичное представление слагаемых и~суммы.


% % В~примере \eqref{eq:digits-binadd-0} каждое из слагаемых занимает семь бит, а~сумма "--- восемь за счёт переноса из старшего разряда.
% % Длина суммы не может превышать длину слагаемых более чем на один разряд:
% Если при сложении старших разрядов возникнет перенос,  сумма будет длиннее слагаемых на один разряд:
% % (перенос из старшего разряда).
% \begin{equation}
% \label{eq:digits-binadd-0}
% \begin{tikzpicture}[arythm-picture]
% \matrix (m) [arythm-matrix, row 1/.style={nodes={arythm-carry}}]
% {
% 1&1&1&1&1&1&1& \\
%  &1&1&1&1&1&1&1\\
%  &1&1&1&1&1&1&1\\[\rulerowsep]
% 1&1&1&1&1&1&1&0\\
% };
% \coordinate (lineleft) at ($0.6*(m-3-1.south west)+0.4*(m-4-1.north west)$); %(m-3-1.south west);
% \draw (lineleft) -- (lineleft-|m.east);
% 
% \node[left = of m-2-2.south west] {$+$};
% \end{tikzpicture}
% ~~~~
% (127_{10} + 127_{10} = 254_{10})
% \end{equation}


% Ещё одна особенность 
Как уже было сказано, одной из особенностей
арифметики вычислительных систем %добавляет ограниченная разрядность чисел
является ограниченный диапазон представимых чисел.
% Возможна ситуация, когда операнды арифметической операции попадают в~допустимый диапазон, а~её результат "--- уже нет.
% Ограниченные размеры чисел добавляют ещё одну особенность арифметике в~вычислительных системах "---
% результаты некоторых
% В~таких случаях 
% Рассмотрим сложение чисел ограниченной разрядности на примере восьмиразрядных слагаемых.
% 
% Процессор не может обрабатывать числа %сколь угодно большой
% произвольной разрядности.
Все операции в~ЭВМ выполняется над числами фиксированной длины~$N$ (в~данном разделе рассматривается случай $N=8_{10}$).
% % , то есть %оба операнда
% % все обрабатываемые числа имеют длину~$N$
% % % Большинство современных процессоров является 64-разрядными, то есть может выполнять операции с~числами размером от байта (обычно занимающего восемь бит) до 64.

В~этом случае пример \eqref{eq:digits-binadd-a+b} корректнее было бы записать в~виде
\begin{equation}
\label{eq:digits-binadd-a+b-8}
\begin{tikzlongsum}
{
 & & & & &1&1& \\
0&1&0&1&0&0&1&1\\
0&0&0&0&1&0&1&1\\[\rulerowsep]
0&1&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
(83_{10} + 11_{10} = 94_{10})
\end{equation}
так как ни один из разрядов числа не может быть пуст.
Но такая запись тяжело читается, поэтому незначащие нули часто опускают.


Пусть необходимо прибавить к~максимальному представимому числу (для восьми разрядов это $1111\,1111=255_{10}$) единицу.
% Корректный результат данной операции равен $256_{10}$ и~не может быть представлен натуральным двоичным кодом в~восьми разрядах.
Сумма младших разрядов слагаемых даст ноль в~младшем разряде и~единицу переноса ($1+1=10$); 
сумма единицы переноса и~вторых разрядов слагаемых "--- ноль во втором разряде и~единицу переноса ($1+1+0=10$)
и~так далее.
Сумма старших (восьмых) разрядов тоже также даст ноль в~старшем (восьмом) разряде результата и~единицу переноса в~девятый разряд результата ($1+1+0=10$),
так что в~неограниченной арифметике (в~частности, при ручном расчёте) получилось бы
\begin{equation}
\label{eq:digits-binadd-ff+1-9}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 & & & & & & & &1\\[\rulerowsep]
1&0&0&0&0&0&0&0&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
~~~~
(255_{10} + 1_{10} = 256_{10})
\end{equation}
но у~восьмибитного результата нет девятого разряда "--- поэтому фактический результат будет равен нулю.
Такая ситуация называется \termin{беззнаковым переполнением.}
Бит переноса в~несуществующий разряд результата сохраняется в~специальной ячейке, называемой \termin{флагом переноса} (%Carry, в~архитектуре 
$CF$ "--- Carry flag).
\index{Флаги!переноса}
\begin{equation}
\label{eq:digits-binadd-ff+1}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 & & & & & & & &1\\[\rulerowsep]
 &0&0&0&0&0&0&0&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
% ~~~~
% \begin{tikzlongsum}
% {
% 1&1&1&1&1&1&1&1&1\\
%  &1&1&1&1&1&1&1&1\\
%  & & & & & & & &1\\[\rulerowsep]
% |[draw]|1
%  &0&0&0&0&0&0&0&0\\
% };
% \node[left = of m-2-2.south west] {$+$};
% \end{tikzlongsum}
~~~~
(255_{10} + 1_{10} = 0_{10})
~~~~
CF = 1
\end{equation}
В~общем случае в~$N$-битной арифметике $(2^N - 1) + 1 = 0$, при этом $CF=1$.

Флаг переноса не является частью числа, куда записывается результат.
Конструктивно ячейка~$CF$ принадлежит сумматору и,~если подряд выполняется несколько операций, каждая из них будет перезаписывать $CF$ новым значением.

Если размер суммы не превышает %восьми
$N$ разрядов, всё делается аналогично неограниченной арифметике и~флаг переноса $CF$ равен нулю.
\begin{equation}
\label{eq:digits-binadd-a+b-9E}
\begin{tikzlongsum}
{
1& & & & &1&1& \\
0&1&0&1&0&0&1&1\\
0&1&0&0&1&0&1&1\\[\rulerowsep]
1&0&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
(83_{10} + 75_{10} = 158_{10})
~~~~
CF = 0
\end{equation}

Одного разряда для флага переноса достаточно.
Даже при сложении двух максимально возможных восьмибитных беззнаковых значений возникает перенос в~девятый, но не в~десятый разряд:
\begin{equation}
\label{eq:digits-binadd-ff+ff}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 &1&1&1&1&1&1&1&1\\[\rulerowsep]
 &1&1&1&1&1&1&1&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
~~~~
(255_{10} + 255_{10} = 254_{10})
~~~~
CF = 1
\end{equation}

Таким образом, в~ЭВМ реализована циклическая двоичная арифметика: при сложении операндов $a$ и~$b$ разрядности~$N$ результат фактически равен~$(a+b) \Mod 2^N$.
Программист может %учесть этот флаг %и~реализовать сложение больших чисел 
% вручную.
% узнать о~переносе из старшего разряда, анализируя флаг переноса.
определить корректность результата, анализируя флаг переноса из старшего разряда~$CF$.

Вычитание выполняется, как и~сложение, %в~столбик 
поразрядно.
\index{Представление данных!натуральных!вычитание}
При необходимости выполняется заём из старшего разряда:
\begin{equation}
\label{eq:digits-binadd-a-b}
\begin{tikzlongsum}
{
\centerdot&\centerdot&\centerdot%\bullet
     & & & & \\
1&0&0&0&0&1&1\\
 & & &1&0&0&1\\[\rulerowsep]
 &1&1&1&0&1&0\\
};
\node[left = of m-2-1.south west] {$-$};
\end{tikzlongsum}
~~~~
(67_{10} - 9_{10} = 58_{10})
\end{equation}
В~случае, когда уменьшаемое меньше вычитаемого, возможен заём из несуществующего девятого разряда.
Такая ситуация также отмечается  единичным значением флага переноса $CF$:
\begin{equation}
\label{eq:digits-binadd-a-b-neg}
\begin{tikzlongsum}
{
\centerdot&\centerdot
 & & & &\centerdot&\centerdot& & \\
 &0&0&0&0&1&0&0&1\\
 &0&1&0&0&0&0&1&1\\[\rulerowsep]
 &1&1&0&0&0&1&1&0\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
~~~~
(9_{10} - 67_{10} = 198_{10})
~~~~
CF = 1
\end{equation}
Как можно заметить, в~неограниченной арифметике $58_{10} + 198_{10} = 256_{10}$.

Таким образом, вычитание, реализованное в~ЭВМ, также циклическое:
разность  $a$ и~$b$ разрядности~$N$  равна~$(a-b) \Mod 2^N$, где под знаком <<$-$>> подразумевается вычитание в~неограниченной арифметике.
Здесь остаток \mbox{$(a-b) \Mod 2^N$} всегда неотрицателен (то есть вычисляется по правилам математики, а~не C++).
Корректность результата можно определить, анализируя флаг~$CF$, показывающий также заём в~старший разряд.

В~частности,
\begin{equation}
\label{eq:digits-binadd-0-1}
\begin{tikzlongsum}
{
\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot& \\
 &0&0&0&0&0&0&0&0\\
 & & & & & & & &1\\[\rulerowsep]
 &1&1&1&1&1&1&1&1\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
~~~~
(0_{10} - 1_{10} = 255_{10})
~~~~
CF = 1
\end{equation}

Циклические сложение и~вычитание (сложение и~вычитание по модулю~$2^N$) коммутативны и~ассоциативны.

\subsubsection{Умножение и~деление}
\index{Представление данных!натуральных!умножение}

При умножении двух чисел первый множитель последовательно умножается на каждый разряд второго множителя и~сдвигается %в~сторону старших разрядов
влево на соответствующее количество разрядов (что соответствует умножению на~$10$, то есть на два).
Затем результаты складываются:
\begin{equation}
\label{eq:digits-binmul-axb}
% \begin{tikzpicture}[arythm-picture]
% \matrix (m) [arythm-matrix, row 3/.style={nodes={arythm-carry}}]
% {
%  & & &1&0&1&0&0&1&1\\
%  & & & & & &1&0&1&1\\[\rulerowsep]
%  &1&1&1&1&1&1&1& & \\
%  & & &1&0&1&0&0&1&1\\
%  & &1&0&1&0&0&1&1& \\
%  &0&0&0&0&0&0&0& & \\
% 1&0&1&0&0&1&1& & & \\[\rulerowsep]
% 1&1&1&0&0&1&0&0&0&1\\
% };
% \drawrulerow[3]{2}
% \drawrulerow[1]{7}
% 
% \node[left = of m-1-4.south west] {$\times$};
% \end{tikzpicture}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix]
{
 & & &1&0&1&0&0&1&1\\
 & & & & & &1&0&1&1\\[\rulerowsep]
 & & &1&0&1&0&0&1&1\\
 & &1&0&1&0&0&1&1& \\
 &0&0&0&0&0&0&0& & \\
1&0&1&0&0&1&1& & & \\[\rulerowsep]
1&1&1&0&0&1&0&0&0&1\\
};
\drawrulerow[3]{2}
\drawrulerow[1]{6}
\node[left = of m-1-4.south west] {$\times$};
\end{tikzpicture}
~~~~
(83_{10} \cdot 11_{10} = 913_{10})
\end{equation}
Как видно из \eqref{eq:digits-binmul-axb}, разрядность произведения может превысить разрядность множителей более чем на один бит.
Поэтому %самые старые 
большинство команд умножения  процессоров семейства x86, работающие с~операндами размера~$N$, возвращают результат размера~$2N$.

Действительно, рассмотрим умножение двух максимально возможных восьмибитных беззнаковых значений.
В умножении столбиком, как правило, переносы между разрядами не записываются, а~запоминаются, но в~данном примере ввиду его громоздкости перенос %в~десятичной форме
показан мелким шрифтом в~следующей строке после множителей.
Для наглядности столбцы, соответствующие тетрадам произведения, отделены пробелами.
\begin{equation}
\label{eq:digits-binmul-ffxff}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, row 3/.style={nodes={arythm-carry}}]
{
 & & & &[0.5ex] & & & &[0.5ex]1&1&1&1&[0.5ex]1&1&1&1\\
 & & & & & & & &1&1&1&1&1&1&1&1\\[\rulerowsep]
1&2&3&4&5&6&7&7&6&5&4&3&2&1& & \\
 & & & & & & & &1&1&1&1&1&1&1&1\\
 & & & & & & &1&1&1&1&1&1&1&1& \\
 & & & & & &1&1&1&1&1&1&1&1& & \\
 & & & & &1&1&1&1&1&1&1&1& & & \\
 & & & &1&1&1&1&1&1&1&1& & & & \\
 & & &1&1&1&1&1&1&1&1& & & & & \\
 & &1&1&1&1&1&1&1&1& & & & & & \\
 &1&1&1&1&1&1&1&1& & & & & & & \\[\rulerowsep]
1&1&1&1&1&1&1&0&0&0&0&0&0&0&0&1\\
};
\drawrulerow[8]{2}
\drawrulerow[1]{11}

\node[left = of m-1-9.south west] {$\times$};
\end{tikzpicture}
~~~~
(255_{10} \cdot 255_{10} = 65025_{10})
\end{equation}
Таким образом, для произведения двух восьмибитных множителей достаточно шестнадцати разрядов.

% Если рассматривать только $N$ разрядов произведения 


Деление также выполняется по классической схеме:
\index{Представление данных!натуральных!деление}
\begin{equation}
\label{eq:digits-bindiv-a/b-full}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix]
{
1&0&1&0&0&1&1	&[1ex]	1&0&1&1\\
0&0&0&0& & & 	& 	0&1&1&1& \\[\rulerowsep]
1&0&1&0&0& & \\
 &1&0&1&1& &\\[\rulerowsep]
 &1&0&0&1&1\\
 & &1&0&1&1& & \\[\rulerowsep]
 & &1&0&0&0&1 \\
 & & &1&0&1&1& & \\[\rulerowsep]
 & & & &1&1&0& & \\
};
\draw ($0.5*(m-1-7.north east) + 0.5*(m-1-8.north west)$) -- coordinate (lineleft) ($0.5*(m-2-7.south east) + 0.5*(m-2-8.south west)$);
\draw (lineleft) -- (lineleft-|m.east);

\node[left = of m-1-1.south west] {$-$};
\drawclinerow[2]{1}{4}

\node[left = of m-3-1.south west] {$-$};
\drawclinerow[4]{1}{5}

\node[left = of m-5-2.south west] {$-$};
\drawclinerow[6]{2}{6}

\node[left = of m-7-3.south west] {$-$};
\drawclinerow[8]{3}{7}

\end{tikzpicture}
~~~~
(83_{10} / 11_{10} = 7_{10}~\text{и~$6_{10}$ в~остатке})
\end{equation}
обычно при ручном счёте нулевые вычитаемые опускают:
\begin{equation}
\label{eq:digits-bindiv-a/b}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix]
{
1&0&1&0&0&1&1	&[1ex]	1&0&1&1\\
 &1&0&1&1& & 	& 	1&1&1& \\[\rulerowsep]
 &1&0&0&1&1\\
 & &1&0&1&1& & \\[\rulerowsep]
 & &1&0&0&0&1 \\
 & & &1&0&1&1& & \\[\rulerowsep]
 & & & &1&1&0& & \\
};
\draw ($0.5*(m-1-7.north east) + 0.5*(m-1-8.north west)$) -- coordinate (lineleft) ($0.5*(m-2-7.south east) + 0.5*(m-2-8.south west)$);
\draw (lineleft) -- (lineleft-|m.east);

\node[left = of m-1-1.south west] {$-$};
\drawclinerow[2]{1}{5}

\node[left = of m-3-2.south west] {$-$};
\drawclinerow[4]{2}{6}

\node[left = of m-5-3.south west] {$-$};
\drawclinerow[6]{3}{7}

\end{tikzpicture}
~~~~
(83_{10} / 11_{10} = 7_{10}~\text{и~$6_{10}$ в~остатке})
\end{equation}
Так как деление обратно умножению,
большинство команд деления процессоров семейства x86 для делителя и~частного размера~$N$ используют делимое  размера~$2N$.
%  и~возвращают результат размера~$N$





\section{Представление отрицательных чисел}
\index{Представление данных!знаковых}
\label{sec:digits-negcodes}
\epigraph{
Каждому виду симметрии соответствует свой закон сохранения.
}{А.\,Б.\,Мигдал}
% http://physiclib.ru/books/item/f00/s00/z0000024/st014.shtml
\addquestion{Какие способы представления знаковых чисел используются в~ЭВМ?}

% Часто неотрицательных чисел недостаточно для решения задачи.
% Необходимо использовать целые числа со знаком.

Натуральный двоичный код позволяет кодировать только неотрицательные числа.
При этом в~некоторых задачах необходимы целые числа со знаком.
% Но, так как память компьютера состоит только из битов, которые принимают
В~ячейках памяти нельзя непосредственно сохранить знак числа, так что знаковые и,~в~частности, отрицательные числа необходимо представить в~виде комбинации нулей и~единиц.

Рассмотрим различные способы кодирования знаковых чисел на восьми разрядах.
Всего в~восьмиразрядную ячейку можно записать $256$ различных комбинаций нулей и~единиц.
Каждой из этих комбинаций соответствует некоторое неотрицательное число~$u$ в~натуральном двоичном коде.

Для кодирования знаковых чисел необходимо поставить в~соответствие каждой комбинации новое число (декодированное значение $x$), причём около половины из~этих чисел должны быть отрицательными.
Это можно сделать различными способами.

К~представлению знаковых чисел можно сформулировать следующие пожелания:
\begin{itemize}
\item код должен позволять представить 
с~помощью $N$ битов
% числа в~диапазоне около $-\frac{N}{2}$ до  $+\frac{N}{2}$;
все целые числа некоторого диапазона %$\nu_1 \leqslant x \leqslant \nu_2$.
$x \in [\nu_1, \nu_2]$.
Представимый диапазон $[\nu_1, \nu_2]$ должен включать ноль и~примерно равное количество положительных и~отрицательных чисел;

\item представление неотрицательных чисел должно совпадать с~их натуральным двоичным кодом;
\item должен существовать простой способ различения положительных и~отрицательных чисел;
\item сложение и~вычитание должно выполняться с~помощью того же сумматора, что и~сложение и~вычитание неотрицательных чисел.
% (во многих ранних ЭВМ не было  команд умножения и~деления).
\end{itemize}

Три наиболее известных способа представления знаковых чисел 
на примере восьми разрядов
представлены в~таблицах~\ref{tab:digits-neg-encode}  и~\ref{tab:digits-neg-decode}.


\begin{table}[p]

\caption{Различные способы представления знаковых чисел (кодирование)}
\label{tab:digits-neg-encode}

\begingroup

\renewcommand\theadfont{\bfseries\small}
\newcommand{\tdhead}[1]{\multicolumn{3}{c}{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}
\newcommand{\tdheadline}[1]{\multicolumn{3}{c|}{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}
\begin{tabularx}{1\linewidth}{R|ccr|ccr|ccr}
\multicolumn{1}{r|}{\llap{{\theadfont Значение}}}
&\multicolumn{9}{c}{ \theadlong{Код $u$}}\\\hline
\multirow{2}{*}{$x_{10}$}	
& \tdheadline{Величина\\со знаком}
& \tdheadline{Код \\с~избытком~128}
& \tdhead{Дополнительный код\\(дополнение до 2)} 
\\
&$u_{2}$&$u_{16}$&$u_{10}$&$u_{2}$&$u_{16}$&$u_{10}$&$u_{2}$&$u_{16}$&$u_{10}$
\\\hline
	$-128$	&\multicolumn{3}{c|}{отсутствует}      	&$0000\,0000$ &	\hex{00}& $0$   	&$1000\,0000$ &	\hex{80}& $128$   	\\%\hline
	$-127$	&$1111\,1111$ &	\hex{FF}& $255$   	&$0000\,0001$ &	\hex{01}& $1$   	&$1000\,0001$ &	\hex{81}& $129$   	\\%\hline
	$-126$	&$1111\,1110$ &	\hex{FE}& $254$   	&$0000\,0010$ &	\hex{02}& $2$   	&$1000\,0010$ &	\hex{82}& $130$   	\\%\hline
	$-125$	&$1111\,1101$ &	\hex{FD}& $253$   	&$0000\,0011$ &	\hex{03}& $3$   	&$1000\,0011$ &	\hex{83}& $131$   	\\%\hline
	$-124$	&$1111\,1100$ &	\hex{FC}& $252$   	&$0000\,0100$ &	\hex{04}& $4$   	&$1000\,0100$ &	\hex{84}& $132$   	\\%\hline
% 	$-123$	&$1111\,1011$ &	\hex{FB}& $251$   	&$0000\,0101$ &	\hex{05}& $5$   	&$1000\,0101$ &	\hex{85}& $133$   	\\%\hline
% 	$-122$	&$1111\,1010$ &	\hex{FA}& $250$   	&$0000\,0110$ &	\hex{06}& $6$   	&$1000\,0110$ &	\hex{86}& $134$   	\\%\hline
	$\ldots$&$\ldots$     &	$\ldots$&$\ldots$	&$\ldots$     &	$\ldots$&$\ldots$	&$\ldots$     &	$\ldots$&$\ldots$	\\
	$-4$	&$1000\,0100$ &	\hex{84}& $132$ 	&$0111\,1100$ &	\hex{7C}& $124$ 	&$1111\,1100$ &	\hex{FC}& $252$ 	\\%\hline
	$-3$	&$1000\,0011$ &	\hex{83}& $131$ 	&$0111\,1101$ &	\hex{7D}& $125$ 	&$1111\,1101$ &	\hex{FD}& $253$ 	\\%\hline
	$-2$	&$1000\,0010$ &	\hex{82}& $130$ 	&$0111\,1110$ &	\hex{7E}& $126$ 	&$1111\,1110$ &	\hex{FE}& $254$ 	\\%\hline
	$-1$	&$1000\,0001$ &	\hex{81}& $129$ 	&$0111\,1111$ &	\hex{7F}& $127$ 	&$1111\,1111$ &	\hex{FF}& $255$		\\   \hline
\multirow{2}{*}{$0$}&$1000\,0000$ &	\hex{80}& $128$ &\multirow{2}{*}{$1000\,0000$}&	\multirow{2}{*}{\hex{80}}& \multirow{2}{*}{$128$}	&\multirow{2}{*}{$0000\,0000$} &	\multirow{2}{*}{\hex{00}}& \multirow{2}{*}{$0$}	\\
		&$0000\,0000$ &	\hex{00}& $0$   	&	      &		&		&		&	&		\\\hline

	$+1$	&$0000\,0001$ &	\hex{01}& $1$ 		&$1000\,0001$ &	\hex{81}& $129$ 	&$0000\,0001$ &	\hex{01}& $1$ 		\\%\hline
	$+2$	&$0000\,0010$ &	\hex{02}& $2$ 		&$1000\,0010$ &	\hex{82}& $130$ 	&$0000\,0010$ &	\hex{02}& $2$ 		\\%\hline
	$+3$	&$0000\,0011$ &	\hex{03}& $3$ 		&$1000\,0011$ &	\hex{83}& $131$ 	&$0000\,0011$ &	\hex{03}& $3$ 		\\%\hline
	$\ldots$&$\ldots$     &	$\ldots$&$\ldots$	&$\ldots$     &	$\ldots$&$\ldots$	&$\ldots$     &	$\ldots$&$\ldots$	\\
% 	$+121$	&$0111\,1001$ &	\hex{79}& $121$ 	&$1111\,1001$ &	\hex{F9}& $249$ 	&$0111\,1001$ &	\hex{79}& $121$ 	\\%\hline
% 	$+122$	&$0111\,1010$ &	\hex{7A}& $122$ 	&$1111\,1010$ &	\hex{FA}& $250$ 	&$0111\,1010$ &	\hex{7A}& $122$ 	\\%\hline
	$+123$	&$0111\,1011$ &	\hex{7B}& $123$ 	&$1111\,1011$ &	\hex{FB}& $251$ 	&$0111\,1011$ &	\hex{7B}& $123$ 	\\%\hline
	$+124$	&$0111\,1100$ &	\hex{7C}& $124$ 	&$1111\,1100$ &	\hex{FC}& $252$ 	&$0111\,1100$ &	\hex{7C}& $124$ 	\\%\hline
	$+125$	&$0111\,1101$ &	\hex{7D}& $125$ 	&$1111\,1101$ &	\hex{FD}& $253$ 	&$0111\,1101$ &	\hex{7D}& $125$  	\\%\hline
	$+126$	&$0111\,1110$ &	\hex{7E}& $126$ 	&$1111\,1110$ &	\hex{FE}& $254$ 	&$0111\,1110$ &	\hex{7E}& $126$  	\\%\hline
	$+127$	&$0111\,1111$ &	\hex{7F}& $127$		&$1111\,1111$ &	\hex{FF}& $255$ 	&$0111\,1111$ &	\hex{7F}& $127$  	\\\hline
\end{tabularx}

\endgroup
\end{table}

Таблица~\ref{tab:digits-neg-encode} показывает кодирование  знаковых чисел~$x$ различными способами.
Первый столбец содержит десятичное представление знакового числа~$x$,
следующая группа из трёх столбцов показывает двоичный код $x$ в~виде величины со знаком, 
% а~также шестнадцатеричное и~десятичное беззнаковое представление этого кода и~
шестнадцатеричное представление этого кода, а~также десятичное представление кода (так как это представление кода, а~не самого числа~$x$, оно беззнаковое).
Аналогично, следующая группа из трёх столбцов содержит код с~избытком (представлен избыток 128) и~его шестнадцатеричное и~десятичное представления,
третья группа "--- дополнительный код.


Таблица~\ref{tab:digits-neg-decode} показывает декодирование кода~$u$.
Первые три столбца содержат код~$u$ в~десятичном, шестнадцатеричном и~двоичном виде,
четвёртый "--- значение, получаемое при декодировании~$u$ как величины со знаком, 
пятый "--- при декодировании как кода с~избытком 128,
шестой "--- как дополнительного кода.


\begin{table}[p]

% \caption{Различные способы интерпретации двоичных кодов (декодирование)}
\caption{Различные способы представления знаковых чисел (декодирование)}
\label{tab:digits-neg-decode}
\begingroup
\renewcommand\theadfont{\bfseries\small}
\newcommand{\tdhead}[1]{\multicolumn{1}{c}{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}
\begin{tabularx}{1\linewidth}{rrc|R<{\hspace{1em}\strut}RR}
% \hline
\multicolumn{3}{c|}{ \theadlong{Код~$u$}} & \multicolumn{3}{c}{ \theadlong{Декодированное значение~$x$}}  \\\hline
$u_{10}$&$u_{16}$&$u_{2}$
				& \tdhead{Величина\\со знаком}
					& \tdhead{Код \\с~избытком~128}
& %\multicolumn{1}{c}
\tdhead{Дополнительный код\\(дополнение до 2)} 	\\\hline
 $0$   &	\hex{00}	&$0000\,0000$ &	$+0$ 	&	$-128$	&	$0$		\\%\hline
 $1$   &	\hex{01}	&$0000\,0001$ &	$+1$	&	$-127$	&	$+1$		\\%\hline
 $2$   &	\hex{02}	&$0000\,0010$ &	$+2$	&	$-126$	&	$+2$		\\%\hline
 $3$   &	\hex{03}	&$0000\,0011$ &	$+3$	&	$-125$	&	$+3$		\\%\hline
 $4$   &	\hex{04}	&$0000\,0100$ &	$+4$	&	$-124$	&	$+4$		\\%\hline
 $5$   &	\hex{05}	&$0000\,0101$ &	$+5$	&	$-123$	&	$+5$		\\%\hline
 $6$   &	\hex{06}	&$0000\,0110$ &	$+6$	&	$-122$	&	$+6$		\\%\hline
$\ldots$&	$\ldots$	&$\ldots$     &	$\ldots$&	$\ldots$&	$\ldots$	\\
 $124$ &	\hex{7C}	&$0111\,1100$ &	$+124$	&	$-4$	&	$+124$		\\%\hline
 $125$ &	\hex{7D}	&$0111\,1101$ &	$+125$	&	$-3$	&	$+125$		\\%\hline
 $126$ &	\hex{7E}	&$0111\,1110$ &	$+126$	&	$-2$	&	$+126$		\\%\hline
 $127$ &	\hex{7F}	&$0111\,1111$ &	$+127$	&	$-1$	&	$+127$		\\\hline
 $128$ &	\hex{80}	&$1000\,0000$ &	$-0$	&	$0$	&	$-128$		\\%\hline
 $129$ &	\hex{81}	&$1000\,0001$ &	$-1$	&	$+1$	&	$-127$		\\%\hline
 $130$ &	\hex{82}	&$1000\,0010$ &	$-2$	&	$+2$	&	$-126$		\\%\hline
 $131$ &	\hex{83}	&$1000\,0011$ &	$-3$	&	$+3$	&	$-125$		\\%\hline
$\ldots$&	$\ldots$	&$\ldots$     &	$\ldots$&	$\ldots$&	$\ldots$	\\
 $249$ &	\hex{F9}	&$1111\,1001$ &	$-121$	&	$+121$	&	$-7$		\\%\hline
 $250$ &	\hex{FA}	&$1111\,1010$ &	$-122$	&	$+122$	&	$-6$		\\%\hline
 $251$ &	\hex{FB}	&$1111\,1011$ &	$-123$	&	$+123$	&	$-5$		\\%\hline
 $252$ &	\hex{FC}	&$1111\,1100$ &	$-124$	&	$+124$	&	$-4$		\\%\hline
 $253$ &	\hex{FD}	&$1111\,1101$ &	$-125$	&	$+125$	&	$-3$		\\%\hline
 $254$ &	\hex{FE}	&$1111\,1110$ &	$-126$	&	$+126$	&	$-2$		\\%\hline
 $255$ &	\hex{FF}	&$1111\,1111$ &	$-127$	&	$+127$	&	$-1$		\\\hline
\end{tabularx}
\endgroup
\end{table}




Для кодирования целых знаковых чисел как самостоятельных величин в~ЭВМ используется дополнительный код, соответствующих всем  перечисленным выше критериям.
Представление в~виде величины со знаком или кода с~избытком  используются в~кодировании компонент  вещественных чисел.


\subsection{Величина со знаком}
\index{Представление данных!знаковых!код со знаком}
\epigraph{
Зеркальная симметрия законов природы означает, что если две экспериментальные установки отличаются только тем, что одна есть зеркальное отражение другой, то такие установки работают совершенно одинаково. 
}{А.\,Б.\,Мигдал}

Наиболее очевидный способ кодирования чисел со знаком "--- выделить один бит (обычно старший) для хранения знака, а~в~оставшихся хранить абсолютную величину (модуль) числа (столбец «Величина со~знаком» таблицы~\ref{tab:digits-neg-decode}).
Такой код легко читается человеком и~для неотрицательных чисел совпадает с~натуральным.
Код в~виде величины со знаком из $N$ разрядов позволяет представить числа в~диапазоне $\left[-2^{N-1}+1, 2^{N-1}-1\right]$ 
"--- всего $2^{N}-1$ значений, хотя $N$ разрядов вмещают $2^{N}$ различных двоичных кодов.

Это связано с~тем, что данный код включает два нуля: $+0$, совпадающий с~беззнаковым нулём, и~$-0$ "--- с~единичным знаковым битом и~нулевым модулем.

Сложение таких чисел
с~использованием беззнакового сумматора
требует большого числа дополнительных действий (в~случае слагаемых одного знака модули будут складываться, для разных знаков "--- вычитаться).

Напротив, умножение и~деление отрицательных чисел, представленных в~виде величины со знаком, выполняется как беззнаковое умножение или деление величин,
дополненное сложением знаков по модулю~$2$ ($\XOR$).
% Но это не было  существенным аргументом «за», так как способ кодирования отрицательных чисел сложился в~ранний период развития вычислительной техники.
Но, так как способ кодирования отрицательных чисел сложился в~ранний период развития вычислительной техники, 
когда аппаратно были реализованы только сложение и~вычитание
(умножение и~деление выполнялись подпрограммами), 
это достоинство оказалась несущественным. % для целых чисел.

Соответственно, код в~виде величины со знаком не используется для целых чисел.
Идея раздельного кодирования знака и~абсолютной величины используется при кодировании вещественных чисел с~плавающей запятой.



\subsection{Код с~избытком}
\index{Представление данных!знаковых!код с~избытком}
\epigraph{
 Означает ли это, что наше пространство не симметрично, или же опять нарушение есть свойство частиц, а не пространства? 
}{А.\,Б.\,Мигдал}

Также можно задать некоторую константу $\xi$ и~поставить в~соответствие числу $x$ значение $x+\xi$.
% Натуральный код  $x+\xi$ для $x$ будет называться кодом с~избытком $\xi$.
После этого к~полученному значению $x+\xi$ применяется беззнаковое кодирование.
Соответственно,
\begin{equation}
\label{eq:digits-codes-izb}
x = u -\xi,
\end{equation}
где $u$ "--- код, $x$ "--- закодированное значение.

Подобный код позволяет представить $N$ разрядами числа в~диапазоне $\left[-\xi, 2^{N}-\xi-1 \right]$
и~называется кодом с~избытком~$\xi$.
В~частности, запись года двумя цифрами "--- код с~избытком~$\xi=-2000$.

В~пятом столбце таблицы~\ref{tab:digits-neg-decode} показан код с~избытком~$128$.

В~данном коде присутствует только один ноль, но его код не равен $0000\,0000$; %беззнаковому нулю
кроме того, положительные числа кодируются не натуральным кодом.

Для сложения и~вычитания чисел, представленных в~коде с~избытком, можно воспользоваться беззнаковым сумматором, но понадобится коррекция полученного результата.
В~частности, сложение двух чисел с~избытком  $\xi$ даст результат с~избытком $2\xi$, так что необходимо вычесть $\xi$.
Таким образом, сложение или вычитание таких чисел требует двух операций сложения/вычитания.

% В~настоящее время представление в~виде величины со знаком или кода с~избытком %практически 
% не используется для внутреннего представления в~вычислительных системах; 
% тем не менее, обе эти идеи используются для представления вещественных чисел.

% Также кодирование
Код с~избытком используется
% как элемент кодирования
для представления порядка
вещественных чисел с~плавающей запятой, 
\index{Представление данных!вещественных!с~плавающей запятой}
а~также в~специальной аппаратуре или для передачи данных по каналам связи, если диапазон данных невелик, но заведомо несимметричен относительно нуля
(в~частности, год или температура в~помещении в~градусах Цельсия).


\subsection{Дополнительный код}
\index{Представление данных!знаковых!дополнительный код}
\epigraph{
Никакие законы природы не изменятся, если все заряды в~мире изменить на обратные и~одновременно произвести зеркальное отражение...

Но и~эта симметрия оказалась неточной.
}{А.\,Б.\,Мигдал}


% И~наконец, можно для положительных чисел использовать натуральный двоичный код, а~отрицательные значения $-x$  закодировать как результат вычитания $0-x$, то есть, с~учётом цикличности сложения и~вычитания в~ЭВМ, как $2^N - x$.
% 
% Сложение и~вычитание знаковых чисел в~дополнительном коде выполняется беззнаковым сумматором за один шаг.


Для того, чтобы записывать ноль и~положительное число $x$ натуральным двоичным (прямым) кодом и~при этом иметь возможность %складывать и~вычитать
пользоваться для знаковых чисел беззнаковым сумматором без коррекции результата, 
необходимо записывать отрицательное число $-x$ тем кодом, который получается в~результате беззнакового вычитания $0-x$ (с~учётом цикличности сложения и~вычитания в~ЭВМ беззнаковое представление этого кода $2^N - x$).
% \begin{equation}
% \label{eq:digits-codes-dop}
% decode_s(\hi) = 
% \left\{
% \begin{array}{ll}
% x, & x < 2^N - x\\
% 0-x, & \\
% \end{array}
% \right.
% \end{equation}

Такой код называется дополнительным (или дополнением до двух) и~представлен в~последнем столбце таблицы~\ref{tab:digits-neg-decode}.
В~таблице видно, что 
с~помощью восьми двоичных разрядов можно представить
\begin{itemize}
\item одно значение нуля ($0 = -0 = 0000\,0000$);
\item положительные значения от~$1$ до~$127$, представленные в~натуральном двоичном коде,
% , с~нулевым старшим битом;
которым соответствуют коды от~$0000\,0001$ до~$0111\,1111$;
\item соответствующие им отрицательные значения от~$-1$ до~$-127$
% с~единичным старшим битом.
% Таким образом, старший бит нуля и~положительных чисел равен нулю, старший бит отрицательных чисел "--- единице.
% \item код $128$,
"--- коды от~$1111\,1111$ ($0-1$) до~$1000\,0001$ ($0-127$);
\end{itemize}
Старший бит называется знаковым, так как у~нуля и~положительных чисел он равен нулю, у~отрицательных "--- единице.
Соответственно, код $1000\,0000$, который можно в~принципе трактовать и~как~$128$, и~как~$0-128=-128$, считается кодом отрицательного числа $-128$.

% восьмиразрядные коды можно интерпретировать следующим образом:
% \begin{itemize}
% \item одно значение нуля ($0 = -0 = 0000\,0000$);
% \item положительные значения от~$1$ до~$127$, представленные в~натуральном двоичном коде;
% % , с~нулевым старшим битом;
% "--- коды от~$0000\,0001$ до~$0111\,1111$
% \item соответствующие им отрицательные значения от~$-1$ до~$-127$;
% % с~единичным старшим битом.
% % Таким образом, старший бит нуля и~положительных чисел равен нулю, старший бит отрицательных чисел "--- единице.
% % \item код $128$,
% \end{itemize}

Таким образом, дополнительный код позволяет представить с~помощью~$N$ разрядов целые числа в~диапазоне~$\left[-2^{N-1}, 2^{N-1}-1\right]$.

Дополнительный код неотрицательных чисел совпадает с~прямым (натуральным).

Для перевода отрицательного числа $-x$ на практике используется %не вычитание $0-x = 2^N-x$, а~
следующая схема.
Преобразуем $0-x$ с~учётом ассоциативности и~коммутативности циклического вычитания:
\begin{equation}
-x = 0-x = (-1 - x) +1.
\end{equation}
С~учётом того, что дополнительный код $-1$ состоит из единиц во всех разрядах, $-1 - x$ "--- это инверсия всех битов $x$.
Соответственно, дополнительный код $-x$ может быть рассчитан как $\lnot x+1$, где $\lnot x$ "--- побитовое отрицание (инверсия битов) натурального двоичного представления абсолютной величины числа  $x$.


Именно в~дополнительном коде представлены отрицательные числа в~современных вычислительных системах.
При этом нет способа, анализируя двоичный код, в~частности, $1111\,1111$, понять, кодирует ли он беззнаковое число~$255$ или знаковое~$-1$ (или и~вовсе %является частью 
что-то иное).
Программист должен сам помнить, что именно было записано в~данную ячейку, и~применять соответствующие команды для обработки и~вывода.
При программировании на %типизированном 
языке высокого уровня (в~частности, C++) данную информацию хранит компилятор, но %программист может преобразовать
при присваивании переменных различного типа значения могут интерпретироваться по-разному.


\subsection{Знаковая арифметика в~вычислительных системах}
\index{Представление данных!знаковых!сложение}
\epigraph{
Существование в нашем мире асимметричных частиц не противоречит симметрии пространства, так же как ей не противоречит асимметрия живых объектов. 
}{А.\,Б.\,Мигдал}

Дополнительный код построен таким образом, что операции с~беззнаковым переполнением получают смысл.

В~частности, примеры~\eqref{eq:digits-binadd-ff+1} и~\eqref{eq:digits-binadd-ff+ff} являются корректными операциями сложения, если рассматривать операнды и~результат как знаковые:
\begin{equation}
\label{eq:digits-binadd-ff+1-dop}
\begin{array}{r@{\hspace{2em}}rcl}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 & & & & & & & &1\\[\rulerowsep]
 &0&0&0&0&0&0&0&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
&
% \left(
% \begin{tikzlongsum}
% {
% \\
% -&1\\
% +&1\\[\rulerowsep]
%  &0\\
% };
% \node[left = of m-2-1.south west] {$+$};
% \end{tikzlongsum}
% \right)
% \left(
-1_{10} + 1_{10} &=& 0_{10}
% \right)
\\
% \end{equation}
% \begin{equation}
% \label{eq:digits-binadd-ff+ff}
\begin{tikzlongsum}
{
1&1&1&1&1&1&1&1& \\
 &1&1&1&1&1&1&1&1\\
 &1&1&1&1&1&1&1&1\\[\rulerowsep]
 &1&1&1&1&1&1&1&0\\
};
\node[left = of m-2-2.south west] {$+$};
\end{tikzlongsum}
&
% (
-1_{10} + (-1_{10}) &=& -2_{10}
% )
\end{array}
\end{equation}
\index{Представление данных!знаковых!вычитание}
Корректными станут и~операции вычитания большего числа из меньшего в~\eqref{eq:digits-binadd-a-b-neg} и~\eqref{eq:digits-binadd-0-1}:
\begin{equation}
\label{eq:digits-binadd-a-b-neg-dop}
\begin{array}{r@{\hspace{2em}}rcl}
\begin{tikzlongsum}
{
\centerdot&\centerdot
 & & & &\centerdot&\centerdot& & \\
 &0&0&0&0&1&0&0&1\\
 &0&1&0&0&0&0&1&1\\[\rulerowsep]
 &1&1&0&0&0&1&1&0\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
&
9_{10} - 67_{10} &=& -58_{10}
\\
\begin{tikzlongsum}
{
\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot&\centerdot& \\
 &0&0&0&0&0&0&0&0\\
 & & & & & & & &1\\[\rulerowsep]
 &1&1&1&1&1&1&1&1\\
};
\node[left = of m-2-2.south west] {$-$};
\end{tikzlongsum}
&
0_{10} - 1_{10} &=& -1_{10}
\end{array}
\end{equation}
Операции~\eqref{eq:digits-binadd-a+b} и~\eqref{eq:digits-binadd-a-b}, где и~операнды, и~результат неотрицательны и~не превышают~$127_{10}$,
корректны и~при знаковой, и~при беззнаковой трактовке.

Если беззнаковая операция корректна (переполнения не было), но результат превышает максимально возможное знаковое положительное число (для восьми бит~$127_{10}$), то при знаковой интерпретации результат перестаёт быть правильным.
Например, в~\eqref{eq:digits-binadd-a+b-9E}
\begin{equation}
\label{eq:digits-binadd-a+b-9E-dop-err}
\begin{tikzlongsum}
{
1& & & & &1&1& \\
0&1&0&1&0&0&1&1\\
0&1&0&0&1&0&1&1\\[\rulerowsep]
1&0&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
83_{10} + 75_{10} = -98_{10}
\end{equation}
В~\eqref{eq:digits-binadd-a+b-9E-dop-err}, в~отличие от~\eqref{eq:digits-binadd-ff+1-dop} и~\eqref{eq:digits-binadd-a-b-neg-dop}, есть перенос в~старший (знаковый) разряд, но нет переноса из него в~несуществующий девятый разряд.
Возможна ситуация, когда, наоборот, сумма двух отрицательных чисел имеет ноль в~знаковом разряде:
\begin{equation}
\label{eq:digits-binadd-a+b-0-dop-err}
\begin{tikzlongsum}
{
1& & & & & &1&1& \\
 &1&0&0&1&0&0&1&1\\
 &1&1&0&0&1&0&1&1\\[\rulerowsep]
 &0&1&0&1&1&1&1&0\\
};
\node[left = of m-2-1.south west] {$+$};
\end{tikzlongsum}
~~~~
-109_{10} + (-53_{10}) = +94_{10}
\end{equation}
Здесь не было переноса в~знаковый разряд, но есть перенос из него.

Подобная ситуация называется \termin{знаковым переполнением.}

Таким образом, сложение и~вычитание знаковых чисел, представленных в~дополнительном коде, может выполняться таким же образом, как и~беззнаковых чисел.
При этом для проверки корректности результата %не имеет смысла 
нужно анализировать не перенос/заём в~несуществующий разряд (флаг переноса~$CF$),
а~знаковое переполнение "--- комбинацию переноса/заёма в~знаковый разряд и~переноса/заёма из знакового разряда в~несуществующий.

\index{Флаги!переполнения}
Наличие знакового переполнения также отражается специальным флагом "--- флагом переполнения ($OF$, Overflow flag).

Соответственно, команды сложения и~вычитания не разделяются на знаковые и~беззнаковые.
По~результатам выполнения 
устанавливается значение как флага переноса (беззнакового переполнения),
так и~флага знакового переполнения.



% Как правило
% Команды сложения и~вычитания
% процессоров семейства x86, 

\index{Представление данных!знаковых!умножение}
Умножение отрицательных чисел по беззнаковой схеме, показанное, в~частности, в~\eqref{eq:digits-binmul-ffxff}, явно некорректно "--- результат получается также отрицательным.
Это связано с~тем, что при сложении частичных произведений
% смещённых произведений первого множителя на одну цифру второго 
подразумевалось, что пустые ячейки "--- это пропущенные незначащие нули.
Но ведущий ноль в~дополнительном коде обозначает положительное число, поэтому во~всех пустых ячейках необходимо разместить {единицы:}
\begin{equation}
\label{eq:digits-binmul-ffxff-dop}
\begin{tikzpicture}[arythm-picture]
\matrix (m) [arythm-matrix, row 3/.style={nodes={arythm-carry}}]
{
\ldots&[0.5ex]1&1&1&1&[0.5ex]1&1&1&1&[0.5ex]1&1&1&1\\
\ldots&1&1&1&1&1&1&1&1&1&1&1&1\\[\rulerowsep]
&\mathrm{A}&9&8&7&6&5&4&3&2&1& & \\
\ldots&1&1&1&1&1&1&1&1&1&1&1&1\\
\ldots&1&1&1&1&1&1&1&1&1&1&1& \\
\ldots&1&1&1&1&1&1&1&1&1&1& & \\
\ldots&1&1&1&1&1&1&1&1&1& & & \\
\ldots&1&1&1&1&1&1&1&1& & & & \\
\ldots&1&1&1&1&1&1&1& & & & & \\
\ldots&1&1&1&1&1&1& & & & & & \\
\ldots&1&1&1&1&1& & & & & & & \\
\ldots&1&1&1&1& & & & & & & & \\
\ldots&1&1&1& & & & & & & & & \\
\ldots&1&1& & & & & & & & & & \\
\ldots&1& & & & & & & & & & & \\[\rulerowsep]
\ldots&0&0&0&0&0&0&0&0&0&0&0&1\\
};
\drawrulerow{2}
\drawrulerow{15}

\node[left = of m-1-1.south west] {$\times$};
\end{tikzpicture}
~~~~
(-1_{10}) \cdot (-1_{10}) = 1_{10}
\end{equation}
Таким образом, %в~тех вычислительных системах, где
знаковое и~беззнаковое умножение (и,~соответственно, деление)
осуществляется разными командами.

% http://phg.su/basis2/X148.HTM
% 	младшие N байт произведения (N*N) не зависят от знака
Тем не менее, младшие $N$ бит произведения двух $N$-разрядных чисел одинаковы и~для беззнакового, и~для знакового умножения~\cite{phg.su}.

\section{Альтернативная арифметика} 
\epigraph{\begin{limerick}
    Жил-был старичок у причала,\\
    Которого жизнь удручала.\\
    Ему дали салату\\
    И сыграли сонату,\\
    И немного ему полегчало.\\
\end{limerick}
}
{\Lear}

В~предыдущих разделах рассматривались позиционное двоичное представление беззнаковых и~знаковых целых чисел ограниченной разрядности
и~циклическая (по модулю~$2^N$) арифметика над такими числами.
Но для некоторых задач удобнее использовать другое представление или другой способ обработки.

Следует помнить, что как невозможно по %содержимому памяти 
представлению в~памяти 
отличить знаковое число от беззнакового,
нельзя %и~понять, глядя на фрагмент памяти,  что 
отличить их и~от  двоично-десятичных чисел, и~от вектора остатков модулярного представления, и~т.\,д.
Программист должен отслеживать тип данных и~применять соответствующие команды.


\subsection{Двоично-десятичная арифметика} 
\epigraph{\begin{limerick}
    Говорил старичок у куста:\\
    «Эта птичка поёт неспроста».\\
    Но, узрев, что за птаха,\\
    Он затрясся от страха:\\
    «Она вчетверо больше куста!»\\
\end{limerick}
}
{\Lear}
\index{Представление данных!натуральных!двоично-десятичное}

Двоично-десятичное представление (binary-coded decimal, BCD) беззнаковых целых чисел "--- это десятичное позиционное представление, в~котором каждая десятичная цифра записана двоичным кодом.
Если для записи используется $n$ десятичных цифр, представимый диапазон чисел "--- $[0, 10^n-1]$.

Существует множество вариантов как для размера кода десятичных цифр, так и~для сопоставления различных кодовых комбинаций цифрам.

% В~различных системах (в~зависимости от способа кодирования) одно и~то же число может быть записано по-разному.
% Но в~пределах одного вида двоично-десятичного кода (ДДК) код каждого числа $X \in [0, 10^n-1]$ уникален. нет

Для записи десятичных цифр, принимающих десять различных значений, недостаточно трёх бит (с~их помощью можно задать восемь кодовых комбинаций), 
% но слишком много четырёх
а~четырёх (шестнадцать комбинаций) %или большего количества бит "---  
хватает с~избытком.
% 
Таким образом, размер двоичного кода десятичной цифры в~принципе может принимать значения от четырёх до бесконечности, но на практике используются всего два размера:
\begin{itemize}
\item четыре бита (двоичная тетрада) "--- для максимальной компактности записи;
\item байт используемой системы "--- для упрощения поразрядных десятичных арифметических действий.
\end{itemize}
% Если размер цифры равен байту, то есть основной целью является быстрая обработка двоично-десятичных чисел,
% для записи цифр используется натуральный двоичный код (также называемый кодом прямого замещения).
Если размер цифры равен байту, значение обычно записано в~младшей тетраде байта,
а~все остальные (старшие) биты раны нулю.
Таким образом, достаточно рассмотреть четырёхбитные двоично-десятичные коды.

Так как десятичных цифр десять, а~четырёхбитных кодовых комбинаций шестнадцать, то либо шесть комбинаций будут недопустимыми (не будут обозначать никакую цифру),
либо некоторые цифры будут кодироваться неоднозначно "--- двумя и~более комбинациями.

% Если размер цифры равен четырём, в~различных системах могут использоваться различные коды.
% Они 
Виды представления десятичных цифр (двоично-десятичные коды)
делятся на две основные группы.
\begin{enumerate}
\item \termin{Взвешенные} коды, когда значение десятичной цифры $d$ вычисляется по битам $b_3, b_2, b_1, b_0$ тетрады 
с~использованием постоянных весов: 
\begin{equation}
\label{eq:digits-bcd-w}
d = \sum_{i=0}^{3} q_i\cdot b_i = q_0\cdot b_0 + q_1\cdot b_1 + q_2\cdot b_2 + q_3\cdot b_3.
\end{equation}
Взвешенный код обычно обозначается своими весами~$q_3q_2q_1q_0$ (может также использоваться обозначение $q_3{-}q_2{-}q_1{-}q_0$ или $q_3, q_2, q_1, q_0$).

Натуральный двоичный код цифр (также называемый кодом прямого замещения или кодом %$8-4-2-1$) 
$8421$),
для которого значение десятичной цифры $d$ равно двоичному значению тетрады $\overline{b_3 b_2 b_1 b_0}$,
% Код прямого замещения
является частным случаем  взвешенного кода.
% Веса битов для натурального кода равны $8, 4, 2$ и~$1$.
Такой код легко читается человеком и~переводится в~двоичный, но при выполнении сложения и~вычитания при помощи двоичного сумматора
% \begin{itemize}
% \item необходима коррекция результата;
% \item 
сложно выделить десятичный перенос.
% \end{itemize}
Тетрады $1010_2{-}1111_2$, соответствующие значениям $10_{10}{-}15_{10}$, не являются корректными двоично-десятичными цифрами в~коде прямого замещения.

Хотя код прямого замещения наиболее популярен в~ЭВМ (BCD без уточнения обычно означает именно код прямого замещения),
на практике используются и~другие взвешенные коды, в~частности, код Айкена"--~Эмери $2421$.
Веса также могут быть отрицательными.

Основным недостатком взвешенных кодов является то, что,
если при передаче будет искажён один из % старших  (с~б\'{о}льшим весом) разрядов, 
разрядов в~большим по модулю весом (в~частности, $\pm 8$ или $\pm 7$),
ошибка будет значительно больше, чем при искажении %младшего разряда.
% разряда с~весом~$\pm 1$.
разряда с~малым по модулю весом. % (в~частности, $\pm 1$).
С~этой точки зрения лучше применять невзвешенный код, у~которого ошибки, вызванные помехами, были бы одинаковыми для любого разряда.

\item \termin{Невзвешенные} коды "---
значение десятичной цифры %в~невзвешенном коде 
не может быть представлено в~виде~\eqref{eq:digits-bcd-w}.
Перечислим некоторые невзвешенные двоично-десятичные коды:
\begin{itemize}
\item код с избытком 3 (код $8421+3$)
% http://studopedia.ru/7_35754_dvoichno-desyatichnie-kodi-s-izbitkom-.html
\begin{equation}
d =  b_0 + 2\cdot b_1 + 4\cdot b_2 + 8\cdot b_3 + 3
\end{equation}
позволяет относительно просто осуществлять коррекцию после сложения или вычитания двоичным сумматором, 
в~частности, десятичный перенос равен двоичному переносу из тетрады~\cite{puh_digit_dev};
% http://know.sernam.ru/book_deq.php?id=132
% \begin{equation}
% ()
% \end{equation}
\item код Грея (двоичный рефлексный, или двоичный отражённый код), для которого инверсия любого одного бита изменяет значение на $\pm 1$~\cite{rsdn_gray}.

% \item код Грея с избытком 3 
% % http://www.studfiles.ru/preview/1566784/page:31/
% сопоставляет цифрам от $0$ до $9$ код Грея чисел от $3$ до $12$
% и, как и~для простого кода Грея, инверсия одного бита изменяет значение на $\pm 1$.
\end{itemize}
\end{enumerate}
% Различные коды 

% % Код прямого замещения 
% Натуральный двоичный код цифр
% позволяет использовать для арифметических действий
% двоичный сумматор с~последующей коррекцией результата. % (формированием переноса в~случае)
Процессоры семейства x86 содержат набор команд,
% коррекции двоичного результата,
облегчающих арифметические действия над цифрами двоично-десятичных чисел в~коде прямого замещения.
% позволяющих осуществлять коррекцию результата после сложения или вычитания 
Эти команды доступны при разрядности кода до 32 включительно.
% 
В~64-разрядном режиме они исключены, так что коррекцию при операциях с~двоично-десятичными цифрами необходимо осуществлять программно~\cite{rsdn_bcd_64}.


Двоично-десятичные числа, поддерживаемые командами x86, делятся на две разновидности по размеру цифры:
\begin{itemize}
\item упакованные "--- каждый байт содержит две десятичные цифры, представленные в~коде прямого замещения; например, $12_{10}$ кодируется одним байтом $0001\,0010$;
\item неупакованные "--- байт содержит одну цифру в~коде прямого замещения, так что $12_{10}$ кодируется двумя байтами $0000\,0010~0000\,0001$.
\end{itemize}

% на основе 
% (по цифре)
% Обработка каждой цифры

Упакованные числа складываются и~вычитаются  побайтово (по две десятичные цифры) в~два этапа.
Сначала выполняется двоичное сложение или вычитание байтов, затем "--- соответствующая команда коррекции.
% Для умножения и~деления упакованные числа необходимо 

Цифры неупакованных чисел можно не только складывать и~вычитать, но и~умножать и~делить.
При делении одной цифрой (то есть одним байтом) записываются делитель и~частное,
делимое состоит из двух десятичных цифр, %делитель и~частное "--- одна цифра, 
остаток  не вычисляется.
Обработка %десятичной цифры %, как и~для упакованных чисел,
также
выполняется в~два этапа "--- сначала двоичная операция над байтом, затем команда коррекции.

Действия над двоично-десятичными числами, содержащими %множество
несколько цифр, реализуются программно.
Соответственно, длина таких чисел потенциально не ограничена.
% на основе однобайтовых команд работы с~цифрами.

% В~64-разрядном режиме все эти команды исключены, так что коррекцию при операциях с~двоично-десятичными цифрами также придётся осуществлять программно.


% Альтернативные коды могут обладать другими свойствами, в~частности, большей помехоустойчивостью

% \begingroup
% 
% Основной системой счисления является \termin{десятичная.}
% 
% Каждая значащая десятичная цифра представляется %четырьмя двоичными знаками "--- 
% тетрадой (16~кодовых значений) и~содержит десять значений сигнала $S$ от~0 до~9.
% 
% Например:  
% $10_{10} \to 0001\, 0000$; $99_{10} \to 1001\, 1001$ \mbox{(код прямого замещения).}
% 
% 
% \subsubsection{Взвешенные коды}
% 
% Пусть биты тетрады "--- $b_3, b_2, b_1, b_0$, \termin{веса} битов "--- $q_3$-$q_2$-$q_1$-$q_0$.
% 
% Код называется \termin{взвешенным,} если %значение вычисляется %по формуле
% $$S = q_0\cdot b_0 + q_1\cdot b_1 + q_2\cdot b_2 + q_3\cdot b_3$$
% Коды, получаемые друг из друга  перестановкой весов $q_i$, образуют \termin{кодовую группу.}
% 
% Веса кода прямого замещения "--- 8-4-2-1.
% 
% 
% 
% \subsubsection{Свойства}
% 
% \begin{itemize}
% \item \termin{Взвешенность}
% полезна для реализации логических и~арифметических операций.
% 
% % \tmbCircled{-} 
% Если при передаче будет искажен старший разряд (с~б\'{о}льшим весом), ошибка будет гораздо больше, чем при искажении младшего разряда.
% 
% \item \termin{Упорядоченность}
% 
% $
% 0_2<1_2<2_2<...<9_2
% $
% или
% $
% 0_2>1_2>2_2>...>9_2
% $
% 
% где $0_2,1_2,2_2,...,9_2$ "--- двоичные представления десятичных цифр $0,1,2,...,9$ 
% (для сравнений).
% 
% Только ДДК, не имеющие отрицательных весов.
% 
% 
% \item \termin{Чётность}:\\чётным десятичным цифрам соответствуют либо только чётные, либо только нечётные их двоичные представления;
% % \\нечётным десятичным, соответственно, только нечётные либо только чётные двоичные представления 
% нечётным "---  нечётные либо чётные соответственно
% (умножение, деление, округление).
% 
% \item \termin{Дополнительность (самодополняемость)} если $A_{10}+B_{10}=9$, то $A_2 = \overline{B_2}$ (побитовая инверсия) "--- операции с~учётом знаков.
% 
% Все взвешенные ДДК с~положительными весами, где сумма весов равна 9.
% 
% \item \termin{Однозначность} "--- каждой десятичной цифре соответствует только одна из 16 двоичных тетрад (нецелесообразно).
% 
% Ни одна кодовая группа с~положительными весами не однозначна, кроме 8-4-2-1.
% 
% \item \termin{Единственность} "--- между десятичной цифрой и~комбинацией двоичных цифр установлено взаимно однозначное соответствие (упрощает кодирование и~декодирование) "--- выбор одного представления и~исключение прочих.
% \end{itemize}
% 
% \subsubsection{Кодовые группы взвешенных ДДК по свойствам}
% \paragraph{Кодовые группы однозначных взвешенных ДДК}
% \begin{tabularx}{1\linewidth}{XXXXX}
% 
% 8,4,2,1& 	8,-4,2,1& 	8,-6,4,1& 	8,-4,3,2& 	8,-5,4,2\\
% 8,4,2,-1& 	8,4,3,-2& 	8,-6,5,3& 	7,-6,5,3& 	8,-4,-2,1\\
% 8,4,-2,1& 	8,6,-4,1& 	8,4,-3,2& 	8,-4,2,-1& 	8,5,-4,2\\
% 8,-4,3,-2&	7,6,-5,3& 	8,4,-3,-2& 	8,5,-4,-2& 	8,6,-4,-1\\
% 8,7,-4,-2& 	  
% \end{tabularx}
% 
% \paragraph{Взвешенные ДДК со свойствами единственности и~дополнительности}
% \begin{tabularx}{1\linewidth}{XXXXX}
% 5,2,1,1& 4,3,1,1& 4,2,2,1& 3,3,2,1\\
% 6,3,1,-1& 	7,3,1,-2& 	6,4,1,-2& 	6,5,1,-3& 	7,5,1,-4\\
% 6,2,2,-1& 	5,3,2,-1& 	6,3,2,-2& 	8,3,2,-4& 	4,4,2,-1\\
% 6,4,2,-3& 	8,4,2,-5& 	6,5,2,-4& 	4,4,3,-2& 	5,4,3,-3\\
% 8,4,3,-6& 	7,5,3,-6& 	8,4,-2,-1& 	8,6,-1,-4\\ 	  
% \end{tabularx}
% 
% \paragraph{Кодовые группы взвешенных ДДК со свойствами единственности, упорядоченности и~дополнительности}
% "5,2,1,1", "4,3,1,1", "3,3,2,1","4,2,2,1"  
% 
% \paragraph{Взвешенные ДДК со свойствами единственности, упорядоченности и~дополнительности}
% 
% 5,2,1,1
% 
% 4,3,1,1
% 
% 3,3,2,1
% 
% 4,2,2,1
% 
% % \subsection{Код Эмери}
% % \subsubsection{Взвешенные, единственностные, чётные, упорядоченные, дополнительные}
% \paragraph{Взвешенные ДДК со свойствами единственности, чётности, упорядоченности и~дополнительности}
% Группа 4,2,2,1 "---  коды Эмери 
% 
% 2,4,2,1 "--- код Айкена (Айкена"--~Эмери)
% 
% 
% \begin{tabularx}{1\linewidth}{XXXXX}
% \hline
% 0 & 1 & 2 & 3 & 4 \\
% 0000 & 0001 & 0010, 1000 &  0011, 1001 & 0100, 1010 \\\hline
% 
% % 5 & 6 & 7 & 8 & 9 \\
% % 0101, 1011 & 0110, 1100 &  0111, 1101 &  1110 & 1111 \\\hline
% 
% 9 & 8 & 7 & 6 & 5 \\
% 1111 & 1110 &  1101, 0111 &   1100, 0110 &  1011, 0101  \\\hline
% \end{tabularx}
% 
% 
% \subsubsection{Недостатки взвешенных кодов}
% Если при передаче будет искажен старший разряд (разряд с~б\'{о}льшим весом), ошибка будет значительно больше, чем при искажении младшего разряда.
% С~этой точки зрения лучше применять невзвешенный код, у~которого ошибки, вызванные помехами, были бы одинаковыми для любого разряда.
% 
% \endgroup


\subsection{Модулярная арифметика} 
\epigraph{\begin{limerick}
    У старушки одной в Эритрее\\
    Был девиз: «Дальше, выше, быстрее!»\\
    Если нужно, на спор\\
    Перепрыгнуть забор\\
    Старушонка могла в Эритрее.\\
\end{limerick}
}
{\Lear}
\index{Представление данных!натуральных!модулярное}

Модулярная арифметика основана на представлении целого неотрицательного числа~$X$ в~виде последовательности 
% набора 
остатков от деления $X$ на набор взаимно простых чисел $p_1, p_2,\ldots p_n$:
\begin{equation}
X = %(x \Mod p_1,~ x \Mod p_2,\ldots ~ x \Mod p_n)
(x_1, x_2,\ldots x_n),
\end{equation}
где
\begin{equation*}
\begin{array}{lll}
x_1 &=& X \Mod p_1\\
x_2 &=& X \Mod p_2\\
\ldots \\
x_n &=& X \Mod p_n\\
\end{array},
~~
\begin{array}{c}
p_1, p_2,\ldots p_n \in \Naturalset,\\
% \not\exists i: p_i = 1,\\
% \text{НОД}(p_1, p_2,\ldots p_n) = 1.\\
\forall i\neq j: \text{НОД}(p_i,p_j) = 1.\\
\end{array}
\end{equation*}
% \begin{equation}
% X = %(x \Mod p_1,~ x \Mod p_2,\ldots ~ x \Mod p_n)
% (x_1, x_2,\ldots x_n),
% ~~\text{где}~~
% \left\{
% \begin{array}{lll}
% x_1 &=& X \Mod p_1\\
% x_2 &=& X \Mod p_2\\
% \ldots \\
% x_n &=& X \Mod p_n\\
% \end{array},
% \right.
% \end{equation}
Согласно китайской теореме об остатках, такое представление единственно для любого целого $X \in [0, P)$, где $P = p_1\cdot p_2\cdot\ldots\cdot p_n$.

% Реализация 
% В~модулярной арифметике умножение реализуется с~той же скоростью, что и~сложение.
% malashevich-mod-epos
Для вычисления суммы (или произведения) двух чисел, представленных подобным образом, достаточно сложить (или перемножить) каждую пару  соответственных остатков.

Так, пусть
\begin{equation}
\left\{
\begin{array}{llllll}
X &=& (x_1,& x_2,&\ldots& x_n)\\
Y &=& (y_1,& y_2,&\ldots& y_n)\\
\end{array},
\right.
\end{equation}
тогда
\begin{equation}
% \begin{array}{c}
% X+Y = \Big((x_1+y_1) \Mod p_1,~ (x_2+y_2) \Mod p_2,\ldots ~ (x_n+y_n) \Mod p_n\Big)\\
% X-Y = \Big((x_1-y_1) \Mod p_1,~ (x_2-y_2) \Mod p_2,\ldots ~ (x_n-y_n) \Mod p_n\Big)\\
% X\cdot Y = \Big((x_1\cdot y_1) \Mod p_1,~ (x_2\cdot y_2) \Mod p_2,\ldots ~ (x_n\cdot y_n) \Mod p_n\Big)\\
% \end{array}
\begin{array}{cccccc}
X+Y &=& \Big((x_1+y_1) \Mod p_1,& (x_2+y_2) \Mod p_2,&\ldots  &(x_n+y_n) \Mod p_n\Big)\\
X-Y &=& \Big((x_1-y_1) \Mod p_1,& (x_2-y_2) \Mod p_2,&\ldots  &(x_n-y_n) \Mod p_n\Big)\\
X\cdot Y &=& \Big((x_1\cdot y_1) \Mod p_1,& (x_2\cdot y_2) \Mod p_2,&\ldots &(x_n\cdot y_n) \Mod p_n\Big)\\
\end{array}
\end{equation}
Здесь остаток от деления ($\Mod$) вычисляется по правилам математики, а~не C/C++ "--- он неотрицателен (то есть $(-1) \Mod 7 = 6$).

При этом действия с~различными парами остатков можно выполнять параллельно, так как действия выполняются независимо друг от друга. 
% 
При использовании небольших  $p_1, p_2,\ldots p_n$ возможно 
% Малая разрядность остатков обеспечивает возможность реализации табличной арифметики, при которой 
вместо вычисления результата операции 
% каждый раз в память машины заранее помещается таблица готовых значений. 
воспользоваться предварительно вычисленной таблицей.
Таким образом, любая операция при %такой табличной арифметике и
соответствующей конвейеризации будет  выполняться за один машинный такт.
% для сколь угодно большого числа
%  ( количество разрядов в котором зависит лишь от конструкции машины ). Это позволяет чрезвычайно эффективно выполнять некоторые распространенные классы задач , сводящихся к сложению , умножению и возведению в степень многоразрядных чисел . 

Подобная арифметика в~целом циклична по модулю $P$, так что,
% если «правильный» результат сложения, вычитания или умножения выходит за~границы диапазона $[0, P)$, 
в~частности, $(P-1) + 1 = 0$;
ассоциативна и~коммутативна.

Некоторые операции выполняются сложнее, чем в~позиционных системах счисления.
Такие операции называются немодульными.
% https://habrahabr.ru/post/144886/
Это, прежде всего, {сравнение}, то есть установление порядка (установление равенства "--- модульная операция),  и~все операции, в~реализации которых оно используется.
\begin{itemize}
\item сравнение чисел;
\item контроль переполнения;
\item деление;
\item квадратный корень и~т.\,п.
\end{itemize}
Из-за немодульности сравнения расширение модулярного представления на все целые числа возможно только в~виде значения со знаком.
При использовании для отрицательных чисел кода со смещением $x \to x+\xi$ или дополнительного кода $(-x) \to P - x$
нет простого способа отличить отрицательное число от положительного.
На вещественные числа модулярное представление  естественным путём  не расширяется.

% Модулярное представление не расширяется естественным путём на вещественные числа.

Модулярная арифметика позволяет реализовать очень быстрые вычисления над неотрицательными целыми числами,
а~также контролировать корректность результата в~процессе вычислений, что позволяет обнаруживать аппаратные ошибки.

\subsection{Арифметика с~насыщением} 
\epigraph{\begin{limerick}
    Жил премудрый политик в Сеуле.\\
    Но когда его перевернули\\
    И стали крутить,\\
    «Прошу прекратить», "---\\
    Заявил он коллегам в Сеуле.\\
\end{limerick}
}
{\Lear}

В~предыдущих разделах рассматривалась циклическая арифметика, 
то есть, если обрабатываемые числа находятся в~диапазоне~$[Min, Max]$,
то
$Max+1=Min$ и~$Min-1 = Max$.
Это основная используемая в~ЭВМ схема.

Для некоторых задач в~случае выхода за границы допустимого диапазона удобнее схема с~насыщением
"--- если «правильный» результат операции превышает наибольшее представимое значение $Max$, то он считается равным $Max$,
если  он меньше $Min$, то, соответственно, формируется результат $Min$.

Таким образом,
$Max+1 = Max$ и~$Min-1 = Min$.

% Значения $Min$ и~$Max$

Арифметика с~насыщением неассоциативна, в~частности
% \begin{equation}
% (Max-1) - (Max-1) = 0, ~\text{но} Max-(1 +Max) + 1 = Max-Max+1 = 1
% \end{equation}
\begin{equation*}
(Max-1) - (Max-1) = 0,
\end{equation*}
но
\begin{equation*}
Max-(1 +Max) + 1 = Max-Max+1 = 1.
\end{equation*}

Процессоры семейства x86 
% содержат набор команд MMX,
% которые, при соответствующих настройках
поддерживают арифметику с~насыщением в~рамках команд расширения MMX.

\section{Битовые операции}
% \index{Представление данных!битовые операции}
\epigraph{\begin{limerick}
    Жил старик в славном городе Бремене, \\
    Не терявший там попусту времени:\\
    Просыпался, зевал,\\
    Вверх ногами вставал\\
    И стоял до обеда на темени.\\
\end{limerick}
}
{\Lear}

Битовые операции "--- операции, производимые над цепочками битов.

Существует три основных класса битовых операций:
\begin{itemize}
\item поразрядные операции (not, and, or, xor);
% \item Арифметические.
\item операции расширения (увеличения разрядности);

\item сдвиги.

\end{itemize}

\subsection{Поразрядные операции}
\index{Представление данных!поразрядные операции}
\epigraph{\begin{limerick}
Жил мужчина близ озера Чад,\\
Воспитал он сто чад и внучат.\\
Он кормил их улитками\\
И корил их убытками,\\
Старый скаред близ озера Чад.
\end{limerick}
}
{\Lear}
\addquestion{Какие логические и~битовые операции вы~знаете?}


Поразрядные операции применяются к~каждому разряду операнда (для унарных операций)
или к~каждой паре соответствующих разрядов операндов (для бинарных операций)
независимо от соседних разрядов.
% Результат 
% и~не влияет на соседние

Так как один двоичный разряд может принимать только два значения,
которые можно трактовать как «ложь» и~«истина»,
набор поразрядных операций обычно включает все логические операции (таблица~\ref{tab:digits-bit-logic}).

\begin{table}[!ht]
\caption{Логические операции над разрядами}
\label{tab:digits-bit-logic}

\newcolumntype{Y}{>{$}C<{$}}
\newcolumntype{y}{>{$}c<{$}}
% \newcolumntype{Z}{>{\columncolor{csMarker}}Y}
\begin{tabularx}{1\linewidth}{yy|Y|YYY}
~~a~~ 	&	~~b~~ 	&	\lnot a ~(\NOT, !)	& a \land b ~(\AND, {\And\!\!})& a \lor b ~(\OR, |) & a \oplus b ~(\XOR, \Xor)\\\hline
0 	&	0 	&\multirow{2}{*}{$1$}	&0         	&	0         &	0\\
0 	&	1 	&			&0         	&	1         &	1\\\hline
1 	&	0 	&\multirow{2}{*}{$0$}	&0         	&	1         &	1\\
1 	&	1 	&			&1         	&	1         &	0\\\hline
\end{tabularx}
\end{table}

Для поразрядных операций применяются различные обозначения, наиболее популярные из них показаны в~шапке таблицы~\ref{tab:digits-bit-logic}.
В~последующих примерах используются обозначения, принятые в~языке C++ ($\Not, \And\!\!, \Or, \Xor$).

% Значения разрядов~$0$ и~$1$ трактуются соответственно как «ложь» и~«истина».
% Операции применяются к~
Результат в~каждом разряде рассчитывается независимо от соседних (отсутствует перенос между разрядами).
Разрядность результата соответствует разрядности операндов, для бинарных операций разрядность обоих операндов должна быть одинаковой.
% 
Поразрядные операции не могут быть знаковыми или беззнаковыми:
обработка старшего бита не отличается от остальных.

Таким образом, поразрядное отрицание (битовая инверсия, дополнение до единицы) "--- это унарная операция, где к~каждому разряду единственного операнда применяется логическое отрицание:
\begin{equation}
\Not 2_{10} = \Not 0000\,0010 = 1111\,1101
\end{equation}
Полученное значение можно трактовать как $-3_{10}$, если интерпретировать результат как знаковый,
либо как $253_{10}$, если интерпретировать его как беззнаковый.
Ни одно из этих двух значений здесь не будет «правильным» или «ошибочным».

При этом необходимо помнить, что если операнд $2_{10}$ имеет б\'{о}льшую разрядность (и, соответственно, включает больше ведущих нулей), 
то и~результат будет содержать больше ведущих единиц.
Соответственно, в~случае разрядности~$N$ значение $\Not 2_{10}$ в~знаковой интерпретации будет иметь значение~$-3_{10}$,
а~в~беззнаковой "--- $(2^N-3)_{10}$.


Поразрядное «и» (конъюнкция) "--- бинарная операция, к~каждой паре разрядов операндов применяется логическое «и»:
\begin{equation}
3_{10} \And 5_{10} = 0000\,0011 \And 0000\,0101 = 0000\,0001 = 1_{10}
\end{equation}
разряд результата равен нулю, если хотя бы один операнд содержит ноль в~соответствующем разряде.


Поразрядное «или» (дизъюнкция) "--- бинарная операция, к~каждой паре разрядов операндов применяется логическое «или»:
\begin{equation}
3_{10} \Or 5_{10} = 0000\,0011 \Or 0000\,0101 = 0000\,0111 = 7_{10}
\end{equation}
разряд результата равен единице, если хотя бы один операнд содержит единицу в~соответствующем разряде.

Поразрядное исключающее «или» (также называется сложением по модулю два, но, в~отличие от арифметической операции сложения, нет переноса между разрядами) "--- бинарная операция, к~каждой паре разрядов операндов применяется исключающее «или»:
\begin{equation}
3_{10} \Xor 5_{10} = 0000\,0011 \Xor 0000\,0101 = 1111\,0110 = -10_{10} = 246_{10}
\end{equation}
разряд результата равен единице, если один и~только один операнд содержит единицу в~соответствующем разряде.
% разряд результата равен нулю, если в~соответствующих разрядах операндов содержатся два нуля или две единицы.

Так как для одного разряда $\forall b \in \{0, 1\}:~ 1 \oplus b = \lnot b$, для чисел любой разрядности верно $\forall x:~ (-1) \Xor x = \Not x$.

\subsection{Расширение целых чисел}
\index{Представление данных!расширение}
\epigraph{\begin{limerick}
    Жила-была дама приятная,\\
    На вид совершенно квадратная.\\
    Кто бы с ней ни встречался,\\
    От души восхищался:\\
    «До чего эта дама приятная!»
\end{limerick}
}
{\Lear}

Часто необходимо увеличить разрядность числа, сохранив его значение.
В~C++ подобное происходит, в~частности, при присваивании переменных разного размера:
\begin{lstlisting}
int i;
short int s = -1;
i = s;
\end{lstlisting}

Операция увеличения разрядности называется расширением $n$-разрядного числа $x$ до $m$ разрядов ($m>n$).

Младшие $n$ разрядов результата совпадают с~расширяемым значением~$x$, 
старшие $m-n$ должны быть как-то инициализированы.

Существует две операции расширения, по-разному инициализирующие расширяемую часть:
\begin{itemize}
\item беззнаковое расширение "--- расширяемая часть заполняется нулями (такая операция сохраняет значение беззнаковой интерпретации~$x$);

\item знаковое расширение "--- расширяемая часть заполняется значением знакового бита (сохраняет значение знаковой интерпретации~$x$).

\end{itemize}

В~таблице~\ref{tab:digits-extend-signed-unsigned} показаны примеры знакового и~беззнакового расширения восьмибитных чисел до шестнадцати бит.

\begin{table}[!ht]

% \newcommand{\extendSigned}{Знаковое расширение~$x$ до 16 бит}
% \newcommand{\extendUnsigned}{Беззнаковое расширение~$x$ до 16 бит}
% \newcommand{\extendSigned}{$x \xrightarrow[\text{знаковое}]{} 16$ бит}
% \newcommand{\extendUnsigned}{$x \xrightarrow[\text{беззнаковое}]{} 16$ бит}
\newcommand{\extendSigned}{$x \xrightarrow{\text{знаковое}} 16$ бит}
\newcommand{\extendUnsigned}{$x \xrightarrow{\text{беззнаковое}} 16$ бит}
 

\caption{Знаковое и~беззнаковое расширение}
\label{tab:digits-extend-signed-unsigned}

\begin{tabularx}{1\linewidth}{r|rRRR}
Значение	&	$bin$				&	$hex$		&	$dec_\text{знак}$	&	$dec_\text{беззн}$	\\\hline
$x$ (8 бит)	&	$0000\,0000$			&	\hex{00}	&	$0$	&	$0$	\\
\extendUnsigned	&	$0000\,0000\,0000\,0000$	&	\hex{0000}	&	$0$	&	$0$	\\
\extendSigned	&	$0000\,0000\,0000\,0000$	&	\hex{0000}	&	$0$	&	$0$	\\\hline

$x$ (8 бит)	&	$0000\,0001$			&	\hex{01}	&	$1$	&	$1$	\\
\extendUnsigned	&	$0000\,0000\,0000\,0001$	&	\hex{0001}	&	$1$	&	$1$	\\
\extendSigned	&	$0000\,0000\,0000\,0001$	&	\hex{0001}	&	$1$	&	$1$	\\\hline

$x$ (8 бит)	&	$0000\,1111$			&	\hex{0F}	&	$15$	&	$15$	\\
\extendUnsigned	&	$0000\,0000\,0000\,1111$	&	\hex{000F}	&	$15$	&	$15$	\\
\extendSigned	&	$0000\,0000\,0000\,1111$	&	\hex{000F}	&	$15$	&	$15$	\\\hline

$x$ (8 бит)	&	$1000\,0000$			&	\hex{80}	&	$-128$	&	$128$	\\
\extendUnsigned	&	$0000\,0000\,1000\,0000$	&	\hex{0080}	&	$128$	&	$128$	\\
\extendSigned	&	$1111\,1111\,1000\,0000$	&	\hex{FF80}	&	$-128$	&	$65\,408$	\\\hline

$x$ (8 бит)	&	$1111\,1111$			&	\hex{FF}	&	$-1$	&	$255$	\\
\extendUnsigned	&	$0000\,0000\,1111\,1111$	&	\hex{00FF}	&	$255$	&	$255$	\\
\extendSigned	&	$1111\,1111\,1111\,1111$	&	\hex{FFFF}	&	$-1$	&	$65\,535$	\\\hline

\end{tabularx}

\end{table}

Каждая строка таблицы соответствует одному значению (цепочке битов).
Во втором столбце показано его двоичное представление,
в~третьем "--- шестнадцатеричное,
в~четвёртом "--- десятичное представление его знаковой интерпретации,
в~пятом "--- десятичное представление беззнаковой интерпретации.


Видно, что для неотрицательных чисел знаковое и~беззнаковое расширение выполняется одинаково.

\subsection{Битовые сдвиги}
\index{Представление данных!битовые сдвиги}
\epigraph{\begin{limerick}
Незлобивый старик из Китая\\
Пса имел "--- толстяка и лентяя.\\
Пёс обычно молчал,\\
А визжал и рычал\\
Добродушный старик из Китая.\\
\end{limerick}
}
{\Lear}

Битовые сдвиги "--- семейство бинарных операций с~несимметричными операндами.
Один из операндов представляет собой цепочку битов, второй "--- неотрицательное целое число "---  величину сдвига.
% 
% При битовых сдвигах 
Цепочка битов смещается 
вправо или влево %(так что каждый бит получает значение соседнего)
% вправо (в~сторону младших разрядов) или влево (в~сторону старших).
на указанное количество битов.
Разрядность результата равна разрядности операнда-цепочки.

Сдвиг на $n$ разрядов эквивалентен повторённому $n$ сдвигу на один разряд,
соответственно, для простоты ниже рассматривается только сдвиги на один бит.
% 
% Для простоты ниже все виды сдвигов рассматриваются на примере восьмибитных значений с~величиной сдвига 1~бит.

Как было сказано выше, сдвиги различаются направлением "--- вправо (в~сторону младших разрядов) или влево (в~сторону старших).
Кроме того, при сдвиге 
крайний  с~одной стороны разряд выдвигается за пределы разрядной сетки (его значение попадает в~ячейку флага переноса~$CF$),
\index{Флаги!переноса}
а~крайняя ячейка с~другой стороны освобождается.

В~зависимости от способа заполнения освободившейся ячейки различаются следующие типы сдвига:
\begin{itemize}
\item арифметические;
\item логические;
\item циклические.
\end{itemize}
Ниже   различные  виды сдвигов рассматриваются на примере восьмибитных значений.


\subsubsection{Логический и~арифметический сдвиг}

В~случае логического сдвига вправо (в~сторону младших разрядов) освободившийся старший разряд инициализируется нулём(рис.~\ref{ris:digits-shr-sar}, а).
В~случае арифметического сдвига вправо "--- копией знакового бита (рис.~\ref{ris:digits-shr-sar}, б).
\begin{illustration}
\begin{tabular}{@{}cc@{}}
\includegraphics[height=0.25\linewidth,valign=c]{shr}&
\includegraphics[height=0.25\linewidth,valign=c]{sar}\\
а) & б) \\
\end{tabular}
\caption{Логический (а) и~арифметический (б) сдвиги вправо}
\label{ris:digits-shr-sar}
\end{illustration}

Логический сдвиг вправо соответствует беззнаковому делению на~$2$ с~остатком, % (остаток "--- бит $CF$),
арифметический "--- знаковому.
Остаток в~обоих случаях равен биту $CF$ (вышедшему за разрядную сетку младшему биту исходного числа).

% \subsubsection{Логический сдвиг влево}

В~случае  сдвига влево  (в~сторону старших разрядов)
освободившийся младший бит инициализируется нулём (рис.~\ref{ris:digits-shl-sal}).
\begin{illustration}
% \begin{tabular}{c}
\includegraphics[height=0.25\linewidth,valign=c]{shl-sal}
% \end{tabular}
\caption{Арифметический (логический) сдвиг влево}
\label{ris:digits-shl-sal}
\end{illustration}

Арифметический и~логический сдвиги влево не различаются.
Сдвиг влево эквивалентен умножению на $2$ (так как разрядность результата равна разрядности исходной цепочки, неважно "--- знаковому или нет).

Битовые сдвиги выполняются гораздо быстрее, чем умножение и~деление с~помощью специализированных команд.

\subsubsection{Циклические сдвиги}

В~случае простого циклического сдвига освободившаяся ячейка с~одной стороны замещается разрядом, вышедшим с~другой стороны за разрядную сетку (рис.~\ref{ris:digits-ror-rol}).

\begin{illustration}
\includegraphics[height=0.25\linewidth,valign=c]{ror-rol}

\caption{Простой циклический сдвиг}
\label{ris:digits-ror-rol}
\end{illustration}

В~случае циклического сдвига через флаг переноса освободившаяся ячейка инициализируется значением флага переноса $CF$, 
а~ячейка $CF$ замещается разрядом, вышедшим за разрядную сетку (рис.~\ref{ris:digits-rcr-rcl}).
Таким образом, результат зависит не только от операндов, но и~от текущего значения~$CF$.

\begin{illustration}
\includegraphics[height=0.25\linewidth,valign=c]{rcr-rcl}
\caption{Циклический сдвиг через флаг переноса}
\label{ris:digits-rcr-rcl}
\end{illustration}

Таким образом, простой циклический сдвиг $N$-разрядного числа циклически перемещает разряды $N$-битной цепочки,
а~сдвиг через флаг переноса "--- $N+1$-битной цепочки (операнд $+ CF$).

Циклические сдвиги широко используются в~криптографии.



\section{Представление вещественных чисел} 
\epigraph{
$i$. Be rational!

$\pi$. Get real!
}{\MathFolk}
\addquestion{Какие способы представления вещественных чисел используются в~ЭВМ?}
% идея, перевод целой и~дробной частей, вещественные с~фиксированной запятой, с~плавающей, мантисса и~порядок

Какой бы код ни использовался, с~помощью $N$ битов ${b_{N-1} \ldots b_{1} b_{0}}$ %двоичных разрядов 
можно получить только $2^N$ разных кодовых комбинаций и,~соответственно, представить не более $2^N$ значений.
При этом, в~отличие от целых чисел,
вещественных значений в~любом диапазоне $[\nu_1, \nu_2] \subseteq \Realset$ бесконечно много (причём эта бесконечность несчётна, то есть количество вещественных чисел, помещающихся на любом интервале, превышает общее число существующих целых чисел).

Таким образом, для того, чтобы закодировать вещественные числа, необходимо не только ограничить допустимый диапазон, но и~проредить его внутреннюю часть.
Большую часть вещественных чисел описываемого диапазона  $[\nu_1, \nu_2] \subseteq \Realset$ невозможно точно представить в~ЭВМ.

Представление вещественных чисел основано на описанной в~разделе~\ref{sec:digits-real-pos} позиционной двоичной записи.
% Дробная часть~\eqref{eq:digits:position-exponentiation-realsweaexsdd} округляется до некоторого количества разрядов.

\subsection{Представление вещественных чисел с~фиксированной запятой} 
\index{Представление данных!вещественных!с~фиксированной запятой}
\epigraph{\begin{limerick}
С каждым днем некий парень в Париже\\
Становился всё ниже и ниже.\\
«Вот кто, "--- он говорил, "---\\
Мне в макушку давил "---\\
Этот ящик с цементною жижей».
\end{limerick}
}
{\Carroll}

Представим вещественное число $X$ в~виде бесконечной двоичной дроби~\eqref{eq:digits:position-exponentiation-realsweaexsdd},
округлим до $n$ разряда после запятой, обозначив результат округления~$\breve{X} $:
\begin{equation}
\label{eq:digits:real-round}
\begin{array}{c}
X \approx \breve{X} 
= x_k\cdot 2^k + \ldots + x_1\cdot 2^1 + x_0\cdot 2^0 + x_{-1}\cdot 2^{-1} + \ldots + x_{-n}\cdot 2^{-n}  = \\[2ex]
= x_k\cdot 2^k + \ldots + x_1\cdot 2 + x_0 + \dfrac{x_{-1}}{2} + \ldots + \dfrac{x_{-n}}{ 2^{n}}  = \\[2ex]
= \overline{%\vphantom{x^2}%\mathstrut 
x_k \ldots x_1 x_0,x_{-1}\ldots x_{-n}}, ~~ 0\leqslant x_i < 2 ~\text{"--- целые}
\end{array}
\end{equation}
и~последовательно запишем цифры $x_k, \ldots x_1, x_0, x_{-1},\ldots x_{-n}$ в~биты ${b_{N-1}, \ldots b_{1}, b_{0}}$.
Таким образом,
% При кодировании вещественных чисел  целая и~дробная часть числа кодируется раздельно.
из $N$~битов, отведённых под представление числа, для дробной части используется~$n$, для целой остаётся $k = N-n$.
% Каждый бит соответствует двоичной цифре, так что целая часть представлена натуральным двоичным кодом, а~дробная округляется до~$n$ разрядов после запятой:
\begin{equation}
\label{eq:digits:real-fixpoint}
\begin{array}{c}
% X =  x_k\cdot 2^k + \ldots + x_1\cdot 2^1 + x_0\cdot 2^0 + x_{-1}\cdot 2^{-1} + \ldots + x_{-n}\cdot 2^{-n}  = \\[2ex]
% = x_k\cdot 2^k + \ldots + x_1\cdot 2 + x_0 + \dfrac{x_{-1}}{2^{1}} + \ldots + \dfrac{x_{-n}}{ 2^{n}}  = \\[2ex]
% = \overline{x_k \ldots x_1 x_0,x_{-1}\ldots x_{-n}}_2, ~~ 0\leqslant x_i < 2 ~\text{"--- целые}
X \approx  \breve{X} 
  =  b_{N-1}\cdot 2^{N-n-1} + \ldots + b_{n+1}\cdot 2^1 + b_{n}\cdot 2^0 + b_{n-1}\cdot 2^{-1} + \ldots + b_{0}\cdot 2^{-n}  = \\[2ex]
  =  b_{N-1}\cdot 2^{N-n-1} + \ldots + b_{n+1}\cdot 2 	+ b_{n} 	+ \dfrac{b_{n-1}}{2} + \ldots + \dfrac{b_{0}}{2^{n}} = \\[2ex]
  = \overline{b_{N-1} \ldots b_{n},b_{n-1}\ldots b_{0}}
\end{array}
\end{equation}
Двоичная запятая, отделяющая дробную часть от целой, всегда расположена между разрядами $n$ и~$n-1$.
Соответственно, такой способ кодирования называется представлением с~фиксированной запятой.


Целая часть числа может принимать значения от $0$ до~$2^{N-n} - 1$, дробная "--- от $0 = \overline{0,00\ldots00}$ до $1-\frac{1}{2^{n}} = \overline{0,11\ldots11}$ (всего $2^n$ значений).
Таким образом, можно представить числа в~диапазоне~$\left[0,~ 2^{N-n}-\frac{1}{2^{n}}\right]$.
% 
На каждом полуинтервале $[\nu, \nu+1)$ находится $2^n$ чисел, представимых в~виде с~фиксированной запятой с~$n$-битной дробной частью.

При округлении вещественного числа $X \in \left[0,~ 2^{N-n}-\frac{1}{2^{n}}\right]$ до $n$ двоичных разрядов после запятой абсолютная погрешность округления не превышает $\frac{1}{2^{n}}$:
\begin{equation}
\label{eq:digits:real-fixpoint-abserror}
\left| X - \breve{X} \right| \leqslant \frac{1}{2^{n}}
\end{equation}
относительная погрешность увеличивается при уменьшении абсолютной величины числа:
\begin{equation}
\label{eq:digits:real-fixpoint-relerror}
\left| \frac{X - \breve{X}}{X} \right| \leqslant \frac{1}{2^{n}\cdot |X|}
\end{equation}



Нетрудно заметить, что при умножении~\eqref{eq:digits:real-fixpoint} на~$2^n$ получим целое число:
\begin{equation}
\label{eq:digits:real-fixpoint-int}
\begin{array}{c}
2^n\cdot \breve{X} = 2^n\cdot \overline{b_{N-1} \ldots b_{n},b_{n-1}\ldots b_{0}} =\\
  = 2^n\cdot\left( b_{N-1}\cdot 2^{N-n-1} + \ldots + b_{n+1}\cdot 2 	+ b_{n} 	+ \dfrac{b_{n-1}}{2} + \ldots + \dfrac{b_{0}}{2^{n}} \right)= \\[2ex]
  =  b_{N-1}\cdot 2^{N-1} + \ldots + b_{n+1}\cdot 2^{n+1} + b_{n}\cdot 2^n + b_{n-1}\cdot 2^{n-1} + \ldots + b_{0}\cdot 2^{0}  = \\[2ex]
  = \overline{b_{N-1} \ldots b_{n} b_{n-1}\ldots b_{0}} = x, ~~ x \in \{0, 1,\ldots 2^N-1\}
\end{array}
\end{equation}
то есть существует взаимно однозначное соответствие между числами с~фиксированной запятой и~целыми числами в~диапазоне~$\left[0, 2^N-1\right]$:
\begin{equation}
\label{eq:digits:real-fixpoint-intdef}
\breve{X} = \frac{x}{2^n}
\end{equation}
причём $\breve{X}$ и~$x$ записываются одной и~той же комбинацией бит.

В~некоторых вычислительных машинах работа с~числами с~фиксированной запятой реализована аппаратно.
% Если необходимо представление знака, 
При этом отрицательные числа часто кодируются как значение со знаком.

Если специального набора команд нет, арифметика с~фиксированной запятой может быть реализована программно с~использованием целочисленных команд.
Сложение и~вычитание чисел с~фиксированной запятой можно выполнять целочисленным сумматором без коррекции результата:
\begin{equation}
\breve{X} + \breve{Y} = \frac{x}{2^n}+\frac{y}{2^n} = \frac{x+y}{2^n}
\end{equation}
После целочисленного умножения требуется коррекция в~виде деления %дополнительное деление
результата на $2^n$:
\begin{equation}
\breve{X} \cdot \breve{Y} = \frac{x}{2^n}\cdot\frac{y}{2^n} = \frac{x\cdot y}{2^{2n}} = \dfrac{ \frac{x\cdot y}{2^{n}} }{2^n}
\end{equation}
после целочисленного деления потребовалась бы коррекция в~виде умножения результата на $2^n$, если бы этот результат был вещественным:
\begin{equation}
\dfrac{\breve{X} }{ \breve{Y} } = \dfrac{\frac{x}{2^n}}{\frac{y}{2^n}} = \dfrac{x}{y} = \dfrac{ \frac{x}{y}\cdot{2^{n}} }{2^n}
\end{equation}
но коррекция целочисленного частного умножением даст нулевые значения младших $n$ бит, то есть дробной части числа с~фиксированной запятой,
что неправильно.
% В~данном случае, если разрядность позволяет, лучше скорректировать делимое на $2^n$ перед делением:
Поэтому необходимо проводить коррекцию перед делением:
\begin{equation}
\dfrac{\breve{X} }{ \breve{Y} } =  \dfrac{ \frac{x\cdot{2^{n}}}{y} }{2^n}
\end{equation}
% В~случае, если используемая разрядность не позволяет умножить делимое на $2^n$ без переполнения, можно воспользоваться тем, что
% целочисленное деление возвращает результат в~виде двух целых чисел "--- частного $q$ и~остатка~$r$:
% \begin{equation}
% \dfrac{x}{y} = q + \frac{r}{y}
% \end{equation}
% Тогда корректное частное чисел в~представлении с~фиксированной запятой с~дробной частью длины~$n$ равно:
% \begin{equation}
% \frac{x}{y}\cdot{2^{n}} = \left(q + \frac{r}{y}\right)\cdot{2^{n}} =  q\cdot{2^{n}} + \frac{r\cdot{2^{n}}}{y}
% \end{equation}
Умножение и~деление на $2^n$ может быть выполнено при помощи битовых сдвигов, что практически не замедлит работу. 

Таким образом, представление с~фиксированной запятой позволяет представить числа в~малом диапазоне с~ограниченной абсолютной погрешностью
% Представление с~фиксированной запятой
и~позволяет использовать для арифметических действий над вещественными числами быстрые целочисленные и~логические операции.

\subsection{Представление вещественных чисел с~плавающей запятой} 

\index{Представление данных!вещественных!с~плавающей запятой}
\epigraph{
\begin{stanza}
Хвосты бывают разные,\\
И ты об этом знай:\\
Любуйся на прекрасные,\\
Иные "--- «обрубай»!\\
\end{stanza}
}{Н.\,Капустюк}

В~основе представления вещественных чисел с~плавающей запятой лежит экспоненциальный (научный) формат:
\begin{equation}
X = N^p \cdot \mu
\end{equation}
где $N$ "--- основание системы счисления (в~современных ЭВМ $N=2$, 
стандарт арифметики с~плавающей точкой IEEE 754~\cite{ieeeFloat1985rus, ieeeFloat1985, ieeeFloat2008} описывает также случай $N=10$),
$\mu$ называется мантиссой числа $X$, целое число $p$ "--- порядком (иногда из-за английского exponent используется термин «экспонента», но он не принят в~отечественной литературе).

% \begin{equation}
% X = \pm 2^{p} \cdot \mu
% \end{equation}
В~настоящее время чаще всего,
кроме порядка и~мантиссы, отделяется ещё и~знак числа:
\begin{equation}
\label{eq:digits-floatpoint-def}
% X = (-1)^{s} \cdot 2^{p} \cdot \mu, ~~ s \in \{0, 1\}, p \in \Integerset, \mu \geqslant 0
X = (-1)^{s} \cdot N^{p} \cdot \mu, ~~ s \in \{0, 1\}, p \in \Integerset, \mu \geqslant 0
\end{equation}
В~форме~\eqref{eq:digits-floatpoint-def} можно представить любое конечное вещественное число, но не единственным способом:
\begin{equation*}
512,12 = 512,12 \cdot 10^0 = 51212 \cdot 10^{-2}  = 51,212 \cdot 10^{1}  = 0,051212 \cdot 10^{4} 
\end{equation*}
Представление~\eqref{eq:digits-floatpoint-def} называется нормализованным, если $0,1_N \leqslant \mu < 1$:
\begin{equation}
\label{eq:digits-floatpoint-norm}
% \label{eq:digits-floatpoint-norm-rus}
X = (-1)^{s} \cdot N^{p} \cdot \mu, ~~ s \in \{0, 1\}, p \in \Integerset, ~ 0,1_N \leqslant \mu < 1
\end{equation}
В~нормализованной форме~\eqref{eq:digits-floatpoint-norm} можно представить любое конечное вещественное число, кроме нуля,
причём единственным образом.
% 
В~частности, $512,12 = 0,51212 \cdot 10^3$.
В~двоичной системе счисления то же самое число и~его нормализованное экспоненциальное представление записываются как $1000000000,0001111\ldots = 0,10000000000001111\ldots \cdot 2^9$.

% Порядок  $p$ можно найти как округлённый вверх логарифм абсолютной величины~$X$.
% Действительно,
Найдём порядок нормализованного представления числа~$X$:
\begin{equation}
\log_N |X| = \log_N (N^{p} \cdot \mu) = p + \log_N\mu
\end{equation}
так что $p = \log_N |X| - \log_N\mu$.
Так как $0,1_N \leqslant \mu < 1$, то $-1 \leqslant \log_N \mu < 0$:
\begin{equation}
\log_N |X| < p \leqslant \log_N |X| + 1
\end{equation}
с~учётом того, что $p \in \Integerset$, получаем
\begin{equation}
p = \Big\lfloor \log_N |X| + 1 \Big\rfloor
\end{equation}


% то есть $\mu = \overline{0,1 m_2 m_3\ldots}$, где $m_i$ "--- двоичные цифры, $0$ или~$1$.
Если записать мантиссу нормализованного представления числа~$X$ в~позиционной форме, получим
\begin{equation}
\mu = \overline{0,m_1 m_2 m_3 m_4\ldots}, ~~ m_1 \neq 0.
\end{equation}
где $m_i \in \{0, 1, \ldots N-1 \}$ "--- цифры.
% Мантисса $\mu = \overline{0,m_1 m_2 m_3\ldots}$ потенциально бесконечна, но для ЭВМ её необходимо округлить до заданного конечного количества разрядов.
Если для представления с~фиксированной запятой до определённого знака округляется дробная часть числа~$X$ (что даёт ограниченную абсолютную погрешность), 
то для представления с~плавающей запятой до определённой длины округляется мантисса (что приводит к~ограниченной относительной погрешности округления).

\subsubsection{Структура двоичного числа с~плавающей запятой согласно IEEE~754}

Представим вещественное число $X \neq 0$ в~нормализованной 
двоичной форме~\eqref{eq:digits-floatpoint-def}
\begin{equation}
\label{eq:digits-floatpoint-def-2}
X = (-1)^{s} \cdot 2^{p} \cdot \mu, ~~ s \in \{0, 1\},~ p \in \Integerset,~ 0,1_2 \leqslant \mu < 1
% 0 \leqslant \mu < 1
\end{equation}
% В~двоичной системе если $m_1 \neq 0$, то $m_1 = 1$,
% то есть $\mu = \overline{0,1 m_2 m_3 m_4\ldots}$, где $m_i$ "--- двоичные цифры, $0$ или~$1$.
Запишем мантиссу в~позиционной двоичной форме $\mu = \overline{0,m_1 m_2 m_3 m_4\ldots}$, где $m_i$ "--- двоичные цифры, $0$ или~$1$.
% 
Так как представление~\eqref{eq:digits-floatpoint-def-2} нормализовано, $m_1 \neq 0$.
В~двоичной системе если $m_1$ не равна нулю, то она равна единице,
то есть $\mu = \overline{0,1 m_2 m_3 m_4\ldots}$.
\begin{equation}
\label{eq:digits-floatpoint-2-norm}
X = (-1)^{s} \cdot 2^{p} \cdot \overline{0,1 m_2 m_3 m_4\ldots}, ~~ s \in \{0, 1\},~ p \in \Integerset
\end{equation}


Запишем в~память компоненты такого представления (рис.~\ref{ris:digit-floatpoint}).
% Для записи знака~$s$ достаточно одного бита.
% Для единообразия с~целыми числами используется старший бит.
Знак~$s$ занимает старший бит.
\newcounter{risletter}
% \def\pmbits{m/0/n-1, p/n/n+w-1}
\tikzstyle{block}	= [text badly centered, minimum height=4ex, draw=black,  fill=clMemoryLight, solidchaincell]
\tikzstyle{blabel}	= [scale=0.7]



\begin{illustration}
\newcommand{\real}[5][]
{
  \node[block, minimum width= 42 ex, on chain, #1]  (m)  {$#4$};
  \node[block, minimum width= 18 ex, on chain]  (p) {$#3$};
  \node[block, minimum width= 4 ex, on chain]  (s) {$#2$};
  
    \node[left = 2ex of s] {\asbuk{risletter})\stepcounter{risletter}};
    \node[right = 2ex of m] {$#5$};
%   \tikzset{node distance=2ex}

  \foreach \nd/\s/\e in {m/0/n-1, p/n/n+w-1}
%   \foreach \nd/\s/\e in {\pmbits}
  {
    \node[below right = of \nd.south west, blabel, anchor=north west] (be) {$\mathstrut\e$};
    \node[below left = of \nd.south east, blabel, anchor=north east] (bs) {$\mathstrut\s$};
%   \coordinate[left =  of \nd.south east, label=below:$\mathstrut\s$] (bs);
  };
  \node[below = of s, blabel]  {$\mathstrut n+w$};
}
\setcounter{risletter}{1}


\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going left,
node distance=0ex,
baseline=(current bounding box.north)
]

  \real{s}{p+\xi}{m_2 m_3 m_4\ldots m_{n+1}}{	
    \begin{array}{c}
      (-1)^s\cdot 2^p \cdot \overline{0,1m_2 m_3 m_4\ldots m_{n+1}}\\
      p_{min} \leqslant p \leqslant p_{max}
    \end{array}
  }
%   \foreach \p/\m/\letter/\pos in {p+\xi/m_2 m_3\ldots m_{n+1}/а)/,p+\xi/m_2 m_3\ldots m_{n+1}/а)/,}
%   {
%     \real[]{s}{\p}{\m}
%   };
\tikzstyle{nextm}	= [below = 6ex of m]

%   \real[nextm]{s}{000\ldots000}{m_1 m_2 m_3\ldots m_{n}}
  \real[nextm]{s}{000\ldots000}{m_2 m_3 m_4\ldots m_{n+1}}{	(-1)^s\cdot 2^{p_{min}} \cdot \overline{0,0m_2 m_3 m_4\ldots m_{n+1}}	}
  \real[nextm]{s}{000\ldots000}{000\ldots 0}{	(-1)^s\cdot 0	}
%   \real[nextm]{s}{000\ldots000}{000\ldots 0}{	\pm 0	}

  \real[nextm]{s}{111\ldots111}{000\ldots 0}{	(-1)^s\cdot \infty	}
%   \real[nextm]{s}{111\ldots111}{000\ldots 0}{	\pm \infty	}
  \real[nextm]{x}{111\ldots111}{q x x\ldots x}{}

\end{tikzpicture}
}

\caption{Структура числа с~плавающей запятой согласно стандарту IEEE~754:
а)~нормализованное число, б)~денормализованное, в)~ноль, г)~бесконечность, д)~неопределённость или нечисло}
\label{ris:digit-floatpoint}
\end{illustration}

Следующие~$w$ бит занимает порядок~$p$.
Порядок представляется кодом с~избытком,
то есть после знакового бита следует натуральный код значения $p + \xi$, где $\xi = 2^{w-1} - 2$ постоянно для формата.
Значение $p + \xi$ называется смещённым порядком.

% Минимально представимое значение $p_{min}$ кодируется строкой из одних нулей, максимально представимое $p_{max}$ "--- строкой из единиц.
% Оба они считаются специальными "--- порядку $p_{min}$ соответствуют нули и~денормализованные числа, 
% $p_{max}$ "--- бесконечности, неопределённости и~нечисла.
Минимально представимое значение смещённого порядка кодируется строкой из одних нулей, максимально представимое  "--- строкой из единиц.
Оба они считаются специальными "--- смещённому порядку $000\ldots 000$ соответствуют нули и~денормализованные числа, 
$111\ldots111$ "--- бесконечности, неопределённость и~нечисла.

% Таким образом, минимальное значение порядка $p_{min}$ кодируется как $00\ldots01$ и~равно $1-\xi$, максимальное $p_{max}$ "--- кодируется как $11\ldots10$ и~равно $2^w-2 - \xi$.
Таким образом, минимальное допустимое значение смещённого порядка нормализованного числа  кодируется как $000\ldots001$,
а~собственно порядок равен $p_{min}=1-\xi = 3-2^{w-1}$, 
максимальное  "--- кодируется как $111\ldots110$, соответственно максимальный порядок числа $p_{max} = 2^w-2 - \xi = 2^{w-1}$.

Последние~$n$ бит числа с~плавающей запятой занимает округлённая мантисса.

Так как для %$p_{min} \leqslant p \leqslant p_{max}$
нормализованного числа старший бит мантиссы $m_1$ всегда равен единице, его не имеет смысла хранить.
Соответственно, $n$ бит мантиссы хранят разряды от $m_2$ до $m_{n+1}$. % (рис.~\ref{ris:digit-floatpoint}, а).
В~поле смещённого порядка нормализованного числа записывается натуральный двоичный код $p + \xi$ (рис.~\ref{ris:digit-floatpoint}, а).

Если порядок числа $X$  слишком мал ($p<p_{min}$), число представляют в~виде:
% Если число не может быть представлено в~нормализованном виде~\eqref{eq:digits-floatpoint-def-2}
% с~$p_{min} \leqslant p \leqslant p_{max}$
% из-за его малости, 
% его представляют в~виде:
\begin{equation}
\label{eq:digits-floatpoint-2-denorm}
X = (-1)^{s} \cdot 2^{p_{min}} \cdot \mu, ~~ s \in \{0, 1\},~ ~ 0 \leqslant \mu < 0,1_2
\end{equation}
% такое число называется денормализованным.
и~называют денормализованным.

Старший бит $m_1$  мантиссы денормализованного числа всегда равен нулю ($\mu = \overline{0,0 m_2 m_3 m_4\ldots}$),
так что его тоже не имеет смысла хранить.
В~поле мантиссы записываются разряды от $m_2$ до $m_{n+1}$. 
В~поле смещённого порядка денормализованного числа записывается специальное значение $000\ldots 000$ (рис.~\ref{ris:digit-floatpoint}, б).

Если смещённый порядок равен $000\ldots 000$ и~при этом все биты мантиссы равны нулю, получаем значение $\pm0$ (рис.~\ref{ris:digit-floatpoint}, в):
\begin{equation}
\label{eq:digits-floatpoint-2-zero}
X = (-1)^{s} \cdot 2^{p_{min}} \cdot \mu, ~~ s \in \{0, 1\},~\mu = \overline{0,0000\ldots 0}
\end{equation}
Нули считаются не денормализованными, а~специальными значениями, хотя и~могут быть декодированы по формуле~\eqref{eq:digits-floatpoint-2-denorm}.

Если смещённый порядок состоит только из единиц (равен $111\ldots111$), а~поле мантиссы "--- только из нулей,
получаем специальное значение бесконечности (рис.~\ref{ris:digit-floatpoint}, г). %$\pm\infty$.

В~зависимости от поля знака, существуют два значения бесконечности и~два нуля, так что $\frac{1}{+0} = +\infty$ и~$\frac{1}{-0} = -\infty$.
На рис.~\ref{ris:digit-floatpoint}, в) и~г) это показано как $(-1)^s\cdot 0$ и~$(-1)^s\cdot \infty$ соответственно.
% хотя при непосредственном умножении 

% Мантисса $\mu = \overline{0,1 m_2 m_3\ldots}$ потенциально бесконечна, но для ЭВМ её необходимо округлить до конечного количества разрядов.
% Порядок $p$ также должен быть представлен конечным количеством битов.
% 
% Пусть для записи порядка $p$ используется $w$ бит, для мантиссы~$\mu$ "--- $n$ бит,
% тогда общая длина кода числа $N=n+w+1$.


Если смещённый порядок равен $111\ldots111$, а~поле мантиссы содержит не только нули,
получаем так называемые нечисла (рис.~\ref{ris:digit-floatpoint}, д). 
Нечисла не имеют знака, бит~$s$ игнорируется.

Если при этом старший сохраняемый бит мантиссы ($q$ на рис.~\ref{ris:digit-floatpoint}, д) равен единице,
это так называемое тихое нечисло, или вещественная неопределённость (получаемая, в~частности, как~$\frac{0}{0}$).
% 
Если $q=0$, нечисло называется сигнальным и~не может быть результатом вещественной операции.
% (при этом не все биты мантиссы должны быть равны нулю, иначе ).

\subsubsection{Форматы двоичных чисел с~плавающей запятой согласно IEEE~754}
\index{Представление данных!вещественных!двойной точности}
\index{Представление данных!вещественных!одинарной точности}

Стандарт IEEE~754-1985 описывает два двоичных формата с~плавающей запятой "--- 32-битный формат одинарной точности и~64-битный формат двойной точности.
В~IEEE~754-2008 были добавлены 16- и~128-битный двоичный форматы (от названий в~новой версии формата отказались),
а~также описана общая формула $k$-битного двоичного формата для $k \geqslant 128$ %(ей соответствуют форматы двойной точности и~128-битный)
(таблица~\ref{tab:digits-float-binbits}).


\begin{table}[!ht]
\newcolumntype{z}{>{$}c<{$}}
\newcolumntype{Z}{>{$}C<{$}}

\caption{Стандартные двоичные форматы с~плавающей запятой}
\label{tab:digits-float-binbits}

% \renewcommand{\arraystretch}{1.5}
\begin{tabularx}{1\linewidth}{|>{\bfseries }l|zzzz|Z|}%{>{\bfseries }l|CCCC}%{>{\bfseries }L|cccc}
\hline
Общая длина $n+w+1$, бит	&	\mathbf{16}	&	\mathbf{32}	&	\mathbf{64}	&	\mathbf{128}	&	 \mathbf{k \geqslant 128}	\\
\hline
Длина кода знака $s$, бит	&	1	&	1	&	1	&	1	&	1	\\
Длина кода порядка $w$, бит	&	5	&	8	&	11	&	15	&	round(4\cdot \log_2 k) - 13\\
Длина кода мантиссы $n$, бит	&	10	&	23	&	52	&	112	&	k-w-1	\\
\hline
\end{tabularx}
\end{table}

Также IEEE~754-2008 описывает возможность расширения стандартных форматов с~увеличением как точности мантиссы, так и~диапазона порядка.

Кроме двоичных, IEEE~754-2008 описывает два десятичных формата длины 64 и~128 бит,
а~также формулы для десятичного формата длины~$k=32\kappa$.
Десятичные форматы IEEE~754-2008 имеют более сложную структуру, чем двоичные.
Для экономии памяти в~мантиссе для цифр $m_2, m_3, m_4\ldots$ используется кодирование троек десятичных цифр группами по десять бит 
(так как число кодовых комбинаций $2^{10} = 1024 > 10^3$, это возможно),
а~код порядка соединён с~кодом старшей цифры $m_1\neq 0$.



\subsubsection{Структура нестандартного числа FPU x87}
\index{Представление данных!вещественных!расширенной точности}

В~математическом сопроцессоре x87, входящем в~состав процессоров линейки x86, используется нестандартный  формат вещественных чисел (рис.~\ref{ris:digit-floatpoint-x87}), 
так как первый подобный сопроцессор был выпущен задолго до первой редакции стандарта  IEEE~754.



\begin{illustration}
\newcommand{\real}[5][]
{
  \node[block, minimum width= 42 ex, on chain, #1]  (m)  {$#4$};
  \node[block, minimum width= 18 ex, on chain]  (p) {$#3$};
  \node[block, minimum width= 4 ex, on chain]  (s) {$#2$};
  
    \node[left = 2ex of s] {\asbuk{risletter})\stepcounter{risletter}};
    \node[right = 2ex of m] {$#5$};
%   \tikzset{node distance=2ex}

  \foreach \nd/\s/\e in {m/0/63, p/64/78}
%   \foreach \nd/\s/\e in {\pmbits}
  {
    \node[below right = of \nd.south west, blabel, anchor=north west] (be) {$\e$};
    \node[below left = of \nd.south east, blabel, anchor=north east] (bs) {$\s$};
%   \coordinate[left =  of \nd.south east, label=below:$\mathstrut\s$] (bs);
  };
  \node[below = of s, blabel]  {$79$};
}
\setcounter{risletter}{1}


\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going left,
node distance=0ex,
baseline=(current bounding box.north)
]
\tikzstyle{block}	= [text badly centered, minimum height=4ex, draw=black,  fill=clRegisterLight, solidchaincell]
\tikzstyle{nextm}	= [below = 6ex of m]

  \real{s}{p+\xi}{1 m_2 m_3 m_4\ldots m_{n}}{	
    \begin{array}{c}
      (-1)^s\cdot 2^p \cdot \overline{0,1m_2 m_3 m_4\ldots m_{n}}\\
      p_{min} \leqslant p \leqslant p_{max}
    \end{array}
  }

  \real[nextm]{s}{000\ldots000}{0 m_2 m_3 m_4\ldots m_{n}}{	(-1)^s\cdot 2^{p_{min}} \cdot \overline{0,0m_2 m_3 m_4\ldots m_{n}}	}
  \real[nextm]{s}{000\ldots000}{000\ldots 0}{	(-1)^s\cdot 0	}
%   \real[nextm]{s}{000\ldots000}{000\ldots 0}{	\pm 0	}

  \real[nextm]{s}{111\ldots111}{000\ldots 0}{	(-1)^s\cdot \infty	}
%   \real[nextm]{s}{111\ldots111}{000\ldots 0}{	\pm \infty	}
  \real[nextm]{x}{111\ldots111}{110\ldots 0}{}
  \real[nextm]{x}{111\ldots111}{q x x\ldots x}{}

\end{tikzpicture}
}

\caption{Структура внутреннего представления чисел в~FPU x87:
а)~нормализованное число, б)~денормализованное, в)~ноль, г)~бесконечность, д)~неопределённость, е)~нечисло}
\label{ris:digit-floatpoint-x87}
\end{illustration}

Порядок этого формата занимает $w=15$ бит,
мантисса "--- $n=64$ бита.
Общий размер числа $k=n+w+1=80$ бит.

Формат сопроцессора x87 отличается от стандартных не только разрядностью полей (IEEE~754 предусматривает расширенные форматы с~увеличенной разрядностью),
но и~тем, что мантисса включает старший бит (единицу для нормализованных чисел и~ноль для денормализованных).

% При этом порядок денормализованных чисел, как и~для стандартных форматов, равен

Также сопроцессор x87 различает несколько видов тихих нечисел.
Только один из них является вещественной неопределённостью (рис.~\ref{ris:digit-floatpoint-x87}, е).

Возможен экспорт из описанного нестандартного представления в~стандартные форматы одинарной и~двойной точности.

\subsubsection{Точность двоичных чисел с~плавающей запятой}

Как и~в~случае фиксированной запятой, 
формат с~плавающей точкой не может описать все вещественные значения в~заданном диапазоне.

При сохранении вещественного числа $X$ в~формате с~плавающей запятой оно округляется до ближайшего представимого числа $\breve{X}$.

Если $\breve{X} = (-1)^{s} \cdot 2^{p} \cdot \mu$ нормализовано,
то абсолютная погрешность округления не превышает веса младшего разряда мантиссы:
\begin{equation}
\label{eq:digits:real-floatpoint-abserror}
\left| X - \breve{X} \right| \leqslant \frac{2^{p}}{2^{n+1}} = 2^{p-n-1}.
\end{equation}
Эта величина зависит от порядка $p$ и~превышает единицу при %$p-n-1>0$, то есть 
$p > n+1$.

Таким образом, с~ростом абсолютной величины $X$ (и,~соответственно, порядка $p$) абсолютная погрешность округления катастрофически растёт.
% Так как при сложении и~вычитании абсолютные погрешности складываются, возможна

Относительная погрешность округления до нормализованного~$\breve{X}$ может быть %приближённо 
оценена сверху как $\frac{1}{2^{n}}$:
\begin{equation}
\label{eq:digits:real-floatpoint-relerror}
\begin{array}{c}
\displaystyle
\left| \frac{X - \breve{X}}{X} \right| \leqslant \frac{2^{p}}{2^{n+1}\cdot |X|} 
\approx\frac{2^{p}}{2^{n+1}\cdot |\breve{X}|} = \frac{2^{p}}{2^{n+1}\cdot 2^p \cdot \mu} = \\
\displaystyle
= \frac{1}{2^{n+1}\cdot \mu} \leqslant \frac{1}{2^{n+1}\cdot 0,1_2} = \frac{1}{2^{n}}.
\end{array}
\end{equation}
Оценка на самом деле точная, так как хотя настоящая мантисса $X$ не равна $\mu$, она также не превышает $0,1_2$.

Если ${X}$ невозможно представить в~нормализованном виде,
абсолютная погрешность округления не превышает $\frac{2^{p_{min}}}{2^{n+1}} = 2^{p_{min}-n-1}$,
относительная погрешность будет расти при уменьшении абсолютной величины~$X$, так как мантисса денормализованного числа %не ограничена снизу.
может быть сколь угодно близка к~нулю.


\subsubsection{Нормализованное представление в~отечественной и~зарубежной традиции}

В~зарубежных источниках~\eqref{eq:digits-floatpoint-def} называется нормализованным в~случае $1 \leqslant \mu < 10_N$~\cite{intelBasic}.
Там считается, что мантисса нормализованного числа включает целую часть (хотя суть от этого не меняется).
Действительно, пусть
% \begin{equation}
% X = (-1)^{s} \cdot 2^{p} \cdot \mu = (-1)^{s} \cdot 2^{\widetilde{p}} \cdot \widetilde{\mu}
% \end{equation}
% где $0,1_2 \leqslant m < 1$ и~$1 \leqslant \widetilde{m} < 10_2$.
\begin{equation}
\label{eq:digits-floatpoint-norm-rus}
X = (-1)^{s} \cdot N^{p} \cdot \mu, ~~ s \in \{0, 1\}, ~p \in \Integerset, ~ 0,1_N \leqslant \mu < 1,
\end{equation}
то есть $\mu = \overline{0,m_1 m_2 m_3 m_4\ldots}, ~m_1 \neq 0$.
Пусть также
\begin{equation}
\label{eq:digits-floatpoint-norm-en}
X = (-1)^{\widetilde{s}} \cdot N^{\widetilde{p}} \cdot \widetilde{\mu}, ~~ \widetilde{s} \in \{0, 1\},~ \widetilde{p} \in \Integerset, ~ 1 \leqslant \mu < 10_N
\end{equation}
Тогда
\begin{equation}
\left\{
\begin{array}{lllllll}
\widetilde{s}  &=& s\\
\widetilde{p} &=& p - 1\\
\widetilde{\mu} &=& N\cdot \mu &=& 10_N \cdot \mu &=& \overline{m_1,m_2 m_3 m_4\ldots}\\
\end{array}
\right.
\end{equation}
Так как двоичная/десятичная запятая является нецифровым символом, она не может быть записана в~память, а~только \emph{подразумевается} на той или иной позиции,
двоичное представление мантиссы в~формах~\eqref{eq:digits-floatpoint-norm-rus} и~\eqref{eq:digits-floatpoint-norm-en} \emph{полностью совпадает.}
Порядок~$\widetilde{p}$ формы~\eqref{eq:digits-floatpoint-norm-en}, %в~этом случае 
соответственно,
записывается с~избытком $\widetilde{\xi} = \xi+1$, так что полученное значение смещённого порядка в~результате также совпадает с~формой~\eqref{eq:digits-floatpoint-norm-rus}.
Таким образом, двоичное представление одинаковых чисел (как нормализуемых в~формате расширенной точности, так и~денормализованных) одинаково и~не зависит от формы нормализованного представления.

В~отдельных источниках мантисса и~вовсе рассматривается как целое беззнаковое число $\overline{m_1 m_2 m_3 m_4\ldots m_{n}}$~\cite{ieeeFloat1985rus}.
Такая трактовка также допустима и~равносильна~\eqref{eq:digits-floatpoint-norm-rus} и~\eqref{eq:digits-floatpoint-norm-en}
при соответствующей коррекции порядка %$p$ 
и~смещения. %~$\xi$




% \nsection{Контрольные вопросы}
% 
% \begin{enumerate}
% % \item Какие вы знаете единицы измерения информации?
% 
% \item Какие способы представления беззнаковых чисел используются в~ЭВМ?
% \item Какие способы представления знаковых чисел используются в~ЭВМ?
% \item Какие логические и~битовые операции вы~знаете?
% 
% % \item Какие способы представления вещественных чисел используются в~ЭВМ?
% \end{enumerate}

\printquestions