% \section{Препроцессор C/C++}
\subsection{Макросы препроцессора C/C++}

Первая стадия компиляции программы на C/C++ "--- обработка исходного кода препроцессором.

Препроцессор «не понимает» языков C, C++ или ассемблера и~обрабатывает собственный язык "--- директивы препроцессора.
В~частности, запись \lstinline!#include имя_заголовочного_файла! целиком копирует указанный заголовочный файл на место, где была директива \lstinline!#include!.

С помощью директивы \lstinline!#define! можно определить \termin{макросы} "---
лексемы, которые принимают параметры подобно функциям, но фактически являющиеся \termin{текстовой заменой} (более гибким аналогом меню Replace текстового редактора) и~раскрываются не во время выполнения (как функции) и~не во время компиляции (как шаблоны C++), а~до анализа и~компиляции программы, никак не сообразуясь с~типами переменных, текстом программы и~так далее.

Использование макросов небезопасно и~не должно (за исключением условной компиляции) применяться при программировании на высоком уровне.

При описании макроса
после директивы \lstinline!#define! указывается имя макроса, за которым в скобках (без пробелов) параметры, отделенные запятыми и определение макроса, отделенное пробелом. 

Макрос без параметров
\begin{lstlisting}
#define THE_NUMBER 13
\end{lstlisting}
Макрос с~двумя параметрами
\begin{lstlisting}
#define MAX(num1, num2) ((num1) > (num2) ? (num1) : (num2))
\end{lstlisting}

При использовании макроса в~тексте на место параметров вписывается какой-либо текст:
\begin{lstlisting}
int i = THE_NUMBER;
int j = MAX(9, i);
\end{lstlisting}

Параметры макроса при подстановке никак не проверяются.
Если в~результате такой текстовой подстановки возникнет ошибка, это выяснится только на этапе компиляции, причём не всегда сообщение об ошибке будет вменяемым.

В~описании параметры макроса берутся в~скобки, чтобы избежать неприятных ситуаций
(если макрос представляет собой вычисление выражения, то и~его тоже лучше взять в~скобки).
Например, макрос, определённый как
\begin{lstlisting}
#define SQUARE(x) x*x
\end{lstlisting}
в~случае 
\begin{lstlisting}
i = SQUARE(2+2);
\end{lstlisting}
раскроется в~\lstinline!i = 2+2*2+2;!, что даст \lstinline!i!, равное~$2+4+2=8$, а~не $(2+2)^2=16$.

Определение макроса должно занимать одну строку.
Если строка-подстановка не помещается в строку файла, то в качестве знака переноса строки используется  обратная косая черта. 
\begin{lstlisting}
#define DISPLAY_ARRAY(arr, size) {\
	int i;\
	for (i = 0; i < size; i++) {\
		printf("%d ", arr[i]);\
	}\
	printf("\n");\
}
\end{lstlisting}

% Макрос с~параметрами "--- это просто текстовая замена, поэтому 

Параметры макроса можно взять в~кавычки, используя оператор \lstinline!#!:
\begin{lstlisting}
#define QUOTES(x) #x
\end{lstlisting}
Тогда следующий оператор
\begin{lstlisting}
cout <<  QUOTES(1+2) << " " << QUOTES(x) << " " << QUOTES(мяу) << " " << QUOTES("мяу") << endl;
\end{lstlisting}
выведет
\begin{lstlisting}
1+2 x мяу "мяу"
\end{lstlisting}

% Строки (не в~смысле C/C++, а~произвольные кусочки исходного )  
% Элементы  
Параметры можно «склеивать» друг с~другом и~с~произвольными строками
% можно объединить
с~помощью оператора \lstinline!##!. 
Пример такого макроса:
\begin{lstlisting}
#define INLINE_TEMPLATE(typename) typename x##typename = 1, y##typename; \
    cout << typeid(x##typename).name() << " " << x##typename << endl;
\end{lstlisting}
получив имя типа как строку (например, \lstinline!int!), мы объявляем две переменные \lstinline!x<имя типа>! и~\lstinline!y<имя типа>!.
Следующий код не вызовет ошибок компиляции.
\begin{lstlisting}
    INLINE_TEMPLATE(int)
    yint = xint+1;
\end{lstlisting}
% Здесь, в~отличие от шаблонов
    
