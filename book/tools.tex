
\chapter{Инструменты разработки}


\subsubsection{Компиляторы C++ (x86)}

\begin{itemize}
\item \termin{GNU Compiler Collection (GCC)} "--- более 45 платформ, большинство ОС (порт под MS Windows "---  \termin{MinGW}), %7 языков (в~том числе C и~C++, стандарт), 
лицензия GNU GPL 3+ 
\item \termin{Portable C Compiler (PCC)} "--- Unix-подобные ОС, %GNU/Linux, 
MS Windows; лицензия BSD


\item \termin{TenDRA} "--- x86, x86-64, IA-64; POSIX-совместимые ОС; лицензия BSD

\item \termin{Oracle Solaris Studio} "--- x86, x86-64, SPARC; Solaris, OpenSolaris, GNU/Linux; собственническая лицензия

\item \termin{Intel C++ compiler} "--- x86, x86-64,  IA-64 (Itanium), GNU/Linux, MacOS X, MS Windows, коммерческая собственническая лицензия

\item \termin{Open Watcom} "--- DOS, OS/2 и MS Windows; лицензия  	
Sybase Open Watcom Public License version 1.0, 
%не полностью поддерживает стандарт С++
неполная поддержка стандарта

\item \termin{MS Visual C++} "--- x86, x86-64, IA-64 и~.NET, только MS Windows, коммерческая собственническая лицензия, %грубые 
нарушения стандарта

% \item \termin{Norcroft C Сompiler} "--- Intel Pentium для GNU/Linux, коммерческая собственническая лицензия
% 
% 
% \hrulefill
% \item \termin{Clang} "--- виртуальная RISC-машина LLVM

\end{itemize}

Коллекция GCC:

\termin{gcc} "---  компилятор~C;

\termin{g++} "---  компилятор~C++.


\subsubsection{Ассемблеры x86}

\begin{itemize}
\item \termin{GNU Assembler (GCC)} "--- более 45 платформ, большинство ОС, лицензия GNU GPL 3+ 
\item \termin{Flat Assembler (FASM)} "--- x86, DOS, Microsoft Windows, UNIX-подобные (GNU/Linux, OpenBSD и др.), MenuetOS, KolibriOS, DexOS,  лицензия BSD 
\item \termin{NASM/Yasm} "--- x86, x86-64, GNU/Linux, DOS, Microsoft Windows, UNIX,  лицензия BSD 
% \item HLASM "--- z/Architecture IBM
\item \termin{Turbo Assembler (TASM)/Lazy Assembler} "--- x86, DOS, Microsoft~Windows
\item \termin{MASM} "--- x86, DOS, Microsoft Windows

\end{itemize}

{} \termin{AT\&T}

\begin{lstlisting}[numbers=none]
movl $42, %eax

movl $0x10, %ebx


lea  -0x30(%rcx,%rax,8), %eax
movl (%ebx), %eax

movl $0xCCCCCCCC, %ecx


movl 0xCCCCCCCC, %ecx
\end{lstlisting}


% -4(%ebp), Intel:  [ebp - 4]
{} \termin{Intel}

\begin{lstlisting}[numbers=none]
mov eax, 42

mov ebx, 10h
mov ebx, 0x10 ; masm

lea eax, [rcx+rax*8-0x30]
mov eax, dword ptr [ebx]

mov ecx, 0xCCCCCCCC   
/*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; masm}@*/
mov ecx, ds:[0xCCCCCCCC]
/*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; nasm}@*/
\end{lstlisting}


\subsubsection{Компиляция}

main.cpp
\begin{lstlisting}
int x = 13;
int main()
{
    int y = 2*x + 123;
...
}
\end{lstlisting}

g++ -S main.cpp $\to$

main.s
\begin{lstlisting}
...
.globl	x
	.data
	.align 4
	.type	x, @object
	.size	x, 4
x:
	.long	13
...
	movl	x, %eax
	addl	%eax, %eax
	addl	$123, %eax
	movl	%eax, -12(%ebp)
\end{lstlisting}



\section{Процесс компиляции}
\epigraph{\begin{stanza}
Вскипятите его, остудите во льду\\
И~немножко припудрите мелом,\\
Но одно безусловно имейте в~виду:\\
Не нарушить симметрию в~целом!\\
\end{stanza}
}
{\Snark}

% \epigraph{
% "--*  Как убить синего слона?
% 
% "--*  Из винтовки для синих слонов.
% 
% "--*  А как убить красного слона?
% 
% "--*  Его надо душить, до тех пор пока он не посинеет, затем застрелить из винтовки для синих слонов.
% 
% "--*  А как убить зелёного слона?
% 
% "--*  Нужно рассказывать ему похабные анекдоты, пока он не покраснеет, затем душить, пока не посинеет, затем застрелить из винтовки для синих слонов.
% }
% {П.\,Канюкова}




\index{Компиляция!этапы}

\subsection{Компиляция программы на языке C++\footnote{%http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html
Использованы материалы CSCI 241
Intermediate Programming in C++
Spring 2015
(The C++ compilation process)
% http://knzsoft.ru/cpp-bgr-ls1/
и~А.\,А.\,Князев. Руководство по C++ для начинающих}
}
\label{sec:cpp-compile}
\addquestion{Какие стадии включает компиляция программы с~помощью GCC?}

Компиляция программы на языке C++ включает четыре этапа (рис.~\ref{ris:c++compile}):
\newlength{\slideheigth}
\setlength{\slideheigth}{0.5\textheight}

% \begin{illustration}[p]
% \includegraphics[width=\linewidth]{compile}
% 
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}
% % \hfill
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}
% 
% \caption{Этапы компиляции программы на C++}
% \label{ris:c++compile}
% \end{illustration}

\begin{illustration}
\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\schemafont
\lstset{basicstyle=\ttfamily\schemafont}

\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{invisblock}	= [text width=16ex,text badly centered, minimum height=3ex]
\tikzstyle{block}	= [invisblock, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]
\tikzstyle{stagenum}	= [stage, text width=2ex, circle, node distance=28ex]
\tikzstyle{filecomment}	= [invisblock,text width=20ex]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[stagenum, left= of cpp_preprocess] {1};
\node[stagenum, left= of compiler] {2};
\node[stagenum, left= of cpp_asm] {3};
\node[stagenum, left= of cpp_linker] {4};

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[right= of compiler] (mangling) {Декорирование};
\node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


% % \node[right= of cpp] (S) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}};
% \node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
% \node[stage,on chain=S] (S_preprocess) {Препроцессор};
% \node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
% \node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
% \node[file,on chain=S] (prog2_o) {prog2.o};
% \node[stage,on chain=S] (S_linker) {Компоновщик};
% % \coordinate[on chain=S] (S_linker);
% 
% % \node[file, right= of S_preprocess,text width=20ex] (S_headers) {Заголовочные файлы (\#include)};
% % \path[blockarrow] (S_headers) -- (S_preprocess);
% \path[blockarrow] (cpp_headers) -- (S_preprocess);
% 
% % \path[blockarrow] (cpp_asm) -- (S_asm);

% \path (cpp_linker)
\node[stage,fit=(cpp_linker)% (S_linker)
, inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[filecomment, left= of prog1_cpp] {Файл исходного кода};
\node[filecomment, left= of prog1_pp] {Дополненный файл исходного кода};
\node[filecomment, left= of prog1_s] {Файл команд ассемблера};
\node[filecomment, left= of prog1_o] {Объектный файл};
\node[filecomment, left= of prog] {Исполняемый файл};

% \node[below= of prog-|cpp_linker]  {extern};

% \node[below= of prog-|S_linker]  {.globl};


% \coordinate[above=6ex of cpp.south] (linking_start);

\begin{pgfonlayer}{background}
% %   \coordinate[left=0ex of cpp.south west] (cpp_egde);
% %   \coordinate[right=0ex of S.south east] (S_egde);
%   \node[rectangle,fit=(cpp.south west) (S.south east) (linking_start), inner sep=0ex, minimum height=11.8mm,fill=yellow] (linking) {};
\node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};

\end{pgfonlayer} 

\end{tikzpicture}
}
\caption{Этапы компиляции программы на C++}
\label{ris:c++compile}
\end{illustration}



\begin{enumerate}[wide=\parindent]
{
\item Препроцессор копирует содержимое включённых  директивой \lstinline!#include! заголовочных файлов в~исходный код модуля, раскрывает макросы и,~в~том числе, выполняет текстовые замены «констант», определённых с~помощью директивы \lstinline!#define!, на их значения, а~также отрабатывает директивы условной компиляции, выбрасывая из кода те или иные фрагменты.\fussy

}
\begingroup
\lstset{language=Bash}

При использовании компилятора из коллекции GCC
увидеть результат препроцессинга можно, воспользовавшись опцией \lstinline!-E!% компилятора g++
. Результат будет выведен в стандартный поток вывода (в~представленном %ниже 
примере %стандартный поток вывода 
перенаправлен в~файл main.E).

\begin{lstlisting}
$ g++ -E main.cpp > main.E
\end{lstlisting}
Здесь и далее, знак доллара (\lstinline!$!) обозначает стандартное приглашение %к вводу команды в 
консоли *nix. Писать знак доллара не требуется.
Регистр важен.


\item Код, обработанный препроцессором, транслируется компилятором в~ассемблерный код для соответствующей платформы.

Для остановки компиляции после этого этапа для компилятора g++ следует воспользоваться ключом \lstinline!-S!:
\begin{lstlisting}
$ g++ -S main.cpp
\end{lstlisting}

На этапе компиляции выполняется \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.
% Имена 
% C++ искорёжены почти до неузнаваемости, C — у меня сохранены, а у вас, если статья Фога не ошибатеся, к ним приписывается префикс _: _Sqr вместо Sqr (и было бы __Sqr вместо _Sqr, но такой функции в C++-программе нет).
В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
(в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).

Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
В~статье Агнера Фога 
«Calling conventions for different C++ compilers and operating systems»
приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).


\item Ассемблерный код, созданный компилятором, транслируется в~объектный код для соответствующей платформы.
Останов компиляции файла после этапа ассемблирования  обеспечивается ключом \lstinline!-c!:

\begin{lstlisting}
$ g++ -c main.cpp
\end{lstlisting}
При ассемблировании  имена функций сохраняются.



\item Объектные файлы% различных модулей и~библиотек
, созданные ассемблером, объединяются компоновщиком (линкером, редактором связей) в~исполняемый файл.

На данном этапе компоновщик ищет реализации для всех внешних (\lstinline!extern!) функций по именам.
Соответственно, имена, которые в~разных модулях носит одна и~та же функция, на этапе компоновки должны совпадать.


\end{enumerate}
\FloatBarrier
Интегрированные среды разработки (IDE) выполняют все этапы автоматически.

\subsection{Расширения файлов исходного кода}

\addquestion{Какое расширение имеет файл с~исходным кодом на языке ассемблера?}
\addquestion{Какое расширение имеет файл с~исходным кодом на языке C++?}

Чтобы начать сборку не с~начала, достаточно задать для файла расширение, отличное от~\lstinline!.cpp! или ~\lstinline!.c!.
Вообще, компилятор "--- одна из немногих программ, которые учитывают расширение файла при его обработке.

Расширение  \programname{.s} соответствует ассемблерному файлу. 
Таким образом, команды
\mbox{\lstinline!$ g++ main.s!} и~\mbox{\lstinline!$ gcc main.s!}
эквивалентны и~выполняют ассемблирование и~компоновку ассемблерного файла~\lstinline!main.s!%.
, минуя этапы препроцессинга и~компиляции с~ЯВУ.

{

Расширение \programname{.o} соответствует объектному файлу, и~команды
\mbox{\lstinline!$ g++ main.o!} и~\mbox{\lstinline!$ gcc main.o!}
выполняют только компоновку файла~\lstinline!main.o!.
\fussy

}

В~случае, когда необходимо выполнить препроцессинг, ассемблирование и~компоновку, выбросив только этап компиляции с~ЯВУ (именно такая последовательность оптимальна при сборке модулей, вручную написанных на ассемблере), используется
расширение \programname{.S}.
\begin{lstlisting}
$ g++ main.S
\end{lstlisting}
Большинство современных файловых систем чувствительны к~регистру имён, а~современные ОС, такие как GNU/Linux и~BSD, различают регистр при обработке.
 
\subsection{Изменение имени выходного файла}

\addquestion{Как изменить имя выходного файла при сборке?}

Имя исполняемого файла по умолчанию (\lstinline!a.out!) можно изменить, используя ключ~\lstinline!-o!:
\begin{lstlisting}
$ g++ main.cpp -o prog
\end{lstlisting}
Таким образом исполняемый файл, полученный после сборки main.cpp (отсутствие ключей остановки сборки соответствует выполнению всех этапов), получит имя~\lstinline!prog!.

\subsection{Компиляция проекта, состоящего из нескольких модулей}
\index{Компиляция!модули}
\addquestion{Как собрать программу, состоящую из нескольких модулей?}


\lstset{language=Bash}

При компиляции проекта, включающего несколько модулей, шаги препроцессинга, компиляции и~ассемблирования повторяются для каждого файла исходного кода.
Затем из полученных объектных файлов линкер собирает единый исполняемый файл (рис.~\ref{ris:c++asmcompile}).
Это можно выполнить одним запуском %любого 
компилятора из коллекции GCC:
\begin{lstlisting}
g++ -o prog prog1.cpp prog3.cpp 
\end{lstlisting}

Если попытаться собрать каждый из модулей отдельно, мы получим ошибки компоновки (так как во всех модулях, кроме главного, отсутствует точка входа "--- функция \lstinline!main!, а~в~главном "--- нет функций, описанных в~остальных).


\begin{illustration}
\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize\singlespacing
\lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=16ex,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[right= of compiler] (mangling) {Декорирование};
\node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


% \node[right= of cpp] (S) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}};
\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {prog2.o};
\node[stage,on chain=S] (S_linker) {Компоновщик};
% \coordinate[on chain=S] (S_linker);

% \node[file, right= of S_preprocess,text width=20ex] (S_headers) {Заголовочные файлы (\#include)};
% \path[blockarrow] (S_headers) -- (S_preprocess);
\path[blockarrow] (cpp_headers) -- (S_preprocess);

% \path[blockarrow] (cpp_asm) -- (S_asm);

% \path (cpp_linker)
\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[below= of prog-|cpp_linker]  {extern};

\node[below= of prog-|S_linker]  {.globl};


% \coordinate[above=6ex of cpp.south] (linking_start);

\begin{pgfonlayer}{background}
% %   \coordinate[left=0ex of cpp.south west] (cpp_egde);
% %   \coordinate[right=0ex of S.south east] (S_egde);
%   \node[rectangle,fit=(cpp.south west) (S.south east) (linking_start), inner sep=0ex, minimum height=11.8mm,fill=yellow] (linking) {};
\node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};

\end{pgfonlayer} 

\end{tikzpicture}
}
\caption{Этапы компиляции программы}
\label{ris:c++asmcompile}
\end{illustration}


Можно остановить сборку после этапа компиляции модулей:
\begin{lstlisting}
g++ -с prog1.cpp prog3.cpp 
g++ -с prog3.cpp 
\end{lstlisting}

Затем из полученных объектных файлов одним запуском линкера можно получить исполняемый файл:
\begin{lstlisting}
g++ -o prog prog1.o prog3.o 
\end{lstlisting}
Ручная сборка небольших проектов обычно выполняется одной командой, в~интегрированных средах разработки этапы, как правило, разделяются.


\endgroup








\section{Компиляция и~отладка в~IDE} 
\label{sec:cpp-ide}
\epigraph{\begin{limerick}
Одному господину в~Версале \\
Так внезапно глаза отказали,\\
Что он видеть не мог\\
Даже собственных ног "---\\
И~просил, чтоб ему показали.\\
\end{limerick}
}
{\Lear}

watch'и, memory, дизассемблер


\input{book/cpp-ide}



\subsection{Обозреватель памяти (Memory~dump)}
\index{Память!просмотр содержимого}

% \addquestion{Уметь пользоваться окнами просмотра переменных и~содержимого памяти в~отладчике используемой вами IDE.}
\addquestion{С~помощью каких инструментов можно просмотреть текущие значения переменных в~используемой вами IDE?}
\addquestion{С~помощью каких инструментов можно просмотреть текущего содержимого памяти в~используемой вами IDE?}

Исследовать структуру объекта и~его представление в~памяти во время отладки можно с~помощью  обозревателя памяти.

% Окно отладчика «Memory~dump» доступно во время отладки и~отображает содержимое памяти.
В~среде Code::Blocks окно просмотра содержимого фрагмента памяти  «Memory~dump»  (рис.~\ref{ris:cb-memory}) доступно во время отладки.
Его можно скрыть или вернуть, используя меню $Debug \to Debugging~windows \to Memory~dump$.

\begin{illustration}
\includegraphics[width=\linewidth]{cb-memory}

\caption{Отладочное окно Memory~dump в~Code::Blocks}
\label{ris:cb-memory}
\end{illustration}

Начало фрагмента может быть литералом (конкретным адресом в~памяти), адресом переменной (\lstinline!&x!), регистром, в~котором содержится адрес или~выражением C++ (результатом выражения должен быть указатель).
% Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.

Содержимое памяти отображается как последовательность байтов. 
Каждый байт представлен как беззнаковое целое (в~виде двух шестнадцатеричных цифр) и~как ASCII-символ (справа).
Байты разбиты на строки по 16; слева перед строкой показан адрес первого байта в~строке в~шестнадцатеричном виде.

% Просмотр памяти по адресу переменной с~помощью отладчика позволяет получит ту же информацию, что и~отладочная печать байтов "--- 



\section{Подключение к~проекту модулей на ассемблере}
\label{sec:gas-extern}
\epigraph{\begin{limerick}
Дама, оставив Равенну,\\
поехала поездом в~Вену,\\
Но, доехав до Вены,\\
решила мгновенно,\\
Что вернётся в~родную Равенну.
\end{limerick}
}
{\Lear}


\addquestion{Как подключить к~проекту используемой вами IDE модуль на ассемблере?}




   
% \section{Подключение модуля на ассемблере к~C++-проекту}
% \index{Подключение модуля на ассемблере}
Функции, описанные в~ассемблерном модуле, необходимо описать в~коде C++ как внешние (\lstinline!extern!).
После спецификатора \lstinline!extern!, согласно стандарту C++, могут быть указаны строки \lstinline!"C++"! (подразумевается по умолчанию) или \lstinline!"C"! (различные компиляторы могут поддерживать и~иные строки) для указания компоновщику, какой язык использовался при написании внешней функции.
Конкретные свойства таких функций не описываются в~стандарте. На практике \lstinline!"C++"! подразумевает декорирование (mangling) имён функций и~передачу параметров по возможности через регистры, что реализуется в~разных компиляторах по-разному.

Указание \lstinline!"C"! на практике подразумевает соглашение о вызовах \lstinline!cdecl!:
\begin{itemize}[wide=\parindent]

\item размещение аргументов исключительно \emph{в~стеке,} без использования регистров, причём аргументы, меньшие 4 байт, расширяются до 4 байт;

\item размещение аргументов в~стеке \emph{справа налево,} так что первый аргумент оказывается на вершине стека;

\item очистку стека \emph{вызывающей программой,} так что аргументы должны не сниматься со стека, а~копироваться оттуда;

\item возврат значения по возможности через регистры:
\begin{itemize}[leftmargin=0\parindent]
\item \EAX, если результат "--- указатель или целое число до 4 байт;
\item пара регистров \EDX:\EAX, если результат "--- целое число 8 байт;
\item вершина стека сопроцессора, если результат "--- вещественное число;

если результат не помещается в~регистры, возвращается указатель на него (через \EAX).
\end{itemize}
\end{itemize}

Также \lstinline!extern "C"! в~GNU/Linux подразумевает
% \item 
\emph{отсутствие декорирования имён,} % "--- имена функций воспринимаются линкером «как есть»
что позволяет не задумываться о~том, как имя, используемое линкером, складывается из имени, данного разработчиком и~характеристик аргументов функции,
но делает невозможной перегрузку таких функций.


Если используемый компилятор для данной платформы изменяет имена внешних C-функций, %упоминаемых в~модулях C++, 
например, добавляет префикс \lstinline!_!, как в случае gcc (mingw) под MS Windows, то ссылка на внешнюю функцию %\lstinline!sqr! 
\lstinline!extern "C" int sqr(int x)!, упоминаемую в~некотором cpp-файле %к~моменту компоновки 
в~соответствующем объектном файле
будет выглядеть как \lstinline!_sqr!.
Таким образом, для корректной компоновки имя данной функции в~объектном файле, полученном из ассемблерного модуля,  также должно быть \lstinline!_sqr!.
Кроссплатформенности в~этом случае можно достичь использованием макросов для изменения имён в~\programname{.S}-файле.


Размещение аргументов в~стеке {справа налево} и~очистка стека вызывающей программой позволяет определить функции с~переменным количеством аргументов, такие, как  \lstinline!printf! и~\lstinline!scanf! из стандартной библиотеки \lstinline!C!, но надо помнить о~небезопасности таких функций.


Рассмотрим функцию, вычисляющую квадрат целого числа.
% \lstset{language=[Motorola68k]Assembler}
Ассемблерный модуль с текстом функции\footnote{
Использованы материалы статьи Hiran Ramankutty «От C к Ассемблеру», перевод: Андрей Киселев
} находится в файле \programname{sqr.S}% (так как здесь нет необходимости в препроцессинге, можно было использовать также имя \programname{sqr.s})
.


% Адрес возврата принято передавать через стек
При вызове функции в~стек сначала помещаются аргументы в~соответствии с~соглашением о~вызовах, а~затем адрес возврата.
Соответственно, когда функция получает управление, 
% http://trubetskoy1.narod.ru/arttranslate/FuncCallPart2_1.html
то первые 4 байта по адресу, хранящемуся в \ESP, будут содержать адрес возврата. 
Далее идут аргументы функции. При использовании соглашения о вызовах \lstinline!cdecl!
непосредственно за адресом возврата (по адресу $\text{\ESP} + 4$) будет находиться первый параметр,
% следующие 4 байта (т.\,е. 4 байта по адресу $\text{\ESP} + 4$) будут содержать первый параметр, 
% в четырёх байтах по адресу $\text{\ESP} + 8$ будет второй параметр
за ним идёт второй 
и~т.\,д.

Функция \lstinline!sqr! принимает единственный параметр типа \lstinline!int! (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком),
т.\,е. 4 байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $\text{\ESP} + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.

Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, через который и нужно вернуть значение.
Таким образом, сразу после умножения можно выйти из функции командой \lstinline!ret!.
Директива \lstinline!.globl! делает функцию   \lstinline!sqr! видимой для внешних модулей.
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
\end{lstlisting}
Если в~файле несколько функций, можно указать для отладчика их границы:
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
.func sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
.endfunc
\end{lstlisting}
Парные директивы .func  $\ldots$  .endfunc не влияют ни на что, кроме добавления некоторой отладочной информации при сборке в~отладочном режиме.
В~режиме Release игнорируются.

Файл \programname{main.cpp} содержит импорт функции как \lstinline!extern "C"! и её вызов.
% Функция \lstinline!sqr! может использоваться так же, как и~функция, описанная на языке C++ (кроме перегрузки).
\begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:main.cpp]
#include <iostream>

using namespace std;
extern "C" int sqr(int x);

int main()
{
    int x=2, y;
    y = sqr(x);
    cout << y <<endl;
    return 0;
}
\end{lstlisting}


\subsection{Code::Blocks}

Создать ассемблерный модуль в~Code::Blocks можно, используя меню $File \to New \to Empty~file$.
Имя файла обязательно должно иметь расширение \lstinline!.S! (заглавное; расширение \programname{.s} не воспринимается Code::Blocks как допустимое).

После создания в~проекте файла с~таким расширением он во время сборки проекта обрабатывается препроцессором и~компилируется gcc; полученный объектный файл в~дальнейшем используется линкером. Дополнительных настроек делать не нужно.

\subsection{Qt~Creator}
% \lstset{frame=top,frame=bottom}


Файл проекта Qt~Creator для добавления ассемблерного модуля \programname{sqr.S} необходимо отредактировать вручную, добавив строку \lstinline!SOURCES += sqr.S!, так как мастер добавления файлов не воспринимает расширения  \programname{.S} и \programname{.s} как допустимые для исходного кода.
\begin{lstlisting}[caption=Файл проекта, label=lst:pro]
TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

SOURCES += main.cpp
SOURCES += sqr.S

include(deployment.pri)
qtcAddDeployment()
\end{lstlisting}
Файл  \programname{sqr.S} должен находиться в~той же папке, что и~проект.
Других настроек, кроме редактирования файла проекта, делать не нужно.







\section{Модули и~функции на ассемблере}
\label{sec:asm-func}
\epigraph{
Что такое заклинание, понятно всем. Это когда говоришь "--- а оно случается.
% 
% Нет, как-то ненаучно вышло. Заглянем в трактат профессора Югоруса Лужжа «Основные направления развития всеобщего магического образования на 1975-2125 годы»:
% 
% «Заклинание "--- вербализованная модуляция унитарного магического воздействия, подкрепленная спорадически сознательным, а иногда эмерджентным импульсом психофизиологического характера».
% 
% Вот.
% 
% А так было все понятно…
% 
% Сейчас попробуем объяснить. «Вербализованный» "--- это значит «словами», «модуляция» "--- это… ну… то сильнее, то слабее…
% 
% Ладно, все равно слово «эмерджентный» авторы даже руками показать не смогут. Вернемся к прежнему определению. Из него следует, что достаточно что-то произнести, и что-то случится. В такой, наиболее общей форме определение верно абсолютно: что бы вы ни произнесли, где-нибудь что-нибудь случится.
% 
% Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{Жвалевский/Мытько}


\subsection{Вызов подпрограммы}
\index{Подпрограммы!вызов}

\addquestion Какая команда передаёт управление подпрограмме?

\addquestion Какая команда возвращает управление вызывающей программе?

\addquestion Что такое адрес возврата?

Вызов подпрограммы в~ассемблере выполняется командой call.
Эта команда имеет один операнд "--- адрес подпрограммы в памяти.
\begin{lstlisting}
...
  movl $10, %eax
  call foo
  // теперь %eax == 15
...
foo:
  addl $5, %eax
  ret
 \end{lstlisting}
Команда \lstinline!call foo! сохраняет указатель команд в~стеке,
управление передаётся foo.
% 
Возврат из подпрограммы выполняется командой 
\lstinline!ret!
"--- управление передаётся адресу, снятому со~стека.


\subsection{Импорт внешних функций в~подпрограмму на ассемблере}

Подпрограмма на ассемблере может обращаться не только к~другим подпрограммам из того же модуля на ассемблере, 
но и~к~внешним, в~частности, к~функциям, из других объектных файлов проекта или к~стандартной библиотеке stdlib.

Для того, чтобы функция, описанная на языке C++, была доступна для экспорта в~другие модули, используется ключевое слово extern, как и~для импорта внешних функций (для отключения декорирования также используется \lstinline!extern "C"!):
\begin{lstlisting}
/*@\colorbox{codestronghighlight}{extern "C"{}}@*/
__attribute__((__cdecl__)) 
int /*@\colorbox{codehighlight}{bar}@*/(int x)
{
    return 3*x+1;
};
\end{lstlisting}
% Декорирование C++-функций делает их имена неопознаваемыми, поэтому на практике при экспорте функций лучше использовать только "C" 
% Соглашение о~вызове на всякий случай указано явно с~использованием ключевого слова \lstinline!__attribute__!, но чаще всего для использования cdecl достаточно\lstinline!extern "C"!. 

Для импорта функции в~ассемблере не требуется никаких директив, достаточно знать её имя.
\begin{lstlisting}
pushl $1
call /*@\colorbox{codehighlight}{bar}@*/
addl $4, %esp
\end{lstlisting}
Команда call, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
Она только помещает в~стек адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.

Параметры необходимо поместить вручную туда, где их ожидает увидеть подпрограмма.
Для соглашения cdecl они должны находиться в~стеке, куда помещаются командой push в~обратном порядке (приведённый код рассчитывает bar(1)).

После завершения работы такой функции параметры необходимо вручную удалить из стека.
% 
Возвращаемое значение типа int можно найти, в~соответствии с~соглашением о~вызове, в~регистре~\lstinline!%eax!.

% Необходимо всегда помнить о~том, что после вызова функции значения многих регистров меняется.





\section{Соглашения о~вызовах}
\label{sec:asm-calling-conventions}
% \epigraph{\begin{stanza}
%  Объясните  мне,  где  теперь  правда,  где  ложь, \\
%  где  жало  змеи, где пылающий   уголь,  где  тюрьма.
% \end{stanza}}
% {\Aquarium}

\epigraph{
Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{Жвалевский/Мытько}

\addquestion{Какие~вы знаете соглашения о~вызове?}

\addquestion{Как в~функции передаются целые параметры?}
\addquestion{Как в~функции передаются вещественные параметры?}
\addquestion{Как в~функции передаются три и~более параметров?}




% \footnote{Использованы материалы:
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.
% }
\index{Подпрограммы!соглашения о~вызовах}

\termin{Соглашение о~вызовах} "--- протокол передачи аргументов:
% \vspace{-1\parskip}
\begin{enumerate}
\item способ передачи (через регистры, через стек, смешанный);
\item порядок размещения аргументов (Pascal "--- первый аргумент помещается в~стек первым, C "--- последним);
\item кто очищает стек и~сохраняет/восстанавливает регистры (и~какие);
\item инструкции вызова и возврата;
\item как передаётся указатель this (для ООП).
\end{enumerate}


\cite{agner_fog_calling_conventions}

\begingroup
% \scriptsize
% \footnotesize
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|M{4em}|l|l|L|%L|
}
\hline
&{Параметры в~регистрах}
&{Порядок}
&{Очистка стека}
% &\theadlong{Дополнения}
\\\hline
cdecl&&
 C&
 вызывающая программа
 %&
 \\\hline
pascal&&
 Pascal&
 функция
 %&
\\\hline
winapi (stdcall)&&
 C&
 функция
 %&
 \\\hline
Gnu&&
 C&
%  hybrid
this "--- функция, \mbox{остальные "---  вызывающая программа}
%  &
% Стек иногда выравнивается на 16 бит
\\\hline
Gnu fastcall&
ecx, edx
&
 C&
функция
\\\hline
Gnu regparm (3)&
eax, edx, ecx
&
 C&
функция
\\\hline
Borland fastcall&
ecx, edx
&
Pascal&
функция
\\\hline
 Microsoft fastcall&
 ecx, edx&
 C&
 функция
%  &
%  return pointer on stack if
% not member function
\\\hline
% \\\hline
\end{tabularx}
\endgroup
\bigskip


Возвращаемое значение:
% \vspace{-1\parskip}
\begin{enumerate}
\item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
\item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
\end{enumerate}

\subsection{Вызов подпрограммы в~GAS}

Соглашения о~вызове: Gnu, cdecl, Gnu fastcall, Gnu regparm (0--3).

\index{Подпрограммы!использование регистров}
Регистры, значение которых не~должно изменяться подпрограммой "---
% \vspace{-1\parskip}
% \section{Подпрограммы в~GAS}
% \subsection{Регистры, значение которых не~должно изменяться подпрограммой}
% \begin{frame}[fragile]{\insertsubsection}
% \begin{enumerate}
% \item
\lstinline!%ebx!
% \item
\lstinline!%esi!
% \item
\lstinline!%edi!
% \item
\lstinline!%ebp!
% \item С
и~сегментные регистры \lstinline!%ds, %es, %ss!.
% \item Вершина стека \lstinline!%esp! нет
% \item\lstinline!%r12—%r15! в~64-битном режиме
% \end{enumerate}
Прочие могут изменяться подпрограммами.






\addquestion Чем различается код, созданный компиляторами одного семейства для различных платформ?
\addquestion Чем различается код, созданный различными компиляторами для одной платформы?


\printquestions
