
\chapter{Инструменты разработки}




\section{Процесс компиляции}
\epigraph{\begin{stanza}
Вскипятите его, остудите во льду\\
И~немножко припудрите мелом,\\
Но одно безусловно имейте в~виду:\\
Не нарушить симметрию в~целом!\\
\end{stanza}
}
{\Snark}

\epigraph{
"--*  Как убить синего слона?

"--*  Из винтовки для синих слонов.

"--*  А как убить красного слона?

"--*  Его надо душить, до тех пор пока он не посинеет, затем застрелить из винтовки для синих слонов.

"--*  А как убить зелёного слона?

"--*  Нужно рассказывать ему похабные анекдоты, пока он не покраснеет, затем душить, пока не посинеет, затем застрелить из винтовки для синих слонов.
}
{П.\,Канюкова}




\index{Компиляция!этапы}

\subsection{Компиляция программы на языке C++\footnote{%http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html
Использованы материалы CSCI 241
Intermediate Programming in C++
Spring 2015
(The C++ compilation process)
% http://knzsoft.ru/cpp-bgr-ls1/
и~А.\,А.\,Князев. Руководство по C++ для начинающих}
}
\label{sec:cpp-compile}

Компиляция программы на языке C++ включает четыре этапа (рис.~\ref{ris:c++compile}):
\newlength{\slideheigth}
\setlength{\slideheigth}{0.5\textheight}

% \begin{illustration}[p]
% \includegraphics[width=\linewidth]{compile}
% 
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}
% % \hfill
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}
% 
% \caption{Этапы компиляции программы на C++}
% \label{ris:c++compile}
% \end{illustration}

\begin{illustration}
\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize\singlespacing
\lstset{basicstyle=\ttfamily\footnotesize\singlespacing}

\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{invisblock}	= [text width=16ex,text badly centered, minimum height=3ex]
\tikzstyle{block}	= [invisblock, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]
\tikzstyle{stagenum}	= [stage, text width=2ex, circle, node distance=28ex]
\tikzstyle{filecomment}	= [invisblock,text width=20ex]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[stagenum, left= of cpp_preprocess] {1};
\node[stagenum, left= of compiler] {2};
\node[stagenum, left= of cpp_asm] {3};
\node[stagenum, left= of cpp_linker] {4};

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[right= of compiler] (mangling) {Декорирование};
\node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


% % \node[right= of cpp] (S) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}};
% \node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
% \node[stage,on chain=S] (S_preprocess) {Препроцессор};
% \node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
% \node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
% \node[file,on chain=S] (prog2_o) {prog2.o};
% \node[stage,on chain=S] (S_linker) {Компоновщик};
% % \coordinate[on chain=S] (S_linker);
% 
% % \node[file, right= of S_preprocess,text width=20ex] (S_headers) {Заголовочные файлы (\#include)};
% % \path[blockarrow] (S_headers) -- (S_preprocess);
% \path[blockarrow] (cpp_headers) -- (S_preprocess);
% 
% % \path[blockarrow] (cpp_asm) -- (S_asm);

% \path (cpp_linker)
\node[stage,fit=(cpp_linker)% (S_linker)
, inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[filecomment, left= of prog1_cpp] {Файл исходного кода};
\node[filecomment, left= of prog1_pp] {Дополненный файл исходного кода};
\node[filecomment, left= of prog1_s] {Файл команд ассемблера};
\node[filecomment, left= of prog1_o] {Объектный файл};
\node[filecomment, left= of prog] {Исполняемый файл};

% \node[below= of prog-|cpp_linker]  {extern};

% \node[below= of prog-|S_linker]  {.globl};


% \coordinate[above=6ex of cpp.south] (linking_start);

\begin{pgfonlayer}{background}
% %   \coordinate[left=0ex of cpp.south west] (cpp_egde);
% %   \coordinate[right=0ex of S.south east] (S_egde);
%   \node[rectangle,fit=(cpp.south west) (S.south east) (linking_start), inner sep=0ex, minimum height=11.8mm,fill=yellow] (linking) {};
\node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};

\end{pgfonlayer} 

\end{tikzpicture}
}
\caption{Этапы компиляции программы на C++}
\label{ris:c++compile}
\end{illustration}



\begin{enumerate}[wide=\parindent]
{
\item Препроцессор копирует содержимое включённых  директивой \lstinline!#include! заголовочных файлов в~исходный код модуля, раскрывает макросы и,~в~том числе, выполняет текстовые замены «констант», определённых с~помощью директивы \lstinline!#define!, на их значения, а~также отрабатывает директивы условной компиляции, выбрасывая из кода те или иные фрагменты.\fussy

}
\begingroup
\lstset{language=Bash}

При использовании компилятора из коллекции GCC
увидеть результат препроцессинга можно, воспользовавшись опцией \lstinline!-E!% компилятора g++
. Результат будет выведен в стандартный поток вывода (в~представленном %ниже 
примере %стандартный поток вывода 
перенаправлен в~файл main.E).

\begin{lstlisting}
$ g++ -E main.cpp > main.E
\end{lstlisting}
Здесь и далее, знак доллара (\lstinline!$!) обозначает стандартное приглашение %к вводу команды в 
консоли *nix. Писать знак доллара не требуется.
Регистр важен.


\item Код, обработанный препроцессором, транслируется компилятором в~ассемблерный код для соответствующей платформы.

Для остановки компиляции после этого этапа для компилятора g++ следует воспользоваться ключом \lstinline!-S!:
\begin{lstlisting}
$ g++ -S main.cpp
\end{lstlisting}

На этапе компиляции выполняется \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.
% Имена 
% C++ искорёжены почти до неузнаваемости, C — у меня сохранены, а у вас, если статья Фога не ошибатеся, к ним приписывается префикс _: _Sqr вместо Sqr (и было бы __Sqr вместо _Sqr, но такой функции в C++-программе нет).
В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
(в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).

Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
В~статье Агнера Фога 
«Calling conventions for different C++ compilers and operating systems»
приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).


\item Ассемблерный код, созданный компилятором, транслируется в~объектный код для соответствующей платформы.
Останов компиляции файла после этапа ассемблирования  обеспечивается ключом \lstinline!-c!:

\begin{lstlisting}
$ g++ -c main.cpp
\end{lstlisting}
При ассемблировании  имена функций сохраняются.



\item Объектные файлы% различных модулей и~библиотек
, созданные ассемблером, объединяются компоновщиком (линкером, редактором связей) в~исполняемый файл.

На данном этапе компоновщик ищет реализации для всех внешних (\lstinline!extern!) функций по именам.
Соответственно, имена, которые в~разных модулях носит одна и~та же функция, на этапе компоновки должны совпадать.


\end{enumerate}
\FloatBarrier
Интегрированные среды разработки (IDE) выполняют все этапы автоматически.

\subsection{Расширения файлов исходного кода}


Чтобы начать сборку не с~начала, достаточно задать для файла расширение, отличное от~\lstinline!.cpp! или ~\lstinline!.c!.
Вообще, компилятор "--- одна из немногих программ, которые учитывают расширение файла при его обработке.

Расширение  \programname{.s} соответствует ассемблерному файлу. 
Таким образом, команды
\mbox{\lstinline!$ g++ main.s!} и~\mbox{\lstinline!$ gcc main.s!}
эквивалентны и~выполняют ассемблирование и~компоновку ассемблерного файла~\lstinline!main.s!%.
, минуя этапы препроцессинга и~компиляции с~ЯВУ.

{

Расширение \programname{.o} соответствует объектному файлу, и~команды
\mbox{\lstinline!$ g++ main.o!} и~\mbox{\lstinline!$ gcc main.o!}
выполняют только компоновку файла~\lstinline!main.o!.
\fussy

}

В~случае, когда необходимо выполнить препроцессинг, ассемблирование и~компоновку, выбросив только этап компиляции с~ЯВУ (именно такая последовательность оптимальна при сборке модулей, вручную написанных на ассемблере), используется
расширение \programname{.S}.
\begin{lstlisting}
$ g++ main.S
\end{lstlisting}
Большинство современных файловых систем чувствительны к~регистру имён, а~современные ОС, такие как GNU/Linux и~BSD, различают регистр при обработке.
 
\subsection{Изменение имени выходного файла}


Имя исполняемого файла по умолчанию (\lstinline!a.out!) можно изменить, используя ключ~\lstinline!-o!:
\begin{lstlisting}
$ g++ main.cpp -o prog
\end{lstlisting}
Таким образом исполняемый файл, полученный после сборки main.cpp (отсутствие ключей остановки сборки соответствует выполнению всех этапов), получит имя~\lstinline!prog!.

\subsection{Компиляция проекта, состоящего из нескольких модулей}
\index{Компиляция!модули}


\lstset{language=Bash}

При компиляции проекта, включающего несколько модулей, шаги препроцессинга, компиляции и~ассемблирования повторяются для каждого файла исходного кода.
Затем из полученных объектных файлов линкер собирает единый исполняемый файл (рис.~\ref{ris:c++asmcompile}).
Это можно выполнить одним запуском %любого 
компилятора из коллекции GCC:
\begin{lstlisting}
g++ -o prog prog1.cpp prog3.cpp 
\end{lstlisting}

Если попытаться собрать каждый из модулей отдельно, мы получим ошибки компоновки (так как во всех модулях, кроме главного, отсутствует точка входа "--- функция \lstinline!main!, а~в~главном "--- нет функций, описанных в~остальных).


\begin{illustration}
\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize\singlespacing
\lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=16ex,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[right= of compiler] (mangling) {Декорирование};
\node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


% \node[right= of cpp] (S) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}};
\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {prog2.o};
\node[stage,on chain=S] (S_linker) {Компоновщик};
% \coordinate[on chain=S] (S_linker);

% \node[file, right= of S_preprocess,text width=20ex] (S_headers) {Заголовочные файлы (\#include)};
% \path[blockarrow] (S_headers) -- (S_preprocess);
\path[blockarrow] (cpp_headers) -- (S_preprocess);

% \path[blockarrow] (cpp_asm) -- (S_asm);

% \path (cpp_linker)
\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[below= of prog-|cpp_linker]  {extern};

\node[below= of prog-|S_linker]  {.globl};


% \coordinate[above=6ex of cpp.south] (linking_start);

\begin{pgfonlayer}{background}
% %   \coordinate[left=0ex of cpp.south west] (cpp_egde);
% %   \coordinate[right=0ex of S.south east] (S_egde);
%   \node[rectangle,fit=(cpp.south west) (S.south east) (linking_start), inner sep=0ex, minimum height=11.8mm,fill=yellow] (linking) {};
\node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};

\end{pgfonlayer} 

\end{tikzpicture}
}
\caption{Этапы компиляции программы}
\label{ris:c++asmcompile}
\end{illustration}


Можно остановить сборку после этапа компиляции модулей:
\begin{lstlisting}
g++ -с prog1.cpp prog3.cpp 
g++ -с prog3.cpp 
\end{lstlisting}

Затем из полученных объектных файлов одним запуском линкера можно получить исполняемый файл:
\begin{lstlisting}
g++ -o prog prog1.o prog3.o 
\end{lstlisting}
Ручная сборка небольших проектов обычно выполняется одной командой, в~интегрированных средах разработки этапы, как правило, разделяются.


\endgroup








\section{Компиляция и~отладка в~IDE} 
\label{sec:cpp-ide}
\epigraph{\begin{limerick}
Одному господину в~Версале \\
Так внезапно глаза отказали,\\
Что он видеть не мог\\
Даже собственных ног "---\\
И~просил, чтоб ему показали.\\
\end{limerick}
}
{\Lear}

watch'и, memory, дизассемблер


\input{book/cpp-ide}



\subsection{Обозреватель памяти (Memory~dump)}
\index{Память!просмотр содержимого}

Исследовать структуру объекта и~его представление в~памяти во время отладки можно с~помощью  обозревателя памяти.

% Окно отладчика «Memory~dump» доступно во время отладки и~отображает содержимое памяти.
В~среде Code::Blocks окно просмотра содержимого фрагмента памяти  «Memory~dump»  (рис.~\ref{ris:cb-memory}) доступно во время отладки.
Его можно скрыть или вернуть, используя меню $Debug \to Debugging~windows \to Memory~dump$.

\begin{illustration}
\includegraphics[width=\linewidth]{cb-memory}

\caption{Отладочное окно Memory~dump в~Code::Blocks}
\label{ris:cb-memory}
\end{illustration}

Начало фрагмента может быть литералом (конкретным адресом в~памяти), адресом переменной (\lstinline!&x!), регистром, в~котором содержится адрес или~выражением C++ (результатом выражения должен быть указатель).
% Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.

Содержимое памяти отображается как последовательность байтов. 
Каждый байт представлен как беззнаковое целое (в~виде двух шестнадцатеричных цифр) и~как ASCII-символ (справа).
Байты разбиты на строки по 16; слева перед строкой показан адрес первого байта в~строке в~шестнадцатеричном виде.

% Просмотр памяти по адресу переменной с~помощью отладчика позволяет получит ту же информацию, что и~отладочная печать байтов "--- 



\section{Подключение к~проекту модулей на ассемблере}
\label{sec:gas-extern}
\epigraph{\begin{limerick}
Дама, оставив Равенну,\\
поехала поездом в~Вену,\\
Но, доехав до Вены,\\
решила мгновенно,\\
Что вернётся в~родную Равенну.
\end{limerick}
}
{\Lear}







   
% \section{Подключение модуля на ассемблере к~C++-проекту}
% \index{Подключение модуля на ассемблере}
Функции, описанные в~ассемблерном модуле, необходимо описать в~коде C++ как внешние (\lstinline!extern!).
После спецификатора \lstinline!extern!, согласно стандарту C++, могут быть указаны строки \lstinline!"C++"! (подразумевается по умолчанию) или \lstinline!"C"! (различные компиляторы могут поддерживать и~иные строки) для указания компоновщику, какой язык использовался при написании внешней функции.
Конкретные свойства таких функций не описываются в~стандарте. На практике \lstinline!"C++"! подразумевает декорирование (mangling) имён функций и~передачу параметров по возможности через регистры, что реализуется в~разных компиляторах по-разному.

Указание \lstinline!"C"! на практике подразумевает соглашение о вызовах \lstinline!cdecl!:
\begin{itemize}[wide=\parindent]

\item размещение аргументов исключительно \emph{в~стеке,} без использования регистров, причём аргументы, меньшие 4 байт, расширяются до 4 байт;

\item размещение аргументов в~стеке \emph{справа налево,} так что первый аргумент оказывается на вершине стека;

\item очистку стека \emph{вызывающей программой,} так что аргументы должны не сниматься со стека, а~копироваться оттуда;

\item возврат значения по возможности через регистры:
\begin{itemize}[leftmargin=0\parindent]
\item \EAX, если результат "--- указатель или целое число до 4 байт;
\item пара регистров \EDX:\EAX, если результат "--- целое число 8 байт;
\item вершина стека сопроцессора, если результат "--- вещественное число;

если результат не помещается в~регистры, возвращается указатель на него (через \EAX).
\end{itemize}
\end{itemize}

Также \lstinline!extern "C"! в~GNU/Linux подразумевает
% \item 
\emph{отсутствие декорирования имён,} % "--- имена функций воспринимаются линкером «как есть»
что позволяет не задумываться о~том, как имя, используемое линкером, складывается из имени, данного разработчиком и~характеристик аргументов функции,
но делает невозможной перегрузку таких функций.


Если используемый компилятор для данной платформы изменяет имена внешних C-функций, %упоминаемых в~модулях C++, 
например, добавляет префикс \lstinline!_!, как в случае gcc (mingw) под MS Windows, то ссылка на внешнюю функцию %\lstinline!sqr! 
\lstinline!extern "C" int sqr(int x)!, упоминаемую в~некотором cpp-файле %к~моменту компоновки 
в~соответствующем объектном файле
будет выглядеть как \lstinline!_sqr!.
Таким образом, для корректной компоновки имя данной функции в~объектном файле, полученном из ассемблерного модуля,  также должно быть \lstinline!_sqr!.
Кроссплатформенности в~этом случае можно достичь использованием макросов для изменения имён в~\programname{.S}-файле.


Размещение аргументов в~стеке {справа налево} и~очистка стека вызывающей программой позволяет определить функции с~переменным количеством аргументов, такие, как  \lstinline!printf! и~\lstinline!scanf! из стандартной библиотеки \lstinline!C!, но надо помнить о~небезопасности таких функций.


Рассмотрим функцию, вычисляющую квадрат целого числа.
% \lstset{language=[Motorola68k]Assembler}
Ассемблерный модуль с текстом функции\footnote{
Использованы материалы статьи Hiran Ramankutty «От C к Ассемблеру», перевод: Андрей Киселев
} находится в файле \programname{sqr.S}% (так как здесь нет необходимости в препроцессинге, можно было использовать также имя \programname{sqr.s})
.


% Адрес возврата принято передавать через стек
При вызове функции в~стек сначала помещаются аргументы в~соответствии с~соглашением о~вызовах, а~затем адрес возврата.
Соответственно, когда функция получает управление, 
% http://trubetskoy1.narod.ru/arttranslate/FuncCallPart2_1.html
то первые 4 байта по адресу, хранящемуся в \ESP, будут содержать адрес возврата. 
Далее идут аргументы функции. При использовании соглашения о вызовах \lstinline!cdecl!
непосредственно за адресом возврата (по адресу $\text{\ESP} + 4$) будет находиться первый параметр,
% следующие 4 байта (т.\,е. 4 байта по адресу $\text{\ESP} + 4$) будут содержать первый параметр, 
% в четырёх байтах по адресу $\text{\ESP} + 8$ будет второй параметр
за ним идёт второй 
и~т.\,д.

Функция \lstinline!sqr! принимает единственный параметр типа \lstinline!int! (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком),
т.\,е. 4 байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $\text{\ESP} + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.

Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, через который и нужно вернуть значение.
Таким образом, сразу после умножения можно выйти из функции командой \lstinline!ret!.
Директива \lstinline!.globl! делает функцию   \lstinline!sqr! видимой для внешних модулей.
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
\end{lstlisting}
Если в~файле несколько функций, можно указать для отладчика их границы:
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
.func sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
.endfunc
\end{lstlisting}
Парные директивы .func  $\ldots$  .endfunc не влияют ни на что, кроме добавления некоторой отладочной информации при сборке в~отладочном режиме.
В~режиме Release игнорируются.

Файл \programname{main.cpp} содержит импорт функции как \lstinline!extern "C"! и её вызов.
% Функция \lstinline!sqr! может использоваться так же, как и~функция, описанная на языке C++ (кроме перегрузки).
\begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:main.cpp]
#include <iostream>

using namespace std;
extern "C" int sqr(int x);

int main()
{
    int x=2, y;
    y = sqr(x);
    cout << y <<endl;
    return 0;
}
\end{lstlisting}


\subsection{Code::Blocks}

Создать ассемблерный модуль в~Code::Blocks можно, используя меню $File \to New \to Empty~file$.
Имя файла обязательно должно иметь расширение \lstinline!.S! (заглавное; расширение \programname{.s} не воспринимается Code::Blocks как допустимое).

После создания в~проекте файла с~таким расширением он во время сборки проекта обрабатывается препроцессором и~компилируется gcc; полученный объектный файл в~дальнейшем используется линкером. Дополнительных настроек делать не нужно.

\subsection{Qt~Creator}
% \lstset{frame=top,frame=bottom}


Файл проекта Qt~Creator для добавления ассемблерного модуля \programname{sqr.S} необходимо отредактировать вручную, добавив строку \lstinline!SOURCES += sqr.S!, так как мастер добавления файлов не воспринимает расширения  \programname{.S} и \programname{.s} как допустимые для исходного кода.
\begin{lstlisting}[caption=Файл проекта, label=lst:pro]
TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

SOURCES += main.cpp
SOURCES += sqr.S

include(deployment.pri)
qtcAddDeployment()
\end{lstlisting}
Файл  \programname{sqr.S} должен находиться в~той же папке, что и~проект.
Других настроек, кроме редактирования файла проекта, делать не нужно.







\nsection{Контрольные вопросы}

\begin{enumerate}
\item Уметь пользоваться окнами просмотра переменных и~содержимого памяти в~отладчике используемой вами IDE.

\end{enumerate}
