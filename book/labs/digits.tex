\chapter{Представление данных в~ЭВМ}
\setlablabel{digits}
\purpose{изучить форматы представления целых чисел и~символьной информации в~ЭВМ.
% \footnote{Использованы: %лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной (использованы материалы и~программы R.Hyde); 
% программа  gbase  (C) 1999 Damian Kramer, Roger Dunce; таблица ASCII, оформленная Victor Eijkhout.
% }
}



\begin{tasks}


\item 
\labellocal{task:intcode}
% \addcontentsline{toc}{subsection}{Задание}%
% Изучите, как интерпретируется один и~тот же код% (рассмотрите два 16-битных кода)
% , если он рассматривается различными способами:
% \\
% а) как десятичное число без знака;\\
% б) как десятичное число со знаком; \\
% в) как шестнадцатеричное число.
% % ;\\
% % г) как двоичное число.
Изучите, как интерпретируется одна и~та же область памяти, если она рассматривается как знаковое или беззнаковое число, а~также как одно и~то же число записывается в~различных системах счисления.

Необходимо сравнить:\\
а) беззнаковую интерпретацию переменной в~шестнадцатеричной форме;\\
б) беззнаковую интерпретацию в~десятичной форме; \\
в) знаковую интерпретацию в~десятичной форме.


Для этого
определите и~запишите в~отчёт 
% \begin{itemize}
% \item 
% двоичное (16 бит) и~шестнадцатеричное представления десятичного числа $-12\,345$, а~также беззнаковую интерпретацию этого представления в~десятичном виде;
% 
% \item 
десятичное,
двоичное (16 бит) и~шестнадцатеричное представления %десятичного 
шестнадцатибитных
чисел $x$ и~$y$, а~также беззнаковую интерпретацию этого представления в~десятичном виде.

\begin{variants}[ss]
$x = -34, y = 2^{15}+7$
\next
$x = -2, y = 2^{14}+1$
\next
$x = -2^{15}, y = 2^{15}$
% \next
% $x = 2^{15}$
\next
$x = -7, y = 2^{16}-2$
% \next
% $x = -8$
\end{variants}

Для получения различных интерпретаций одного и~того же кода 
% можно написать программу на C++, где на один и тот же участок памяти ссылаются знаковая и~беззнаковая переменная одного размера (используя объединения или оператор  \lstinline!reinterpret_cast!).
в~C++ можно использовать объединения или оператор  \lstinline!reinterpret_cast!.
% и,~используя различные форматы вывода,
% напечатать значения обеих переменных.
Шестнадцатеричное и~десятичное представление %в~этом случае 
можно получить, используя различные форматы вывода.
% 
Шестнадцатеричный формат вывода не предусматривает знака, то есть шестнадцатеричное представление знаковой переменной будет соответствовать её беззнаковой интерпретации.


% Также
% возможно 
% использовать конвертер,  в~частности, \url{http://calc.penjee.com/}~\cite{calc.penjee.com} (доступ в~Сеть есть на терминале Galaxy) или  gbase~\cite{gbase}. % (или аналогичный)

% \item двоичное (16 бит) и~шестнадцатеричное представления десятичного числа $65\,502$.
% , а~также знаковую интерпретацию этого представления в~десятичном виде;

% \end{itemize}


% В~программе \programname{gbase} изучите, как одно и~то же число будет представлено (для представления используется 16 бит) в
% виде 
% \\
% а) десятичного числа без знака;\\
% б) десятичного числа со знаком; \\
% в) шестнадцатеричного числа;\\
% г) двоичного числа.

\item 
Найдите и~выпишите в~отчёт минимальное и~максимальное 16-битное число со
знаком и~без знака в~формах представления (а), (б), (в) и~%(г) 
в~двоичной форме
(4~числа, каждое из которых представлено в~4 формах).


\item 
\labellocal{task:bitwise}
Разработайте программу на языке C++, выполняющую над беззнаковыми шестнадцатибитными целыми числами следующие поразрядные операции (результат должен печататься в~десятичной и~шестнадцатеричной формах): 
\begin{itemize}
\item бинарные
% $x \And y$ (конъюнкция), $x \Or y$ (дизъюнкция), $x \Xor y$ (сложение по модулю два); 
% \item унарные $NOT(x)$ (отрицание),
$x \land y$ (конъюнкция), $x \lor y$ (дизъюнкция), 
\\
$x \oplus y$ (сложение по модулю два); 
\item унарные $\lnot x$ (отрицание),
\\
$\Neg(x)$ (дополнение до двух, $x + \Neg(x) = 2^{\text{разрядность }x}$);
% \item $x SHL y$ (логический сдвиг влево), $x SHR y$ (логический сдвиг вправо).
\item $x \ll y$ (логический сдвиг влево), $x \gg y$ (логический сдвиг вправо).
% 
% \item \bonus{+2 балла} ROL (циклический сдвиг влево) и~ROR (циклический сдвиг вправо). 
\end{itemize}

\begin{variants}[bitwise]
$\left\{\begin{array}{ll}
x = \text{\lstinline!0xFFEE!}\\
y = \text{\lstinline!0x0001!}\\
\end{array}\right.$
\hfill
$\left\{\begin{array}{ll}
x = \text{\lstinline!0x000E!}\\
y = \text{\lstinline!0x0003!}\\
\end{array}\right.$
\hfill\strut
\next
$\left\{\begin{array}{ll}
x = \text{\lstinline!0x8008!}\\
y = \text{\lstinline!0x1111!}\\
\end{array}\right.$
\hfill
$\left\{\begin{array}{ll}
x = \text{\lstinline!0x0005!}\\
y = \text{\lstinline!0x0002!}\\
\end{array}\right.$
\hfill\strut
\next
$\left\{\begin{array}{ll}
x = \text{\lstinline!0x9211!}\\
y = \text{\lstinline!0x0004!}\\
\end{array}\right.$
\hfill
$\left\{\begin{array}{ll}
x = \text{\lstinline!0x0009!}\\
y = \text{\lstinline!0x0013!}\\
\end{array}\right.$
\hfill\strut
\end{variants}

\item
Измените в~программе из~задания~\reflocal{task:bitwise} тип переменных на знаковый. 
Объясните изменение (или неизменность) результата.

\item\bonus{+1 балл} 
Разработайте программу на языке C++ (или дополните программу из~задания~\reflocal{task:bitwise}), которая расширяет шестнадцатибитное представление числа~$x$ до
тридцатидвухбитного, рассматривая числа как
\begin{itemize}
\item знаковые (signed);
\item беззнаковые (unsigned).
\end{itemize}

\begin{variants}[expand]
$x = \text{\lstinline!0xFF00!}$
\next
$x = \text{\lstinline!0xF123!}$
\next
$x = \text{\lstinline!0x8001!}$
\next
$x = \text{\lstinline!0xABCD!}$
\next
$x = \text{\lstinline!0xEE22!}$
\end{variants}

Результат должен печататься в~десятичной и~шестнадцатеричной формах.

\descrcomment{Расширение числа происходит, в~частности, при присваивании
% : \lstinline!int i; short s = -1; i = s;!
"--- если размер приёмника больше размера источника.
}

\item
\bonus{+1 балл} 

Напишите программу, демонстрирующую переполнение целых чисел со знаком и~без знака. Для этого опишите целое число со знаком и~инициализируйте его максимально возможным для данного типа значением, результат распечатайте %в~двоичном и~
в~шестнадцатеричном виде. Затем прибавьте к~этому
числу единицу, результат распечатайте %в~двоичном и~
также в~шестнадцатеричном виде. 
Выполните аналогичные действия для беззнаковой переменной.
Выпишите в~отчёт распечатанные значения переменной,
% (в~двоичном и~в~шестнадцатеричном виде), письменно
поясните полученные результаты.

% Пояснения. 1) Для вывода значения целой переменной в~десятичной или шестнадцатеричной
% системах счисления используются манипуляторы \lstinline!dec! (используется по умолчанию) или \lstinline!hex!.
% Пример: \lstinline!cout << hex << i << endl;!
% 
% 2) 
% Для задания шестнадцатеричной константы перед числом указывается \lstinline!0x! или \lstinline!0X!.




\item
\labellocal{task:prog:start}
\labellocal{task:platforms}
\labellocal{task:char}
Определите и~выпишите в~отчёт, как хранятся в~памяти компьютера: % на различных платформах

\begin{itemize}
\item %Определите и~выпишите в~отчёт, как хранятся в~памяти компьютера 
целое
число 0x12345678; по результату исследования определите порядок следования байтов в~словах  для вашего процессора:
\begin{itemize}
\item Little-Endian (от младшего к старшему, порядок Intel);
\item Big-Endian (от старшего к младшему, порядок Motorola);
\end{itemize}


\item строки \lstinline!"abcd"! и~\lstinline!"абвг"! (массив из \lstinline!char!);

\item «широкие» строки \lstinline!L"abcd"! и~\lstinline!L"абвг"! (массив из \lstinline!wchar_t!).
\end{itemize}

% В~отчёт необходимо включить шестнадцатеричный дамп области памяти, где хранятся символы строк и~значение числа.

\item
\labellocal{task:prog:end}
{
При помощи оператора \lstinline!sizeof! выясните, сколько байтов занимают %на различных платформах (аналогично заданию \reflocal{task:platforms})
переменные следующих типов: \lstinline!char, bool, wchar_t, short, int, long, long long, float, double, long double, size_t, ptrdiff_t, void*!. Результаты оформите в~отчёте в~виде таблицы, указывая для каждого типа его назначение.\sloppy

}

Для выполнения единообразных действий над переменными различных типов используются макросы препроцессора C или шаблоны C++.

% \noindent\begin{tabularx}{1\linewidth}{}

Проверьте, соответствуют ли размеры типов современному стандарту C++.
% (файл n4296.pdf "--- свободно распространяемый черновик актуального сейчас ISO International Standard ISO/IEC 14882:2014(E) "--- Programming Language C++).

\item
Запустите программу (программы) из заданий \reflocal{task:prog:start}--\reflocal{task:prog:end} на двух других платформах, доступных на ВЦ "--- 32- и~64-разрядной версиях Microsoft Windows и~повторите измерения.

% Платформы, для которых необходимо провести измерения:
% По результатам 
Для каждого из заданий 
% Оформите таблицу, где приведены результаты измерений на платформах:
дополните таблицу результатами новых измерений.
% на платформах:
Платформы, для которых необходимо провести измерения:
\begin{itemize}
\item \stdOs{} \stdDist{}, архитектура \stdArch{} (компилятор \stdCompiler{}, среда любая);
\item 32-разрядная версия Microsoft Windows (ВЦ, среда Microsoft Visual Studio);
\item 64-разрядная версия Microsoft Windows (терминал Skylab, среда Microsoft Visual Studio, %для проекта необходимо назначить 64-битную конфигурацию
64-битная конфигурация).
\end{itemize}



Результаты однотипных измерений, выполненных на различных платформах, должны быть сгруппированы в~таблицу или последовательно описаны в~одном разделе. 
% Различия платформ должны 



\item \bonus{+2 балла за платформу}  
При подготовке к~работе соберите и~запустите программу (программы) из заданий \reflocal{task:prog:start}--\reflocal{task:prog:end}, используя платформу и/или компилятор, отличные от доступных на ВЦ.  Результаты измерений с~пояснениями внести в~конспект (дополнить таблицы результатов заданий \reflocal{task:prog:start}--\reflocal{task:prog:end}).


\end{tasks}
\section{Дополнительные бонусные и~штрафные баллы}

$+2$ балла "--- корректная автоматизация с~помощью макросов препроцессора C или шаблонов C++.

$-4$ балла "--- неудобочитаемый отчёт.


\emph{Пример неудобочитаемого фрагмента отчёта:}

{
\footnotesize
Задание \reflocal{task:bitwise}.

\includegraphics[width=0.5\linewidth,keepaspectratio]{bad-report}

}

\emph{Возможная альтернатива:}

{
\footnotesize
Задание \reflocal{task:bitwise}.
Разработайте программу на языке C++, выполняющую над беззнаковыми целыми числами следующие операции (результат должен печататься в~десятичной и~шестнадцатеричной формах): 
% \begin{itemize}
% \item бинарные
% \end{itemize}
% AND (конъюнкция)

\lstinline!11 & 14 = 10 (0xB & 0xE = 0xA)!

}

\section{Рекомендации}

% Пояснение. Используйте 
Для просмотра содержимого памяти используйте
возможности отладчика
% (окна Memory и~Watches, рис.~\ref{ris:codeblocks-digits-debugmemory}) 
(окно Memory или подобное ему)
или отладочную печать.
Не стоит использовать для исследования представления объектов в~памяти окно Watches, так как оно по определению показывает состояние объекта, абстрагированное от представления.

Перенаправить стандартный вывод программы в~файл в~большинстве оболочек, в~том числе bash, возможно с~помощью символа \lstinline!>!.

Скопировать вывод программы из терминала в~отчёт можно, используя буфер обмена primary. 
Для этого необходимо выделить мышью необходимый текст в~терминале и~затем щёлкнуть средней кнопкой мыши в~том месте редактора, где планируется вставка.
% Внимание!
После закрытия текста-источника содержимое буфера primary теряется, поэтому вставку желательно проводить непосредственно после выделения фрагмента вывода в терминале.

% \begin{illustration}
% \includegraphics[width=\linewidth]{digits-debugmemory}
% 
% \caption{Отладочные окна Memory и~Watches в~Code::Blocks}
% \label{ris:digits-debugmemory}
% \end{illustration}



\theoryrefs
\theoryref{sec:byte}
\theoryref{sec:byteorder}
\theoryref{sec:stack-segment}
% \theoryref{sec:cpp-ide}
\theoryref{sec:digits}
\theoryref{sec:cpp}
\theoryref{sec:cpp-compile}
% \theoryref{sec:cpp-types}
% \theoryref{sec:cpp-cast}
% \theoryref{sec:cpp-literals}
% 
% \theoryref{sec:cpp-memorydump}




\begin{modifyonelong}


\subsection{Отладка в~интегрированных средах разработки}


Различные IDE для отладки программ используют собственные инструменты или (чаще) предоставляют графический интерфейс к~внешним отладчикам.
Обычно используется отладчик gdb (GNU Symbolic Debugger).
% Для отладки в~различных IDE чаще всего используется отладчик gdb (GNU Symbolic Debugger), графический интерфейс к~которому предоставляет среда.

Базовые инструменты различных отладчиков схожи.
Рассмотрим инструменты отладки на примере  среды Qt Creator (рис.~\ref{ris:qtc})~\cite{doc.crossplatform.ru/qtcreator}.
% \footnote{Использованы материалы 
% % http://doc.crossplatform.ru/qtcreator/1.3.0/creator-debugging.html
% руководства по Qt Creator
% }
\begin{illustration}
\includegraphics[width=\linewidth]{qtc}
\caption{Отладка с~помощью Qt Creator}
\label{ris:qtc}
\end{illustration}

\subsection{Точки останова}

Точки останова представляют место или набор мест в коде, которые при выполнении прервут отлаживаемую программу и передадут управление пользователю. Пользователь может просмотреть состояние прерванной программы или продолжить выполнение построчно или непрерывно.

Обычно точки останова связаны с файлом исходных кодов и строкой или началом функции (рис.~\ref{ris:qtc-breakpoint}).
\begin{illustration}
\includegraphics[width=\wideImageWidth]{qtc-breakpoint}

\caption{Точка останова в~коде}
\label{ris:qtc-breakpoint}
\end{illustration}

Если выполнение не останавливается в~точке останова, проверьте конфигурацию сборки.
В~большинстве сред разработки отладка возможна только для отладочной (Debug), но не для оптимизированной (Release) сборки.
В~Qt~Creator возможна пошаговая отладка Release-сборки с~использованием окон дизассемблера, регистров и~памяти, но точки останова в~исходном коде C++ в~этом режиме игнорируются.

% Большинство возможностей отладчика доступно только для отладочной (Debug), но не для оптимизированной (Release) сборки.

% \subsection{Окна отладчика}

\subsubsection{Локальные и~наблюдаемые переменные}
Окно «\insertsubsubsection» отображает информацию о верхнем кадре стека (параметры функции и~локальные переменные), а~также о~заданных выражениях.
Окно «\insertsubsubsection»  может быть использовано для изменения содержимого переменной простого типа данных (такого как $int$ или $float$) во время останова программы (рис.~\ref{ris:qtc-watches}).
\begin{illustration}
\includegraphics[width=\wideImageWidth]{qtc-watches}
\caption{\insertsubsubsection{} Qt Creator}
\label{ris:qtc-watches}
\end{illustration}

В~среде Code::Blocks окно просмотра переменных можно открыть, используя меню $Debug \to Debugging~windows \to Watches$ (рис.~\ref{ris:codeblocks-digits-debugmemory}, внизу).

\begin{illustration}
\includegraphics[width=\linewidth]{cb-memory-watches}

\caption{Отладочные окна Memory и~Watches в~Code::Blocks}
\label{ris:codeblocks-digits-debugmemory}
\end{illustration}


В~TheIDE для просмотра переменных используются  вкладки $Autos$, $Locals$ и~$Watches$ панели $Debug$ (доступна во~время отладки внизу экрана, скрывается/показывается по Esc).


\subsubsection{Обозреватель и~редактор памяти}

% \subsection{Обозреватель памяти (Memory~dump)}
\index{Память!просмотр содержимого}

% \addquestion{Уметь пользоваться окнами просмотра переменных и~содержимого памяти в~отладчике используемой вами IDE.}
\addquestion{С~помощью каких инструментов можно просмотреть текущие значения переменных в~используемой вами IDE?}
\addquestion{С~помощью каких инструментов можно просмотреть текущего содержимого памяти в~используемой вами IDE?}

\insertsubsubsection{} отображают содержимое памяти.
В~Qt~Creator как обозреватель, так и~редактор памяти можно открыть для просмотра конкретной переменной, используя контекстное меню переменной в~окне «Локальные и~наблюдаемые переменные» (рис.~\ref{ris:qtc-memory}), при этом подсвечивается не только начало, но и~размер объекта.
\begin{illustration}
\includegraphics[width=\linewidth]{qtc-memory}
\caption{Обозреватель и~редактор памяти Qt Creator}
\label{ris:qtc-memory}
\end{illustration}

В~среде Code::Blocks окно просмотра содержимого фрагмента памяти можно открыть, используя меню $Debug \to Debugging~windows \to Memory~dump$
\index{IDE Code::Blocks!дамп памяти} 
(рис.~\ref{ris:codeblocks-digits-debugmemory}, вверху).
% 
% Начало фрагмента может быть не только конкретным адресом в~памяти (как \lstinline!0x401060!) или адресом переменной (\lstinline!&x!), но и~выражением C++.
% Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.
% 
% Исследовать структуру объекта и~его представление в~памяти во время отладки можно с~помощью  обозревателя памяти.
% 
% % Окно отладчика «Memory~dump» доступно во время отладки и~отображает содержимое памяти.
% В~среде Code::Blocks окно просмотра содержимого фрагмента памяти  «Memory~dump»  (рис.~\ref{ris:cb-memory}) доступно во время отладки.
% Его можно скрыть или вернуть, используя меню $Debug \to Debugging~windows \to Memory~dump$.
% 
% \begin{illustration}
% \includegraphics[width=\linewidth]{cb-memory}
% 
% \caption{Отладочное окно Memory~dump в~Code::Blocks}
% \label{ris:cb-memory}
% \end{illustration}
% 
% Начало фрагмента может быть литералом (конкретным адресом в~памяти), адресом переменной (\lstinline!&x!), регистром, в~котором содержится адрес или~выражением C++ (результатом выражения должен быть указатель).
% % Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.
% 
Адрес начала отображаемого фрагмента может быть литералом (конкретным адресом в~памяти, как \lstinline!0x401060!), адресом переменной (\lstinline!&x!), регистром, в~котором содержится адрес (\lstinline!$eax!) или~выражением C++ (результатом выражения должен быть указатель,
например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!).

В~текущей версии TheIDE нет инструмента для просмотра дампа памяти.

Содержимое памяти отображается как последовательность байтов. 
Каждый байт представлен как беззнаковое целое (в~виде двух шестнадцатеричных цифр) и~как ASCII-символ\index{ASCII} (справа).
Байты разбиты на строки по 16; слева перед строкой показан адрес первого байта в~строке в~шестнадцатеричном виде.

% Просмотр памяти по адресу переменной с~помощью отладчика позволяет получит ту же информацию, что и~отладочная печать байтов "--- 


\end{modifyonelong}





\subsection{Создание 64-битной конфигурации Microsoft Visual Studio%\footnote{Использована лабораторная работа, подготовленная Л.\,В.\,Илюшечкиной}
}

% 64-разрядная версия Microsoft Windows доступна в~терминале Skylab (домен SIPC).

Для создания 64-битной конфигурации Microsoft Visual Studio
запустите Microsoft Visual Studio  в~терминале Skylab (домен SIPC) %~\cite{ilus-labs}
и~выполните следующие три шага
(рис.~\ref{ris:win64conf}) \cite{ilus-labs}:

\begin{illustration}
\includegraphics[width=\linewidth]{il-lab1-ris2}

\caption{Создание 64-битной конфигурации для проекта в~Microsoft Visual Studio}
\label{ris:win64conf}
\end{illustration}



Шаг 1. Запустить менеджер конфигураций (рис.~\ref{ris:win64conf}, а).

Шаг 2. В~менеджере конфигураций выбрать поддержку новой платформы (рис.~\ref{ris:win64conf}, б).

Шаг 3. Выбрать 64-битную платформу (x64), а~в~качестве основы выбрать настройки от 32-битной версии (рис.~\ref{ris:win64conf}, в). Те настройки, которые влияют на режим сборки, среда Microsoft Visual Studio
скорректирует сама.

% \section{Базовые типы C++\footnote{Использован черновик стандарта C++14, разделы basic.types, basic.fundamental и~expr.sizeof}}
% \input{book/cpp-basictypes}
% 
% 
% \section{Исследование структуры объектов}
% \input{book/cpp-memorydump}
% 
% \input{labs/c-macro}

\section{Вопросы}
\begin{enumerate}
\item Как представляется символьная информация в~компьютере в~кодах ASCII, расширениях ASCII и~различных кодировках Unicode?
\item Как хранятся русские буквы в~«классических» и~«широких» строках?
\item Как представляются целые числа со знаком и~без знака?
\item Как перевести число в~дополнительный код?
\item Как выполняются логические операции и~сдвиги над строкой битов?
\item Что такое расширение чисел со знаком и~без знака? Для чего нужны операции расширения?
\item Для чего нужно знать %, какой 
порядок следования байтов на вашем компьютере?
% \item Уметь пользоваться окнами Watch и~Memory в~отладчике используемой вами IDE.
\end{enumerate}



\ifthenelse{\equal{\pressversion}{1}}
{}
{

\section{Справочные материалы}

% \subsection{Тексты}
\begingroup
\lstset{keywordstyle=}


\begin{enumerate}

\item Черновик стандарта C
% (latest publically available version of the C11 standard) 
(последняя общедоступная версия C11)
"---
\lstinline!n1570.pdf!

\item
Черновик стандарта C++ 
% (C++14 standard plus minor editorial changes) 
(C++14 с~незначительными редакторскими правками)
"---
November 2014 working draft.
\lstinline!n4296.pdf!

\item IEEE 754 "--- стандарт двоичной арифметики
с плавающей точкой
"---
IEEE Std 754™-2008
(Revision of 
IEEE Std 754-1985)
IEEE Standard for Floating-Point 
Arithmetic.
\lstinline!IEEE754_FP2008.pdf!



\end{enumerate}
\endgroup

}

% \subsection{Коды ASCII}
% \label{sec:ascii}
% \bigskip
% 
% \input{labs/ascii}
