\chapter{Отладка %ассемблерного 
кода}

\setlablabel{disasm}

\purpose{научиться использовать инструменты отладки современных IDE; исследовать генерируемый компилятором код.}


\begin{tasks}

\item 
\labellocal{task:dev:int}
Разработайте программу на языке C++, вычисляющую 
три 
% два 
целых выражения от целого аргумента (в~соответствии с~вариантом).

\begin{tasks}
\renewcommand\vartablewidth{0.8\linewidth}

\item \strut
\labellocal{task:dev:int:a}
% 
\begin{variants}[a]

$y(x) = x \cdot 2$
\next

$y(x) = - x - 1$
\next

$y(x) = x \cdot 3$
\next

$y(x) = |x|$
\next

$y(x) = x \cdot 5$
\next

$y(x) = x/2$
\next

$y(x) = x \Mod 4$
\next

$y(x) = x^2$
\end{variants}

\item \strut
\labellocal{task:dev:int:b}
% 
\begin{variants}[b]

$y(x) = x + 17$
\next

$y(x) = x \cdot 13$
\next

$y(x) = x - 21$
\next

$y(x) = x/11$
\next
$y(x) = x \cdot 7$
\next

$y(x) = x/3$
\next

$y(x) = x^2$
\end{variants}

\item \strut
% 
\begin{variants}[ifelse]

$y(x) = \left\{\begin{array}{ll}
13,& x \geqslant 0 \\
7, & x < 0 \\
\end{array}\right.$
\next

$y(x) = \left\{\begin{array}{ll}
0, & x < 7 \\
x, & x \geqslant 7 \\
\end{array}\right.$
\next

$y(x) = \left\{\begin{array}{ll}
x, & x > 13\\
-1 ,& x \leqslant 13\\
\end{array}\right.$

\end{variants}

\end{tasks}


\descrcomment{Не обязательно вводить $x$ с~клавиатуры. Инициализация локальной переменной «узнаваемым» литералом упростит поиск её адреса.

Сборка всех заданий данной лабораторной работы выполняется одним компилятором при одних и~тех же настройках.

Не все изменения кода на C++ приведут к~видимым изменениям дизассемблированного кода.

}

% {
% \small
% 
% Если разбить вычисление выражения на несколько простых действий, в~частности
% \begin{lstlisting}[style=lstsmall]
% int y, dy, x = 0x123;
% // y = x*5 - x*25 + x*125;
% y = x*5;
% dy = x*25;
% y -= dy;
% dy = x*125;
% y += dy;
% \end{lstlisting}
% будет легче идентифицировать вычисление каждого из них.
% При этом в~коде появится большее количество присваиваний (mov); если оптимизатор при расчёте выражения одним оператором заменял несколько действий одной командой (например, $-x-1$ на битовую инверсию) ассемблерный код вычислений может измениться, но при этом также будет соответствовать исходному выражению.
% 
% }

\item Запустите программу и,~используя инструменты отладчика (в~частности, дизассемблер), изучите ассемблерный код%.
, соответствующий вычислениям (для Code::Blocks "--- переключитесь на синтаксис AT\&T и~включите Mixed mode, чтобы в~окне дизассемблера перед каждой группой команд, соответствующих одному оператору языка высокого уровня, явно отображался этот оператор).

Занесите ассемблерный код, соответствующий вычислению $y(x)$, в~отчёт (код, не связанный с~вычислением $y(x)$, копировать в~отчёт не нужно!).
% , подробно прокомментировав мнемонику и~операнды для каждой команды.
Определите и прокомментируйте:
\begin{itemize}
\item обращение к~переменным $x$ и~$y$;
\item арифметические и~логические операции "--- сложение, вычитание, умножение, деление с~остатком, деление на $2^n$ и~т.\,д. (по возможности);
\item сравнения и~передачу управления в~ветвлениях.
\end{itemize}


% \item В~программе из задания \reflocal{task:dev:int} дополнительно примените к~используемым переменным модификатор volatile (или добавьте новый  фрагмент кода с~аналогичными вычислениями).
% Опишите в~отчёте, как изменился ассемблерный код.
% 
% \item В~программе из задания \reflocal{task:dev:int} дополнительно примените к~используемым переменным спецификатор register.
% Опишите в~отчёте, как изменился ассемблерный код.
% 
% 
% \item В~программе из задания \reflocal{task:dev:int} сделайте переменные глобальными.
% Опишите в~отчёте, как изменился ассемблерный код.
% 
% 
% \item
% Замените тип int на char, short, long и long long.
% Опишите в~отчёте изменения кода для каждого типа.
% 
% 
% \item
% Замените тип переменных на double, single, long double.
% Опишите в~отчёте изменения кода для каждого типа.

\item Внесите в~программу из задания \reflocal{task:dev:int}, \reflocal{task:dev:int:a} изменения (либо, что предпочтительнее, добавьте новые  фрагменты кода, выполняющие аналогичные вычисления для других переменных, используя макросы препроцессора или шаблоны C++).

\begin{itemize}
% \item примените к~используемым переменным модификатор volatile;
% \item  примените к~используемым переменным спецификатор register;
\item сделайте переменные глобальными;
\item измените тип с~int на char, short, long и long long;
\item измените тип с~int на  на %double, float, 
long double% (деление (\lstinline!/!) "--- вещественное, для расчёта остатка (\lstinline!%!) усекайте вещественные переменные до int)
.
\end{itemize}
Опишите в~отчёте различия в ассемблерном коде.
% Объясните эти различия.

% Измените тип переменных с~int на double, single, long double и~рассчитайте
% \begin{variants}[vardouble]
% 
% $y(x) = 
% x + 2\cdot(x/3)$
% \next
% 
% $y(x) = 
% x + x/2 +x /4 + x/8$
% \next
% 
% $y(x) =  x^3 - (x-1)\cdot(x+1)$
% \next
% 
% $y(x) =  x^2+x+1$
% \next
% 
% $y(x) = 1 + x/3$
% \next
% 
% $y(x) =  2x\cdot(x-1)$
% \next
% 
% $y(x) =  x/2+3x+1$
% \end{variants}
% Как изменилось обращение к~переменным?

\item
Оформите вычисления из задания  \reflocal{task:dev:int}, \reflocal{task:dev:int:a} как целую функцию от целого аргумента.
Опишите в~отчёте код вызова функции.
Как передаётся аргумент?
Как возвращается значение?

\item
Измените тип аргумента и~результата на вещественный.
Опишите в~отчёте код вызова функции.
Как передаётся аргумент?
Как возвращается значение?

% \item\bonus{+2 балла} 
% Увеличьте количество аргументов до четырёх.
% Как передаются аргументы?


\item\bonus{+2 балла} 
Используйте в~функции статическую переменную.
Как выглядит обращение к~ней?


% \item\termin{Бонус (+2 балла за платформу):} 
% Вызовите функцию из стандартной библиотеки C и~какой-либо метод/функцию из стандартной библиотеки C++.
% Сравните вызовы библиотечных функций C и~C++ друг с~другом, а~также с~вызовом функции, описанной внутри проекта.


\item \termin{Бонус (+2 балла за платформу):}  запустите тестовую программу (программы), используя платформу и/или компилятор, отличные от \stdOs{} и~\stdCompiler{}.  Результаты с~пояснениями внести в~конспект.
\end{tasks}


% 
% \section{Требования}
% 
% \begin{enumerate}
% \item Программы должны собираться на любой платформе (недопустимо использование платформозависимых элементов).
% % 
% Для разработки программ на языке C++ могут быть использованы кроссплатформенные среды Qt Creator, TheIDE (Ultimate++), Code::Blocks, Codelite.
% 
% \item При выполнении работы оформите отчёт, содержащий: название работы, текст программы (программ) и~ассемблерный код с~комментариями.
% 
% 
% \end{enumerate}

% Для просмотра содержимого памяти используйте
% возможности отладчика (окна Memory и~Watches, рис.~\ref{lab:digits:ris:digits-debugmemory}).


% 
% \section{Варианты заданий}
% 
% % \providecommand\varlocalcountername{var}
% % % % \newcolumntype{q}[1]{>{\singlespacing\raggedright\arraybackslash}m{#1}}%
% % % % \newcolumntype{o}[1]{>{\singlespacing\centering\arraybackslash}m{#1}}%
% % % \newcolumntype{R}{>{\singlespacing\raggedright\arraybackslash}X}
% % % % \newcolumntype{i}{>{\singlespacing\raggedright\arraybackslash}X}
% % \renewcommand\varlocalcountername{\lablabel:var}
% % \newcounter{\varlocalcountername}
% % \setcounter{\varlocalcountername}{0}
% % 
% % \noindent\begin{tabularx}{\linewidth}{|r<{\refstepcounter{\varlocalcountername}\arabic{\varlocalcountername}.}|R|}
% % \hline
% % \multicolumn{1}{|c|}{\thead{$(\text{ПК}-1)\%\ref{\varlocalcountername:end}+1$}}&\thead{Вариант} \\\hline& 
% % $y(x) = x \% 5 + 2*(x/3)$
% % \\\hline& 
% % $y(x) = x + x/2 +x /4 + x/8$
% % \\\hline
% % \end{tabularx}
% % \addtocounter{\varlocalcountername}{-1}\refstepcounter{\varlocalcountername}\label{\varlocalcountername:end}
% 
% {
% % \footnotesize
% \begin{variants}
% 
% $y(x) = \left\{\begin{array}{ll}
% x \% 5 + 2\cdot(x/3),& x \geqslant 0 \\
% 0, & x < 0 \\
% \end{array}\right.$
% \next
% 
% $y(x) = \left\{\begin{array}{ll}
% x + x/2 +x /4 + x/8, & x\%2 = 0 \\
% x-1, & x\%2 \neq 0 \\
% \end{array}\right.$
% \next
% 
% $y(x) = \left\{\begin{array}{ll}
%  x^3 - (x-1)\cdot(x+1),& -4 \leqslant x \leqslant 4\\
%  0,& x < -4 \vee x > 4\\
% \end{array}\right.$
% \next
% 
% $y(x) = \left\{\begin{array}{ll}
%  (x^2)\%(x+1), & x > -1\\
%  x^3, & x \leqslant -1 \\
% \end{array}\right.$
% \next
% 
% $y(x) = \left\{\begin{array}{ll}
%  1 - x\%3 + x/3, & x < 13\\
%  1 + x, & x \geqslant 13
% \end{array}\right.$
% \next
% 
% $y(x) = \left\{\begin{array}{ll}
%  2x\cdot(x-1) & |x-1|<5\\
%  -2x,& |x-1|\geqslant 5\\
% \end{array}\right.$
% \next
% 
% $y(x) = \left\{\begin{array}{ll}
%  x/2, & x\%2 = 0 \\
% 3x+1, & x\%2 \neq 0 \\
% \end{array}\right.$
% \end{variants}
% }


\theoryrefs
\theoryref{sec:mem-segments}
\theoryref{sec:registers}
% \theoryref{sec:cpp-ide} 
% \theoryref{sec:rel}
\theoryref{sec:cpp-compile}
% \theoryref{sec:asm}
\theoryref{sec:asm-gas}
\theoryref{sec:asm-commandsintro}
% \theoryref{sec:asm-fpu}
% 
% \theoryref{sec:asm-flags}



\subsection{Отладка в~интегрированных средах разработки}


Различные IDE для отладки программ используют собственные инструменты или (чаще) предоставляют графический интерфейс к~внешним отладчикам.
Обычно используется отладчик gdb (GNU Symbolic Debugger).
% Для отладки в~различных IDE чаще всего используется отладчик gdb (GNU Symbolic Debugger), графический интерфейс к~которому предоставляет среда.

Базовые инструменты различных отладчиков схожи.
Рассмотрим инструменты отладки на примере  среды Qt Creator (рис.~\ref{ris:qtc}).
\footnote{Использованы материалы 
% http://doc.crossplatform.ru/qtcreator/1.3.0/creator-debugging.html
руководства по Qt Creator
}
\begin{illustration}
\includegraphics[width=\linewidth]{qtc}
\caption{Отладка с~помощью Qt Creator}
\label{ris:qtc}
\end{illustration}

\subsection{Точки останова}

Точки останова представляют место или набор мест в коде, которые при выполнении прервут отлаживаемую программу и передадут управление пользователю. Пользователь может просмотреть состояние прерванной программы или продолжить выполнение построчно или непрерывно.

Обычно точки останова связаны с файлом исходных кодов и строкой или началом функции (рис.~\ref{ris:qtc-breakpoint}).
\begin{illustration}
\includegraphics[width=\wideImageWidth]{qtc-breakpoint}

\caption{Точка останова в~коде}
\label{ris:qtc-breakpoint}
\end{illustration}

Если выполнение не останавливается в~точке останова, проверьте конфигурацию сборки.
В~большинстве сред разработки отладка возможна только для отладочной (Debug), но не для оптимизированной (Release) сборки.
В~Qt~Creator возможна пошаговая отладка Release-сборки с~использованием окон дизассемблера, регистров и~памяти, но точки останова в~исходном коде C++ в~этом режиме игнорируются.

% Большинство возможностей отладчика доступно только для отладочной (Debug), но не для оптимизированной (Release) сборки.

\subsection{Окна отладчика}

\subsubsection{Локальные и~наблюдаемые переменные}
Окно «\insertsubsubsection» отображает информацию о верхнем кадре стека (параметры функции и~локальные переменные), а~также о~заданных выражениях.
Окно «\insertsubsubsection»  может быть использовано для изменения содержимого переменной простого типа данных (такого как int или float) во время останова программы (рис.~\ref{ris:qtc-watches}).
\begin{illustration}
\includegraphics[width=\wideImageWidth]{qtc-watches}
\caption{\insertsubsubsection{} Qt Creator}
\label{ris:qtc-watches}
\end{illustration}

В~среде Code::Blocks окно просмотра переменных можно открыть, используя меню $Debug \to Debugging~windows \to Watches$.
В~TheIDE для просмотра переменных используются  вкладки $Autos$, $Locals$ и~$Watches$ панели $Debug$ (доступна во~время отладки внизу экрана, скрывается/показывается по Esc).


\subsubsection{Обозреватель и~редактор памяти}
\insertsubsubsection{} отображают содержимое памяти.
Как обозреватель, так и~редактор памяти можно открыть для просмотра конкретной переменной, используя контекстное меню переменной в~окне «Локальные и~наблюдаемые переменные» (рис.~\ref{ris:qtc-memory}), при этом подсвечивается не только начало, но и~размер объекта.
\begin{illustration}
\includegraphics[width=\linewidth]{qtc-memory}
\caption{Обозреватель и~редактор памяти Qt Creator}
\label{ris:qtc-memory}
\end{illustration}

В~среде Code::Blocks окно просмотра содержимого фрагмента памяти можно открыть, используя меню $Debug \to Debugging~windows \to Memory~dump$
\index{IDE Code::Blocks!дамп памяти} 
(рис.~\ref{ris:codeblocks-digits-debugmemory}).

\begin{illustration}
\includegraphics[width=\linewidth]{cb-memory-watches}

\caption{Отладочные окна Memory и~Watches в~Code::Blocks}
\label{ris:codeblocks-digits-debugmemory}
\end{illustration}

Начало фрагмента может быть не только конкретным адресом в~памяти (как \lstinline!0x401060!) или адресом переменной (\lstinline!&x!), но и~выражением C++.
Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.



\subsubsection{Дизассемблер}

Окно дизассемблера  отображает дизассемблированный код для текущей функции (рис.~\ref{ris:qtc-disasm}).
В~Qt Creator по умолчанию спрятано, перейти в~режим работы на уровне инструкций процессора возможно во время отладки.
\begin{illustration}
\includegraphics[width=\linewidth]{qtc-disasm}
\caption{Дизассемблированный код программы (Qt Creator)}
\label{ris:qtc-disasm}
\end{illustration}

В~среде Code::Blocks окно дизассемблера \index{IDE Code::Blocks!окно дизассемблера} можно открыть, используя меню $Debug \to Debugging~windows \to Disassembly$ (для редактирования кода и для отладки используются разные наборы окон, поэтому открывать дизассемблер необходимо уже в~процессе отладки).  Опция $Mixed~mode$ в~этом окне включает отображение строки C++ перед соответствующей ей группой команд. Кнопка $Adjust$ позволяет перемотать дизассемблированный код к~текущей команде. Кнопка $Save~to~text~file$ "--- сохранить его.

Рис.~\ref{ris:cb-disasm} показывает окно дизассемблера среды Code::Blocks  с~включённой опцией $Mixed~mode$ (синтаксис AT\&T).
\begin{illustration}
\includegraphics[width=\linewidth]{cb-disasm}
\caption{Дизассемблированный код программы (Code::Blocks)}
\label{ris:cb-disasm}
\end{illustration}

Иногда при внесении изменений в~программу и~включённой опции  $Mixed~mode$ ассемблерный код и~операторы высокого уровня в~окне дизассемблера не изменяются даже после пересборки проекта. В~этом случае необходимо выключить и~снова включить $Mixed~mode$ (останавливать отладку и~пересобирать проект между этими действиями не надо).

В~TheIDE панель дизассемблера всегда доступна во~время отладки (справа). Её содержимое можно скопировать в~буфер обмена, используя пункт меню $Debug \to Copy~disassembly$.


Содержимое окна дизассемблера в любой среде разработки "--- именно читабельное представление машинного кода отлаживаемой программы, а~не промежуточная стадия компиляции модуля в~машинный код, формируемая командой \lstinline!g++ -S! (промежуточный результат компиляции можно увидеть, запустив команду \lstinline!g++ -S <путь к cpp-файлу>! в~консоли; в~TheIDE можно использовать пункт меню $Build \to Show~assembler~code~for~...$). 

\subsubsection{Настройка синтаксиса ассемблерного кода}
% В~частности, в
В~зависимости от используемого отладчика и~его настроек может различаться используемый синтаксис.
Настроить вид дизассемблированного кода можно в~настройках отладчика среды (для Code::Blocks \index{IDE Code::Blocks!синтаксис дизассемблера}
$Settings \to Debugger \to GDB/CDB~debugger : default \to Choose~disassembly~flavor$).


В~Qt Creator 
% для дизассемблированного кода в~отладчике по умолчанию используется синтаксис AT\&T.
% При необходимости это 
настроить синтаксис дизассемблера можно в~окне параметров (меню Инструменты $\to$ Параметры).
Для этого используется переключатель «Стиль Intel для дизассемблера», находящийся
в~разделе «Отладчик» этого окна на вкладке GDB.

% \FloatBarrier
\subsection{Регистры}




Окно «Регистры»  отображает текущее содержимое регистров (рис.~\ref{ris:qtc-reg}).
В~Qt~Creator по умолчанию спрятано, включается через контекстное меню или меню «Окно».

\begin{illustration}
\includegraphics[width=\approvedImageWidth]{qtc-reg}
\caption{Регистры (Qt Creator)}
\label{ris:qtc-reg}
\end{illustration}

{
В~среде Code::Blocks содержимое основных регистров можно увидеть, используя окно CPU registers (меню $Debug \to Debugging~windows \to CPU~registers$).
Регистры сопроцессора отображаются в~окне FPU~status (меню $Debug \to Information \to FPU~status$), но, в~отличие от окна основных регистров, 
открытое окно FPU~status не позволяет продолжить отладку. 
\sloppy

}

В~TheIDE содержимое основных регистров показывается под  панелью дизассемблера и~всегда доступно во~время отладки (справа). 




% \section{Вопросы}


\section{Вопросы}
\begin{enumerate}
\item Уметь пользоваться окнами просмотра переменных и~содержимого памяти в~отладчике используемой вами IDE.
% \item Для чего служит  модификатор volatile в~C++?
% \item Для чего служит спецификатор register в~C++?
\item Чем различается размещение в~памяти локальных, глобальных и~статических переменных?

\item Чем различается работа с~целыми числами разной разрядности?
\item Чем различается работа с~целыми и~вещественными числами?
\item Как в~функции передаются целые параметры (в~исследуемом компиляторе и~платформе%
)?
\item Как в~функции передаются вещественные параметры (в~исследуемом компиляторе и~платформе)?
\item Как в~функции передаются три и~более параметров (в~исследуемом компиляторе и~платформе)?
% \item Какие вы знаете соглашения о вызове?

\item Чем различается код, созданный компиляторами одного семейства для различных платформ?
\item Чем различается код, созданный различными компиляторами для одной платформы?

\end{enumerate}

\section{Справочные материалы}

% \subsection{Статьи}
\begingroup
\lstset{keywordstyle=}


\begin{enumerate}

\item Список основных команд архитектур x86 и x86-64 "---
\lstinline!Команды архитектур x86 и x86-64.htm!

\item Черновик стандарта C
% (latest publically available version of the C11 standard) 
(последняя общедоступная версия C11)
"---
\lstinline!n1570.pdf!

\item
Черновик стандарта C++ 
% (C++14 standard plus minor editorial changes) 
(C++14 с~незначительными редакторскими правками)
"---
November 2014 working draft.
\lstinline!n4296.pdf!


\end{enumerate}
\endgroup
