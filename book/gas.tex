
\chapter{Синтаксис и~команды GNU Assembler x86}

% \epigraphcensoredtwo[
\epigraph{\begin{stanza}
А потому, после того, как будешь свободен, будь деятелен.
\end{stanza}
}
{\Quran{94.7}}
% ]{
% \epigraph{\begin{limerick}
% Удалой старичок из Салоников\\
% Очень прыгать любил с~подоконников.\\
% На вопрос: «Не опасно?»\\
% Говорил он: «Прекрасно! "---\\
% В~этом прелесть прыжков с~подоконников».
% \end{limerick}
% }
% {\Lear}
% }

Язык ассемблера "--- простейший символический язык программирования, каждая команда которого транслируется в~одну команду машинного языка.
Также существуют операторы ассемблера, не соответствующие машинным командам "--- директивы, комментарии, пустые операторы.

% Для архитектуры x86 разработано множество трансляторов ассемблера, каждый из которых описывает свой язык.

% Для программирования на ассемблере требуется знать хотя бы основные команды.
Набор команд ассемблера определяется как архитектурой используемого компьютера, так и~собственно ассемблером "--- транслятором с~символического языка в~объектный код.
Команды  имеют текстовые мнемонические обозначения (мнемоники).
При этом одной и~той же мнемонике может соответствовать несколько опкодов, выполняющих схожие действия над операндами, расположенными в~разных местах или разного размера.
Часто %отдельный опкод имеют восьмибитные команды
существует один опкод для восьмибитных операндов и~другой "--- для операндов, имеющих размер 32, 64 или 16 бит (для него разрядность операндов определяется текущим режимом и~префиксами).
Таким образом, иногда команды обрабатывают восьмибитные операнды  немного иначе, чем любые другие.
Кроме того, одному опкоду может соответствовать несколько разных мнемонических обозначений.

% Данное пособие описывает программирование на языке
В~данной главе описывается 
часть набора команд
% набор команд
GNU Assembler (GAS) для архитектуры x86
с~использованием традиционного синтаксиса AT\&T\index{Синтаксис!AT\&T},
а~также особенности этого синтаксиса.


\section{Особенности GNU Assembler}
\epigraphA{\begin{stanza}
А~тот, кто сторожит баржу, спесив \\
И~вообще не святой;\\
Но тот, кто сторожит баржу, красив \\
Неземной красотой.\\
\end{stanza}}
{\Bg[Стерегущий баржу]}
{\begin{stanza}[0mm]
И малое замкнулось на великом,\\
И Млечный Путь раскрылся для меня!\\
\end{stanza}}{\Sk[Млечный путь]}
\label{sec:asm-gas}

G%NU Assembler
AS, как и~его предок, ассемблер Unix as,
% Ассемблер Unix as (его версия из коллекции GCC назывется gas) 
использует так называемый синтаксис AT\&T System V/386, часто называемый просто синтаксисом AT\&T\index{Синтаксис!AT\&T} или синтаксисом GAS~\cite{Assembler-fsf,linux_parallel}.

\index{Синтаксис!Intel}%
Также для процессоров семейства Intel x86 часто используется  синтаксис, предложенный фирмой Intel.
Основными отличиями синтаксиса Intel от  AT\&T считаются обратный порядок операндов, другие обозначения адресации  и~невозможность явного указания разрядности операции.
Менее известно различие в~мнемонических обозначениях команд.
Современные версии ассемблера GAS  поддерживают оба варианта синтаксиса.

Основными недостатками синтаксиса Intel является неоднозначность и~трудность чтения инструкций.
Кроме того, синтаксис Intel используется только для процессоров Intel или совместимых с~ними.

Синтаксис AT\&T\index{Синтаксис!AT\&T} иногда называется кроссплатформенным, так как GCC и, соответственно, GAS  реализован для множества различных архитектур.
Полной кроссплатформенности при использовании языка ассемблера достичь невозможно, 
так как у~каждой платформы свой набор %команд и~регистров, % и~особенностей,
команд, регистров и~методов адресации,
но использование %универсального синтаксиса облегчает %\чтение программ
схожего синтаксиса
облегчает переход между ними.

Также инструкции, записанные в~соответствии с~синтаксисом AT\&T\index{Синтаксис!AT\&T}, легче читаются.
% (кроме косвенной адресации).
Даже обозначение адреса в~памяти, которое вначале кажется контринтуитивным,  распознаётся однозначно.
Косвенный адрес в~памяти, записанный по правилам синтаксиса AT\&T\index{Синтаксис!AT\&T}, невозможно перепутать с~непосредственным значением, что происходит в~диалектах Intel\index{Синтаксис!Intel}.


% \footnote{Использованы материалы:
% GCC-Inline-Assembly-HOWTO, << ссылка в~inline
% Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А. << ниже
% Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
% X86 Assembly/GAS Syntax << вики
% }

\subsection{Общие правила}
% \epigraphcensored[
\epigraphA{\begin{stanza}[0mm]
И малое замкнулось на великом,\\
И Млечный Путь раскрылся для меня!\\
\end{stanza}}{\Sk[Млечный путь]}
{
% Мы спрашиваем: что лучше "--- всемирный язык или всемирная бойня?
Это равноценно оказалось применимым для целого мира понятий, которым оно дано от~себя, как~почки от~семени.
}
{\Khlebnikov[Мысли и~заметки]}
% \epigraph{\begin{stanza}
% Без имени, как меч кузнеца,\\
% Невиданная без прикрас,\\
% Без начала и без конца,\\
% Бывшая здесь прежде всех нас.\\
% \end{stanza}}
% {\Aquarium}
% \epigraph{\begin{stanza}[0mm]
% Я не знаю, Земля кружится или нет,\\
% Это зависит, уложится ли в строчку слово.
% \end{stanza}}
% {\Khlebnikov}
% ]{
% \epigraph{\begin{stanza}
%  Итак, попался. А теперь что делать?
% \end{stanza}}
% {О.\,Арефьева}
% }

Так как GAS в~основном используется на одном из этапов компиляции программы на %языке высокого уровня, о 
C/C++, 
многие синтаксические конструкции GAS и~C/C++ совпадают.

В~программе могут использоваться латинские буквы, цифры, %символы \lstinline!%, $, *, ., —!
а~также нижнее подчёркивание и~точка.
% 
Допустимые пробельные символы "--- пробел и~табуляция;
они могут сочетаться в~любом порядке.
Перевод строки является разделителем операторов.

Допускаются многострочные комментарии  /* в~стиле C */
и~однострочные // в~стиле C++.
% Также поддерживается устаревший 
% #<не выражение> устаревший
Также для различных платформ поддерживаются платформоспецифичные виды однострочных комментариев.
В~частности, для x86, кроме однострочного комментария в~стиле C++, поддерживается символ комментария \lstinline!#!, но он считается устаревшим.

Оператор ассемблера целиком размещается на одной строке.
В~начале строки может быть одна или несколько меток, заканчивающихся двоеточием.
% Перед оператором может быть метка.
Если первый символ оператора "--- точка, то это "--- директива ассемблера (первая строка листинга~\ref{lst:asm:directive:instruction}).
Набор основных директив %в~основном 
совпадает для всех архитектур, но для многих платформ есть и~специфичные (в~частности, директивы определения данных).
\begin{lstlisting}[caption=Директива и~команда, label=lst:asm:directive:instruction]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}
Пустой оператор может состоять только из пробельных символов или быть пустой строкой (вторая строка).
Оператор, начинающийся с~буквы, представляет собой мнемоническое обозначение машинной команды,
за которым при необходимости следуют операнды, разделённые запятыми (третья строка листинга~\ref{lst:asm:directive:instruction}).
% Оператор оканчивается переводом строки или точкой с~запятой.

\index{Литералы}%
Строковые литералы ограничиваются двойными кавычками, экранирующим символом является обратный слеш «\textbackslash»,
спецсимволы кодируются аналогично C/C++.
Числовые литералы также описываются аналогично C/C++.





\subsection{Основные директивы}
% \epigraphcensored[
\epigraph{\begin{stanza}[0mm]
 Кто море удержал брегами \\
 И бездне положил предел, \\
 И ей свирепыми волнами \\
 Стремиться дале не велел?
\end{stanza}}
{\Lomonosov[Ода, выбранная из~Иова]}
% \begin{stanza}
% Белая, как сибирский мел,\\
% Белая, как нетронутый лист,\\
% Я отдал тебе всё, что имел,\\
% Теперь я чёрный, как трубочист.\\
% \end{stanza}}
% {\Aquarium}
% \epigraph{Таким  образом, если
% помимо  чувственно  воспринимаемых   вещей  и  математических  предметов  не~существует каких-либо иных, таких,  как Эйдосы, о коих говорят некоторые, то~не будет существовать  единой  по числу и  по  виду сущности, и начала вещей
% будут ограничены не по числу, а [только] по виду.}
% {\Metaphiz}
% \epigraph{Итак, слово, как это было сказано вначале, что-то  обозначает, и~притом
% что-то  одно.}
% {\Metaphiz}
% \epigraph{\begin{stanza}
% Что нам подвластно? Гранитные поля,\\
% Птицы из пепла, шары из хрусталя.
% \end{stanza}}
% {\Aquarium}
% ]{
% \epigraph{\begin{stanza}
% Не танцевать же мы на танцы ходим!
% % Так слово за слово "--- и выучишься мату.
% \end{stanza}}
% {О.\,Арефьева}
% }
Директива ассемблера не соответствует никакой машинной команде.
Рассмотрим несколько наиболее употребительных директив; их можно разбить на несколько классов.

\subsubsection{Директивы определения секций}
\index{Сегмент}

Как было описано в~разделе~\ref{sec:mem-segments}, код программы и~различные виды данных должны располагаться в~различных диапазонах адресного пространства.
По историческим причинам эти диапазоны называются сегментами (соответствующие фрагменты исходного кода и~исполняемого файла "--- секциями).
Начало содержимого того или иного сегмента в~исходном ассемблерном коде отмечается специальными директивами.

С~начала файла до первой директивы располагается сегмент кода.
Указать продолжение сегмента кода можно директивой \termin{.text}.

Сегмент данных открывается директивой \termin{.data}.
В~принципе, описание статических данных в~сегменте кода не вызовет ошибки, но такие данные будет невозможно модифицировать, так как сегмент кода защищён от изменений.

% Данные, которые не должны изменяться (доступные только для чтения), описываются в~специальной секции, открываемой директивой  \termin{.rodata}.

% 
% Те глобальные и~статические переменные, которые не были инициализированы при объявлении,
% отделяются  в~специальный \termin{сегмент BSS.}
% % \termin{.bss}

Для сегментов стека\index{Стек} и~кучи\index{Куча} нет соответствующих секций, они заполняются динамически в~процессе выполнения программы.

\subsubsection{Директивы определения данных}

В~сегменте \texttt{.data} статические данные описываются также с~помощью  директив.

После директивы определения данных указывается литерал подходящего типа или несколько литералов, перечисленных через запятую.
В~памяти соответственно  резервируется одна или несколько ячеек соответствующего размера, которые инициализируются указанными значениями.

Для того, чтобы дать адресу ячейки имя, перед соответствующим определением необходимо поставить метку
(листинг~\ref{lst:asm:directive:data}).
\begin{lstlisting}[caption=Определение статических данных, label=lst:asm:directive:data]
foo: .long 0, 1, 2
bar: .double -8.7
\end{lstlisting}
Важно помнить, что ассемблер, в~отличие от языков высокого уровня, не является типизированным.
Таким образом, если, в~частности, 
по адресу $bar$ расположено  восьмибайтовое значение двойной точности~$-8,7$,
а~программист обратится к~нему как к~числу одинарной точности (четыре байта), это не вызовет сообщения об ошибке, но прочитанное значение будет другим.

Для инициализации памяти целыми значениями различного размера используются следующие директивы:
\termin{.byte} %одно или несколько выражений, разделённых запятыми
"--- однобайтовое (восьмибитное) целое,
\termin{.short}
% \termin{.short .half }
"--- %двухбайтовое,
шестнадцатибитное,
% \termin{.int (.long)}
% "--- четырёхбайтовое,
\termin{.long} 
"--- тридцатидвухбитное,
\termin{.quad}
"--- шестидесятичетырёхбитное. %восьмибайтовое 
Размер и~порядок байтов определяются платформой;  приведены размеры для x86 (они же наиболее распространённые).
Также существуют директивы  \termin{.word} и~\termin{.int}, для x86 %эквивалентные .short и~.long 
определяющие шестнадцати- и~тридцатидвухбитные целые
соответственно.
%  H8/500. However, on this platform the `.int' and `.word' directives generate 16-bit numbers.
% On the Sparc, the .word directive produces 32 bit values, instead of the 16 bit values it produces on many other machines. 
 
Значения с~плавающей запятой одинарной (32 бита) и~двойной (64 бита) точности описываются директивами
\termin{.float
(.single)}
и~\termin{.double}. %одно или несколько вещественных значений, разделённых запятыми

Для инициализации памяти строковыми константами различного вида используются 
% следующие директивы.
директивы \termin{.string (.asciz)} и~\termin{.ascii}.


Функции стандартной библиотеки C используют строки, завершающиеся нулём; 
их можно описать директивой
\termin{.string (.asciz)} (листинг~\ref{lst:asm:directive:asciz}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки, завершающейся нулём}, label=lst:asm:directive:asciz]
msg: .string "Hello, world!\n"
\end{lstlisting}
Если после директивы указывается несколько строковых литералов через запятую, завершающий ноль добавляется после каждого.

Строка без завершающего нуля
 описывается директивой
\termin{.ascii} (листинг~\ref{lst:asm:directive:ascii}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки без завершающего нуля}, label=lst:asm:directive:ascii]
msg:
.ascii "Hello, world!\n"
len = . - msg // символу len присваивается длина строки
\end{lstlisting}
Для обработки подобных строк нужно знать их длину (её нельзя определить, анализируя содержимое памяти%, так как строка 
).
Для этого используется специальный символ «.» "--- адрес текущего оператора (в~том числе ячейки с~данными).
% Строки без завершающего нуля используются, в~частности

Директивы определения данных точно так же сработают и~будучи размещёнными в~сегменте кода (\texttt{.text} или неименованная секция в~начале программы),
но такое размещение будет ошибкой.
Если данные попадут во фрагмент кода, который выполняется, они будут интерпретированы как команды, что, скорее всего, приведёт к~сбою при декодировании.
Даже если данные находятся в~той части кода, которая не получает управления, их будет невозможно модифицировать.

\subsubsection{Прочие директивы}

Парные директивы
\termin{.rept $\ldots$ .endr} соответствуют повторению фрагмента между ними,
в~частности
\begin{lstlisting}[caption=Директива \texttt{.rept}, label=lst:asm:directive:rept]
.rept 4   
.long 0   
.endr     
\end{lstlisting}
интерпретируется как четырёхкратное повторение оператора \lstinline!.long 0!:
\begin{lstlisting}[caption={Эквивалентное описание данных без использования \texttt{.rept}}, label=lst:asm:directive:rept-result]
.long 0
.long 0
.long 0
.long 0
\end{lstlisting}
Директивы \texttt{.rept $\ldots$ .endr} могут применяться и~к~командам. 
При этом происходит именно многократное дублирование  фрагмента кода в~исполняемом файле, а~не циклическое повторение одной и~той же его копии.

Директива
\termin{.globl (.global)}
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает 
% описанный в~файле
символ  доступным компоновщику (видимым из других модулей).
\begin{lstlisting}[caption=Перевод символа $main$ в~глобальную область видимости, label=lst:asm:directive:global]
.globl main
\end{lstlisting}
% Директива \texttt{.globl} или \texttt{.global} (возможны оба написания) не определяет символ.
% , он должен быть описан 
Переменные и~функции, имена которых сделаны общедоступными при помощи директивы \texttt{.globl} или \texttt{.global} (возможны оба написания), могут быть импортированы, в~частности, в~модуль на C++ с~помощью ключевого слова \lstinline!extern!.

Парные директивы
\termin{.func  $\ldots$  .endfunc} включают в~исполняемый файл отладочную информацию о~функции (только при сборке в~отладочном режиме).

Таким образом, если в~файле несколько функций, можно указать для отладчика их границы.
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S:endfunc]
\begin{lstlisting}[caption=Границы функции $sqr()$, label=lst:sqr.S:endfunc]
.globl sqr
.func sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
.endfunc
\end{lstlisting}
Директивы \texttt{.func  $\ldots$  .endfunc} не влияют ни на что, кроме отладочной информации.
В~режиме Release игнорируются.


\subsection{Порядок операндов}
% \epigraphcensored[
\epigraph{\begin{stanza}[0mm]
Путь-дорога, господа!\\
Вы откуда и куда?
\end{stanza}}
{П.\,П.\,Ершов. Конёк-горбунок}
% ]
% {
% \epigraph{\begin{stanza}
%     Он, пол сменив, сменил и потолок!
% \end{stanza}}
% {О.\,Арефьева}
% }

В~GAS принят порядок записи операндов слева направо, следуя европейскому направлению письма.
% В~отличие от синтаксиса Intel, 
Соответственно, инструкция GAS обычно имеет вид
% , приведённый в~листинге~\ref{lst:asm:instruction-common-source-destination}.
% [caption=Источник и~приёмник команды, label=lst:asm:instruction-common-source-destination]
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.

Для команд с~тремя операндами (один из них в~x86 "--- всегда непосредственное значение) вначале записывается непосредственное значение, затем источник, затем приёмник.
\begin{lstlisting}
mnemonic immediate, source, destination
\end{lstlisting} 
% [caption={Источник, приёмник и~непосредственный операнд команды}, label=lst:asm:instruction-common-source-destination-imm]

Если среди операндов нет приёмника (в~частности, команды %\lstinline!bound!, \lstinline!invlpga! и~команды 
с~двумя непосредственными операндами, такие как \lstinline!enter!), 
порядок в~AT\&T совпадает с~порядком, указанным в~документации Intel~\cite{Assembler-fsf}.
%  AT&T and Intel syntax use the opposite order for source and destination operands. Intel ‘add eax, 4’ is ‘addl $4, %eax’. The ‘source, dest’ convention is maintained for compatibility with previous Unix assemblers. Note that ‘bound’, ‘invlpga’, and instructions with 2 immediate operands, such as the ‘enter’ instruction, do not have reversed order. i386-Bugs. 

При этом, если команда принимает операнды в~регистрах или памяти, но не модифицирует их (в~частности, команды сравнения~\lstinline!cmp! или~выделения бита \lstinline!bt!), %это не значит, что у~неё нет приёмника.
в~большинстве случаев один из операндов всё равно считается приёмником.
% причём 
Каждая из приведённых команд входит в~семейство, %схожих команд, большая часть которых 
большая часть команд которого
модифицирует этот операнд.
 
В~частности, рассмотрим одну из наиболее употребительных мнемоник ассемблера "--- команду пересылки (копирования) \lstinline!mov!.
\index{Команды!mov}%
Она соответствует оператору присваивания языков высокого уровня.
Её операнды "--- источник (обозначим его $src$) и~приёмник ($dest$).
В~синтаксисе Intel пересылка $dest = src$ имела бы вид \lstinline!mov dest, src!; в~используемом в~данном пособии синтаксисе AT\&T она имеет вид \lstinline!mov src, dest!.
% 
Например, команда \lstinline!movb $0x05, %al! помещает значение~5 в~регистр~$al$.

\subsection{Адресация операндов}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
Поскоблите язык "--- и~вы увидите пространство \\и~его~шкуру.
\end{stanza}}
{\Khlebnikov[Зангези]}
% ]{
%   \epigraphcensored[
%   \epigraph{
%   "--* Но позволительно ли вешать его, не поймав? "--- заметил я. "--- А~в~остальном я~охотно предоставляю вам полагаться на ваши умозаключения.
%   % Катриона
%   }{Р.\,Л.\,Стивенсон}
%   ]{
%   % \epigraph{
%   % %      - Хорошо, - сказал я. - Я~тоже задам  последовательность  вопросов  о
%   % % местоположении.
%   % %      - Задавай, задавай, - пробормотал Чапаев.
%   % %      - Начнем по порядку. 
%   % "--* Вот вы расчёсываете лошадь. А~где находится  эта лошадь?
%   % %      Чапаев посмотрел на меня с~изумлением.
%   % %      - Ты что, Петька, совсем охренел?
%   % %      - Прошу прощения?
%   % 
%   %       "--* Вот она.
%   % }{В.\,Пелевин}
% 
%   \epigraph{
% 
%   "--* Где, "--- спрашивает, "--- ты живёшь?
% 
%   "--* Ступай, "--- говорит, "--- прямо, повороти направо. Тут~будет пень большой. Ты разбегись да треснись башкой. Как искры из глаз посыплются "--- тут меня и~увидишь...
%   }{П.\,Бажов}
%   }
% }

\index{Адресация!виды}%
\label{sec:addressing}


Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
В~разделе~\ref{sec:addressing:common} были описаны различные виды адресации.
% Каждому из них соответствует об
Рассмотрим обозначения, принятые в~GAS для методов адресации явно передаваемых параметров команд x86.

% % Данные могут адресоваться различными способами.
% Для %них 
% явно передаваемых параметров
% доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная}\index{Адресация!непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).

Непосредственные операнды отмечаются префиксом~\lstinline!$!.
% 
Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая}\index{Адресация!прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды.

Операнды, описываемые статическим адресом в~памяти, не имеют префикса.
% 
Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n!~(значение глобальной переменной $n$).


\item \termin{Прямая относительная}\index{Адресация!прямая относительная}, также $rip$-relative или PC-relative, от  program counter   "--- переменная или функция располагается в~памяти по~фиксированному адресу, но в~команду включается не сам адрес, а~его смещение относительно указателя команд $ip$.

Для адресов в~коде (функций, меток для перехода) неявно применяется по умолчанию как в~тридцатидвухбитном, так и~в~шестидесятичетырёхбитном режиме.
% (в~шестнадцатибитном режиме ).
Операнд не имеет префикса и~в~ассемблером коде выглядит так же, как и~прямой абсолютный адрес: 
\lstinline!call func!, \lstinline!jmp label!.
% \lstinline!func!, \lstinline!label!.

В~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} появилась возможность использовать прямую относительную адресацию и~для данных.
Операнд выглядит как базовый адрес со смещением, где базой явно задан указатель команд: 
\lstinline!lea msg(%rip), %rsi!
% \lstinline!msg(%rip)!
(здесь \texttt{msg} "--- метка в~секции данных).
% , вручную рассчитывать
Относительная адресация используется только для базового регистра $rip$.
Аналогичная запись с~другой базой соответствует косвенной адресации и~использованию \emph{абсолютного}, а~не относительного адреса \texttt{msg}.


\item \termin{Регистровая}\index{Адресация!регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;

Операнды в~регистрах отмечаются префиксом~\lstinline!%!.
% 
Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!, \lstinline!%rsi!, \lstinline!%r13!.

\item \termin{Косвенно-регистровая (косвенная)}\index{Адресация!косвенная} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).

{
% \sloppy

Например, 
% Например, для адресации значения
\lstinline!(%ebp)! "---  значение в~памяти по адресу $ebp$.
Можно указать смещение относительно адреса, хранимого в~регистре: \lstinline!4(%esp)! "--- значение в~памяти 
по адресу $esp+4$.


%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров:
\lstinline!4(%ebp, %edi, 8)! "--- значение  в~памяти по адресу \mbox{$ebp + 8edi + 4$.}
Часть параметров может отсутствовать:
\lstinline!(%edx, %esi, 8)! "--- значение по адресу $edx+8esi$, 
\lstinline!(%edx, %esi)! "--- по адресу \mbox{$edx+esi$,}
\lstinline!(,%esi, 8)! "--- по адресу $8esi$.

}

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}

\subsubsection{Компоненты адреса}

В~языке ассемблера x86 конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Как было сказано в~разделе~\ref{sec:rm:addressing}, команда x86 может содержать до четырёх полей, задающих адрес "--- номер базового регистра
% $base$, номер индексного регистра $index$, показатель масштаба индекcного регистра ${scale}$ и~смещение $displacement$.
$Base$, номер индексного регистра $Index$, показатель масштаба индекcного регистра ${Scale}$ и~смещение $Displacement$.


Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
\begin{equation}
\label{eq:asm:full-addressing}
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% *\big({Base} + scalar\,multiplier \cdot {Index} + Displacement\big)
% *\big({base} + scalar\,multiplier \cdot {index} + displacement\big)
*\big({Base} + \sigma\cdot {Index} + Displacement\big)
% *\big({Base} + \gamma\cdot {Index} + Displacement\big)
% *\big({Base} + \alpha\cdot {Index} + Displacement\big)
% *\big({Base} + \theta\cdot {Index} + Displacement\big)
\end{equation}
% где $base$ и~$index$ "--- значения соответствующих регистров (32-разрядные для соответствующей платформы), $displacement$ "--- целое знаковое число (смещение), $scalar\,multiplier$ "--- натуральное число (масштабный коэффициент "--- степень двойки $2^{scale}$, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
где $Base$ и~$Index$ "--- значения соответствующих регистров (32-разрядные для соответствующей платформы), $Displacement$ "--- целое знаковое число (смещение), $\sigma$ "--- натуральное число (масштабный коэффициент "--- степень двойки $2^{Scale}$, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется 
% $scalar\,multiplier = 1$, 
$\sigma = 1$,
вместо остальных пропущенных параметров  используется~$0$).

\subsubsection{Полная форма косвенной адресации}
\label{sec:full-att-addressing}

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS, соответствующая~\eqref{eq:asm:full-addressing}, имеет вид
% \begin{lstlisting}
% displacement(%base, %index, scalar multiplier)
% \end{lstlisting} 
\begin{lstlisting}
displacement(%base, %index, /*@$\sigma$@*/)
\end{lstlisting} 
% [caption={Формат описания адреса в~памяти}, label=lst:asm:pointer-common]
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
Любой из компонентов может отсутствовать, в~этом случае опускается %и~отделяющ%ая его от предыдущих запятая.
% ий его от предыдущих
и~соответствующий разделитель (только в~одном  случае "--- когда отсутствует база, но есть индекс "--- разделяющая их запятая сохраняется, чтобы отличать эту ситуацию от базы без индекса).

Таким образом, прямая адресация в~принципе может рассматриваться как частный случай косвенной,
когда  оба регистра и~масштабный коэффициент опущены вместе со скобками, и~адрес равен смещению $Displacement$.

}

Например, следующая команда использует все четыре параметра и~загружает 
% в~$a$ значение  $*\big(bp - 4 + (d \cdot 4)\big)$
в~$A$ значение  $*\big(bp+ D \cdot 4 - 4 \big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dest! загружает в~приёмник $dest$ значение источника $src$, \lstinline!l! "--- суффикс размера).
\begin{lstlisting}
movl  -4(%ebp, %edx, 4), %eax	// eax = *(ebp + 4edx - 4)
\end{lstlisting} 
% [caption={Расчёт $A = *(bp+ 4D - 4) $}]
Чаще используются сокращённые варианты адресации, когда указывается только часть параметров~\cite{Bartlett-Programming-from-the-Ground-Up,Assembler-fsf}.

\subsubsection{Базовая косвенная адресация со смещением}

Если используется только параметр~$Base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает %значение $*C$ 
четырёхбайтовое значение по адресу~$C$
в~регистр $D$.
\begin{lstlisting}
movl  (%ecx), %edx	// edx = *ecx
\end{lstlisting} 

С~параметрами~$Base$ и~$Displacement$ получим $*\big(Base + Displacement\big)$, что соответствует обращению к~полю структуры ($Base$ "--- адрес структуры, константа~$Displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса $bp - 4$)
в~регистр $A$.
\begin{lstlisting}
movl  -4(%ebp), %eax	// eax = *(ebp - 4)
\end{lstlisting} 
При передаче параметров функции через стек\index{Стек} обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека~$sp$.
% 
На вершине стека, то есть по адресу $*sp =$\lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

 
\subsubsection{Базово-индексная косвенная адресация}

При использовании всех параметров, кроме $Displacement$, получим $*\big(Base + \sigma \cdot {Index}\big)$, что соответствует обращению к~элементу массива.
Действительно, адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
он может быть масштабным коэффициентом ($\sigma$)
и~к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(Base + Index \cdot \sigma\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! %обычно 
равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~$C$, а~индекс "--- в~$si$, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Соответственно, запись~$M[i]$ в~регистр~$A$ будет выглядеть следующим образом:
\begin{lstlisting}
movl (%ecx, %esi, 4), %eax  // eax = *(ecx + 4esi) = C[si]
\end{lstlisting} 

Если размер элемента равен одному байту, адрес можно записать ещё компактнее:
\begin{lstlisting}
movl (%ecx, %esi), %eax  // eax = *(ecx + esi)
\end{lstlisting}

На платформах, отличных от x86 и~x86-64, могут использоваться другие методы адресации и,~соответственно, немного другие обозначения для них.


% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 


\subsection{Размер операндов команды}
% \epigraphcensored[
\epigraph{\begin{stanza}[0mm]Еду я на своём камазике...\\А~из-за поворота навстречу мне жигулище!\end{stanza}}
{Фольклор}
% ]{
% \epigraph{\begin{stanza}
%     Из вредности на красный свет не ходит!
% \end{stanza}}
% {О.\,Арефьева}
% }
\label{sec:att-suffixes}

Большая часть мнемоник соответствует не одной команде уровня архитектуры команд, а~целому семейству однотипных команд, которые выполняют одни и~те же действия над операндами
\modifytwo[различного расположения или]{}
различных размеров и, соответственно, имеют разные коды.

Размер операндов маркируется суффиксом,
добавляемым к~базовой форме мнемоники;
например,
копирование  (базовая форма команды "--- \lstinline$mov$) из~$edx$ в~$eax$ (размер операндов $long$) записывается как
\lstinline!movl %edx, %eax!.
Суффиксы перечислены в~таблице~\ref{tab:asm-suffixes}.

\begin{table}[!ht]
\caption{Суффиксы размера операндов}
\label{tab:asm-suffixes}

\noindent\begin{tabularx}{\linewidth}{|c|C|C|}
\hline
\thead{Суффикс} & 
% \thead{Целые} 
\begin{tabular}{@{}c@{}}
\theadfont{Целый}\\
\theadfont{операнд (бит)}
\end{tabular}
& 
% \thead{Вещественные} 
\begin{tabular}{@{}c@{}}
\theadfont{Вещественный}\\
\theadfont{операнд (бит)}
\end{tabular}
\\\hline
    b & byte (8) &\\\hline
    s & short (16) & single (32) \\\hline
    w & word (16) &\\\hline
    l & long (32) & double (64) \\\hline
    q & quad (64) &\\\hline
    t & & ten bytes (80) \\\hline
%     o & octuple (128 бит)&\\\hline
\end{tabularx}
\end{table}
Необходимо отметить, что для целочисленных команд и~команд обработки вещественных чисел одни  и~те же суффиксы означают различную разрядность.
Некоторые суффиксы допустимы только для одного семейства команд.
Для целочисленных команд суффиксы~\lstinline!s! и~\lstinline!w! обозначают 16-битное целое и~в~целом  равноправны
(для команды \lstinline!mov! используется только~\lstinline!w!, так как существует другая команда с~базовой формой \lstinline!movs!).
\index{Команды!mov}%

У~команд с~операндами разных размеров указывается два суффикса.
Порядок суффиксов, как и~порядок операндов "--- слева направо (от источника к~приёмнику).
Так, копирование целого числа со знаковым расширением (базовая форма команды "--- \lstinline$movs$) из~$al$ в~$edx$ выглядит как
\lstinline!movsbl %al, %edx!.
\index{Команды!movs}%
% \index{Команды!movz}%
% в синтаксисе AT&T означает "расширить знак от %al к %edx". Таким образом возможны суффиксы `bl' (от byte к long), `bw' (от byte к word) и `wl' (от word к long). 
% http://www.opennet.ru/docs/RUS/gas/gas-8.html
Возможны двойные суффиксы \lstinline'bl' (от $byte$ к~$long$), \lstinline'bw' (от $byte$ к~$word$) и~\lstinline'wl' (от $word$ к~$long$) и~так далее.
Суффикс~\lstinline!s! не используется как компонент составного суффикса (таблица~\ref{tab:asm-2suffixes}).


\begin{table}[!ht]
\caption{Двойные суффиксы размера для копирования целых чисел с~расширением}
\label{tab:asm-2suffixes}

\begin{tabularx}{\linewidth}{|c|ClC|}
\hline
\thead{Суффикс} & 
% \multicolumn{3}{|c|}{\theadlong{Расширение (бит)}} 
\thead{Источник (бит)} && \thead{Приёмник (бит)}
\\\hline
    bw & byte (8)  & $\to$ & word/short (16)	\\\hline
    bl & byte (8)  & $\to$ & long (32)	\\\hline
    bq & byte (8)  & $\to$ & quad (64)	\\\hline
    wl & word/short (16) & $\to$ & long (32)	\\\hline
    wq & word/short (16) & $\to$ & quad (64)	\\\hline
    lq & long (32) & $\to$ & quad (64)	\\\hline
\end{tabularx}
\end{table}


% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  %размер может быть определён по регистровому операнду.
GAS определяет размер по  регистровому операнду.
% Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
Такое поведение несовместимо с~оригинальным ассемблером AT\&T Unix, который предполагает, что отсутствие суффикса означает размер операнда $long$.
Эта несовместимость не влияет на компиляцию с~ЯВУ, так как компиляторы всегда выставляют суффиксы размера~\cite{Assembler-fsf}.

Если размер не удалось определить по операндам (то есть используются либо непосредственные операнды, либо расположенные в~памяти),
по умолчанию \modifyone[для основного набора команд]{} принимается размер $long$ (32 бита).
% Отсутствие суффикса чаще всего не вызывает ошибки компиляции,
Такая ситуация не всегда вызывает ошибку компиляции,
но 
\modifytwo[в~некоторых случаях приводит к~странному результату.

% Особенно внимательным надо быть при обработке командами FPU операндов, находящихся в~памяти,
% так как при отсутствии суффикса размера 
% для целых  операндов FPU используется размер $short$ (16~бит),
% а~для вещественных "--- одинарная точность ($float$, 32~бита).
При отсутствии суффикса размера у~команды FPU 
для целых  операндов, находящихся в~памяти,  используется размер $short$ (16~бит),
а~для вещественных "--- одинарная точность ($float$, 32~бита),
так что при работе с~FPU надо быть особенно внимательным к~суффиксам.
]
{при обработке чисел с~плавающей запятой, находящихся в~памяти, приводит к~странному результату, так как по умолчанию используется операнд одинарной точности.}


\subsection{Мнемоники}
% \epigraphcensored[
\epigraph{
\begin{stanza}
Научный вестник,\\
пожалуйста, не пугайтесь!\\
Полный перечень\\
так называемых ругательств!
\end{stanza}
}{\Vvm[Клоп]}
% ]
% {\epigraph{\begin{stanza}
%     Нет, я людей практически не ем...
% \end{stanza}}
% {О.\,Арефьева}}
\label{sec:att-mnemonic}

Первоначальные мнемонические обозначений команд процессора предлагаются
% предложена 
его разработчиками в~документации, описывающей набор команд.
В~дальнейшем ассемблеры в~основном используют именно их.
Большая часть мнемоник GAS (их базовые формы) также совпадает с~документацией Intel.

Тем не менее, часть обозначений различается.
В~частности, отличаются базовые формы команд копирования со знаковым расширением ($movs$ в~GAS, $movsx$ в~Intel)
и~копирования с~беззнаковым расширением  ($movz$ в~GAS, $movzx$ в~Intel)\modifyone[; подробнее они описаны в~разделе~\ref{sec:asm-conversion-mov}]{}.
\index{Команды!movs}%
\index{Команды!movz}%
\index{Команды!расширения}%
\index{Команды!удвоения разрядности $A$}%
\modifyone[Впрочем, для данных команд некоторые шестидесятичетырёхбитные версии GAS используют обозначения Intel; для этих версий мнемоники $movs$ и~$movz$ некорректны.]{}

% Кроме того, 
Синтаксис AT\&T предлагает для команд знакового расширения (их неявным аргументом всегда является регистр~$A$\modifyone[; подробнее в~разделе~\ref{sec:asm-conversion-A}]{}) обозначения, построенные по схеме $cStD$ (convert $S$ to $D$), 
где $S$ "--- суффикс размера источника, $D$ "---  суффикс размера или обозначение расположения (в~случае расширения в~пару регистров) приёмника.
В~документации Intel приведены другие обозначения: они построены по схеме $cSD$ или $cSDe$ и~используют другие обозначения размера\modifyone{ (раздел~\ref{sec:asm-conversion-A})}.
% https://sourceware.org/binutils/docs/as/i386_002dMnemonics.html
% The Intel-syntax conversion instructions
% 
%  ‘cbtw’   ‘cbw’ — sign-extend byte in ‘%al’ to word in ‘%ax’,
%  ‘cwtl’   ‘cwde’ — sign-extend word in ‘%ax’ to long in ‘%eax’,
%  ‘cwtd’   ‘cwd’ — sign-extend word in ‘%ax’ to long in ‘%dx:%ax’,
%  ‘cltd’   ‘cdq’ — sign-extend dword in ‘%eax’ to quad in ‘%edx:%eax’,
%  ‘cltq’   ‘cdqe’ — sign-extend dword in ‘%eax’ to quad in ‘%rax’ (x86-64 only),
%  ‘cqto’   ‘cqo’ — sign-extend quad in ‘%rax’ to octuple in ‘%rdx:%rax’ (x86-64 only), 
% 
% are called ‘cbtw’, ‘cwtl’, ‘cwtd’, ‘cltd’, ‘cltq’, and ‘cqto’ in AT&T naming. as accepts either naming for these instructions. 
% GAS поддерживает как вариант AT\&T, так и~вариант Intel.
\index{Команды!cbw/cbtw}%
\index{Команды!cwde/cwtl}%
\index{Команды!cwd/cwtd}%
\index{Команды!cdqe/cltq}%
\index{Команды!cqo/cqto}%
При программировании в~GAS с~использованием синтаксиса  AT\&T можно без ограничений использовать для команд расширения регистра~$A$
как вариант AT\&T, так и~вариант Intel.

Опкоды дальнего перехода (с~указанием сегмента и~абсолютного адреса) в~AT\&T соответствуют мнемоникам  \lstinline!lcall!\modifyone[/\lstinline!lret!]{} (long call\modifyone[/long return]{}) и~\lstinline!ljmp! (long jump), 
в~то время как Intel обозначает их как \lstinline!call far!\modifyone[/\lstinline!retf!]{} и~\lstinline!jump far!.
\modifyone[Для этих команд GAS также поддерживает оба варианта.]{}

Для несимметричных арифметических команд обработки чисел с~плавающей точкой (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
GAS использует те же мнемоники, что и~Intel, но при этом реализует качественно иное поведение %(подробнее в~разделе).
(раздел~\ref{sec:fpu-trouble-with-fsub}).
\index{Команды!fsub[p]}%
\index{Команды!fsubr[p]}%
\index{Команды!fdiv[p]}%
\index{Команды!fdivr[p]}%

В~шестидесятичетырёхбитном режиме команда загрузки шестидесятичетырёхбитного непосредственного значения в~регистр обозначается \lstinline!movabs! в~синтаксисе AT\&T (загрузка абсолютного адреса).
\index{Команды!movabs}%
Синтаксис Intel не выделяет единственную команду с~шестидесятичетырёхбитным непосредственным операндом из семейства команд пересылки и~обозначает её как \lstinline!mov!.

\subsection{Префиксы}
\epigraph{
Не будь цветов, все ходили бы в~одноцветных одеяниях!
}{\PrutkovAN}
% \epigraphcensored[
% \epigraph{
% \begin{stanza}[0mm]
% И в тот же самый миг безмерность\\
% Мне в грудь плеснула, как волна,\\
% И понял я, что достоверность\\
% Теперь навек обретена.\\
% \end{stanza}
% }{\Gumilyov[Евангелическая~церковь]}
% ]
% {\epigraph{\begin{stanza}
% %     Чудесны рифмы в Ваших одностишьях…
%         Инструкция к ёлке: «товар несъедобен».
% \end{stanza}}
% {О.\,Арефьева}
% }

Как уже было сказано, регистры и~непосредственные операнды обозначаются специальными префиксами.
Для ассемблера x86 имена {регистров} начинаются с~\lstinline!%!,
% (\lstinline!%eax!, \lstinline!%dl!);
% 
а~непосредственные значения (константы) отмечаются префиксом \lstinline!$!.
% , например,
% \lstinline!addl $5, %eax!
% (добавить константу 5 к~регистру $A$).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных. Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Префикс непосредственного операнда~\lstinline!$! указывается перед префиксом системы счисления (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!).

На платформах, отличных от x86 и~x86-64, могут использоваться другие префиксы для указания метода адресации операнда.
% В~частности, 

% Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

% \index{Адресация!непосредственная}%
% \index{Адресация!прямая}%
% Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
% \lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
% команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

% \paragraph{Вычисление адреса}
% 
% Вычисление адреса с~одновременным разыменованием
% $$
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% $$
% в~соответствии с~синтаксисом~AT\&T имеет вид
% {
% \lstset{language=}
% % There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
% \begin{lstlisting}
% displacement(base, offset, scalar multiplier)
% \end{lstlisting} 
% 
% где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% % в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% % где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% 
% В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% % \lstinline![base + displacement + offset * scalar multiplier]!.
% \begin{lstlisting}
% [base + displacement + offset * scalar multiplier]
% \end{lstlisting} 



% \subsection{Сравнение синтаксиса AT\&T и~Intel}
% \epigraph{\begin{stanza}
%     Ой, не тому угрозы ты отправил!
% \end{stanza}}
% {О.\,Арефьева}
% 
% % Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% % % 
% % % Синтаксис AT&T немного 
% % отличается от синтаксиса Intel, который используется, например, MASM. 
% % %
% % Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.
% 
% \cite{linux_parallel,}
% 
% % Рассмотрим 
% Сравним 
% \termin{AT\&T}
% 
% \begin{lstlisting}[numbers=none]
% movl $42, %eax
% 
% movl $0x10, %ebx
% 
% 
% lea  -0x30(%rcx,%rax,8), %eax
% movl (%ebx), %eax
% 
% movl $0xCCCCCCCC, %ecx
% 
% 
% movl 0xCCCCCCCC, %ecx
% \end{lstlisting}
% 
% 
% % -4(%ebp), Intel:  [ebp - 4]
% {} \termin{Intel}
% 
% \begin{lstlisting}[numbers=none]
% mov eax, 42
% 
% mov ebx, 10h
% mov ebx, 0x10 ; masm
% 
% lea eax, [rcx+rax*8-0x30]
% mov eax, dword ptr [ebx]
% 
% mov ecx, 0xCCCCCCCC   
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; masm}@*/
% mov ecx, ds:[0xCCCCCCCC]
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; nasm}@*/
% \end{lstlisting}

% \subsection{О}



\section{Основные команды}
\epigraph{
ЭТО не работает на восьмиразрядных машинах.
}{\ProgFolk}
\label{sec:asm-commands}



Основной набор команд x86 включает команды обработки целых чисел и~разнообразные команды управления вычислениями.
Полный список команд приведён в~первом томе руководства разработчика программного обеспечения для архитектур Intel 64 (так архитектура x86-64 называется в~документации Intel) и~IA-32~\cite{intelBasic}, а~подробное описание "--- во втором~\cite{intelInstructionSet}.
Также набор инструкций описан в~третьем томе руководства разработчика AMD~\cite{amd64Instructions}.

Структура команды такова, что
если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что %$src$ и~$dest$ 
операнды могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.

Если не указано иное, используются следующие обозначения.
Операнд, принимающий значение (приёмник) 
может быть обозначен либо как~$dest$, если он может быть регистром или переменной в~памяти,
либо как~$dreg$ или $dmem$, если он может быть соответственно только регистром или только в~памяти.
% обозначается как~$dest$, неизменяемый операнд (источник) может быть обозначен как $src$, $arg$ или иным образом.
% $src$ "--- регистр, переменная в~памяти или непосредственное значение, $dest$ и~$arg$ "--- регистры или переменные в~памяти,
% $imm$ "--- непосредственно адресуемая константа, $mem$ "--- переменная в~памяти, $reg$ "--- регистр.
Неизменяемый операнд (источник) может быть обозначен как $src$ (регистр, переменная в~памяти или непосредственное значение),
$srm$ (регистр или переменная в~памяти), $sreg$ (регистр), $smem$ (переменная в~памяти).
% Неизменя
Непосредственно адресуемая константа обозначается как $imm$.

Для большинства команд
источник и~приёмник должны быть одного размера.
Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
% При необходимости в~обозначении операнда указывается конкретная разрядность (\texttt{reg8, reg16, reg32, reg64} и~т.\,п.).

Наиболее часто используемые команды доступны как в~тридцатидвухбитном, так и~в~шестидесятичетырёхбитном режимах (\lstinline!mov!, \lstinline!lea! и~т.\,д.);\index{Команды!mov}
\index{Команды!lea}
некоторые "--- только в~шестидесятичетырёхбитном (в~частности, \lstinline!movabs!).\index{Команды!movabs}
Некоторые команды тридцатидвухбитного режима недоступны в~шестидесятичетырёхбитном, но для аналогичных операций введены новые (\lstinline!syscall! вместо \lstinline!sysenter!).\index{Команды!sysenter}\index{Команды!syscall}


Есть и~такие команды, 
которые доступны в~тридцатидвухбитном режиме, но 
полностью исключены из~шестидесятичетырёхбитного\index{Шестидесятичетырёхбитный режим}.
В~частности, это команды коррекции  двоично-десятичной арифметики,\index{Арифметика!двоично-десятичная}
% ~\lstinline!daa! и~\lstinline!das!, 
проверка выхода за границы \lstinline!bound!, условный вызов прерывания \lstinline!into! и~другие~\cite{rsdn_bcd_64}.%
% В~данном пособии эти команды не описываются во избежание путаницы.
\index{Команды!bound}%
\index{Команды!into}%

% Также многие команды не упом
В~данном пособии описывается только малая  часть доступных команд x86.
В~частности, во избежание путаницы в~описание не вошли команды, полностью исключённые из шестидесятичетырёхбитного режима.


\subsection{Общие команды}
\label{sec:asm-commandsintro}
% \epigraphcensored[
\epigraph{
\begin{stanza}
Дело земли "---\\ вертеться.\\
Литься "---\\
дело вод.
\end{stanza}
}{\Vvm[Молодая гвардия]}
% ]
% {\epigraph{
% \begin{stanza}[0mm]
% I like to move it, move it,\\
% She like to move it, move it,\\
% We like to move it, move it,\\
% We like to move it!\\
% \end{stanza}
% }{Reel 2 Real}}

\index{Команды!nop}%
\index{Команды!mov}%
\index{Команды!lea}%
\index{Команды!push}%
\index{Команды!pop}%
% \index{Команды!call}%
% \index{Команды!ret}%

В~таблице~\ref{tab:asm-common-list} приведены некоторые наиболее употребительные команды x86-совместимых процессоров.%
\index{Команды!пересылки}%

\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-common.tex}

\end{table}

Наверное, самой популярной командой является команда пересылки %(move)
% \lstinline!mov источник, приёмник! 
% "--- присваивание \lstinline!приёмник = источник!
\lstinline!mov src, dest! "--- аналог оператора присваивания $dest = src$ языков высокого уровня.
Рассмотрим некоторые примеры её работы:
\begin{lstlisting}[numbers=none]
movl $4, %eax	// eax = 4
movb $42, %al	// al = 42
movl %eax, (%esi)	// *esi = eax
movl %eax, 4(%esi)	// *(esi+4 байта) = eax
movl $some_var, %eax	// eax = &some_var
movl $some_var+4, %eax	// eax = &some_var+4 байта
movl some_var, %eax	// eax = some_var
movl %eax, foo	// foo = eax
\end{lstlisting}

% \index{Команды!lea}%
Аналогом оператора получения адреса (оператор $\&$ в~C++) является команда \lstinline!lea!.
Если \lstinline!mov smem, dreg! загружает в~регистр~$dreg$ значение по адресу~$smem$, 
то  \lstinline!lea smem, dreg! загружает в~$dreg$ сам адрес~$smem$.

Например, следующая команда 
% использует все четыре параметра косвенной адресации и~
загружает в~$A$ значение  
$*\big(bp + 4D  - 4\big)$,
используя косвенную адресацию "--- вычисление адреса из четырёх компонент с~разыменованием:
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
% (команда \lstinline!mov src, dest! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}[numbers=none]
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда %\lstinline!lea src, dest! 
\lstinline!lea! 
загружает в~приёмник адрес источника, что компенсирует разыменование, то есть команда
\begin{lstlisting}[numbers=none]
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~$A$ значение  
$bp + 4D  - 4$.

Адрес статической переменной в~тридцатидвухбитном режиме (то есть при использованими прямой абсолютной адресации)\index{Адресация!прямая} может быть загружен в~регистр двумя способами "--- копированием адреса как тридцатидвухбитной константы или с~помощью вычисления адреса:
\begin{lstlisting}[numbers=none]
movl $msg, %esi	// si = &msg
leal  msg, %esi	// si = &msg
\end{lstlisting}
Непосредственным  операндом первой команды и~смещением без базы во второй будет абсолютный тридцатидвухбитный  адрес метки  \lstinline!msg!.
\index{Команды!mov}%
\index{Команды!lea}%

В~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} предпочтительной является прямая относительная ($rip$-relative) адресация.
В~этом случае загрузка должна осуществляться командой \lstinline!lea!:
\begin{lstlisting}[numbers=none]
lea msg(%rip), %rsi	// si = ip + (&msg - ip) = &msg
\end{lstlisting}
% Хотя метка \lstinline!msg:! в~обоих случаях выглядит одинаково
Смещением в~соответствующей команде будет не абсолютный шестидесятичетырёхбитный адрес метки  \lstinline!msg!, а~вычисленная ассемблером тридцатидвухбитная знаковая разность адреса \lstinline!msg! и~адреса следующей команды $ip$.

Использование в~данной команде вместо $rip$ любого другого регистра приведёт к~тому, что в~поле смещения будет записана не разность шестидесятичетырёхбитного адреса метки \texttt{msg} и~значения базового регистра, а~собственно адрес \texttt{msg}~\cite{how-to-use-rip-relative-addressing-in-a-64-bit-assembly-program}, причём усечённый до 32 бит:
\begin{lstlisting}[numbers=none]
lea msg(%rsp), %rsi	// si = sp + &msg
\end{lstlisting}
Таким образом, прямая относительная адресация\index{Адресация!прямая относительная} не является частным случаем косвенной\index{Адресация!косвенная}, хотя для их описания используется одна синтаксическая конструкция; эти виды адресации необходимо различать.

Если по какой-то причине требуется загрузить именно абсолютный шестидесятичетырёхбитный адрес как константу, это можно сделать командой \texttt{movabs:}\index{Команды!movabs}
\begin{lstlisting}[numbers=none]
movabs $msg, %rsi	// si = &msg
\end{lstlisting}
Команда \texttt{mov} в~шестидесятичетырёхбитном режиме может содержать не более чем тридцатидвухбитный непосредственный операнд.

Команда вычисления адреса~\lstinline!lea! также часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем %команда беззнакового умножения~\lstinline!mul!:
команды умножения~\lstinline!mul/imul!:
\begin{lstlisting}[numbers=none]
leal    8(,%eax,4), %eax    // A = A*4 + 8   
leal    (%eax,%eax,2), %eax // A = A*2 + A = A*3
\end{lstlisting} 
В~отличие от «настоящих» арифметических команд, \lstinline!lea! не изменяет флагов.

\subsubsection{Работа со стеком}
\index{Команды!push}%
\index{Команды!pop}%
\index{Стек}

Для работы со стеком предназначены в~основном команды \lstinline!push! и ~\lstinline!pop!.
Они работают только с операндами размером 4 или 2 байта, то есть указатель вершины стека всегда выравнен на 2 байта (его начальное значение делается двоично-круглым).
В~GNU/Linux стек по соглашению выравнен по $long$ (на 4~байта).


% \lstinline!push источник! \\
Команда \lstinline!push src! помещает источник в~стек.
При этом указатель стека~$sp$ уменьшается на размер источника.

Таким образом, если попытаться смоделировать работу команды \lstinline!push! при помощи команды пересылки, 
то, в~частности
% \lstinline!pushl %eax! эквивалентна
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(eax)
% movl %eax, (%esp)// *esp = %eax
% \end{lstlisting}
% Здесь суффиксы 
\lstinline!pushl $13! (здесь суффикс~$l = long$ необходим, так как разрядность операнда невозможно определить без явного указания) 
эквивалентна последовательному уменьшению~$sp$ и~записи значения в~память:
\index{Команды!sub}%
\begin{lstlisting}[numbers=none]
sub  $4, %esp	 // esp -= sizeof(long)
movl $13, (%esp) // *esp = 13
\end{lstlisting}
% \begin{lstlisting}[numbers=none]
% pushl foo
% \end{lstlisting}
% \lstinline!pushl foo! эквивалентно
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(int)
% movl foo, %eax	// eax= foo
% movl %eax, (%esp)// *esp = eax
% \end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки неэффективна, так как она и~выполняется медленнее, чем~\lstinline!push!, и~занимает больше места в~памяти.
Тем не менее, %часто встречается задача 
иногда необходимо зарезервировать в~стеке место для локальных переменных, начальное значение которых пока неизвестно.
В~этом случае можно воспользоваться командой~\lstinline!sub $size, %esp!.



Команда~\lstinline!pop dest!
"--- извлечение значения из стека и~помещение его в~приёмник~$dest$ "---
увеличивает указатель стека~$sp$  на размер приёмника.

\index{Команды!add}%
Таким образом, \lstinline!popl %eax! можно также выполнить с~помощью команд
\begin{lstlisting}
movl (%esp), %eax // eax = *esp
add  $4, %esp     // esp += sizeof(int)
\end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки здесь так же менее эффективна, чем~\lstinline!pop!.
При этом отдельная команда~\lstinline!add $size, %esp! для удаления элемента или набора элементов из стека «в~никуда»
используется очень часто.
Она быстрее, чем однократный вызов~\lstinline!pop!, так как не обращается к~памяти; короче множественного вызова~\lstinline!pop!,
а~также не требует указания приёмника.
%множественного 
% \lstinline!popl foo! эквивалентно
% \begin{lstlisting}
% movl (%esp), %eax // eax = *esp
% movl %eax, foo	// foo = eax
% addl $4, %esp	// esp += sizeof(int)
% \end{lstlisting}



% \subsection{Вызов и~возврат}
\subsection{Передача управления, вызов и~возврат}
% \epigraph{\begin{stanza}[0mm]
% Я пришёл сюда из-за дальних гор,\\
% Ибо ныне я знаю, что делать с собой.\\
% В шесть сторон кроплю, обхожу костёр,\\
% Подношу к губам горьких трав настой.\\
% \end{stanza}}{\Orgia}
% \epigraphcensored[
\epigraphA{\begin{stanza}[0mm]
Он один остался в живых. 
Он вошёл сквозь контуры двери.\\
Он поднялся на башню. Он вышел в окно.\\
И он сделал три шага "---
и упал не на землю, а в небо. \\
Она взяла его на руки, потому что они были одно. \\
\end{stanza}
}{\Bg[\mbox{На её стороне}]}
{
Строчка есть ходьба или пляска входящего в~одни двери и~выходящего в~другие.
}
{\Khlebnikov[Песни 13 вёсен]}
% Зэ - отражение луча от зеркала. - Угол падения равен углу отражения (зрение). 
% ]{
% \epigraph{\begin{stanza}[0mm]
% Deine Schritte kennt sie,
% Deinen sch\"{o}nen Gang,\\
% Alle Abend brennt sie,
% Doch mich verga{\fontfamily{cmr}\selectfont\ss} sie lang\\
% \hspace{\stanzaoddindent}Und sollte mir ein Leid gescheh'n\\
% \hspace{\stanzaoddindent}Wer wird bei der Laterne stehen\\
% \hspace{\stanzaoddindent}Mit dir Lili Marleen?\\
% \end{stanza}
% }{H. Leip}
% }
\index{Команды!передачи управления}%
Команды передачи управления (таблица~\ref{tab:jcall-command-list}) делятся на две основные группы.
Некоторые из них просто замещают указатель команд новым адресом, то есть передают управление новому фрагменту кода аналогично оператору \lstinline!goto! языка C++. %; таким образом, выполнение продолжается с~н 
Другие перед передачей управления запоминают адрес следующей по счёту команды, так что затем можно вернуться к~выполнению последовательности команд.
Такие команды соответствуют вызовам разного рода подпрограмм (в~том числе функций, прерываний, системных вызовов); каждой из них соответствует своя команда возврата, которая должна находиться в~конце соответствующей подпрограммы.
\index{Системные вызовы}%


\begin{table}[!ht]
\caption{Команды передачи управления, вызова и~возврата}
\label{tab:jcall-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
jmp src	&	{Безусловный переход  по адресу $src$ ($goto~src$)}
\\\hline
jCC src	&	Условный переход по адресу $src$ (если верно условие $src$)
\\\hline
\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из функций}}\\\hline
call src
 & Вызов подпрограммы "--- помещает в~стек адрес следующей инструкции (адрес возврата) и~переходит по адресу $src$
\\\hline
ret [imm] & Возврат из подпрограммы "--- снимает со стека адрес возврата и~помещает его в~указатель команд.

Если указан параметр $imm$, снимает со стека ещё $imm$ байтов.
\\\hline
\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из программного прерывания}}\\\hline
int imm8 & Вызов прерывания с~номером~$imm8$ "--- помещает в~стек флаги $flags$, затем адрес возврата, после чего переходит к~обработчику прерывания $imm8$
\\\hline
iret  & Возврат из прерывания "---  снимает со стека адрес возврата и~флаги, возвращает к~прерванной программе
\\\hline

\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из системного вызова (32 бита)}}\\\hline
sysenter & Быстрый системный вызов
\\\hline
sysexit  & Возврат из  системного вызова
\\\hline

\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из системного вызова (64 бита)}}\\\hline
syscall & Быстрый системный вызов
\\\hline
sysret  &  Возврат из  системного вызова
\\\hline
% \multicolumn{2}{|c|}{\textbf{Длинные (межсегментные) передача управления, вызов и~возврат}}\\\hline
% ljmp smem
%  & Безусловный переход
% \\\hline
% lcall smem
%  & Вызов подпрограммы
% \\\hline
% lret [imm] & Возврат из подпрограммы
% \\\hline
\end{tabularx}
\index{Команды!jmp}%
\index{Команды!jCC}%
\index{Команды!call}%
\index{Команды!ret}%
\index{Команды!int}%
\index{Команды!iret}%
\index{Команды!sysenter}%
\index{Команды!sysexit}%
\index{Команды!syscall}%
\index{Команды!sysret}%
\end{table}

\subsubsection{Простая передача управления}
\index{Команды!jmp}%
\index{Команды!jCC}%

К~командам «безвозвратной» передачи управления относятся команда безусловного перехода \lstinline$jmp src$ и~семейство команд условного перехода  \lstinline$jCC src$.
Команды условного перехода отличаются только тем, что передача управления осуществляется только при наличии некоторой комбинации флагов $CC$ в~регистре~$flags$.

Операнд команд передачи управления $src$ может быть непосредственным значением (обычно меткой $label$), регистром или памятью.
В~первом случае неявно используется прямая относительная адресация\index{Адресация!прямая относительная}, так что в~соответствующий машинный код включается не абсолютный адрес $label$, а~смещение относительно текущего указателя команд $label - ip$. Это позволяет получить переносимый код.

Если операнд команды перехода находится в~регистре или памяти% (обозначим его $srm$)
, то это "--- абсолютный адрес перехода.
Использование такой адресации позволяет выбирать адрес перехода во время выполнения программы.

\subsubsection{Вызов и~возврат}
\index{Подпрограммы}%

Команды вызова 
% сохраняют адрес той команды, которая следует за ней (адрес возврата),
% некоторые из них также сохраняют и~другие данные
используются для передачи управления {подпрограмме} "--- последовательности команд, завершающихся командой возврата.
Команды вызова и~возврата всегда бывают парными.

Любая команда вызова сохраняет в~определённом месте адрес той команды, которая следует за ней (адрес возврата),
некоторые из них также сохраняют и~другие данные (флаги, указатель стека и~т.\,д).
Парная к~ней команда возврата восстанавливает сохранённые элементы и~помещает  в~указатель команд адрес возврата.
Таким образом, после выполнения подпрограммы управление перейдёт обратно к~вызвавшей её программе и~продолжится именно с~той команды, которая следует за командой вызова.

Для вызова подпрограммы любого вида (функции или системного вызова) допустимо использовать только ту команду, которая является парной к~завершающей эту подпрограмму команде возврата. В~противном случае %управление перейдёт не 
% возврат невозможен
% при попытке возврата 
произойдёт крах.


Команды 
% \lstinline!call/ret! 
вызова и~возврата
не осуществляют передачу в~подпрограмму параметров и~возврат значения.
Эти действия выполняются вручную и~регламентируются соглашениями о~вызовах\modifyone[\strut{}
(подробнее механизм вызова рассматривается в~разделе~\ref{sec:calling-functions})]{}.

В~систему команд x86 входят три пары команд вызова/возврата.
\begin{enumerate}
\item Команды 
\lstinline!call/ret! предназначены для вызова функций и~процедур, описанных в~самой программе и~прикладных библиотеках.
\index{Команды!call}%
\index{Команды!ret}%

\item Команды 
\lstinline!int/iret! предназначены для программного обращения к~прерыванию.
\index{Команды!int}%
\index{Команды!iret}%

В~современной прикладной программе явный вызов программного прерывания обычно используется только для обращения к~ядру операционной системы (системного вызова\modifyone[, подробнее в~разделе~\ref{sec:sys-call}]{}).

\item Команды, предназначенные специально для системных вызовов.
\index{Команды!sysenter}%
\index{Команды!sysexit}%
\index{Команды!syscall}%
\index{Команды!sysret}%

В~тридцатидвухбитном режиме это \lstinline!sysenter/sysexit!, в~шестидесятичетырёхбитном\index{Шестидесятичетырёхбитный режим} "--- \lstinline!syscall/sysret!.

\end{enumerate}

\paragraph{Вызов и~возврат из функций}
\index{Команды!call}%
\index{Команды!ret}%
Вызов функции в~ассемблере выполняется командой \lstinline!call!.
Эта команда имеет один операнд "--- адрес подпрограммы в~памяти.

Команда \lstinline!call foo! сохраняет указатель команд в~стеке,\index{Стек}
управление передаётся $foo$.
% 
Возврат из подпрограммы выполняется командой 
\lstinline!ret!, которая должна находиться в~конце кода подпрограммы.
"--- управление передаётся адресу, снятому со~стека.

В~листинге~\ref{lst:gas:call-foo-ret} показана подпрограмма $foo()$, прибавляющая к~значению регистра $eax$ константу~$5$, а~также её вызов.

\begin{lstlisting}[caption={Функция и~её вызов}, label=lst:gas:call-foo-ret]
// Вызывающая программа
  movl $10, %eax
  call foo
  // теперь %eax == 15
...
// Функция foo()
foo:
  addl $5, %eax
  ret
 \end{lstlisting}

Так же, как и~для команд перехода \lstinline$jmp/jCC$, если операндом команды \lstinline!call! является метка $label$, неявно используется прямая относительная адресация\index{Адресация!прямая относительная} (в~машинный код включается смещение относительно текущего указателя команд $label - ip$),
а~если операнд в~регистре или памяти "--- это абсолютный адрес перехода, задаваемый соответственно регистровой или косвенной адресацией\index{Адресация!регистровая}\index{Адресация!косвенная}.

Вызов подпрограммы по указателю 
% в~регистре или памяти
применяется, в~частности, для реализации механизма виртуальных функций, адрес которых выбирается из таблицы виртуальных методов на этапе выполнения программы.

% При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
% На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше $sp$, то есть первый параметр равен \lstinline!4(%esp)!.
% % \begin{lstlisting}[numbers=none]
% % 4(%esp)   // *(ESP+4)
% % \end{lstlisting} 
% Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее.

\paragraph{Вызов и~возврат из прерывания}
\index{Команды!int}%
\index{Команды!iret}%

Для вызова прерывания необходимо указать его восьмибитный номер~$imm8$ (то есть номера прерываний могут принимать значения от $0$ до $255$).
Каждому номеру прерывания соответствует специальный системный регистр, содержащий адрес обработчика этого прерывания.

Команда вызова прерывания \lstinline!int imm8! помещает в~стек сначала регистр флагов $flags$, затем адрес возврата.
Если обработчик выполняется с~привилегиями ядра операционной системы, в~специальном регистре сохраняется также указатель стека, так как система использует другой стек.
После этого управление передаётся обработчику прерывания $imm8$.

Команда возврата из прерывания \lstinline!iret! восстанавливает указатель стека (при необходимости), флаги и~передаёт управление по адресу возврата (из стека при этом извлекаются оба помещённых туда командой~\lstinline!int! машинных слова).


Необходимо отметить, что в~документации AMD команда вызова программного прерывания \lstinline!int! относится к~командам общего назначения, а~соответствующая команда возврата~\lstinline!iret! "--- к~системным~\cite{amd64Instructions}.

Один из номеров прерываний в~тридцатидвухбитных операционных системах обычно используется для системных вызовов.


\paragraph{Вызов и~возврат из системных вызовов}
\index{Команды!sysenter}%
\index{Команды!sysexit}%

Начиная с~Pentium II, доступна предложенная Intel команда \lstinline!sysenter!, %/sysexit (Intel)
ускоряющая обращение к~ядру.
\index{Команды!sysenter}%
% 
Адрес возврата и~другие сохраняемые данные помещаются командой \lstinline!sysenter! в~специальные регистры, что быстрее обращения к~памяти.
В~конце обработчика системного вызова их восстанавливает команда \lstinline!sysexit!.

В~шестидесятичетырёхбитном режиме  использование команды \lstinline!sysenter! невозможно.


Для быстрого обращения к~функциям ядра  в~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} применяется команда \lstinline!syscall!, %/sysret 
% (AMD, 64-битный режим Intel);
предложенная AMD.
\index{Команды!syscall}%
Она также сохраняет данные для возврата в~регистрах.
\index{Команды!syscall}%
Для возврата из системного вызова в~шестидесятичетырёхбитном режиме предназначена команда~\lstinline!sysret!.
\index{Команды!sysret}%

Отметим, что команда возврата из системного вызова (\lstinline!sysexit! или \lstinline!sysret!) используется только в~обработчике этого вызова, то есть в~коде ядра операционной системы.

\subsection{Обнуление регистра}
% \epigraph{\begin{limerick}
%     Жил один господин из Ливорно,\\
%     Он вкушал только крошки и зёрна,\\
%     Их клюя по привычке,\\
%     Как прочие птички\\
%     На лужках и аллеях Ливорно.\\
% \end{limerick}
% }
% {\Lear}
% \epigraph{\begin{stanza}
% Но он побрил лицо лифтом,\\
% Он вышел в январь;\\
% Он сосал бирюзу и ел кусками янтарь.
% \end{stanza}}
% {\Bg[Нога судьбы]}
% \epigraph{\begin{stanza}[0mm]
% Но ветер развеял всё. 
% \end{stanza}
% }{\Khlebnikov[Зангези]}

\epigraph{
"--* Начало? "--- лицо Эдуарда приобрело обиженное выражение. "--- То есть к нулю? Но это же вырожденный случай!
}{\ZhvalevskijMytko[Сестрички и~другие чудовища]}

\index{Команды!обнуления регистра}%

% https://habrahabr.ru/post/183462/
% • XOR REG,REG
% • SUB REG,REG
% • PXOR/VPXOR XMMREG,XMMREG
% • PSUBB/W/D/Q XMMREG,XMMREG
% • VPSUBB/W/D/Q XMMREG,XMMREG
% • XORPS/PD XMMREG,XMMREG
% • VXORPS/PD YMMREG, YMMREG
% Более подробно – в Intel® 64 and IA-32 Architectures Optimization Reference Manual, страница 43. 
Исторически для обнуления регистров использовались команды побитового исключающего «или» с~одинаковыми операндами~\lstinline!xor %reg, %reg! и~вычитания регистра из самого себя~\lstinline!sub %reg, %reg!,
так как они выполнялись быстрее команды пересылки \lstinline!mov $0, %reg!, а~также занимали меньше места.
Зависимость по данным в~ранних моделях процессора не имела значения, так как вычисления не были конвейеризированы.

После введения конвейера традиция обнуления регистров командами \lstinline!xor! и~\lstinline!sub! сохранилась.
Поэтому в~современных моделях процессоров команды обнуления регистров (zero idioms) распознаются при декодировании 
и~выполняются как не имеющие зависимостей по данным.

% Начиная с~Pentiun~4, 
Таким образом, сейчас руководство по оптимизации Intel~\cite{intelOptimization} снова рекомендует использовать для обнуления регистров общего назначения команды:
\begin{lstlisting}
xor %reg, %reg
sub %reg, %reg
\end{lstlisting}
Для регистров расширения XMM распознаются следующие команды обнуления:
\begin{lstlisting}
xorps/pd  %xmmreg,  %xmmreg
pxor  %xmmreg,  %xmmreg
subps/pd  %xmmreg,  %xmmreg
psubb/w/d/q  %xmmreg,  %xmmreg
\end{lstlisting}
Для некоторых архитектур используются и~другие  команды обнуления регистров расширения X/Y/ZMM~\cite{intelOptimization}.

При этом команды \lstinline!xor! и~\lstinline!sub!, не распознающиеся как zero idioms, выполняются медленнее из-за зависимости по данным
(даже если результатом будет ноль).

% GENERAL OPTIMIZATION GUIDELINES
% 3-26
% 3.5.1.8  
% Clearing Registers and Dependency Breaking Idioms
% Code sequences that modifies partial register can ex
% perience some delay in its dependency chain, but 
% can be avoided by using dependency breaking idioms.
% In processors based on Intel Core microarchitecture, a number of instructions can help clear execution 
% dependency when software uses these instruction to clear register content to zero. The instructions 
% include:
% XOR REG, REG
% SUB REG, REG
% XORPS/PD XMMREG, XMMREG
% PXOR XMMREG, XMMREG
% SUBPS/PD XMMREG, XMMREG
% PSUBB/W/D/Q XMMREG, XMMREG
% In processors based on Intel microarchitecture code name Sandy Bridge, the instruction listed above plus 
% equivalent AVX counter parts are also zero idioms that can be used to break dependency chains. Further-
% more, they do not consume an issue port or an execut
% ion unit. So using zero id
% ioms are preferable than 
% moving 0’s into the register. The AVX equivalent zero idioms are:
% VXORPS/PD XMMREG, XMMREG
% VXORPS/PD YMMREG, YMMREG
% VPXOR XMMREG, XMMREG
% VSUBPS/PD XMMREG, XMMREG
% VSUBPS/PD YMMREG, YMMREG
% VPSUBB/W/D/Q XMMREG, XMMREG
% In Intel Core Solo and Intel Core Duo processors, the XO


\subsection{Команды целочисленной арифметики
% Основные арифметические команды
}
\index{Команды!арифметические}%
% \epigraph{\begin{stanza}
% Те, кто рисует нас, рисуют красным на сером.\\
% Цвета как цвета, но я говорю о другом,\\
% Если бы я умел это, я нарисовал бы тебя\\
% Там, где зелёные деревья и золото на голубом. \\
% \end{stanza}
% }{\Bg[Золото на~голубом]}
% \epigraph{\begin{stanza}[0mm]
% А, шагает Азбука!
% \end{stanza}
% }{\Khlebnikov[Зангези]}
\epigraph{
\begin{stanza}[0mm]
В одном потоке чехарды\\
Игра числа и чисел сроки. 
\end{stanza}
}{\Khlebnikov[Зангези]}

Из-за ограниченного количества операндов в~системе команд x86 практически нет привычных по языкам высокого уровня неразрушающих арифметических операторов.
% Вместо них используются
Один из операндов, как правило, используется и~как исходное данное, и~как ячейка для записи результата.
\index{Команды!add}%
В~частности, аналогом ассемблерной команды сложения \lstinline!add src, dest! в~C++ будет не оператор «плюс», не изменяющий свои операнды ($dest = src_1 + src_2$), а~оператор «${+}{=}$» ($dest~ {+}{=} ~src$, то есть $dest = dest+src$).

Некоторые команды, предназначенные для обработки целых чисел, перечислены в~таблице~\ref{tab:ar-command-list}.
% Некоторые команды целочисленной арифметики перечислены в~таблице~\ref{tab:ar-command-list}.


\begin{table}[p]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar.tex}

\endgroup

\index{Команды!inc}%
\index{Команды!dec}%
\index{Команды!add}%
\index{Команды!adc}%
\index{Команды!sub}%
\index{Команды!cmp}%
\index{Команды!sbb}%
\index{Команды!neg}%

\index{Команды!mul}%
\index{Команды!imul}%
\index{Команды!div}%
\index{Команды!idiv}%

\index{Битовые сдвиги}%
\index{Команды!shl}%
\index{Команды!sal}%
\index{Команды!shr}%
\index{Команды!sar}%
\end{table}


\subsubsection{Команды сложения и~вычитания}

К~этой группе, кроме собственно сложения и~вычитания, относятся также команды инкремента, декремента и~изменения знака.

\index{Арифметика!знаковая}%
\index{Арифметика!беззнаковая}%
Как было сказано в~разделе~\ref{sec:digits-negcodes}, представление отрицательных чисел выбиралось так, чтобы 
знаковые  числа можно было складывать и~вычитать с~помощью беззнакового сумматора.
Соответственно, операции сложения и~вычитания не делятся на знаковые и~беззнаковые.
% Каждая из них выставляет как флаг знак
Команды из группы сложения и вычитания выставляют значения  
% флагов $OF, SF, ZF, AF, PF, CF,$ 
всех шести флагов состояния
соответственно результату,
так что программист, понимая, какого рода числа он обрабатывает, может выбрать для анализа нужные флаги.
% \begin{description}
% \item[CF] беззнаковое переполнение  (перенос из~старшего разряда)
% \item[ZF] результат равен нулю
% \item[SF] старший (знаковый) бит результата
% \item[OF] знаковое переполнение (перенос в~старший разряд, но не из него или наоборот)
% \end{description}

% Источник и~приёмник должны быть одного размера.
% Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
% Более длинные числа 
Числа, разрядность которых превышает разрядность системы,
при необходимости можно складывать и~вычитать по частям.
Для этого вначале младшие части обрабатываются командами \lstinline!add/sub!, затем~к~остальным в~порядке возрастания адресов "---  \lstinline!adc/sbb!, учитывающие перенос из младшей части.
Части могут иметь любую разрядность (в~частности, шестибайтовые целые можно разбить на две части "---  четыре и~два байта или на шесть однобайтовых), но логичнее использовать четырёхбайтовые части на тридцатидвухбитной системе и~восьмибайтовые "--- на шестидесятичетырёхбитной.

\subsubsection{Вычисление линейной комбинации регистров}
\index{Команды!lea}%

Также для арифметических вычислений используется команда \lstinline!lea!, которая, в~соответствии с~возможностями косвенной адресации,
может рассчитать выражение~$r1 + \sigma\cdot r2 + \delta$ (может быть опущен любой из регистров и~любая из констант).
Команда \lstinline!lea! предназначена для манипуляций с~беззнаковыми данными (указателями),
но %в~том самом распространённом случае, когда 
смещение $\delta$ интерпретируется как знаковое.
Так как
разрядность $r1$ и~$r2$ совпадает с~разрядностью $dreg$, результат совпадает со знаковым.

В~отличие от «настоящих» арифметических команд, 
\lstinline!lea! не изменяет флагов.

\subsubsection{Команды умножения и~деления}
\index{Команды!mul}%
\index{Команды!imul}%
\index{Команды!div}%
\index{Команды!idiv}%

Самые старые команды умножения рассчитывают произведение заданного множителя~$srm$ на неявный операнд "--- регистр $A$ той же разрядности, что и~$srm$.
Разрядность произведения при этом вдвое больше разрядности множителей, так что младшая  половина $A\cdot srm$ помещается в~регистр~$A$ на место неявного множителя,
а~старшая "--- в~регистр~$D$ той же разрядности.
Исключением является случай с~восьмибитными множителями "--- так как на момент появления команд умножения уже существовали шестнадцатибитные регистры,
результат $al\cdot srm$ размещается в~$ax$ (таблица~\ref{tab:ar-command-muldiv}).
Старшая половина результата отличается для знаковой и~беззнаковой интерпретации множителей, так что существуют две команды описанного действия "--- \lstinline!mul! для беззнакового умножения и~\lstinline!imul! для знакового.
\index{Арифметика!знаковая}%
\index{Арифметика!беззнаковая}%
% Если старшую половину можно отбросить,
% % (она равна $0$ для \lstinline!mul! и~состоит только из копий знака для~\lstinline!imul!)
% сбрасываются оба флага~$CF$ и~$OF$,
% если в~старшей половине есть значащие биты, $CF$ и~$OF$ оба взводятся.
\begin{table}[!ht]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar-muldiv.tex}

\endgroup
\end{table}

Введённая позже команда \lstinline!imul srm, dreg! рассчитывает только младшую половину произведения, а~она совпадает для знаковых и~беззнаковых чисел.
Таким образом, 
% \lstinline!imul srm, dreg! "--- умножение
двухоперандную форму команды~\lstinline!imul! можно использовать и~для знакового, и~для беззнакового умножения.

Трёхоперандная форма \lstinline!imul imm, srm, dreg! также рассчитывает только младшую половину произведения,
но перед этим константа \lstinline!imm! при необходимости расширяется.
Данная форма
соответствует двум опкодам "--- с~константой \lstinline!imm!, разрядность которой соответствует разрядности источника и~приёмника
(в~этом случае расширение не требуется)
и~с~восьмибитной константой \lstinline!imm8!~\cite{intelInstructionSet}.
Во втором случае случае \lstinline!imm8! расширяется как знаковое, поэтому трёхоперандную форму~\lstinline!imul! следует считать командой знакового умножения.

% Как двух-, так и~трёхоперандная форма 
Если произведение помещается в~младшей половине произведения, 
все формы команд \lstinline!mul/imul!
сбрасывают оба флага~$CF$ и~$OF$.
Если в~старшей половине есть значащие биты (для двух- и~трёхоперандной форм~\lstinline!imul! это значит, что результат некорректен),
оба этих флага взводятся~\cite{asmworld}.
Значения флагов нуля и~знака не определены~\cite{club155}.

Для %обратной операции "--- 
деления существуют только однооперандная форма.
Делимое (неявный операнд) всегда вдвое больше делителя (явного операнда~$srm$)
и~располагается в~паре регистров $D:A$ (старшая половина "--- в~$D$, младшая "--- в~$A$), кроме случая восьмибитного делителя  (таблица~\ref{tab:ar-command-muldiv}).
Необходимо помнить об этом и~корректно инициализировать регистр~$D$ перед делением.

Таким образом, команды  деления обратны однооперандной форме умножения.
Соответственно, деление также будет беззнаковым (\lstinline!div!) и~знаковым (\lstinline!idiv!).


После деления $D:A$ на $srm$ частное помещается на место младшей половины делимого (в~$A$), остаток "--- на место старшей половины (в~$D$).
Если старшая половина делимого содержит значащие биты, возможна ситуация, когда частное не помещается  в~отведённом для него регистре.
Соответственно, результат деления будет некорректным.


Умножение и~деление на $2^{times}$ ($times$ трактуется как беззнаковое число) может также быть выполнено с~помощью битовых сдвигов (раздел~\ref{sec:asm-bitwise}).
\index{Битовые сдвиги}%
\index{Арифметика!знаковая}%
\index{Арифметика!беззнаковая}%

\subsubsection{Расширение целых чисел}

\index{Расширение целых чисел}%
\index{Команды!movs}%
\index{Команды!movz}%
\index{Команды!расширения}%
\index{Команды!удвоения разрядности $A$}%

Также к~командам целочисленной арифметики можно отнести команды расширения (таблица~\ref{tab:ext-command-list}).


\begin{table}[!ht]
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ext.tex}

\endgroup
\end{table}

Современная система команд x86 включает два вида команд, которые используются для расширения "--- пересылка из источника малой разрядности в~приёмник большей
и~удвоение разрядности неявного операнда~в~регистре~$A$.

Существует две команды пересылки с~расширением "--- \lstinline!movz! для беззнакового расширения (дополнения нулями)
и~\lstinline!movs! для знакового  (дополнения знаковым битом).
\label{sec:asm-conversion-mov}

% Приёмник $dreg$ может быть  только регистром, источник $srm$ может быть регистром или переменной в~памяти, размер $srm$ меньше~$dreg$.


При пересылке возможно увеличение разрядности более чем в~два раза, поэтому, если %хотя бы один операнд
источник находится в~памяти, для команды обязательно нужно указывать два суффикса (раздел~\ref{sec:att-suffixes}).

Также существует набор команд для удвоения разрядности неявного операнда в~регистре~$A$
(таблица~\ref{tab:asm-conversion}).
\label{sec:asm-conversion-A}

\begin{table}[!ht]
\caption{Мнемоники команд знакового расширения~$A$}
\label{tab:asm-conversion}
\small

\noindent\begin{tabularx}{\linewidth}{|c|cCC|cCC|}
\hline
\multirow{2}{*}{\thead{Размер}}	& \multicolumn{3}{c|}{Расширение в~регистр~$A$}	&	\multicolumn{3}{c|}{Расширение в~пару~$D:A$}	\\
\cline{2-7}
% \thead{Размер} & \thead{Действие} & \thead{Intel} & \thead{GAS} & \thead{Действие} &\thead{Intel} & \thead{GAS} \\\hline
		& \thead{Действие} & \thead{Intel} & \thead{AT\&T} & \thead{Действие} &\thead{Intel} & \thead{AT\&T} \\\hline
$8\to16$	&	$al\to ax$	& cbw 	& cbtw	&	\multicolumn{3}{c|}{---}	\\\hline
$16\to32$	&	$ax\to eax$	& cwde 	& cwtl	&	$ax\to dx:ax$		& cwd 	& cwtd	\\\hline
$32\to64$	&	$eax\to rax$	& cdqe 	& cltq	&	$eax\to edx:eax$	& cdq 	& cltd	\\\hline
$64\to128$	&	\multicolumn{3}{c|}{---}	&	$rax\to rdx:rax$	& cqo 	& cqto	\\\hline
\end{tabularx}
\index{Команды!cbw/cbtw}%
\index{Команды!cwde/cwtl}%
\index{Команды!cwd/cwtd}%
\index{Команды!cdqe/cltq}%
\index{Команды!cqo/cqto}%
\end{table}

Практически для всех случаев есть две команды "--- расширение %младшей части 
$A$ до $A$ вдвое большей разрядности 
и~расширение~$A$ до пары $D:A$.
Последний вариант необходимо  использовать перед командами, использующими пару регистров~$D:A$ как источник, в~частности, командами деления $(D:A)/srm$.

Для команд удвоения разрядности регистра~$A$ есть два набора мнемоник "--- исторически используемые в~ассемблере Unix \modifyone[(AT\&T)]{} и~предложенные Intel.

Мнемоники  AT\&T для команд удвоения разрядности регистра~$A$ строятся по  схеме $cStD$ (convert $S$ to $D$),
где~$S$ "--- размер источника, $D$ "--- размер приёмника или символ~$d$ для пары регистров (кроме \lstinline!cqto!).

Мнемоники Intel построены по одной из двух схем "--- $cSD$  или $cSDe$. 
Исторически на шестнадцатибитных машинах первыми доступными вариантами удвоения были $al \to ax$ и~$ax \to dx:ax$,  так что они получили имена без суффикса~$e$.
В~дальнейшем суффикс $e$ использовался для расширения $A \to A$, а~расширение $A \to D:A$ выполняется командой без суффикса.

Для команд удвоения разрядности $A$ GAS поддерживает оба набора мнемоник \modifyone["--- AT\&T и~Intel "---]{}  перечисленные в~таблице~\ref{tab:asm-conversion}.


Увеличить разрядность неявного операнда~$A$ более чем в~два раза с~помощью команд таблицы~\ref{tab:asm-conversion} можно только последовательным применением нескольких команд удвоения.

Все команды удвоения разрядности~$A$ выполняют знаковое расширение.
% 
Беззнаковое расширение $A \to D:A$ может быть выполнено явным обнулением регистра~$D$.
% В~случае расширения $A \to A$ можно обнулить $$

% Все команды расширения имеют различные мнемоники для синтаксиса AT\&T и~синтаксиса~Intel (раздел~\ref{sec:att-mnemonic}).

% Команды пересылки с~расширением в~синтаксисе Intel имеют дополнительный суффикс~\lstinline!x!.
% В~GAS 

% Мнемоники Intel "--- по схеме $cSD$ или $cSDe$.


% \FloatBarrier

\bottompagebreak[5\baselineskip]
\subsection{Битовые операции}
\epigraphA{\begin{stanza}[0mm]
Она может двигать,\\
Она может двигать собой,\\
В полный рост "---\\
Она знает толк в полный рост
\end{stanza}
}{\Bg[Она может двигать]}
{
 Все изменения тел происходят посредством движения.
}
{\Lomonosov[Элементы математической химии]}
% \epigraph{\begin{stanza}[0mm]
% \emph{Дэ} "--- удаление части от целого,\\ уход части от~целого к~другому целому (дар, даль).
% \end{stanza}}{\Khlebnikov[Царапина по~небу]}


\label{sec:asm-bitwise}
\index{Поразрядные операции}%
\index{Команды!not}%
\index{Команды!and}%
\index{Команды!or}%
\index{Команды!xor}%
\index{Команды!test}%

\index{Битовые сдвиги}%
\index{Команды!shl}%
\index{Команды!sal}%
\index{Команды!shr}%
\index{Команды!sar}%

\index{Команды!rol}%
\index{Команды!ror}%
\index{Команды!rcl}%
\index{Команды!rcr}%

\index{Команды!bt}%
\index{Команды!btc}%
\index{Команды!bts}%
\index{Команды!btr}%

Некоторые команды, предназначенные для обработки битовых строк, перечислены в~таблице~\ref{tab:bit-command-list}.

\begin{table}[p]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-bit.tex}

\end{table}

Система команд x86 включает поразрядные логические операции, все описанные в~разделе~\ref{sec:bitwise} битовые сдвиги, а~также команды выделения бита по номеру.

Поразрядные логические операции «и», «или», «не» и~«исключающее или» изменяют в~соответствии с~полученным результатом три флага состояния "--- флаги нуля, знака и~чётности.

Команды битового сдвига принимают два операнда: сдвигаемое значение $dest$ и~беззнаковое количество сдвигов~$times$.
Количество~$times$ может быть непосредственным значением или регистром~$cl$, причём даже в~шестидесятичетырёхбитных системах используются только младшие~шесть его бит (в~тридцатидвухбитных "--- пять).
\pagebreak[3]

При $times=1$ происходит сдвиг в~указанную сторону на один бит.
% При этом с~одного конца $dest$ освобождается ячейка, а
% один бит выходит за г
\index{Флаги!CF (переноса)}%
Значение бита, вышедшего за разрядную сетку, после выполнения команды заносится в~$CF$.
Освободившаяся с~другого конца $dest$ ячейка инициализируется в~соответствии с~видом сдвига.

При $times > 1$ однобитовый сдвиг повторяется $times$ раз.

Знаковый и~беззнаковый сдвиги используется для быстрого умножения и~деления на степени двойки.
% 
Сдвиги вправо эквивалентны соответственно знаковому (в~этом случае остаток предполагается неотрицательным как для положительных, так и~для отрицательных делимых) или беззнаковому делению на $2^{times}$.
В~случае однобитового сдвига (деления на два) остаток попадает в~$CF$.
Для б\'{о}льших значений сдвига остаток не вычисляется.

Сдвиг влево эквивалентен умножению на $2^{times}$, если результат умножения помещается в~$dest$. Если не помещается, старшая часть произведения теряется.

Кроме того, с~помощью  команд семейства \lstinline!btX! можно выделить отдельный бит числа.
Эти команды принимают два операнда "--- число-приёмник, один бит которого будет скопирован в~флаг~$CF$ и~затем изменён,
и~номер бита $idx$ "--- непосредственное значение или регистр.
Для младшего бита $idx=0$.
% При выполнении команды \lstinline!btX! значение бита  с~указанным номером заносится в~флаг~$CF$, 
% после чего этому биту числа присваивается новое значение.
Одна из команд семейства, \lstinline!bt!, не изменяет значение битов в~числе, но для единообразия её  операнд, из которого выделяется бит, также считается приёмником.

% \FloatBarrier




\subsection{Флаги}
% \epigraphcensored[
\epigraph{
\begin{stanza}[0mm]
Грудью вперёд бравой!\\
Флагами небо оклеивай!
\end{stanza}
}{\Vvm[Левый марш]}
% ]
% {\epigraph{\begin{stanza}[0ex]
% I can talk with you,\\
% I can walk with you,\\
% \hspace{\stanzaoddindent}All throughout your life;\\
% Stay with you, smile on you,\\
% \hspace{\stanzaoddindent}Light in your fire.\\
% \end{stanza}}
% {\Aquarium}
% }
% \subsubsection{Установка, сохранение и~восстановление флагов}
% \subsubsection{Флаги}
\label{sec:asm-flags}
\index{Флаги!установка}%


Все арифметические команды устанавливают по результатам вычислений  флаги состояния.

% Команды группы сложения/вычитания устанавливают све шесть 
\index{Команды!арифметические}%
\index{Команды!inc}%
\index{Команды!dec}%
\index{Команды!add}%
% \index{Команды!adc}%
\index{Команды!sub}%
% \index{Команды!cmp}%
% \index{Команды!sbb}%
% \index{Команды!neg}%
\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!SF (знака)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!AF (коррекции)}%
Команды группы сложения/вычитания (\texttt{add/sub, inc/dec} и~т.\,д) выставляют все шесть флагов состояния $CF, PF, AF, ZF, SF, OF$ в~соответствии с~результатом:
\begin{itemize}
\item флаг нуля~$ZF$, если результат равен нулю;
\item флаг переноса (беззнакового переполнения)~$CF$ в~случае переноса/заёма за пределы разрядной сетки (беззнакового переполнения);
\item флаг знака~$SF$, если старший (знаковый) бит результата равен 1;
\item флаг знакового переполнения~$OF$, если произошло знаковое переполнение (перенос/заём из знакового бита, но не за пределы разрядной сетки, или наоборот);
\item флаг чётности $PF$, если количество единиц в~младшем байте результата чётно;
\item флаг вспомогательного переноса $AF$, если в~младшем байте был перенос между тетрадами.
\end{itemize}
При этом \lstinline!add $-1, dest! и~\lstinline!sub $1, dest! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит ($OF=0$); при вычитании единицы из нуля возникает заём из старшего бита  ($OF=1$).

\index{Команды!not}%
\index{Команды!and}%
\index{Команды!or}%
\index{Команды!xor}%
% \index{Команды!test}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!SF (знака)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!AF (коррекции)}%
Побитовые команды (\lstinline!and, or, xor!) выставляют флаги $SF, ZF$ и~$PF$ в~соответствии с~результатом аналогично группе сложения/вычитания,
флаги переноса и~знакового переполнения сбрасываются: $CF = OF = 0$.
Значение флага~$AF$ не определено.

\index{Команды!mul}%
\index{Команды!imul}%
\index{Флаги!CF (переноса)}%
\index{Флаги!OF (переполнения)}%
Команды умножения выставляют флаги $CF=OF$ в~зависимости от того, выходит ли результат за разрядность множителей.
Значение остальных флагов не определено.
После команд деления все шесть флагов имеют неопределённое значение.

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
\index{Команды!сравнения}%
Это:
\begin{itemize}
\item \lstinline!cmp!
\index{Команды!cmp}%
"--- то же самое, что и~\lstinline!sub! (группа сложения/вычитания), но операнд-приёмник не изменяется (используется для сравнения целых чисел);
\item \lstinline!test!
\index{Команды!test}%
"--- то же самое, что и~\lstinline!and! (группа побитовых операций), но операнд-приёмник не изменяется (используется для сравнения битовых строк).
\end{itemize}

Основной набор инструкций x86 не содержит команд для обработки и,~в~частности, сравнения вещественных чисел.
Предназначенные для этого инструкции сравнения относятся к~набору команд FPU (раздел~\ref{sec:fpu-cmp}), но могут взаимодействовать с~регистром~$flags$.
\index{Команды!fcom}%
Вещественные числа можно сравнить командой \lstinline!fcom! и~подобными ей.
% Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
% Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~$flags$ (вручную или автоматически "--- в~зависимости от используемой команды сравнения) таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел:
$ZF$ указывает на равенство, $CF$ "--- на $dest<src$; кроме того, в~$PF$ копируется флаг несравнимости операндов. 
% , так что для команды .
% флаг $ZF$ соответствует нулевой 


 
Кроме того,  флаги можно установить или сбросить вручную 
с~помощью специальных команд или загрузив изменённый регистр~$flags$
(таблица~\ref{tab:flags-command-list}).
\begin{table}[!ht]
\small
\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/instr-flags.tex}
\index{Команды!stc}%
\index{Команды!clc}%
\index{Команды!cmc}%
\index{Команды!std}%
\index{Команды!cld}%
\index{Команды!sti}%
\index{Команды!cli}%
\index{Команды!lahf}%
\index{Команды!sahf}%
\index{Команды!pushf/pushfd/pushfq}%
\index{Команды!popf/popfd/popfq}%
\end{table}


% Кроме того, 
Младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить для анализа в~регистр $ah$ командой~\lstinline!lahf! \ethm{(Load Flags into AH Register).} 
Обратная операция выполняется командой~\lstinline!sahf! \ethm{(Store AH into Flags).}
% 
Регистр $flags/eflags$ можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно.
% (таблица~\ref{tab:flags-command-list}).
При загрузке флагов из~$ah$ или стека зарезервированные биты не загружаются в~$flags$.




\subsection{Условные команды}
\label{sec:asm-cc}
% \epigraphcensored[
\epigraph{
\begin{stanza}
Жезлом\\
правит,\\
чтоб вправо\\
шёл.\\
Пойду\\направо.\\
Очень хорошо.
\end{stanza}
}{\Vvm[Хорошо!]}
% ]
% {\epigraph{\begin{stanza}
% Я~могу быть бессмысленным,\\
% Выбрать пути не те,\\
% Но есть смелая истина\\
% В~широте-долготе.\\
% \end{stanza}}
% {О.\,Арефьева}
% }
\index{Команды!jCC}%
\index{Команды!setCC}%
\index{Команды!cmovCC}%
\index{Команды!fcmovCC}%

% Как было указано в~разделе~\ref{sec:flags}, 
Существует несколько семейств команд, действие которых определяется значением флагов состояния в~регистре~$flags$.
Это команды условного перехода \lstinline!jCC!, 
условной установки байта \lstinline!setCC! и~условной пересылки~\lstinline!cmovCC! и~\lstinline!fcmovCC!.
% (таблица~\ref{tab:cc-command-list}).
% 
% % Команды условного ветвления %\lstinline!jCC, setCC, loopCC!,
% % \lstinline!jCC!, 
% % условной установки байта \lstinline!setCC! и~условной пересылки~\lstinline!cmovCC! используют один или несколько флагов состояния, проверяя различные условия (таблица~\ref{tab:cc-command-list}).
% 
% \begin{table}[!ht]
% \caption{Условные команды}
% \label{tab:cc-command-list}
% 
% \small
% \def\normalsize{\small}
% \begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
% \hline
% \normalfont\thead{Команда} & \thead{Действие} 
% \\\hline
% jCC label	&	Переход по адресу $label$, если %установлено сочетание флагов 
% верно условие $CC$ (таблица~\ref{tab:jmp-command-list}) 	\\\hline
% setCC dest	&	Установка байта $dest = 1$, если %установлено сочетание флагов 
% верно  $CC$, и~$dest=0$ иначе	
% % 
% % $dest$ может быть однобайтовым регистром или переменной в~памяти
% \\\hline
% cmovCC src, dest	&	Присваивание $dest = src$, если %установлено сочетание флагов $CC$	\\\hline
% верно  $CC$ \\\hline
% fcmovCC \%st(i), \%st(0) & %Условная пересылка регистров~FPU 
% Присваивание  регистров~FPU  $st(0) = st(i)$, если %установлено сочетание флагов $CC$	\\\hline
% верно  $CC$
% (таблица~\ref{tab:fpu-fst-list}) \\\hline
% \end{tabularx}
% \end{table}

% \FloatBarrier

Команда~\lstinline!fcmovCC! относится к~набору команд FPU и~описана также в~разделе~\ref{sec:fcmovCC} (таблица~\ref{tab:fpu-fst-list}), но условие~$CC$ определяется значением регистра~$flags$,
а~не собственного регистра состояния~FPU.
% Соответственно,~\lstinline!fcmovCC! рассматривается в~данном разделе 

Мнемоники таких команд состоят из двух частей "--- общего для всех команд семейства обозначения действия (\lstinline!j! от \ethm{jump,} \lstinline!set! и~т.\,п.)
и~обозначения условия~$CC$.
Условие не может быть произвольным.
Существует определённый набор обозначений~$CC$, каждому из которых соответствует некоторое состояние флагов в~регистре $flags$ "--- условие.


\subsubsection{Условия}
\index{Флаги!проверка}%


Рассмотрим доступные варианты условий, их обозначения и~связь с~арифметическими операциями (таблица~\ref{tab:cc-list}). 


\begin{table}[p]
\small
\def\normalsize{\small}
\renewcommand\theadfont{\bfseries\footnotesize}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\att}[1]{{\emph{\textcolor{clGas}{\hfill #1}}}}

\newcolumntype{E}{m{0.71\linewidth}}%
% \newcolumntype{E}{l}%

\singlespacing
\renewcommand{\arraystretch}{1.2}

\LTXtable{\textwidth}{book/tables/cc-list.tex}

\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!SF (знака)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!AF (коррекции)}%

\end{table}

Каждое из условий 
имеет некоторое буквенное обозначение~$CC$, приведённое в~первом столбце.
Одно и~то же условие может обозначаться по-разному, в~частности, «меньше или равно» "--- \lstinline!le! и~«не больше» "--- \lstinline!ng!,
но машинный код в~таких случаях одинаков.
Различные обозначения одного условия помещены в~одну ячейку таблицы и~разделяются косой чертой.

Мнемоники одного семейства с~разными условиями, в~частности, \lstinline!e! и~\lstinline!l!, ассемблируются в~разные машинные коды.


% соответствует некоторому 
Условие складывается из некоторой комбинации флагов состояния в~регистре $flags$,
указанной во втором столбце.
% 
Эти флаги определяются результатом последней  команды.
% Большинство из них выставляется только командами группы сложения/вычитания, в~частности, часто используемыми для реализации цикла командами \lstinline!inc/dec!.
% В~частности, 
% Команды группы сложения/вычитания (в~частности, часто используемыми для реализации цикла командами \lstinline!inc/dec!) выставляют все шесть флагов в~соответствии с~результатом.
% Команды умножения выставляют флаги $CF=OF$ в~зависимости от того, выходит ли результат за разрядность множителей.
% Побитовые команды выставляют флаги $SF, ZF$ и~$PF$ в~соответствии с~результатом.
% 
Различные виды арифметических команд  выставляют их в~соответствии с~полученным результатом.
\index{Команды!арифметические}%
\index{Команды!inc}%
\index{Команды!dec}%
% \index{Команды!add}%
% \index{Команды!adc}%
% \index{Команды!sub}%
% \index{Команды!cmp}%
% \index{Команды!sbb}%
% \index{Команды!neg}%
В~частности, команды группы сложения/вычитания (включая часто используемые для реализации цикла команды \lstinline!inc/dec!)
изменяют все шесть флагов состояния;
% \index{Команды!not}%
% \index{Команды!and}%
% \index{Команды!or}%
% \index{Команды!xor}%
% \index{Команды!test}%
побитовые команды "---  флаги $SF, ZF$ и~$PF$.
В~третьем столбце таблицы указаны свойства результата, приводящие к~подобному сочетанию флагов.


% \FloatBarrier

Часто перед условной командой вызывается команда сравнения \lstinline!cmp src, dest!, выставляющая флаги аналогично команде  \lstinline!sub src, dest! (то есть её результатом будет $dest-src$), но не изменяющая $dest$.
В~четвёртом столбце указаны соотношения между $dest$ и~$src$ для каждого условия.
Большинство обозначений условий образовано именно от них.


% Тем не менее
% \pagebreak[3]

Для беззнаковых операндов~$dest$ и~$src$ признаком отрицательности результата~$dest-src$ (то есть соотношения~$dest<src$)
будет заём в~старший бит при вычитании, то есть беззнаковое переполнение~$CF=1$.
Равенство операндов достигается при $dest-src=0$, что отмечается флагом нуля $ZF=1$.
Соответственно, $dest>src$ может быть, если $dest \not< src$ и~при этом $dest \neq src$, то есть $CF=ZF=0$.
Таким образом, любое соотношение между беззнаковыми операндами можно выразить через флаги~$CF$ и~$ZF$.

Чтобы отличить условия знакового и~беззнакового сравнения,
для беззнакового % сравнения
вместо термина «меньше» часто используется термин «ниже» \ethm{(below),} вместо «больше» "--- «выше» \ethm{(above).} 

Для знаковых %чисел отрицательность 
арифметических операций
знак результата невозможно определить только по знаковому биту (флагу $SF$), так как этот бит может быть искажён знаковым переполнением.
То есть если знак равен единице ($SF=1$), но в~процессе вычислений произошло знаковое переполнение ($OF=1$), то знаковый бит неверен и~результат на самом деле %неотрицателен
положителен.
Таким образом, результат будет отрицательным в~двух случаях: 
$\footnotesize
\left\{
\begin{array}{@{\,}l}
SF = 1\\
OF = 0
\end{array}
\right.
$ 
(знаковый бит "--- единица и~переполнения не было)
и~$\footnotesize
\left\{
\begin{array}{@{\,}l}
SF = 0\\
OF = 1
\end{array}
\right.
$
(было переполнение и~знаковый бит "--- ноль).
Обычно это условие записывается в~виде~$SF \neq OF$.
Соответственно, при~$SF=OF$ результат неотрицателен.

% Соответствующие обозначения 

% Кроме \lstinline!cmp!

% Флаг переноса~$CF$ используется многими командами «не по назначению»,
% поэтому, кроме обозначений \lstinline!b/nae! и nb/ae

% \FloatBarrier

% Условия для команд 
После сравнения вещественных чисел %и~выгрузки 
флаг вещественной несравнимости выгружается в~бит~$PF$ регистра~$flags$,
поэтому для команд условной пересылки вещественных чисел (и~только для них) условие $PF=1$ записывается как~\lstinline!u!.



\subsubsection{Условные и~безусловные переходы}
\index{Флаги!проверка}%
\index{Команды!jmp}%
\index{Команды!jCC}%

% \footnote{Использованы: 
% http://asmworld.ru/spravochnik-komand/jcond/,
% http://unixwiz.net/techtips/x86-jumps.html
% }

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода~\cite{asmworld}.

В~таблице~\ref{tab:jmp-command-list} приведены эти команды.
\index{Команды!передачи управления}%

\begin{table}[!ht]
\caption{Команды передачи управления}
\label{tab:jmp-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
jmp label	&	{Безусловный переход ($goto$)}
\\\hline
jCC label	&	Переход по адресу $label$, если верно условие $CC$ (%таблица~\ref{tab:cc-list}, 
кроме \texttt{u} и~\texttt{nu}) 	
\\\hline
\end{tabularx}
\end{table}


Безусловный переход \lstinline!jmp!
% \begin{lstlisting}
%   jmp label
% \end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу $label$.

Команды условного перехода~\lstinline!jCC!
% \begin{lstlisting}
%   jCC label
% \end{lstlisting}
передают адресу $label$ при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~регистре $flags$).
Если условие не выполнено,  \lstinline!jCC! не делает ничего,  и~выполняется команда, следующая за \lstinline!jCC! по тексту программы.

Условие~$CC$ может быть любым из перечисленных в~таблице~\ref{tab:cc-list}, кроме \texttt{u} и~\texttt{nu} (но могут использоваться \texttt{p/pe} и~\texttt{np/po}).
В~частности, команда \lstinline!jnae label! \ethm{(jump if not above or equal)} передаст управление на метку~$label$ в~случае~\mbox{$CF=1$.}
Если перед командой условного перехода выполнялась команда \lstinline!cmp src, dest!, управление будет передано на метку~$label$ в~случае, если~$dest \not\geqslant src$ как беззнаковые числа.

Это условие эквивалентно $dest < src$.
Действительно, команды \lstinline!jnae! и~\lstinline!jb! \ethm{(jump if below)} имеют один и~тот же опкод. Также этот опкод соответствует мнемонике~\lstinline!jc! \ethm{(jump if carry).}

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

% В~следующей таблице 
% В~таблице~\ref{tab:jmp-command-list}
% приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.

% \begingroup
% \small
% \def\normalsize{\small}
% \renewcommand\theadfont{\bfseries\footnotesize}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% % \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% % \newcolumntype{H}{>{\raggedright\arraybackslash}X}
% \providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
% \providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}
% 
% \newcolumntype{E}{m{0.7\linewidth}}%
% 
% \singlespacing
% 
% \LTXtable{\textwidth}{book/tables/jmp-list.tex}
% 
% \endgroup

\index{Команды!loop}%
\index{Команды!loopCC}%
\index{Команды!jcxz}%
\index{Команды!jecxz}%
Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop!, псевдоцикла с~анализом флага нуля \lstinline!loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если регистр $cx/ecx$ равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop label! эквивалентна  командам \lstinline!dec %ecx; jz label!, при этом \lstinline!loop! не меняет флаги $flags$. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только $cx/ecx$, но и~флаг нуля $ZF$ (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{@{\,}l}
cx\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{@{\,}l}
cx\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).

\index{Команды!dec}%
Эти команды были введены в~набор  8086 для получения более компактного кода (однобайтовая инструкция \lstinline!loop! заменяет связку двух однобайтовых \lstinline!dec+jz!) и~экономии дорогой памяти.
При этом пара инструкций \lstinline!dec+jz! выполняется быстрее \lstinline!loop!~\cite{agner_fog_optimizing_assembly,burdaev_kudiz_zzi}, легче читается и~позволяет организовывать вложенные циклы.
В~настоящее время оптимизация направлена на ускорение, соответственно,
использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать.

% Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода~\cite{agner_fog_optimizing_assembly}.
% % \footnote{Optimizing subroutines in assembly 
% % language.
% % An optimization guide for x86 platforms. 
% % By Agner Fog. Technical University of Denmark. }.

\subsubsection{Условная пересылка}
\index{Флаги!проверка}%
\index{Команды!условной пересылки}%
\index{Команды!jCC}%
\index{Команды!cmovCC}%
\index{Команды!mov}%
\index{Команды!movs}%
\index{Команды!movz}%
\index{Команды!fcmovCC}%

Для каждого условия~$CC$, кроме команды условного перехода \lstinline!jCC!,
% Для каждой команды условного перехода \lstinline!jCC! 
существует команда условной пересылки \lstinline!cmovCC src, dest!, выполняющая присваивание $dest = src$, если соответствующее условие верно.

В~таблице~\ref{tab:mov-command-list} показаны различные команды безусловной и~условной пересылки.

\begin{table}[!ht]
\caption{Команды пересылки данных}
\label{tab:mov-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
mov src, dest	&	Присваивание $dest = src$ %, $src$ "---  непосредственное значение, регистр или память одного размера с~$dest$
% $src \in \{imm, mem, reg\}, dest \in \{mem, reg\}$
\\\hline
\begin{tabular}{@{}l@{}}
movs srm, dreg\\movz srm, dreg
\end{tabular}	&	Присваивание $dreg = srm$ с~расширением %, $src$ "---  регистр или память 
% $src \in \{imm, mem, reg\}, dest \in \{mem, reg\}$
\\\hline
cmovCC srm, dreg	&	Присваивание $dreg = srm$, если верно  $CC$ (%таблица~\ref{tab:cc-list}, 
кроме \texttt{u} и~\texttt{nu}) \\\hline
fcmovCC \%st(i), \%st(0) & Присваивание  регистров~FPU  $st(0) = st(i)$, если верно  $CC$
 (\texttt{e, ne, b/nae, be/na, ae/nb, a/nbe,} \texttt{u} и~\texttt{nu})
\\\hline
setCC dest8	&	Присваивание $dest8 = \left\{\begin{array}{@{}ll}
1,& \text{если верно  $CC$ (кроме \texttt{u} и~\texttt{nu})}\\
0,& \text{иначе}
\end{array}\right.$ \\\hline
\end{tabularx}
\end{table}


Команды условной пересылки не полностью аналогичны \lstinline!mov!: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
Для флагов, которые могут быть установлены командами сравнения FPU ($ZF, CF, PF$) существует также команда условной пересылки в~стеке FPU из $st(i)$ в~$st(0)$
\lstinline!fcmovCC  %st(i), %st(0)! (раздел \ref{sec:fcmovCC}, таблица~\ref{tab:fpu-mov-list}).



\subsubsection{Установка байта по условию}
\index{Флаги!проверка}%
\index{Команды!установки байта}%
\index{Команды!setCC}%

Для каждого условия~$CC$
% Для каждой команды условного перехода jCC 
существует команда установки байта по условию \lstinline!setCC dest8!, выполняющая присваивание $dest8 = 1$, если соответствующее условие верно, и~$dest8 = 0$ иначе.

% \section{Установка флагов}

Приёмник $dest8$ может быть как регистром, так и~переменной в~памяти, но только однобайтовыми.







\modifytwo[
\section{Команды FPU}
]{
\section{Математический сопроцессор}
}
\label{sec:asm-fpu}
\index{FPU}
% \epigraphcensored[
% \epigraph{\begin{stanza}[0mm]
% Но что ж: бог длинноты в кольце нашел уют, \\
% И птицы вечности в кольце поют.\\
% \end{stanza}}
% {\Khlebnikov[В~руках забытое письмо~коснело...]}
% ]{
% \epigraph{
% "--*  Фапофадофажди, "--- сказала Алиса Пашке, пользуясь старым школьным кодом. "--- Фамыфаосфатафанемфася фаодфани.
% 
% "--*  Фапофанял, "--- ответил Пашка.
% 
% "--*  Фавлефасу, "--- сказала Алиса.
% }
% {Кир.\,Булычёв}}
\epigraph{\begin{stanza}[0mm]
Я "--- разомкнутый круг, обрету в этом браке смыкание круга.\\
Мой укрывшийся в глине двойник, я ищу твою руку!
\end{stanza}}{\Sk[Скульптор лепит автопортрет]}



% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX
% }  

Команды расширения FPU, или математического сопроцессора, предназначены для обработки числовых данных в~формате с~плавающей точкой.

% Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой.
% % 
% Первый математический сопроцессор для линейки x86 "--- FPU 8087 "--- был выпущен в~1980 году.
% Он представлял собой отдельную микросхему, устанавливаемую в~специальный сокет на системной плате.
% Взаимодействие с~основным процессором выполнялось в~основном через оперативную память.
% 
% % Использование сопроцессора 8087 ускоряло вычисления с плавающей точкой, но, так как сопроцессор мог отсутствовать, 
% Начиная с~процессора i486DX математический сопроцессор интегрирован в~процессор.
% При этом сопроцессор долгое время (вплоть до линейки микропроцессоров Atom) имел почти независимое ядро, так что обработка целых чисел CPU и~вещественных FPU могла выполняться параллельно.
% % С одной стороны, это позволяло
% Из-за этого в~систему команд была введена команда ожидания завершения работы сопроцессора, а~многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
% В~современных  процессорах FPU настолько плотно интегрирован с~ядром CPU, что их параллельная работа невозможна и~ожидание не требуется.


FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.

Регистры \modifyone[данных]{} FPU образуют стек с~плавающей вершиной.
Соответственно, система команд FPU идеологически отличается от основной системы команд.
% Хотя бы одним из операндов 
% Хотя бы один из операндов должен находиться в~стеке FPU; 
\modifyone[Один из операндов вычислений "--- всегда вершина стека FPU.]{}

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы.
Все мнемонические обозначения начинаются с~символа \lstinline!f! (FPU).
Вторая буква мнемонического обозначения
(если она не является частью имени действия, как в~\lstinline!finit!\index{Команды!finit})
% может определять % 
определяет
тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item \lstinline!i! "--- целое двоичное число со знаком;

\item \lstinline!b! "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы для арифметических команд обозначает вещественное число.
\end{itemize}

Последняя буква \lstinline!p! в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная \lstinline!pp! "---  из стека извлекаются оба операнда). 
Размер операнда в~памяти, если он используется, задаётся суффиксом команды в~соответствии с~правилами синтаксиса~\Att.

Команды FPU не могут иметь непосредственных операндов %или операндов-регистров основного процессора. 
и,~за исключением команды выгрузки слова состояния, не могут работать с~регистрами основного процессора. 
Если не указано иное, используются следующие обозначения.
Операнд-приёмник
может быть обозначен либо как~$dest$, если он может быть регистром сопроцессора или переменной в~памяти либо как $dmem$, если он может быть только в~памяти.
Операнд-источник может быть обозначен как $src$ (регистр сопроцессора или переменная в~памяти) или $smem$ (переменная в~памяти).




\subsection{Внутреннее представление чисел}
\index{Представление вещественных чисел!с~плавающей запятой}%
\index{Представление вещественных чисел!расширенной точности}%
% \epigraph{\begin{stanza}[0ex]
% Походка, стан кошачий,\\
% Драконий хвост наждачный,\\
% А крылья "--- из удачи впридачу.\\
% \end{stanza}}
% {О.\,Арефьева}
\epigraphA{\begin{stanza}
Мое сердце из масти,\\ 
Кровь "--- диэтиламид;\\
Не надо смотреть на меня, \\
Потому что иначе ты вымрешь, как вид.\\
\end{stanza}
}{\Bg[Таможенный блюз]}
{
Корпускулы, на которые в~конечном счёте действует тяготительная материя, суть шарики.
}
{\Lomonosov[О~тяжести тел]}
\index{Мантисса}\index{Порядок}


% О тяжести тел
% Корпускулы, на которые в конечном счете действует тяготительная материя, суть шарики.

% IEEE 754

% http://stackoverflow.com/questions/612507/what-are-the-applications-benefits-of-an-80-bit-extended-precision-data-type
Значения в~сопроцессоре представлены в %80-битном формате 
% (с~двойной расширенной точностью соответственно IEEE 754-1985~\cite{ieeeFloat1985rus}).
% Этот формат исключён из современной версии стандарта IEEE 754~\cite{ieeeFloat2008}, но из-за соображений совместимости формат данных FPU не изменился.
нестандартном 80-битном формате с~плавающей запятой,
называемом форматом с~двойной расширенной (или просто расширенной) точностью, описанном в~разделе~\ref{sec:digits:floatpoint}.

Нормализованное двоичное представление вещественного числа имеет вид~\cite{urov,av-assembler-asm-real-normalization}:
\begin{equation}
\label{eq:float-rus}
(-1)^s \cdot 2^p \cdot \mu, ~~ %0 \leqslant \mu < 1
0,1_2 \leqslant \mu < 1
\end{equation}
где
% $0,1_2 \leqslant \mu < 1$ нормализованное число,
% \\
% $0 \leqslant \mu < 0,1_2$ денормализованное число.
$p$ "--- порядок числа, $\mu$ "--- мантисса, $s$ определяет знак.
Таким образом, все значащие разряды мантиссы находятся в~дробной части.
Старший из них (следующий сразу после запятой) для нормализованного числа всегда равен единице.

Старший бит 80-битного формата "--- знак~$s$,
порядок занимает следующие 15 бит и~представляется кодом с~избытком $2^{14}-2$ %(см. раздел~\ref{sec:digits-negcodes}),
(так называемый смещённый порядок).
% % то есть соответствующее поле содержит натуральный двоичный код числа~$p + 2^{14}$,
% мантисса занимает 64 бита, % и~представляется натуральным кодом
% причём её представление  включает ведущую единицу (рис.~\ref{ris:fpu_digits}),
В~оставшиеся 64 бита записывается дробная часть мантиссы, включая ведущую единицу.

В~частности, единица в~нормализованном представлении имеет вид~$(-1)^0 \cdot 2^1\cdot 0,1_2$.
Тогда значение смещённого порядка (после добавления избытка) будет равно $2^{14}-1$:
$$
\begin{array}{rrrr}
1 = (-1)^0 \cdot 2^1\cdot 0,1_2 &\to &\regfloat[fill=none]{0}{2^{14}-1}{100...} &=\\
% = 0~~0\underbrace{11...11}_{14 \text{единиц}}%\,1111\,1111\,1111
% ~~\underbrace{100...}_{64 \text{бита}}
&=& \regfloat[fill=none]{0}{011...11}{100...} &\\
\end{array}
$$
% После 
Таким образом, %шестнадцатеричное представление вещественного числа 
вещественное число расширенной точности, равное единице, имеет вид
\lstinline$3FFF$\,\lstinline$8000$\,~\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$.
Это подтверждает исследование с~помощью отладчика.

Значение порядка, состоящее из пятнадцати нулей, зарезервировано под специальные значения, таким образом, 
минимально возможное значение порядка корректного вещественного числа имеет вид $00...001$ и~равно~$p_{min} = 1 + \left(-2^{14}+2\right) = -2^{14}+3$.
Соответственно, минимальное положительное  число, представимое в~нормализованном виде в~%80-битном формате FPU, 
формате расширенной точности,
равно 
$X_{min} = 2^{p_{min}} \cdot 0,1_2 = 2^{-2^{14}+2} = $ \lstinline$0001$\,\lstinline$8000...00$.
Числа в~диапазоне $(0, X_{min})$ представляются в~виде $2^{p_{min}} \cdot \mu, ~~ 0 < \mu < 0,1_2$ и~называются \termin{денормализованными}.
В~поле смещённого порядка таких чисел при этом записываются нули.
В~частности, $\frac{X_{min}}{2} = 2^{p_{min}} \cdot 0,01_2 = 2^{p_{min}-1} \cdot 0,1_2$, но представляется это число как \lstinline$0000$\,\lstinline$4000...00$, 
% хотя порядок 
в~чём можно убедиться при помощи отладчика.
Если попытаться прочесть такую запись как корректное число, то получим нулевой знаковый бит, нулевой смещённый порядок, что соответствует порядку $p_{min}-1$, 
и~мантиссу $0,0100..._2$, то есть $(-1)^0 \cdot 2^{p_{min}-1}\cdot 0,01_2 = \frac{X_{min}}{4}$, что неверно.
Денормализованные числа "--- один из видов \termin{специальных значений,} которые нельзя раскодировать по общему правилу.
% Если попытаться 

Представление отрицательных вещественных чисел, в~том числе из диапазона $(-X_{min}, 0)$ ,
отличается от представления их модулей только знаковым битом.


Как было сказано в~разделе~\ref{sec:digits:floatpoint},
в~некоторых источниках нормализованной формой мантиссы считается число, включающее один разряд целой части и~63 бита дробной~\cite{intelBasic}
или целое беззнаковое 64-битное число с~единицей в~старшем разряде~\cite{ieeeFloat1985rus}.\index{Мантисса}\index{Порядок}
% 
Обе этих трактовки приводят к~тому же самому двоичному представлению, что и~описанная выше.

% В~зарубежных источниках то же самое представление вещественных чисел в~FPU интерпретируется иначе~\cite{intelBasic} (хотя суть от этого не меняется).
% % 
% Там считается, что мантисса нормализованного числа включает целую часть (рис.~\ref{ris:fpu_digits-en}).
% \begin{illustration}
% \includegraphics[width=\linewidth]{X86_Extended_Floating_Point_Format_ru}
% \caption{Внутренний 80-битный формат сопроцессора в~зарубежной интерпретации}
% \label{ris:fpu_digits-en}
% \end{illustration}
% % \begin{equation}
% % \label{eq:float-en}
% % (-1)^s \cdot 2^{\tilde{p}} \cdot \widetilde{\mu},~~ 1 \leqslant \widetilde{\mu} < 10_2
% % \end{equation}
% % % тогда нормализованные числа соответствуют мантиссам $1 \leqslant \widetilde{\mu} < 10_2$,
% 
% Соответственно, в~зарубежной трактовке мантисса $\widetilde{\mu}$ числа 
% 
% Такое представление, как указано в~разделе~\ref{sec:digits:floatpoint}, не влияет на 
% двоичное представление
% % мантисса будет 
% % нормализованные числа
% % тогда денормализованные числа соответствуют мантиссам $0 \leqslant \widetilde{\mu} < 1$.

% Формы~\eqref{eq:float-rus} и~\eqref{eq:float-en} взаимно однозначно соответствуют друг другу:
% $$
% \left\{
% \begin{array}{lll}
% \tilde{p} &=& p - 1\\
% \widetilde{\mu} &=& 2\cdot \mu\\
% \end{array}
% \right.
% $$
% Так как двоичная запятая не может быть сохранена в~регистре~$r_i$, а~только \emph{подразумевается} на той или иной позиции,
% двоичное представление мантиссы в~формах~\eqref{eq:float-rus} и~\eqref{eq:float-en} \emph{полностью совпадает.}
% Порядок~$\tilde{p}$ формы~\eqref{eq:float-en}, %в~этом случае 
% соответственно,
% записывается с~избытком $2^{14} -1$, так что полученное значение смещённого порядка в~результате также совпадает с~формой~\eqref{eq:float-rus}.
% Таким образом, двоичное представление одинаковых чисел (как нормализуемых в~формате расширенной точности, так и~денормализованных) одинаково и~не зависит от формы нормализованного представления.

\subsubsection{Виды значений}
\label{sec:valueclasses}
\index{Мантисса}\index{Порядок}

Регистры сопроцессора могут содержать следующие значения:
\begin{itemize}
\item  вещественные числа "--- порядок не равен $0$ и~не состоит из всех единиц, %то есть не равен 0x7FFF
% целая часть мантиссы равна 1; %, корректно представимые
старший бит мантиссы равен~$1$;
\item денормализованные вещественные числа "--- порядок и~%целая часть
старший бит мантиссы равны $0$, но мантисса не равна нулю;
\item нули ($+0,0$ и~$-0,0$, в~соответствии со знаковым битом) "--- порядок и~мантисса равны нулю;
\item бесконечности ($+\infty$ и~$-\infty$, в~соответствии со знаковым битом, обозначаются как \lstinline!+inf! и~\lstinline!-inf!) "--- порядок состоит из всех единиц, 
% целая часть мантиссы "--- единица, дробная часть равна нулю;
старший бит мантиссы "--- единица, остальные равны нулю;
\item нечисла двух типов:
\begin{itemize}
\item сигнальные нечисла (при  появлении такого значения в~стеке генерируется исключение недействительной операции);
\item тихие нечисла (не генерируют исключения, но результат вычислений с~операндом-нечислом "--- тоже нечисло):
\begin{itemize}
\item вещественная неопределённость\index{Неопределённость вещественная} $nan$ (знаковый бит не имеет значения) "--- порядок состоит из всех единиц, 
% целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные нули;
\item другие тихие нечисла "--- порядок состоит из всех единиц, %целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные "--- не все нули;\index{Мантисса}\index{Порядок}

\end{itemize}
\end{itemize}
\item недопустимые значения.
\end{itemize}
Начиная с~80387 некоторые ранее недопустимые значения стали нечислами различного типа, и~наоборот "--- многие недопустимые для современных сопроцессоров значения были корректными нечислами в~ранних дискретных моделях.

Если один из операндов равен произвольному тихому нечислу, он интерпретируется как вещественная неопределённость\index{Неопределённость вещественная}.
Если вещественная неопределённость является результатом операции, она может быть равной только описанному значению $nan$.

% Регистр состояний SW содержит слово состояния FPU.
% Регистр управления CW содержит управляющие биты и~маски.
% 
% Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.
% 
% Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.



\subsection{Возможные форматы экспорта-импорта}
\epigraphA{\begin{stanza}[0mm]
У меня есть что-то, я могу поделиться с тобой.\\
И это алая дверь.
\end{stanza}
}{\Bg[Алая~дверь]}
{
  Но какое разнообразие наблюдается в~этом отношении! 
}
{\Lomonosov[Размышления о~причине теплоты и~холода]}

Регистры сопроцессора могут содержать только вещественные числа расширенной точности или специальные значения формата расширенной точности.
Тем не менее, при
выгрузке значений из стека возможно преобразовать их в~различные форматы трёх основных видов "---  с~плавающей запятой, целые двоичные и~целые двоично-десятичные\index{Представление знаковых целых чисел!двоично-десятичное}%
.

Соответственно, при явной загрузке значений из памяти в~стек \modifyone[FPU]{}
или выполнении вычислений с~операндом в~памяти
возможен экспорт значений из этих форматов.

\subsubsection{Форматы с~плавающей запятой}
\index{Представление вещественных чисел!с~плавающей запятой}%

FPU поддерживает импорт и~экспорт в~стандартные форматы с~плавающей запятой одинарной %(32 бита, $float$) 
и~двойной %(64 бита, $double$) 
точности, соответствующие стандарту IEEE 754-2008.
Также возможен импорт-экспорт в~нестандартный 80-битный формат двойной расширенной точности, совпадающий с~внутренним представлением чисел FPU.

Конкретный выбор формата определяется суффиксом команды (раздел~\ref{sec:att-suffixes}).
Суффикс $s$  соответствует одинарной точности (32 бита, $float$), $l$ "--- двойной (64 бита, $double$), $t$ "--- нестандартному формату расширенной точности (80 бит, для GCC \modifyone[этот формат соответствует типу]{"---} $long~double$).

Если суффикс \modifyone[размера]{} не указан, используется одинарная точность ($float$).

\subsubsection{Целые форматы}
\index{Представление знаковых целых чисел}%

Поддерживается  импорт и~экспорт в~двоичные знаковые целые форматы от~двух до восьми байт.
\modifyone[При экспорте значение округляется в~соответствии с~текущими настройками FPU.]{}
Отрицательные числа представлены %, как принято для целых чисел, 
в~дополнительном коде.

Выбор формата определяется суффиксом команды (раздел~\ref{sec:att-suffixes}).
Суффикс $s$  соответствует короткому целому (16 бит, $short$), $l$ "--- длинному (32 бита, $long$ и~чаще всего~$int$), $q$ "--- четверному (64 бита, $long~long$).

Если суффикс \modifyone[размера]{} не указан, \modifyone[число импортируется или экспортируется как короткое (16-битное) знаковое целое, в~большинстве реализаций языка C++ соответствующее типу $short$.]{используется одинарная точность ($float$).}


\subsubsection{Двоично-десятичный формат}
\index{Представление знаковых целых чисел!двоично-десятичное}%

FPU поддерживает экспорт и~импорт только в~один вид двоично-десятичных  чисел "--- это 80-битный  упакованный целый BCD-формат в~виде значения со знаком.

Всего такое число занимает десять байт.
Старший из них "--- знаковый.
Его старший бит хранит знак числа "--- ноль соответствует положительному числу, единица "--- отрицательному.
Младшие семь бит знакового байта не имеют значения.
% 
Остальные девять байтов содержат модуль числа в~виде \modifyone[восемнадцати]{18} упакованных десятичных цифр.

Таким образом, BCD-формат FPU, как и~форматы с~плавающей запятой, включает два нуля: $+0$ и~$-0$.





% \subsection{Набор инструкций x87}
% \subsection{Общие команды x87}
\subsection{Общие команды}
\epigraphA{\begin{stanza}
Багровый и белый пришли в мои песни.\\
Мы здесь не ради парада.\\
Мы стоим вместе и падаем вместе;\\
И я буду петь тебе, если ты будешь рада.\\
\end{stanza}
}{\Bg[Поутру]}
{
"--*  Статус-кво! "--- раздался каменный голос судьи.
"--- Восстановим статус-кво!
}{\ZhvalevskijMytkoSA[5-9]}
% http://www.studfiles.ru/preview/4034449/

Исторически набор команд FPU включает команды для начальной настройки сопроцессора, а~также для синхронизации с~центральным процессором.
В~настоящее время 
% начальная настройка выполняется операционной системой, 
синхронизация не требуется.
% , так как FPU интегрирован в~

\subsubsection{Сброс FPU}
\index{Команды!finit}%

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Так как ранние модели сопроцессора \modifytwo[FPU]{} были отдельными устройствами, 
перед началом работы было необходимо определить, есть ли сопроцессор в~системе, и, в~случае его наличия, инициализировать сопроцессор.
Для инициализации предназначена команда \lstinline!finit! "--- сброс сопроцессора.

Команда \lstinline!finit! восстанавливает значения по умолчанию в~регистрах $cw$, $sw$, $tw$, а~начиная с~80387 "--- $fip$ и~$fdp$. Управляющее слово инициализируется значением \lstinline$0x037F$ (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на $0$, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Слово состояния обнуляется ($top = 0$, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~слове тегов $tw$. Регистры $fip$ и~$fdp$ обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.


\subsubsection{Ожидание синхронизации}
\index{Команды!fwait/wait}%

Оригинальный арифметический сопроцессор, выполненный в~виде отдельной микросхемы, мог работать параллельно с~центральным процессором.
Для их синхронизации использовалась команда \lstinline!wait/fwait!.
Этим мнемоникам соответствует один и~тот же машинный код.
% , который применялся для 
Эта команда приостанавливает работу либо FPU, либо центрального процессора "--- в~зависимости от того, какой из них «вырвался вперёд»
"--- и~ждёт отстающего.
% Выполнение программы 
Кроме того, многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
Мнемоника команды без ожидания отличается префиксом~\lstinline!n! после префикса FPU~\lstinline!f!, например, \lstinline!fnstsw! и~\lstinline!fstsw!.
При этом, согласно документации Intel, машинный код команды без префикса~\lstinline!n! состоит из кода команды \lstinline!wait/fwait! и~кода команды с~префиксом~\lstinline!n!. %, то есть основной
В~частности, команда~\lstinline!fstsw! полностью эквивалентна последовательности \texttt{fwait + fnstsw}.

\index{Команды!nop}%
В~современных  процессорах параллельная работа команд FPU и~основного набора невозможна, так что команда \lstinline!wait/fwait! эквивалентна \lstinline!nop!.
Соответственно, из двух команд "--- с~префиксом~\lstinline!n! и~без "--- в~настоящее время необходимо выбирать вариант с~префиксом.


% \subsection{Загрузка и~выгрузка данных}
% \subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}
\subsection{Загрузка, выгрузка и~пересылка данных}
% \epigraph{\begin{stanza}
% Но будь ты хоть роллс-ройс "--- всё равно стоять в пробке.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}[0mm]
 И падут предо мною преграды стекла,\\
Я смогу без препятствий входить в зеркала!\\
\end{stanza}}{\Sk[Скульптор лепит автопортрет]}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
Также невозможно загрузить в~стек произвольную константу.

Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти.
В~частности, листинг~\ref{lst:asm:fpu:x+a} показывает вычисление значение выражения $x+a$ и~запись результата в~$y$.
Параметры (как входные \texttt{[X]} и~\texttt{[A]}, так и~выходной~\texttt{[Y]}) расположены в~памяти.
\modifyone[К~константе~$a$ (значению входного параметра \texttt{[A]}) применён модификатор \texttt{volatile}, чтобы компилятор не оптимизировал её и~разместил в~памяти, как и~необходимо.]{}

\begin{lstlisting}[style=lstsmall, caption={Вычисление $y = x+a$ вставкой в~код C++}, label=lst:asm:fpu:x+a]
const volatile double a = 12;
double x = 1, y;
asm(
    "fldl %[X]\n"  // st(0) = %[X]
    "faddl %[A]\n" // st(0) = %[X] + %[A]
    "fstpl %[Y]\n" // %[Y] = %[X] + %[A], стек пуст
    :[Y]"=m"(y)
    :[X]"m"(x), [A]"m"(a)
    :"cc"
);
\end{lstlisting}
\index{Команды!fld}%
\index{Команды!fadd[p]}%
\index{Команды!fst[p]}%

В~списке  перезаписываемых регистров\index{Перезаписываемые элементы} GCC не позволяет описывать элементы стека сопроцессора.
Это %, как правило, 
не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

Если вычисления должны быть не вставкой в~код C++, а~частью программы на ассемблере, все числа, включая константы (кроме, может быть, тех, для загрузки которых есть специальные команды), необходимо разместить в~памяти.
\begin{lstlisting}[style=lstsmall, caption={Вычисление $y = x+a$}, label=lst:asm:fpu:x+a:noinline]
.data
a: .double 12
x: .double 1
y: .double
.text
  fldl x
  faddl a
  fstpl y
\end{lstlisting}
\index{Команды!fld}%
\index{Команды!fadd[p]}%
\index{Команды!fst[p]}%

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).





\subsubsection{Загрузка данных в~стек FPU}
\index{Команды!FPU!загрузки}%

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций \lstinline!f*ld! (таблица~\ref{tab:fpu-fld-list}).
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение $st(0)$.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры
\begin{table}[!ht]
% \caption{Команды загрузки данных в~стек сопроцессора}
% \label{tab:fpu-fld-list}
% \begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-fld-list.tex}

% \endgroup
\index{Команды!fld}%
\index{Команды!fild}%
\index{Команды!fbld}%
\index{Команды!fldz}%
\index{Команды!fld1}%
\index{Команды!fldpi}%
\index{Команды!fldl2t}%
\index{Команды!fldl2e}%
\index{Команды!fldlg2}%
\index{Команды!fldln2}%

\end{table}

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.


\subsubsection{Выгрузка данных из~стека FPU}
\index{Команды!FPU!выгрузки}%
\index{Команды!FPU!пересылки}%


Для выгрузки данных из~стека сопроцессора предназначен набор инструкций \lstinline!f*st[p]! (таблица~\ref{tab:fpu-fst-list}).

\begin{table}[!ht]

\begingroup
\small
% \def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-fst-list.tex}

\endgroup

\index{Команды!fst[p]}%
\index{Команды!fist[p]}%
\index{Команды!fbst[p]}%

\end{table}



Ниже показан пример использования команд загрузки и~выгрузки (листинг~\ref{lst:asm:fpu:ldst}).

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Последовательная загрузка и~выгрузка данных}, label=lst:asm:fpu:ldst]
double x = 5.7, y;
float f;
long double l;
int i = 10;

asm(                //          st(0),st(1),st(2),st(3)
    "fldl %[x]\n"   // в стеке: [x]
    "fldz\n"        // в стеке: 0,    [x]
    "fld1\n"        // в стеке: 1,    0,    [x]
    "fildl %[i]\n"  // в стеке: [i],  1,    0,    [x]
    "fstps %[f]\n"  // в стеке: 1,    0,    [x]       [f] = [i] 
    "fstpt %[l]\n"  // в стеке: 0,    [x]             [l] = 1   
    "fstpl %[y]\n"  // в стеке: [x]                   [y] = 0   
    "fistpl %[i]\n" // стек пуст                      [i] = [x]

    :[y]"=m"(y), [i]"+m"(i), [f]"=m"(f), [l]"=m"(l)
    :[x]"m"(x)
    :"cc"
)

#define PRINT(val) cout << #val << " = " << val << "  ";

PRINT(x)
PRINT(y)
PRINT(i)
PRINT(f)
PRINT(l)
\end{lstlisting}
Вначале в~стек сопроцессора последовательно загружаются четыре значения:
вещественная переменная двойной точности $x = 5,7$, константы "--- ноль и~единица, а~также целое 32-битное число $i = 10$.
% При загрузке данных из памяти размер источника определяется суффиксом. 
% Команда $fldl$ загружает из памяти длинное вещественное значение (64-битное, $double$),
% $fildl$ "--- длинное целое (32-битное, $int$).

После загрузки всех четырёх значений в~стеке сопроцессора находятся следующие значения:
$$
\begin{array}{l}
st(0) =10= i \\
st(1) = 1 \\
st(2) = 0 \\
st(3)= 5,7 = x \\
\end{array}
$$
Все они внутри стека хранятся в~80-битном вещественном формате.

Затем верхнее значение $st(0)$, равное последнему загруженному значению~$i = 10$, выталкивается из стека и~записывается по адресу параметра $[f]$, преобразованное в~вещественное число одинарной точности.
% (суффикс $s$ для вещественных команд обозначает короткое вещественное число, то есть 32-битное $float$).
Новое значение вершины стека $st(0)$ после выталкивания %значения $10$
"--- единица. Соответственно, изменятся и~обозначения более глубоких элементов стека: $st(1) = 0$ и~$st(2) = x$.

Затем новое значение вершины стека, равное единице, выталкивается в~параметр~$[l]$ как 80-битное число (суффикс $t$ "--- $ten~bytes$, что для компиляторов GCC соответствует типу $long~double$).
Ноль выталкивается из стека и~записывается в~$[y]$ как число двойной точности.
Последний оператор выталкивает значение~$x$ в~параметр~$[i]$ как длинное целое ($int$), после чего стек остаётся пустым.
Значение $5,7$ округляется в~соответствии с~текущими настройками округления, в~данном случае "--- к~ближайшему, то есть получим $[i]=6$.

Соответственно, результат отладочной печати в~конце листинга выглядит следующим образом:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, numbers=none]
x = 5.7  y = 0  i = 6  f = 10  l = 1 
\end{lstlisting}

Используя команды выгрузки или загрузки из памяти, необходимо внимательно следить за суффиксами команд.
% , так как только по суффиксу определяется размер "--- единственная
В~вышеописанном примере команда \lstinline!fstp %[y]! не вызвала бы ошибки ни во время компиляции, ни во время выполнения, но переменная $y$ получила бы весьма странное значение.
По умолчанию (без указания суффикса) \lstinline$fstp$ записывает снятое с~вершины стека значение как вещественное число одинарной точности, то есть из 64 бит переменной $y$ будут перезаписаны только первые 32, причём в~формате, не соответствующем типу $double$.

\subsubsection{Пересылка данных внутри стека FPU}
\label{sec:fcmovCC}
\index{Флаги!проверка}%
\index{Команды!условной пересылки}%
% \index{Команды!FPU!пересылки}%

Для пересылки данных внутри стека сопроцессора можно использовать команды \lstinline!fld st(i)! для загрузки копии значения $st(i)$ в~вершину стека
и~\lstinline!fst st(i)! для помещения значения $st(0)$ в~ранее пустую ячейку~$st(i)$.
Кроме того, существует две специализированные команды (таблица~\ref{tab:fpu-mov-list}).

\begin{table}[!ht]
\caption{Команды пересылки данных~FPU}
\label{tab:fpu-mov-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
fcmovCC \%st(i), \%st(0) & Присваивание   $st(0) = st(i)$, если верно  $CC$
 (\texttt{e, ne, b/nae, be/na, ae/nb, a/nbe,} \texttt{u} и~\texttt{nu})
\\\hline
fxch & Меняет местами  $st(0)$ и~$st(1)$
\\
fxch \%st(i)
& Меняет местами  $st(0)$ и~$st(i)$
\\\hline
\end{tabularx}

\index{Команды!fcmovCC}%
\index{Команды!fxch}%

\end{table}


Команда условного копирования~\lstinline!fcmovCC! использует как условие флаги регистра~$flags$,
а~не регистра состояния~$sw$.
При этом для неё доступны 
не все  условия~$CC$, перечисленные в~таблице~\ref{tab:cc-list},
и~даже не все синонимы доступных условий.
Используемые условия перечислены в~таблице~\ref{tab:fpu-cc-list}.
% Таблица~\ref{tab:fpu-cc-list} содержит доступные для условного копирования условия.

\begin{table}[!ht]
\small\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/fpu-cc-list.tex}
\end{table}

% После сравнения вещественных чисел 
% После сравнения флаги состояния сопроцессора копируются в~$flags$ (вручную или автоматически "--- в~зависимости от используемой команды сравнения) таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел:
% $ZF$ указывает на равенство, $CF$ "--- на $dest<src$; кроме того, в~$PF$ копируется флаг несравнимости операндов. 

Условия~\lstinline!fcmovCC! включают те биты регистра флагов~$flags$, которые могут быть прямо или косвенно (путём сохранения слова состояния~$sw$ и~загрузки его части в~$flags$) установлены командами сравнения FPU, то есть флаги $ZF, CF, PF$.

Команда обмена регистров \lstinline!fxch! на самом деле не копирует данные, а~переименовывает регистры, так что её выполнение практически не занимает времени.
Так как большинство команд работает с~вершиной стека, переименование регистров  с~помощью~\lstinline!fxch! часто бывает удобным.


\subsubsection{Загрузка и~выгрузка управляющих регистров}

Содержимое управляющих регистров также может быть сохранено в~памяти (таблица~\ref{tab:fpu:ld-st-spec}).

\begin{table}[!ht]
\caption{Команды загрузки и~выгрузки управляющих регистров~FPU}
\label{tab:fpu:ld-st-spec}

\small
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|}
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
fnstcw dmem16	&	Выгрузка управляющего слова~$cw$ в~память  \\\hline
fldcw smem16	&	Загрузка управляющего слова~$cw$ из памяти  \\\hline
fnstsw dest16	&	Выгрузка (разрушающая) слова состояния~$sw$ в~память или регистр~$ax$ \\\hline
\end{tabularx}
\index{Команды!fnstcw}%
\index{Команды!fldcw}%
\index{Команды!fnstsw}%
\end{table}

Управляющее слово можно как выгрузить в~память по заданному адресу, так и~загрузить из неё.

Слово состояния сопроцессора  можно только сохранить в~память,  а~также в~регистр~$ax$ (и~только в~этот регистр).

\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
После выгрузки слова состояния~$sw$ командой~\lstinline$fnstsw$ теряется значение специальных флагов~$C0{-}C3$.

% Приёмник 
% Сохранение состояния сопроцессора с~последующей загрузкой его в~регистр~$flags$ может применяться при сравнении вещественных чисел.
% 
% \subsection{Арифметические и~трансцендентные команды}
% \epigraph{\begin{stanza}
% Ещё раз напьюсь\\
% Этой бесконечной воды...\\
% И двинусь дальше\\
% Вслед за пламенем Зелёной Звезды.\\
% \end{stanza}
% }{\Aquarium}
% 
% Основное назначение FPU "--- производить вычисления; соответственно, данный раздел наиболее объёмен.
% 
% Сопроцессор поддерживает шесть форм для команд, выполняющих четыре действия арифметики над различными типами операндов.
% При этом  реализация несимметричных операций (вычитания и~деления) качественно отличается от ассемблеров с~синтаксисом Intel.
% 
% Также существует множество команд, выполняющих более сложные действия.
% Их формы не так разнообразны, а~неявным операндом является вершина стека~$st(0)$ и,~при необходимости, $st(1)$.

\subsection{Основные арифметические команды}
\index{Команды!FPU!арифметические}%
% \epigraph{\begin{stanza}[0ex]
%  Объясните  мне,  где  теперь  правда,  где  ложь, \\
%  где  жало  змеи, где пылающий   уголь,  где  тюрьма.
% \end{stanza}}
% {\Bg[Прикуривать от~пустоты]}
\epigraph{\begin{stanza}[0mm]
Напишу в чернилах: верь!\\
Близок день, что всех возвысил!\\
И грядёт бесшумно зверь\\
С парой белых нежных чисел! \\
\end{stanza}
}{\Khlebnikov[Зверь+число]}

\index{Команды!fadd[p]}%
\index{Команды!fmul[p]}%
\index{Команды!fsub[p]}%
\index{Команды!fsubr[p]}%
\index{Команды!fdiv[p]}%
\index{Команды!fdivr[p]}%
\index{Команды!fiadd[p]}%
\index{Команды!fimul[p]}%
\index{Команды!fisub[p]}%
\index{Команды!fisubr[p]}%
\index{Команды!fidiv[p]}%
\index{Команды!fidivr[p]}%

Основные арифметические команды сопроцессора выполняют базовые бинарные арифметические операции "--- сложение, вычитание, умножение и~деление.
Хотя бы один операнд должен быть %в~стеке сопроцессора.
в~вершине стека сопроцессора~$st(0)$.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.
Приёмник должен быть в~стеке сопроцессора, но не обязательно на его вершине. %, таким образом, .


Каждая из основных арифметических команд может быть записана в~нескольких формах. %, подробнее описанных в~следующем подразделе.
Они различаются  положением источника и~приёмника, также некоторые из форм после вычисления результата выталкивают источник из стека сопроцессора, что обозначается суффиксом~\lstinline!p!.

\subsubsection{Обозначения основных арифметических команд}

Четырём арифметическим операциям в~FPU соответствует шесть различных %команд
операций. %и~может быть
При этом каждой из симметричных относительно перестановки операндов арифметических операций
"--- сложению и~умножению "--- соответствует по одной операции FPU: сложение \lstinline!fadd! и~умножение \lstinline!fmul!.
Несимметричным операциям "--- вычитанию и~делению "--- соответствует по две операции FPU, отличающиеся порядком операндов.
Это соответственно прямое вычитание \lstinline!fsub! и~обратное вычитание~\lstinline!fsubr!, а~также прямое деление \lstinline!fdiv! и~обратное деление~\lstinline!fdivr! (таблица \ref{tab:fpu-ar-list}).



\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arcommon-mnemlist.tex}

*
%Один из операндов всегда находится на вершине стека~$st(0)$.
% Обозначим другой операнд как~$x$.
$\xi$ "--- операнд, не лежащий на~вершине стека.

Может быть как источником, так и~приёмником, в~зависимости от используемой формы.

\index{Команды!fadd[p]}%
\index{Команды!fmul[p]}%
\index{Команды!fsub[p]}%
\index{Команды!fsubr[p]}%
\index{Команды!fdiv[p]}%
\index{Команды!fdivr[p]}%
\index{Команды!fiadd[p]}%
\index{Команды!fimul[p]}%
\index{Команды!fisub[p]}%
\index{Команды!fisubr[p]}%
\index{Команды!fidiv[p]}%
\index{Команды!fidivr[p]}%
\end{table}

Все формы основных арифметических команд используют два явно или неявно заданных операнда.
Один из них всегда в~вершине стека~$st(0)$, другой (обозначим его~$\xi$) может быть в~памяти или в~регистре~$st(i)$.
Кроме того, один из этих операндов является приёмником~$dest$, второй "--- источником~$src$.

% 
% Мнемоника команды состоит из префикса FPU \lstinline!f!, опционального 

\warning{\index{Синтаксис!AT\&T}%
Внимание!

Ассемблер Unix исторически использовал для основных арифметических команд FPU те же мнемонические обозначения, что и~предложенные Intel, но другую семантику операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
% в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel %и~большинстве учебников.
и~учебниках, описывающих синтаксис Intel.
}

% \subsubsection{Различие арифметических команд Intel и~\Att}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
% всегда
% , в~том числе
% в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
\label{sec:fpu-trouble-with-fsub}
% в~таком случае 
% для двух регистров
вычисляет $st(0) - \xi$ 
% независимо от того, какой из этих регистров является приёмником
даже в~том случае, если приёмником является $\xi$.
% (это возможно, если~$xi$ "--- регистр~$st(i)$).
В~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры. 
Обратное вычитание~\lstinline!fsubr! вычисляет $\xi - st(0)$.



% Соответственно, шесть форм команды прямого вычитания \lstinline$fsub$ и~обратного вычитания \lstinline$fsubr$ в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-fsub-r-typelist}.
% 
% \begin{table}[!ht]
% \caption{Прямое и~обратное вычитание в~синтаксисе \Att}
% \label{tab:fpu-fsub-r-typelist}
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-fsub-r-typelist.tex}
% 
% \end{table}


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!~\cite{trouble-with-fsub}.
Анализ сгенерированного компилятором из коллекции GCC кода это подтверждает.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.
% 
% Приёмником, в~соответствии с~синтаксисом \Att, является второй аргумент.
% Если команда вызывается с~одним аргументом или без них, то приёмником является $st(0)$, что соответствует документации Intel.
% Таким образом,
% % Соответственно, 
% шесть форм несимметричных операций (вычитания и~деления) в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-att-r-typelist}.
% 
% \begin{table}[!ht]
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-att-r-typelist.tex}
% 
% \end{table}
% 
Такое поведение в~случае сочетания синтаксиса AT\&T и~платформы x86 в~некоторых источниках описывается как баг GCC~\cite{sourceware-i386_002dBugs}, но из соображений совместимости с~имеющимся кодом меняться не будет.
% Из-за него, кроме всего прочего, в~GCC для всех основных арифметических команд доступна <<нелегальная>> седьмая форма записи, например, \lstinline!fsubp %st(i), %st(0)!.
% Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)! (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
% Подобную некорректную форму лучше не использовать.

% Также большинство ассемблеров поддерживает формы \lstinline!fXXX %st(i)! и~\lstinline!fXXXp %st(i)!


Поведение Intel и~GAS совпадает в~тех случаях, когда приёмником является~$st(0)$, в~том числе в~ситуациях, когда источник находится в~памяти.
% 
Также поведение Intel и~GAS полностью совпадает для симметричных операций "--- сложения и~умножения.


\subsubsection{Формы основных арифметических команд}

Согласно документации Intel, сопроцессор использует шесть  форм~\cite{frolov} основных арифметических команд (таблица~\ref{tab:fpu-arcommon-typelist}).
% На самом деле 
Строка XXX соответствует выполняемой операции %и~может быть
(\lstinline!add!, \lstinline!sub!, \lstinline!subr!, \lstinline!mul!, \lstinline!div!, \lstinline!divr!).


\begin{table}[!htpb]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arcommon-typelist.tex}

\end{table}
% \FloatBarrier

Если посмотреть на опкоды этих форм~\cite{intelInstructionSet}, видно, что опкод формы без параметров \lstinline!fXXXp!
полностью совпадает с~опкодом формы с~двумя параметрами~\lstinline!fXXXp %st(0), %st(1)!.
% то есть практически форм пять.
Напротив, формы \lstinline!f[i]add smem! для различной разрядности источника~$smem$ имеют по два различных опкода.

% \newcommand{\faddform}[1]{\hspace*{0pt}\rlap{{#1}}\phantom{\texttt{faddp \%st(0), \%st(i)}}}


% Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
% Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
В~частности, для операции сложения \lstinline!fadd! возможны следующие формы:
\begin{alphenumerate}[wide=\parindent]
\item \lstinline!faddp!
выполняет сложение $st(1) = st(0) + st(1)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(0)$	
(эквивалент \lstinline!faddp %st(0), %st(1)!);
\item \lstinline!fadd  smem!	"--- $st(0) = st(0) + \text{вещественное}~smem$;
\item \lstinline!fiadd smem!	"--- $st(0) = st(0) + \text{целое}~smem$;
\item \lstinline!fadd  %st(i), %st(0)!	"--- $st(0) = st(0) + st(i)$;
\item \lstinline!fadd  %st(0), %st(i)! "--- $st(i) = st(0) + st(i)$;
\item \lstinline!faddp %st(0), %st(i)!\ "---\ $st(i) = st(0) + st(i)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{alphenumerate}


Большинство ассемблеров, в~частности, GAS, поддерживает
и~некоторые дополнительные формы основных арифметических команд,
оба операнда которых находятся в~стеке.
В~частности,
для формы без операндов \lstinline!fXXXp! практически во всех ассемблерах принят синоним~\lstinline!fXXX!.
% Форма \lstinline!fXXX! без аргумента допустима (эквивалентна \lstinline!fXXXp!), но,~
Но,  так как мнемоника без суффикса~\lstinline!p! не~отражает выполняемое выталкивание $st(0)$  из~стека, её использование не~рекомендуется.

Кроме того, по аналогии с~\lstinline!fXXX smem! поддерживается
% для всех основных арифметических команд  форму 
форма \lstinline!fXXX %st(i)!
с~приёмником в~$st(0)$, а~также \lstinline!fXXXp %st(i)! с~приёмником изначально в~$st(i)$, а~после выталкивания $st(0)$ "--- в~$st(i-1)$.

% Из-за него, кроме всего прочего, 
В~GAS, кроме всего прочего, доступна 
<<нелегальная>> %седьмая 
форма записи~\lstinline!fXXXp %st(i), %st(0)!, например, \lstinline!fsubp %st(i), %st(0)!.
Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)!.
% (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), 
% то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
% Подобную некорректную форму лучше не использовать.

Подобные формы лучше не использовать из-за неочевидности расположения операндов.
При этом неуказание части операндов в~программе не даёт преимущества в~исполняемом файле, так как любая форма
% арифметической команды с~операндами в~регистрах FPU 
из перечисленных дополнительных форм арифметических команд
будет ассемблироваться в~тот же опкод, что и~форма с~двумя явно указанными операндами.

\subsubsection{Практическое использование основных арифметических команд}

Ниже показано использование основных арифметических команд для расчёта значения выражения $x + \frac{1}{i} + a \cdot \pi$.
% 
Так как используется GAS, команда \lstinline!fdivr! без операндов рассчитывает %прямое деление 
$st(1)/st(0)$, после чего источник $st(0)$ выталкивается из стека FPU.

В~листинге~\ref{lst:asm:fpu:add-mul-foo} приведена функция \lstinline$double foo(double x, int i, double a)$, соответствующая соглашению о~вызове cdecl (см.~раздел~\ref{sec:calling-conventions}).
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = x + \frac{1}{i} + a \cdot \pi$ как функция}, label=lst:asm:fpu:add-mul-foo]
.globl foo
foo:                   //          st(0),    st(1),   st(2),   st(3)
  fldl 4(%esp)         // в стеке: x                           
  fldpi                // в стеке: pi,       x                 
  fld1                 // в стеке: 1,        pi,      x        
  fildl 12(%esp)       // в стеке: i,        1,       pi,      x
  fdivr                // в стеке: 1/i,      pi,      x        
  fldl  16(%esp)       // в стеке: a,        1/i,     pi,      x
  fmulp %st(0), %st(2) // в стеке: 1/i,      pi*a,    x        
  faddp                // в стеке: 1/i+pi*a, x                 
  faddp                // в стеке: 1/i+pi*a+x (результат)
\end{lstlisting}
Операнды, в~соответствии с~тридцатидвухбитным соглашением cdecl, передаются в~стеке %основного процессора
в~памяти
(первый параметр $x$ находится по адресу $sp+4$ и~занимает восемь байт, так что следующий параметр, $i$, располагается по адресу $\&x+8 = sp + 4 + 8 = sp+12$ и~$a$ "--- по адресу $sp+16$), поэтому их можно загрузить командами \lstinline!f*ld! в~стек регистров FPU.
Возвращаемое вещественное значение, согласно тому же соглашению, передаётся в~$st(0)$, поэтому оно не выталкивается после вычислений.

Далее показан 
тот же код расчёта значения выражения $x + \frac{1}{i} + a \cdot \pi$, 
оформленный как вставка в~программу на C++,
где $x$, $i$ и~$a$ "--- значения переменных (листинг~\ref{lst:asm:fpu:add-mul}).

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = x + \frac{1}{i} + a \cdot \pi$ как вставка}, label=lst:asm:fpu:add-mul]
const volatile double a = 0.01;
double x = 5, y;
int i = 10;
asm(                           //          st(0),    st(1), st(2), st(3)
    "fldl %[x]\n"              // в стеке: x
    "fldpi\n"                  // в стеке: pi,       x
    "fld1\n"                   // в стеке: 1,        pi,    x
    "fildl %[i]\n"             // в стеке: i,        1,     pi,    x
    "fdivr\n"                  // в стеке: 1/i,      pi,    x
    "fldl  %[A]\n"             // в стеке: A,        1/i,   pi,    x
    "fmulp %%st(0), %%st(2)\n" // в стеке: 1/i,      pi*A,  x
    "faddp\n"                  // в стеке: 1/i+pi*A, x
    "faddp\n"                  // в стеке: 1/i+pi*A+x
    "fstpl %[y]\n"             // y = 1/i + pi*A + x, стек пуст

    :[y]"=m"(y)
    :[x]"m"(x), [A]"m"(a), [i]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}
Приведённый код "--- не единственный способ расчёта значения указанного выражения.
% Как порядок вычислений, так и~используемые команды могут различаться.
В~зависимости от того, в~каком порядке программист будет рассчитывать компоненты выражения, может различаться как порядок команд, так и~сами команды (в~частности, возможно использование прямого деления \lstinline!fdiv!, а~не обратного \lstinline!fdivr!).


\subsection{Дополнительные арифметические и~трансцендентные команды}
% \epigraphcensored[
% \epigraph{\begin{stanza}[0ex]
% Тарелки не влетали в окно,\\и все мои слова оставались со мной.\\
% \end{stanza}
% }{\Bg[Джунгли]}
% \epigraph{\begin{stanza}
% Куда бы мы ни шли "--- всё было мелко;\\
% Куда бы ни пришли "--- всё никакое.\\
% А потом руками раздвинули ветви\\
% И вышли поутру в поле.
% \end{stanza}
% }{\Bg[Поутру]}
% ]{\epigraph{\begin{stanza}[0ex]
% Кто бы ты ни был, куда б ты ни шёл,\\
% Ты неподвижен "--- ты ось круговерти.\\
% \end{stanza}}
% {О.\,Арефьева}}
\epigraph{\begin{stanza}[0mm]
Здесь площади из горниц, в один слой,\\
Стеклянною страницею повисли,\\
Здесь камню сказано «долой»,\\
Когда пришли за властью мысли.
\end{stanza}
}{\Khlebnikov[Город будущего]}


% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX} 


Дополнительные арифметические и~трансцендентные команды~\cite{zubkov, intelInstructionSet} работают с~вершиной стека $st(0)$ и,~при необходимости, с~$st(1)$. Для них не указывают явных операндов. % и~соответствующих пяти форм.
Соответственно, каждая из команд этой группы имеет только одну форму.


Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице \ref{tab:fpu-arex-list}.
\index{Команды!FPU!трансцендентные}%
\index{Команды!FPU!дополнительные}%

\begin{table}[p]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arex-list.tex}

\index{Команды!fabs}%
\index{Команды!fsqrt}%
\index{Команды!fptan}%
\index{Команды!fpatan}%
\index{Команды!fsincos}%
\index{Команды!fsin}%
\index{Команды!fcos}%
\index{Команды!fscale}%
\index{Команды!f2xmi}%
\index{Команды!fyl2x}%
\index{Команды!fyl2xp1}%
\index{Команды!fprem1}%

\end{table}


Использование этих команд не перезаписывает значения, лежащие в~стеке ниже неявных аргументов. 
Если у~команды только один аргумент в~$st(0)$ и~один результат, результат записывается в~$st(0)$ на место аргумента.
Если у~команды один аргумент в~$st(0)$ и~два результата (\lstinline$fptan$, \lstinline$fsincos$ и т.\,д.), то один из результатов помещается в~$st(0)$, второй затем помещается в~стек сверху (так что первый результат оказывается в~$st(1)$, второй "--- в~$st(0)$).
% В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом (или наоборот "--- с~одним аргументом $st(0)$ и~двумя результатами)
% изменятся номера нижележащих значений, но ни одно значение, кроме аргументов, не исчезнет и~не появится ни одной «дырки».
% Если результатом выполнения команды являются два числа, а~аргументом "--- $st(0)$, одно из %них 
% полученных значений заменяет аргумент в~$st(0)$, другое помещается сверху, так что 

В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом
чаще всего результат помещается в~$st(1)$, затем $st(0)$ выталкивается из стека, так что после этой операции результат оказывается в~$st(0)$. 
Таким образом, результат замещает собой аргументы (в~таблице~\ref{tab:fpu-arex-list} такая ситуация соответствует обозначению $\big[st(1)\to st(0)\big]$ для результата).

Иногда (в~частности, \lstinline$fscale$) команда с~двумя аргументами в~$st(0)$ и~$st(1)$ записывает результат в~$st(0)$, оставляя аргумент в~$st(1)$ в~стеке.

Результат трансцендентных и~тригонометрических команд (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда помечается как неточный (исключительная ситуация {\#Р}).
\index{Команды!FPU!трансцендентные}%
\index{Команды!fptan}%
\index{Команды!fsincos}%
\index{Команды!fsin}%
\index{Команды!fcos}%
\index{Команды!f2xmi}%
\index{Команды!fyl2x}%
\index{Команды!fyl2xp1}%
\index{Команды!fpatan}%


Пример использования тригонометрических команд для расчёта значения выражения $a\cdot\cos(x) + \sin(x)$ показан в~листинге~\ref{lst:asm:fpu:sinsos}.

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = a\cdot\cos(x) + \sin(x)$}, label=lst:asm:fpu:sinsos]
const volatile double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[X]\n"   // st(0) = %[X]
    "fsincos\n"     // st(0) = cos(%[X]),       st(1) = sin(%[X])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[X]),  st(1) = sin(%[X])
    "faddp\n"        // st(0) = %[A]*cos(%[X]) + sin(%[X])
    "fstpl %[Y]\n"  // %[Y] = %[A]*cos(%[X]) + sin(%[X]), стек пуст

    :[Y]"=m"(y)
    :[X]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
Если операнд выходит за эти пределы, флаг $C2$ устанавливается \modifyone[в~единицу]{в 1}, значение $st(0)$ и~стек не изменяются. 


\begin{modifyonelong}
Частичный арктангенс \lstinline!fpatan! отличается от математического определения арктангенса тем, что принимает два аргумента, соответствующие координатам некоторой точки
$\footnotesize
\left\{
\begin{array}{@{\,}l}
st(0) = x\\
st(1) = y
\end{array}
\right.
$ 
и~возвращает результат в~диапазоне $[-\pi, \pi]$, равный азимуту заданной точки $(x, y)$. 
Соответственно, знаки аргументов определяют квадрант результата.
% (знак результата равен знаку $st(1)$).

Чтобы получить результат в~диапазоне $(-\frac{\pi}{2}, \frac{\pi}{2})$, то есть в~соответствии с~математическим определением $arctg(x)$,
необходимо задать точку в~первом или четвёртом квадрантах, то есть с~положительной абсциссой "--- $\footnotesize
\left\{
\begin{array}{@{\,}l}
st(0) = 1\\
st(1) = x
\end{array}
\right.
$.

Остальные обратные тригонометрические функции  можно получить с~помощью команды \lstinline!fpatan! 
% и~прямых тригонометрических функций 
и~арифметических команд,
используя основное тригонометрическое тождество и~задавая координаты соответствующих точек.
% задавая точки в~необходимых квадрантах.
\index{Команды!fpatan}%
\end{modifyonelong}


\subsection{Сравнение вещественных чисел}
\label{sec:fpu-cmp}
\epigraph{\begin{stanza}[0mm]
Я крушу зеркала, чтоб не видеть, как смотрит двойник; \\
Зеркала, разбиваясь, сочатся багровым и алым.\\
\end{stanza}}{\Sk[Скульптор лепит автопортрет]}

FPU включает несколько семейств команд сравнения вещественных чисел.
Все они сравнивают приёмник $st(0)$ с~некоторым источником $src$. 
По аналогии с~командой целочисленного сравнения можно сказать, что анализируется знак разности~$st(0)-src$.
Так как приёмником является~$st(0)$, поведение команд сравнения не различается для GAS и~Intel.

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
Некоторые из них помещают результат в~слове состояния~$sw$, откуда его надо вручную копировать в~регистр флагов~$flags$ (при этом осмысленное значение приобретают $ZF, CF, PF$)\modifyone[. Они поддерживаются, но считаются устаревшими.
Более современные команды сравнения помещают результат]{,
некоторые "---} непосредственно во флагах $ZF, CF, PF$ регистра~$flags$.

Также система команд FPU включает~\lstinline!fxam!, которая определяет вид значения в~$st(0)$ в~соответствии с~разделом~\ref{sec:valueclasses}.
\index{Команды!fxam}%

Знак нуля при сравнении не учитывается, то есть считается, что 	$-0=+0$.


\subsubsection{Команды сравнения}
% \footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается

% \index{Команды!сравнения!вещественных чисел}%
\index{Команды!FPU!сравнения}%

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

% В~таблице~\ref{tab:fpu-cmp-list} приводится сводная информация по семействам команд сравнения FPU.
Все команды сравнения вещественных чисел~\cite{club155} сравнивают вершину стека "--- приёмник $st(0)$ с~другим операндом  "--- источником $src$
% , который может 
(таблица~\ref{tab:fpu-cmp-list}).

\begin{table}[ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-list.tex}
\index{Команды!fcom[p[p]]}%
\index{Команды!fucom[p[p]]}%
\index{Команды!ficom[p]}%
\index{Команды!ftst}%
\index{Команды!fcomi[p]}%
\index{Команды!fucomi[p]}%

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\end{table}

По результатам сравнения  (в~соответствии со знаком разности~$st(0)-src$) устанавливается значение трёх флагов:
% флаг отрицательности, флаг нуля и~флаг несравнимости 
% в~соответствии с~таблицей~\ref{tab:fpu-cmp-flags}.
отрицательности, нуля и~несравнимости (таблица~\ref{tab:fpu-cmp-flags}).
Операнды считаются несравнимыми, если хотя бы один из них "--- тихое нечисло 
% (обычно 
(любые тихие нечисла как операнды команд обрабатываются, как
вещественная неопределённость~$nan$\index{Неопределённость вещественная},
поэтому обычно говорят, что операнды несравнимы, если хотя бы один из них равен $nan$).

\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\end{table}

Действие команд сравнения одинаково для синтаксиса AT\&T и~синтаксиса Intel.
% 
Мнемоника может включать суффикс~\lstinline!p!, в~этом случае приёмник~$st(0)$ после сравнения выталкивается из стека.
Если явный операнд не задан (то есть источником считается~$st(1)$), может также использоваться суффикс \lstinline!pp! "--- в~этом случае после сравнения из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$.
% 
Если источник задан явно и~находится в~памяти, необходимо указывать также суффикс размера по тем же правилам, что и~для арифметических команд.

Если хотя бы одно из сравниваемых значений "--- нечисло,
для б\'{о}льшей части команд сравнения (без префикса~\lstinline!u!) это недействительная арифметическая операция \#IA.
Если соответствующее исключение не замаскировано (раздел~\ref{sec:fpu:cw-mask}), работа программы прерывается,
% так что флаг несравнимости не устанавливается.
если замаскировано "--- устанавливается флаг несравнимости.
% 
\index{Команды!fucom[p[p]]}%
\index{Команды!fucomi[p]}%
Команды неупорядоченного сравнения, мнемоники которых включают префикс~\lstinline!u!,
% после префикса FPU~\lstinline!f!,
% не генерируют исключений при сравнении тихих нечисел,  в~частности, вещественной неопределённости, так что флаг несравнимости для~$nan$ устанавливается при любом наборе масок в~управляющем слове~$cw$.
считают операцию сравнения с~тихим нечислом,  в~частности, вещественной неопределённостью\index{Неопределённость вещественная}, действительной, и~устанавливают в~этом случае флаг несравнимости.
% вне зависимости от маски~$IM$.
% 
Если хотя бы одно из сравниваемых значений "--- неподдерживаемое значение или сигнальное нечисло, операция сравнения недействительна (\#IA) для всех команд.

По набору используемых флагов команды сравнения делятся на две группы "--- часть их выставляет биты слова состояния~$sw$ ($C3, C0$ и~$C2$),
часть "--- биты регистра~$flags$ ($CF, ZF$ и~$PF$).
\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

В~слове состояния сопроцессора~$sw$ результат сохраняют
команды сравнения оригинального FPU 8087 и~80387.
% (\texttt{fcom, fcomp, fcompp, ftst}) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (\texttt{fucom, fucomp, fucompp}).
% % , не генерирующее исключений при сравнении некоторых нечисел, 
% сохраняют результат сравнения в~биты $C3, C0$ и,~в~случае несравнимости операндов, в~бит~$C2$ слова состояния.
% % \pagebreak[3]
% Для анализа результата сравнения
% в~этом случае
% % вещественных чисел в~ранних (отдельных) моделях сопроцессора было 
% необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  
% \pagebreak[3]
% После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.
%  
В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.
% 
\index{Команды!fcomi[p]}%
\index{Команды!fucomi[p]}%
Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (\texttt{fcomi, fcomip, fucomi, fucomip}), которые напрямую устанавливают флаги $ZF, CF, PF$ в~$flags$.
% Эти команды не изменяют биты $C0,  C3, C2$ регистра~$sw$.
% и~не дублируют туда результат сравнения.
Неиспользуемые три флага состояния $flags$ сбрасываются в~$0$; биты $C0, C2,  C3$ слова состояния сопроцессора не изменяются.
\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% \subsubsection{Флаги сравнения}
% % \subsubsection{Сравнение вещественных чисел}
% \index{Флаги!установка}%
% 
% Команды сравнения выставляют значения трёх флагов в~соответствии с~результатом сравнения $st(0)$ и~$src$ (знаком разности~$st(0)-src$):
% флаг отрицательности, флаг нуля и~флаг несравнимости (таблица~\ref{tab:fpu-cmp-flags}).
% 
% 
% \begin{table}[!ht]
% \small\def\normalsize{\small}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% \LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}
% \end{table}


Если при сравнении целых чисел \modifyone[в~регистре~$flags$]{} выставляется значение %флагов из того же набора,
тех же флагов, которые выставляются по результатам арифметических действий,
то в~FPU %флаги сравнения и~флаги, выставляемые при вычислениях, разделены.
% Арифметические и~трансцендентные команды влияют на флаги исключительных ситуаций;
% команды сравнения "--- на специальную группу флагов.
флаги, выставляемые \modifyone[устаревшими]{} командами сравнения\modifyone[~в~слове состояния~$sw$]{}, отличаются от тех, что устанавливаются, в~частности, при вычитании.

\subsubsection{Анализ результатов сравнения}

Условные команды, даже из набора FPU, не могут анализировать флаги слова состояния FPU~$sw$.
Соответственно, если используется одна из \modifyone[устаревших]{старых} команд сравнения, сохраняющая результат в~$cw$, после её выполнения
% Для анализа результата сравнения
% в~этом случае
% % вещественных чисел в~ранних (отдельных) моделях сопроцессора было 
необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  


Это выполняется в~два этапа:
\begin{itemize}
\item 
% \index{Команды!fstsw}%
\index{Команды!fnstsw}%
\index{Команды!sahf}%
слово состояния $sw$ выгружается в~регистр $ax$ 
% командами \lstinline!fstsw! (проверяет на наличие отложенных необработанных исключений) или~\lstinline!fnstsw! (также данные команды могут выгрузить $sw$  в~память);
командой~\lstinline!fnstsw!;
\item старший байт $ax$ загружается в~младший байт регистра флагов $flags$ командой \lstinline!sahf!.
\end{itemize}

% \subsubsection{Соответствие битов слова состояния FPU и~$flags$}

% 
% 
% В~таблице~\ref{tab:fpu-status} представлено краткое описание структуры слова состояния, а~также соответствие старшего байта слова состояния сопроцессора $sw$ и~младшего байта регистра флагов основного процессора~$flags$.
% 
% % \colorlet{csControl}{green!50}
% % \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% % \colorlet{csSystem}{blue!20!red!10}
% 
% 
% \begin{table}[!ht]
% \caption{Слово состояния FPU}
% \label{tab:fpu-status}
% \footnotesize
% 
% \begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% % № 	& 	&Название 	\\\hline
% \multicolumn{3}{c}{$sw$}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}$flags$, fnstsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
% \\\hline
% \rowcolor{clFlagStatus}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
% \rowcolor{clFlagStatus}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
% \rowcolor{clFlagStatus}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
% \rowcolor{clFlagSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
% \rowcolor{clFlagSystem}12 	& 	&&\cellcolor{clFlagStatus}4 	&\cellcolor{clFlagStatus}AF 	&\cellcolor{clFlagStatus}Auxiliary Carry Flag\\
% \rowcolor{clFlagSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
% \rowcolor{clFlagStatus}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
% \rowcolor{clFlagExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
% \end{tabularx}
% \end{table}
% 
% \pagebreak[3]
% %слово состояния $sw$ могло быть выгружено в~память или регистр $ax$ командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки $sw$ в~регистр $ax$ его старший байт загружал
% 
% % Таким образом, после выполнения команды сравнения (%и~%пары команд 
% % % \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% % % или при использовании совместимых с~ними 
% % при использовании совместимых с~ранними моделями 
% % команд %f*com[p[p]]
% % без суффикса~\lstinline!i! 
% % необходимы также \lstinline!fnstsw %ax! + \lstinline!sahf!)
% % результат  можно 
% % анализировать как результат сравнения беззнаковых целых чисел.
% % 
% % 
% % После этого значение $C3$ помещается в~аналогичный ему по смыслу флаг нуля $ZF$ ($st(0) - src = 0$), $C0$ "--- в~флаг переноса~$CF$ ($st(0) - src < 0$),
% % то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
% % Бит несравнимости $C2$ попадает на место флага чётности~$PF$. 
% 
% Как видно из таблицы, 
При загрузке старшего байта~$sw$ во~$flags$
флаг отрицательности~$C0$ помещается во флаг беззнакового переполнения~$CF$,
флаг нуля~$C3$ "--- в~аналогичный ему по смыслу $ZF$,
а~флаг несравнимости $C2$ "--- во флаг чётности $PF$. 
Другие флаги младшего байта~$flags$ получают фактически неопределённое значение.
% 
Таким образом, результат можно анализировать как результат сравнения беззнаковых целых чисел.
\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% 
% % После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% % Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.

Результат современных команды сравнения, напрямую устанавливающих флаги $ZF, CF, PF$ и~обнуляющих остальные флаги состояния в~регистре~$flags$,
можно анализировать как результат сравнения беззнаковых целых чисел без дополнительных действий.


\subsubsection{Определение вида значения}


Кроме команд сравнения, анализирующих разность двух значений $st(0)-src$ как число,
набор команд FPU включает также команду~\lstinline!fxam!, которая анализирует тип содержимого вершины стека (нормальное число, ноль, бесконечность, денормализованное число и~т.\,д.).
% При этом определяются
Эта команда достаточно старая, поэтому записывает результат в~слово состояния FPU.

Команда~\lstinline!fxam! выставляет  в~соответствии с~значением~$st(0)$
все четыре специальных флага $C0-C3$ слова состояния $sw$
 (таблица~\ref{tab:fpu-xam-flags}).
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% \FloatBarrier
\bottompagebreak[8ex]

\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-xam-flags.tex}

\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\index{Неопределённость вещественная}%
\end{table}

% \bottompagebreak


% \bottompagebreak[80mm]

% регистром тегов (в~частности, теги определяют, пуст ли регистр $r_{top}$, соответствующий вершине стека~$st(0)$) и~содержимым~$r_{top}$
 
Флаг~$C1$ всегда устанавливается равным знаковому биту~%$r_{top}$, даже если согласно тегам этот регистр пуст или 
$st(0)$, даже
если в~нём находится значение, не имеющее знака (вещественная неопределённость\index{Неопределённость вещественная} или недопустимое значение).
% \bottompagebreak
Необходимо отметить, что при загрузке флагов FPU в~регистр~$flags$ бит $C1$ попадает на зарезервированный разряд и,~соответственно, игнорируется.

% Флаги сравнения $C0, C3, C2$ получают значения в~соответствии с~таблицей~\ref{tab:fpu-xam-flags}.

Команда~\lstinline!fxam! корректно работает даже при пустом стеке.
Если регистр данных $r_{top}$, соответствующий вершине стека, помечен в~регистре тегов~$tw$ как пустой, % (то есть ), 
флаги  $C0, C3, C2$ получают значения, указанные в~последней строке таблицы~\ref{tab:fpu-xam-flags},
а~$C2$ "--- значение знакового бита~$r_{top}$.

Если $st(0)$ не пуст, флаги  $C0, C3, C2$ соответствуют виду содержащегося в~нём значения (\modifyone[более подробно виды значений FPU описаны в~разделе]{раздел}~\ref{sec:valueclasses}).
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% Конечным значениям~$st(0)$ соответствует нулевое значение~$C0$


% \section{Команды X/Y/ZMM}
% 
% Багровый и белый отброшен и скомкан,
% в зелёный бросали горстями дукаты,
% а чёрным ладоням сбежавшихся окон
% раздали горящие жёлтые карты.
% 
% Владимир Маяковский «Ночь»



\addquestion{Какой порядок операндов принят в~синтаксисе AT\&T?}


% \addquestion Знаковой или беззнаковой является операция инкремента?




% \addquestion{Какие вы знаете регистры общего назначения?}
% \addquestion{Какие вы знаете команды ассемблера x86?}
% \addquestion{Какие вы знаете флаги?}
% \addquestion{Какие регистры используются в~сопроцессоре для хранения операндов?}

\addquestion{Какие вы знаете команды передачи управления?}
\addquestion{Какие вы знаете команды  пересылки данных?}

\addquestion{Какие команды используются для обнуления регистра?}
\addquestion{Какие команды используются для выполнения арифметических операций над целыми числами?}

\addquestion{Какие команды используются для выполнения арифметических операций над вещественными числами?}



\addquestion{Какие команды используются для выполнения тригонометрических операций?}
\addquestion{Какие команды используются для сравнения вещественных чисел?}
\addquestion{Какие флаги регистра $flags$ содержат результат сравнения вещественных чисел?}


\printquestions
