
\chapter{Синтаксис и~команды GNU Assembler x86}

\epigraph{\begin{limerick}
Удалой старичок из Салоников\\
Очень прыгать любил с~подоконников.\\
На вопрос: «Не опасно?»\\
Говорил он: «Прекрасно! "---\\
В~этом прелесть прыжков с~подоконников».
\end{limerick}
}
{\Lear}

Язык ассемблера "--- простейший символический язык программирования, каждая команда которого транслируется в~одну команду машинного языка.
Также существуют операторы ассемблера, не соответствующие машинным командам "--- директивы, комментарии, пустые операторы.

% Для архитектуры x86 разработано множество трансляторов ассемблера, каждый из которых описывает свой язык.

% Для программирования на ассемблере требуется знать хотя бы основные команды.
Набор команд ассемблера определяется как архитектурой используемого компьютера, так и~собственно ассемблером "--- транслятором с~символического языка в~объектный код.
Команды  имеют текстовые мнемонические обозначения (мнемоники).
При этом одной и~той же мнемонике может соответствовать несколько опкодов, выполняющих схожие действия над операндами, расположенными в~разных местах или разного размера.
Часто %отдельный опкод имеют восьмибитные команды
существует один опкод для восьмибитных операндов и~другой "--- для операндов, имеющих размер 32, 64 или 16 бит (для него разрядность операндов определяется текущим режимом и~префиксами).
Таким образом, иногда команды обрабатывают восьмибитные операнды  немного иначе, чем любые другие.
Кроме того, одному опкоду может соответствовать несколько разных мнемонических обозначений.

% Данное пособие описывает программирование на языке
В~данной главе описывается 
часть набора команд
% набор команд
GNU Assembler (GAS) для архитектуры x86
с~использованием традиционного синтаксиса AT\&T\index{Синтаксис!AT\&T},
а~также особенности этого синтаксиса.


\section{Особенности GNU Assembler}
\epigraph{\begin{stanza}
А~тот, кто сторожит баржу, спесив \\
И~вообще не святой;\\
Но тот, кто сторожит баржу, красив \\
Неземной красотой.\\
\end{stanza}}
{\Aquarium}
\label{sec:asm-gas}

G%NU Assembler
AS, как и~его предок, ассемблер Unix as,
% Ассемблер Unix as (его версия из коллекции GCC назывется gas) 
использует так называемый синтаксис AT\&T System V/386, часто называемый просто синтаксисом AT\&T\index{Синтаксис!AT\&T} или синтаксисом GAS~\cite{Assembler-fsf,linux_parallel}.

\index{Синтаксис!Intel}%
Также для процессоров семейства Intel x86 часто используется  синтаксис, предложенный фирмой Intel.
Основными отличиями синтаксиса Intel от  AT\&T считаются обратный порядок операндов, другие обозначения адресации  и~невозможность явного указания разрядности операции.
Менее известно различие в~мнемонических обозначениях команд.
Современные версии ассемблера GAS  поддерживают оба варианта синтаксиса.

Основными недостатками синтаксиса Intel является неоднозначность и~трудность чтения инструкций.
Кроме того, синтаксис Intel используется только для процессоров Intel или совместимых с~ними.

Синтаксис AT\&T\index{Синтаксис!AT\&T} иногда называется кроссплатформенным, так как GCC и, соответственно, GAS  реализован для множества различных архитектур.
Полной кроссплатформенности при использовании языка ассемблера достичь невозможно, 
так как у~каждой платформы свой набор %команд и~регистров, % и~особенностей,
команд, регистров и~методов адресации,
но использование %универсального синтаксиса облегчает %\чтение программ
схожего синтаксиса
облегчает переход между ними.

Также инструкции, записанные в~соответствии с~синтаксисом AT\&T\index{Синтаксис!AT\&T}, легче читаются.
% (кроме косвенной адресации).
Даже обозначение адреса в~памяти, которое вначале кажется контринтуитивным,  распознаётся однозначно.
Косвенный адрес в~памяти, записанный по правилам синтаксиса AT\&T\index{Синтаксис!AT\&T}, невозможно перепутать с~непосредственным значением, что происходит в~диалектах Intel\index{Синтаксис!Intel}.


% \footnote{Использованы материалы:
% GCC-Inline-Assembly-HOWTO, << ссылка в~inline
% Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А. << ниже
% Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
% X86 Assembly/GAS Syntax << вики
% }

\subsection{Общие правила}
\epigraphcensored[
\epigraph{\begin{stanza}[0mm]
И малое замкнулось на великом,\\
И Млечный Путь раскрылся для меня!\\
\end{stanza}}{\Orgia}
% \epigraph{
% Усердный в службе не должен бояться своего незнанья; ибо каждое новое дело он прочтёт. 
% }{К.\,П.\,Прутков}
% \epigraph{\begin{stanza}
% Без имени, как меч кузнеца,\\
% Невиданная без прикрас,\\
% Без начала и без конца,\\
% Бывшая здесь прежде всех нас.\\
% \end{stanza}}
% {\Aquarium}
% \epigraph{\begin{stanza}[0mm]
% Я не знаю, Земля кружится или нет,\\
% Это зависит, уложится ли в строчку слово.
% \end{stanza}}
% {\Khlebnikov}
]{
\epigraph{\begin{stanza}
 Итак, попался. А теперь что делать?
\end{stanza}}
{О.\,Арефьева}
}

Так как GAS в~основном используется на одном из этапов компиляции программы на %языке высокого уровня, о 
C/C++, 
многие синтаксические конструкции GAS и~C/C++ совпадают.

В~программе могут использоваться латинские буквы, цифры, %символы \lstinline!%, $, *, ., —!
а~также нижнее подчёркивание и~точка.
% 
Допустимые пробельные символы "--- пробел и~табуляция;
они могут сочетаться в~любом порядке.
Перевод строки является разделителем операторов.

Допускаются многострочные комментарии  /* в~стиле C */
и~однострочные // в~стиле C++.
% Также поддерживается устаревший 
% #<не выражение> устаревший
Также для различных платформ поддерживаются платформоспецифичные виды однострочных комментариев.
В~частности, для x86, кроме однострочного комментария в~стиле C++, поддерживается символ комментария \lstinline!#!, но он считается устаревшим.

Оператор ассемблера целиком размещается на одной строке.
В~начале строки может быть одна или несколько меток, заканчивающихся двоеточием.
% Перед оператором может быть метка.
Если первый символ оператора "--- точка, то это "--- директива ассемблера (первая строка листинга~\ref{lst:asm:directive:instruction}).
Набор основных директив %в~основном 
совпадает для всех архитектур, но для многих платформ есть и~специфичные (в~частности, директивы определения данных).
\begin{lstlisting}[caption=Директива и~команда, label=lst:asm:directive:instruction]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}
Пустой оператор может состоять только из пробельных символов или быть пустой строкой (вторая строка).
Оператор, начинающийся с~буквы, представляет собой мнемоническое обозначение машинной команды,
за которым при необходимости следуют операнды, разделённые запятыми (третья строка листинга~\ref{lst:asm:directive:instruction}).
% Оператор оканчивается переводом строки или точкой с~запятой.

\index{Литералы}%
Строковые литералы ограничиваются двойными кавычками, экранирующим символом является обратный слеш «\textbackslash»,
спецсимволы кодируются аналогично C/C++.
Числовые литералы также описываются аналогично C/C++.





\subsection{Основные директивы}
\epigraphcensored[
\epigraph{\begin{stanza}[0mm]
 Кто море удержал брегами \\
 И бездне положил предел, \\
 И ей свирепыми волнами \\
 Стремиться дале не велел?
\end{stanza}}
{М.\,В.\,Ломоносов}
% \begin{stanza}
% Белая, как сибирский мел,\\
% Белая, как нетронутый лист,\\
% Я отдал тебе всё, что имел,\\
% Теперь я чёрный, как трубочист.\\
% \end{stanza}}
% {\Aquarium}
% \epigraph{Таким  образом, если
% помимо  чувственно  воспринимаемых   вещей  и  математических  предметов  не~существует каких-либо иных, таких,  как Эйдосы, о коих говорят некоторые, то~не будет существовать  единой  по числу и  по  виду сущности, и начала вещей
% будут ограничены не по числу, а [только] по виду.}
% {\Metaphiz}
% \epigraph{Итак, слово, как это было сказано вначале, что-то  обозначает, и~притом
% что-то  одно.}
% {\Metaphiz}
% \epigraph{\begin{stanza}
% Что нам подвластно? Гранитные поля,\\
% Птицы из пепла, шары из хрусталя.
% \end{stanza}}
% {\Aquarium}
]{
\epigraph{\begin{stanza}
Не танцевать же мы на танцы ходим!
% Так слово за слово "--- и выучишься мату.
\end{stanza}}
{О.\,Арефьева}
}
Директива ассемблера не соответствует никакой машинной команде.
Рассмотрим несколько наиболее употребительных директив; их можно разбить на несколько классов.

\subsubsection{Директивы определения секций}
\index{Сегмент}

Как было описано в~разделе~\ref{sec:mem-segments}, код программы и~различные виды данных должны располагаться в~различных диапазонах адресного пространства.
По историческим причинам эти диапазоны называются сегментами (соответствующие фрагменты исходного кода и~исполняемого файла "--- секциями).
Начало содержимого того или иного сегмента в~исходном ассемблерном коде отмечается специальными директивами.

С~начала файла до первой директивы располагается сегмент кода.
Указать продолжение сегмента кода можно директивой \termin{.text}.

Сегмент данных открывается директивой \termin{.data}.
В~принципе, описание статических данных в~сегменте кода не вызовет ошибки, но такие данные будет невозможно модифицировать, так как сегмент кода защищён от изменений.

% Данные, которые не должны изменяться (доступные только для чтения), описываются в~специальной секции, открываемой директивой  \termin{.rodata}.

% 
% Те глобальные и~статические переменные, которые не были инициализированы при объявлении,
% отделяются  в~специальный \termin{сегмент BSS.}
% % \termin{.bss}

Для сегментов стека\index{Стек} и~кучи\index{Куча} нет соответствующих секций, они заполняются динамически в~процессе выполнения программы.

\subsubsection{Директивы определения данных}

В~сегменте \texttt{.data} статические данные описываются также с~помощью  директив.

После директивы определения данных указывается литерал подходящего типа или несколько литералов, перечисленных через запятую.
В~памяти соответственно  резервируется одна или несколько ячеек соответствующего размера, которые инициализируются указанными значениями.

Для того, чтобы дать адресу ячейки имя, перед соответствующим определением необходимо поставить метку
(листинг~\ref{lst:asm:directive:data}).
\begin{lstlisting}[caption=Определение статических данных, label=lst:asm:directive:data]
foo: .long 0, 1, 2
bar: .double -8.7
\end{lstlisting}
Важно помнить, что ассемблер, в~отличие от языков высокого уровня, не является типизированным.
Таким образом, если, в~частности, 
по адресу $bar$ расположено  восьмибайтовое значение двойной точности~$-8,7$,
а~программист обратится к~нему как к~числу одинарной точности (четыре байта), это не вызовет сообщения об ошибке, но прочитанное значение будет другим.

Для инициализации памяти целыми значениями различного размера используются следующие директивы:
\termin{.byte} %одно или несколько выражений, разделённых запятыми
"--- однобайтовое (восьмибитное) целое,
\termin{.short}
% \termin{.short .half }
"--- %двухбайтовое,
шестнадцатибитное,
% \termin{.int (.long)}
% "--- четырёхбайтовое,
\termin{.long} 
"--- тридцатидвухбитное,
\termin{.quad}
"--- шестидесятичетырёхбитное. %восьмибайтовое 
Размер и~порядок байтов определяются платформой;  приведены размеры для x86 (они же наиболее распространённые).
Также существуют директивы  \termin{.word} и~\termin{.int}, для x86 %эквивалентные .short и~.long 
определяющие шестнадцати- и~тридцатидвухбитные целые
соответственно.
%  H8/500. However, on this platform the `.int' and `.word' directives generate 16-bit numbers.
% On the Sparc, the .word directive produces 32 bit values, instead of the 16 bit values it produces on many other machines. 
 
Значения с~плавающей запятой одинарной (32 бита) и~двойной (64 бита) точности описываются директивами
\termin{.float
(.single)}
и~\termin{.double}. %одно или несколько вещественных значений, разделённых запятыми

Для инициализации памяти строковыми константами различного вида используются 
% следующие директивы.
директивы \termin{.string (.asciz)} и~\termin{.ascii}.


Функции стандартной библиотеки C используют строки, завершающиеся нулём; 
их можно описать директивой
\termin{.string (.asciz)} (листинг~\ref{lst:asm:directive:asciz}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки, завершающейся нулём}, label=lst:asm:directive:asciz]
msg: .string "Hello, world!\n"
\end{lstlisting}
Если после директивы указывается несколько строковых литералов через запятую, завершающий ноль добавляется после каждого.

Строка без завершающего нуля
 описывается директивой
\termin{.ascii} (листинг~\ref{lst:asm:directive:ascii}). %"строка" 
% используется для описания строк, завершающихся нулём
\begin{lstlisting}[caption={Определение строки без завершающего нуля}, label=lst:asm:directive:ascii]
msg:
.ascii "Hello, world!\n"
len = . - msg // символу len присваивается длина строки
\end{lstlisting}
Для обработки подобных строк нужно знать их длину (её нельзя определить, анализируя содержимое памяти%, так как строка 
).
Для этого используется специальный символ «.» "--- адрес текущего оператора (в~том числе ячейки с~данными).
% Строки без завершающего нуля используются, в~частности

Директивы определения данных точно так же сработают и~будучи размещёнными в~сегменте кода (\texttt{.text} или неименованная секция в~начале программы),
но такое размещение будет ошибкой.
Если данные попадут во фрагмент кода, который выполняется, они будут интерпретированы как команды, что, скорее всего, приведёт к~сбою при декодировании.
Даже если данные находятся в~той части кода, которая не получает управления, их будет невозможно модифицировать.

\subsubsection{Прочие директивы}

Парные директивы
\termin{.rept $\ldots$ .endr} соответствуют повторению фрагмента между ними,
в~частности
\begin{lstlisting}[caption=Директива \texttt{.rept}, label=lst:asm:directive:rept]
.rept 4   
.long 0   
.endr     
\end{lstlisting}
интерпретируется как четырёхкратное повторение оператора \lstinline!.long 0!:
\begin{lstlisting}[caption={Эквивалентное описание данных без использования \texttt{.rept}}, label=lst:asm:directive:rept-result]
.long 0
.long 0
.long 0
.long 0
\end{lstlisting}
Директивы \texttt{.rept $\ldots$ .endr} могут применяться и~к~командам. 
При этом происходит именно многократное дублирование  фрагмента кода в~исполняемом файле, а~не циклическое повторение одной и~той же его копии.

Директива
\termin{.globl (.global)}
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает 
% описанный в~файле
символ  доступным компоновщику (видимым из других модулей).
\begin{lstlisting}[caption=Перевод символа $main$ в~глобальную область видимости, label=lst:asm:directive:global]
.globl main
\end{lstlisting}
% Директива \texttt{.globl} или \texttt{.global} (возможны оба написания) не определяет символ.
% , он должен быть описан 
Переменные и~функции, имена которых сделаны общедоступными при помощи директивы \texttt{.globl} или \texttt{.global} (возможны оба написания), могут быть импортированы, в~частности, в~модуль на C++ с~помощью ключевого слова \lstinline!extern!.

Парные директивы
\termin{.func  $\ldots$  .endfunc} включают в~исполняемый файл отладочную информацию о~функции (только при сборке в~отладочном режиме).

Таким образом, если в~файле несколько функций, можно указать для отладчика их границы.
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S:endfunc]
\begin{lstlisting}[caption=Границы функции $sqr()$, label=lst:sqr.S:endfunc]
.globl sqr
.func sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
.endfunc
\end{lstlisting}
Директивы \texttt{.func  $\ldots$  .endfunc} не влияют ни на что, кроме отладочной информации.
В~режиме Release игнорируются.


\subsection{Порядок операндов}
\epigraphcensored[\epigraph{\begin{stanza}[0mm]
Путь-дорога, господа!\\
Вы откуда и куда?
\end{stanza}}
{П.\,П.\,Ершов}]
{
\epigraph{\begin{stanza}
    Он, пол сменив, сменил и потолок!
\end{stanza}}
{О.\,Арефьева}
}

В~GAS принят порядок записи операндов слева направо, следуя европейскому направлению письма.
% В~отличие от синтаксиса Intel, 
Соответственно, инструкция GAS обычно имеет вид
% , приведённый в~листинге~\ref{lst:asm:instruction-common-source-destination}.
% [caption=Источник и~приёмник команды, label=lst:asm:instruction-common-source-destination]
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.

Для команд с~тремя операндами (один из них в~x86 "--- всегда непосредственное значение) вначале записывается непосредственное значение, затем источник, затем приёмник.
\begin{lstlisting}
mnemonic immediate, source, destination
\end{lstlisting} 
% [caption={Источник, приёмник и~непосредственный операнд команды}, label=lst:asm:instruction-common-source-destination-imm]

Если среди операндов нет приёмника (в~частности, команды %\lstinline!bound!, \lstinline!invlpga! и~команды 
с~двумя непосредственными операндами, такие как \lstinline!enter!), 
порядок в~AT\&T совпадает с~порядком, указанным в~документации Intel~\cite{Assembler-fsf}.
%  AT&T and Intel syntax use the opposite order for source and destination operands. Intel ‘add eax, 4’ is ‘addl $4, %eax’. The ‘source, dest’ convention is maintained for compatibility with previous Unix assemblers. Note that ‘bound’, ‘invlpga’, and instructions with 2 immediate operands, such as the ‘enter’ instruction, do not have reversed order. i386-Bugs. 

При этом, если команда принимает операнды в~регистрах или памяти, но не модифицирует их (в~частности, команды сравнения~\lstinline!cmp! или~выделения бита \lstinline!bt!), %это не значит, что у~неё нет приёмника.
в~большинстве случаев один из операндов всё равно считается приёмником.
% причём 
Каждая из приведённых команд входит в~семейство, %схожих команд, большая часть которых 
большая часть команд которого
модифицирует этот операнд.
 
В~частности, рассмотрим одну из наиболее употребительных мнемоник ассемблера "--- команду пересылки (копирования) \lstinline!mov!.
\index{Команды!mov}%
Она соответствует оператору присваивания языков высокого уровня.
Её операнды "--- источник (обозначим его $src$) и~приёмник ($dest$).
В~синтаксисе Intel пересылка $dest = src$ имела бы вид \lstinline!mov dest, src!; в~используемом в~данном пособии синтаксисе AT\&T она имеет вид \lstinline!mov src, dest!.
% 
Например, команда \lstinline!movb $0x05, %al! помещает значение~5 в~регистр~$al$.

\subsection{Адресация операндов}
\epigraphcensored[
\epigraph{
"--* Но позволительно ли вешать его, не поймав? "--- заметил я. "--- А~в~остальном я~охотно предоставляю вам полагаться на ваши умозаключения.
% Катриона
}{Р.\,Л.\,Стивенсон}
]{
% \epigraph{
% %      - Хорошо, - сказал я. - Я~тоже задам  последовательность  вопросов  о
% % местоположении.
% %      - Задавай, задавай, - пробормотал Чапаев.
% %      - Начнем по порядку. 
% "--* Вот вы расчёсываете лошадь. А~где находится  эта лошадь?
% %      Чапаев посмотрел на меня с~изумлением.
% %      - Ты что, Петька, совсем охренел?
% %      - Прошу прощения?
% 
%       "--* Вот она.
% }{В.\,Пелевин}

\epigraph{

"--* Где, "--- спрашивает, "--- ты живёшь?

"--* Ступай, "--- говорит, "--- прямо, повороти направо. Тут~будет пень большой. Ты разбегись да треснись башкой. Как искры из глаз посыплются "--- тут меня и~увидишь...
}{П.\,Бажов}
}


\index{Адресация!виды}%
\label{sec:addressing}


Параметры команд ассемблера, в~отличие от операндов ЯВУ, не могут быть произвольными выражениями.
В~разделе~\ref{sec:addressing:common} были описаны различные виды адресации.
% Каждому из них соответствует об
Рассмотрим обозначения, принятые в~GAS для методов адресации явно передаваемых параметров команд x86.

% % Данные могут адресоваться различными способами.
% Для %них 
% явно передаваемых параметров
% доступны следующие методы адресации:
\begin{enumerate}
\item \termin{Непосредственная}\index{Адресация!непосредственная} "--- константа, 
значение которой при компиляции непосредственно включается в~код команды
(адрес глобальной переменной или выражение, вычисляемое на этапе компиляции, %в~частности, 
также является непосредственным значением).

Непосредственные операнды отмечаются префиксом~\lstinline!$!.
% 
Например, \lstinline!$0!, \lstinline!$13!, \lstinline!$0xFFFFFFFF!, \lstinline!$(0 + 1 + 2*2 - 7/4)! (значение, равное $4$), \lstinline!$n! (адрес глобальной переменной $n$).


\item \termin{Прямая}\index{Адресация!прямая} (абсолютная) "--- переменная в~памяти по~фиксированному адресу (статическая или глобальная),
адрес при компиляции также включается в~код команды.

Операнды, описываемые статическим адресом в~памяти, не имеют префикса.
% 
Например, \lstinline!0! (вызовет ошибку чтения по нулевому адресу), \lstinline!n!~(значение глобальной переменной $n$).


\item \termin{Прямая относительная}\index{Адресация!прямая относительная}, также $rip$-relative или PC-relative, от  program counter   "--- переменная или функция располагается в~памяти по~фиксированному адресу, но в~команду включается не сам адрес, а~его смещение относительно указателя команд $ip$.

Для адресов в~коде (функций, меток для перехода) неявно применяется по умолчанию как в~тридцатидвухбитном, так и~в~шестидесятичетырёхбитном режиме.
% (в~шестнадцатибитном режиме ).
Операнд не имеет префикса и~в~ассемблером коде выглядит так же, как и~прямой абсолютный адрес: 
\lstinline!call func!, \lstinline!jmp label!.
% \lstinline!func!, \lstinline!label!.

В~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} появилась возможность использовать прямую относительную адресацию и~для данных.
Операнд выглядит как базовый адрес со смещением, где базой явно задан указатель команд: 
\lstinline!lea msg(%rip), %rsi!
% \lstinline!msg(%rip)!
(здесь \texttt{msg} "--- метка в~секции данных).
% , вручную рассчитывать
Относительная адресация используется только для базового регистра $rip$.
Аналогичная запись с~другой базой соответствует косвенной адресации и~использованию \emph{абсолютного}, а~не относительного адреса \texttt{msg}.


\item \termin{Регистровая}\index{Адресация!регистровая} "--- переменная в~регистре,
в~команду при компиляции включается имя (номер) регистра;

Операнды в~регистрах отмечаются префиксом~\lstinline!%!.
% 
Например, \lstinline!%eax!, \lstinline!%dh!, \lstinline!%bp!, \lstinline!%rsi!, \lstinline!%r13!.

\item \termin{Косвенно-регистровая (косвенная)}\index{Адресация!косвенная} "--- переменная в~памяти,
указатель на неё в~регистре (или наборе регистров).

{
% \sloppy

Например, 
% Например, для адресации значения
\lstinline!(%ebp)! "---  значение в~памяти по адресу $ebp$.
Можно указать смещение относительно адреса, хранимого в~регистре: \lstinline!4(%esp)! "--- значение в~памяти 
по адресу $esp+4$.


%, так, 
В~x86-совместимых процессорах для косвенной адресации можно использовать до двух регистров и,~%совместно с~ними, 
кроме того, до двух констант.
Таким образом, 
для вычисления адреса используется до четырёх параметров:
\lstinline!4(%ebp, %edi, 8)! "--- значение  в~памяти по адресу \mbox{$ebp + 8edi + 4$.}
Часть параметров может отсутствовать:
\lstinline!(%edx, %esi, 8)! "--- значение по адресу $edx+8esi$, 
\lstinline!(%edx, %esi)! "--- по адресу \mbox{$edx+esi$,}
\lstinline!(,%esi, 8)! "--- по адресу $8esi$.

}

%указатель в~регистре
% $$
% \text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Disp
% $$
% $\Reg{Base}$ и~$\Reg{Index}$ "--- регистры, $Disp$ "--- смещение (константа)
\end{enumerate}

\subsubsection{Компоненты адреса}

В~языке ассемблера x86 конструкция косвенной адресации %, соответствующая разыменованию указателя на ЯВУ, является более сложной и~гибкой, чем в~C++,
% и~включает в~себя вычисление адреса и~собственно разыменование (%часть возможностей адресации 
включает в~себя вычисление адреса и~его разыменование
% частично адресация эквивалентна операции обращения к~элементу массива "--- оператор []
% (в~этом смысле косвенная  адресация частично является аналогом оператора
(частичным аналогом может быть
оператор обращения к~элементу массива  на ЯВУ "--- \lstinline![]!,
а~для сокращённых форм "--- разыменование указателя "--- \lstinline!*!, но при этом косвенная адресация "--- более сложный и~гибкий механизм).

Как было сказано в~разделе~\ref{sec:rm:addressing}, команда x86 может содержать до четырёх полей, задающих адрес "--- номер базового регистра
% $base$, номер индексного регистра $index$, показатель масштаба индекcного регистра ${scale}$ и~смещение $displacement$.
$Base$, номер индексного регистра $Index$, показатель масштаба индекcного регистра ${Scale}$ и~смещение $Displacement$.


Используя для обозначения разыменования $*$, как в~С++,
результат вычисления адреса с~разыменованием в~полной форме (с~четырьмя параметрами) можно записать как
\begin{equation}
\label{eq:asm:full-addressing}
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% *\big({Base} + scalar\,multiplier \cdot {Index} + Displacement\big)
% *\big({base} + scalar\,multiplier \cdot {index} + displacement\big)
*\big({Base} + \sigma\cdot {Index} + Displacement\big)
% *\big({Base} + \gamma\cdot {Index} + Displacement\big)
% *\big({Base} + \alpha\cdot {Index} + Displacement\big)
% *\big({Base} + \theta\cdot {Index} + Displacement\big)
\end{equation}
% где $base$ и~$index$ "--- значения соответствующих регистров (32-разрядные для соответствующей платформы), $displacement$ "--- целое знаковое число (смещение), $scalar\,multiplier$ "--- натуральное число (масштабный коэффициент "--- степень двойки $2^{scale}$, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
где $Base$ и~$Index$ "--- значения соответствующих регистров (32-разрядные для соответствующей платформы), $Displacement$ "--- целое знаковое число (смещение), $\sigma$ "--- натуральное число (масштабный коэффициент "--- степень двойки $2^{Scale}$, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% This is equivalent to [base register + displacement + offset register * scalar multiplier] in Intel syntax. 
% Either or both of the numeric, and either of the register parameters may be omitted:
Одно или оба числовых значения, а~также любой из регистров могут быть опущены (%в~этом случае 
если не указан масштаб, используется 
% $scalar\,multiplier = 1$, 
$\sigma = 1$,
вместо остальных пропущенных параметров  используется~$0$).

\subsubsection{Полная форма косвенной адресации}
\label{sec:full-att-addressing}

{
\lstset{language=}

% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
Полная форма косвенной адресации (вычисления адреса с~разыменованием) в~GAS, соответствующая~\eqref{eq:asm:full-addressing}, имеет вид
% \begin{lstlisting}
% displacement(%base, %index, scalar multiplier)
% \end{lstlisting} 
\begin{lstlisting}
displacement(%base, %index, /*@$\sigma$@*/)
\end{lstlisting} 
% [caption={Формат описания адреса в~памяти}, label=lst:asm:pointer-common]
% где \lstinline!base! и~\lstinline!offset! "--- регистры (32-разрядные для соответствующей платформы), \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки, причём только $1, 2, 4$ или~$8$ из-за размера соответствующего поля в~теле команды).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% В~соответствии с~синтаксисом Intel это записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
Любой из компонентов может отсутствовать, в~этом случае опускается %и~отделяющ%ая его от предыдущих запятая.
% ий его от предыдущих
и~соответствующий разделитель (только в~одном  случае "--- когда отсутствует база, но есть индекс "--- разделяющая их запятая сохраняется, чтобы отличать эту ситуацию от базы без индекса).

Таким образом, прямая адресация в~принципе может рассматриваться как частный случай косвенной,
когда  оба регистра и~масштабный коэффициент опущены вместе со скобками, и~адрес равен смещению $Displacement$.

}

Например, следующая команда использует все четыре параметра и~загружает 
% в~$a$ значение  $*\big(bp - 4 + (d \cdot 4)\big)$
в~$A$ значение  $*\big(bp+ D \cdot 4 - 4 \big)$
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
(команда \lstinline!mov src, dest! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера).
\begin{lstlisting}
movl  -4(%ebp, %edx, 4), %eax	// eax = *(ebp + 4edx - 4)
\end{lstlisting} 
% [caption={Расчёт $A = *(bp+ 4D - 4) $}]
Чаще используются сокращённые варианты адресации, когда указывается только часть параметров~\cite{Bartlett-Programming-from-the-Ground-Up,Assembler-fsf}.

\subsubsection{Базовая косвенная адресация со смещением}

Если используется только параметр~$Base$, получим эквивалент разыменования указателя в~C++.
% Копирование значения по указателю (\lstinline!*ECX!) в~регистр (без смещения):
В~частности, следующая команда записывает %значение $*C$ 
четырёхбайтовое значение по адресу~$C$
в~регистр $D$.
\begin{lstlisting}
movl  (%ecx), %edx	// edx = *ecx
\end{lstlisting} 

С~параметрами~$Base$ и~$Displacement$ получим $*\big(Base + Displacement\big)$, что соответствует обращению к~полю структуры ($Base$ "--- адрес структуры, константа~$Displacement$ "--- относительное смещение нужного поля), к~параметру функции или к~локальной переменной.
% Загрузка в~\EAX{} значения стековой переменной (из адреса \lstinline!EBP - 4!):
Следующая команда загружает значение %\lstinline!*(EBP - 4)! 
из адреса $bp - 4$)
в~регистр $A$.
\begin{lstlisting}
movl  -4(%ebp), %eax	// eax = *(ebp - 4)
\end{lstlisting} 
При передаче параметров функции через стек\index{Стек} обратиться к~ним внутри функции можно только используя %косвенную 
адресацию 
относительно указателя стека~$sp$.
% 
На вершине стека, то есть по адресу $*sp =$\lstinline!(%esp)!, находится адрес возврата.
Под ним (но по б\'{о}льшему адресу, так как стек растёт вниз) помещаются параметры.

 
\subsubsection{Базово-индексная косвенная адресация}

При использовании всех параметров, кроме $Displacement$, получим $*\big(Base + \sigma \cdot {Index}\big)$, что соответствует обращению к~элементу массива.
Действительно, адрес элемента одномерного массива складывается из адреса начала массива, индекса элемента и~размера элемента, то есть запись~$M[i]$ эквивалентна $*\big(M + i\cdot sizeof(M[0])\big)$.
Если размер элемента равен $1, 2, 4$ или~$8$, 
он может быть масштабным коэффициентом ($\sigma$)
и~к~элементу можно обратиться, используя три из четырёх параметров адреса: $*\big(Base + Index \cdot \sigma\big)$.

В~частности, адрес $i$-го элемента массива~$M$ из~чисел типа \lstinline!int! %обычно 
равен $M + i\cdot 4$.
Если адрес начала массива~$M$ находится в~регистре~$C$, а~индекс "--- в~$si$, то элемент $M[i]$, или $*(M + i\cdot 4)$,
будет записан как~\lstinline!(%ecx, %esi, 4)!.
Соответственно, запись~$M[i]$ в~регистр~$A$ будет выглядеть следующим образом:
\begin{lstlisting}
movl (%ecx, %esi, 4), %eax  // eax = *(ecx + 4esi) = C[si]
\end{lstlisting} 

Если размер элемента равен одному байту, адрес можно записать ещё компактнее:
\begin{lstlisting}
movl (%ecx, %esi), %eax  // eax = *(ecx + esi)
\end{lstlisting}

На платформах, отличных от x86 и~x86-64, могут использоваться другие методы адресации и,~соответственно, немного другие обозначения для них.


% Индексация выполняется с помощью заключения индексного регистра в скобки,
% например, \verb|in testb \$0x80, 17(%ebp)| (проверить установку старшего бита
% в байте по смещению 17 от ячейки, указанной \verb|ebp|).

% А теперь несколько примеров
% 
%     +------------------------------+------------------------------------+
%      |       Intel Code             |      AT&T Code                     |
%      +------------------------------+------------------------------------+
%      | mov     eax,1                |  movl    $1,%eax                   |   
%      | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
%      | int     80h                  |  int     $0x80                     |   
%      | mov     ebx, eax             |  movl    %eax, %ebx                |
%      | mov     eax,[ecx]            |  movl    (%ecx),%eax               |
%      | mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
%      | mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
%      | add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
%      | lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
%      | sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
%      +------------------------------+------------------------------------+
%      
% 


\subsection{Размер операндов команды}
\epigraphcensored[
\epigraph{\begin{stanza}[0mm]Еду я на своём камазике...\\А~из-за поворота навстречу мне жигулище!\end{stanza}}
{Фольклор}]
{
\epigraph{\begin{stanza}
    Из вредности на красный свет не ходит!
\end{stanza}}
{О.\,Арефьева}
}
\label{sec:att-suffixes}

Большая часть мнемоник соответствует не одной команде уровня архитектуры команд, а~целому семейству однотипных команд, которые выполняют одни и~те же действия над операндами различных размеров и, соответственно, имеют разные коды.

Размер операндов маркируется суффиксом,
добавляемым к~базовой форме мнемоники;
например,
копирование  (базовая форма команды "--- \lstinline$mov$) из~$edx$ в~$eax$ (размер операндов $long$) записывается как
\lstinline!movl %edx, %eax!.
Суффиксы перечислены в~таблице~\ref{tab:asm-suffixes}.

\begin{table}[!ht]
\caption{Суффиксы размера операндов}
\label{tab:asm-suffixes}

\noindent\begin{tabularx}{\linewidth}{|c|C|C|}
\hline
\thead{Суффикс} & 
% \thead{Целые} 
\begin{tabular}{@{}c@{}}
\theadfont{Целый}\\
\theadfont{операнд (бит)}
\end{tabular}
& 
% \thead{Вещественные} 
\begin{tabular}{@{}c@{}}
\theadfont{Вещественный}\\
\theadfont{операнд (бит)}
\end{tabular}
\\\hline
    b & byte (8) &\\\hline
    s & short (16) & single (32) \\\hline
    w & word (16) &\\\hline
    l & long (32) & double (64) \\\hline
    q & quad (64) &\\\hline
    t & & ten bytes (80) \\\hline
%     o & octuple (128 бит)&\\\hline
\end{tabularx}
\end{table}
Необходимо отметить, что для целочисленных команд и~команд обработки вещественных чисел одни  и~те же суффиксы означают различную разрядность.
Некоторые суффиксы допустимы только для одного семейства команд.
Для целочисленных команд суффиксы~\lstinline!s! и~\lstinline!w! обозначают 16-битное целое и~в~целом  равноправны
(для команды \lstinline!mov! используется только~\lstinline!w!, так как существует другая команда с~базовой формой \lstinline!movs!).
\index{Команды!mov}%

У~команд с~операндами разных размеров указывается два суффикса.
Порядок суффиксов, как и~порядок операндов "--- слева направо (от источника к~приёмнику).
Так, копирование целого числа со знаковым расширением (базовая форма команды "--- \lstinline$movs$) из~$al$ в~$edx$ выглядит как
\lstinline!movsbl %al, %edx!.
\index{Команды!movs}%
% \index{Команды!movz}%
% в синтаксисе AT&T означает "расширить знак от %al к %edx". Таким образом возможны суффиксы `bl' (от byte к long), `bw' (от byte к word) и `wl' (от word к long). 
% http://www.opennet.ru/docs/RUS/gas/gas-8.html
Возможны двойные суффиксы \lstinline'bl' (от $byte$ к~$long$), \lstinline'bw' (от $byte$ к~$word$) и~\lstinline'wl' (от $word$ к~$long$) и~так далее.
Суффикс~\lstinline!s! не используется как компонент составного суффикса (таблица~\ref{tab:asm-2suffixes}).


\begin{table}[!ht]
\caption{Двойные суффиксы размера для копирования целых чисел с~расширением}
\label{tab:asm-2suffixes}

\begin{tabularx}{\linewidth}{|c|ClC|}
\hline
\thead{Суффикс} & 
% \multicolumn{3}{|c|}{\theadlong{Расширение (бит)}} 
\thead{Источник (бит)} && \thead{Приёмник (бит)}
\\\hline
    bw & byte (8)  & $\to$ & word/short (16)	\\\hline
    bl & byte (8)  & $\to$ & long (32)	\\\hline
    bq & byte (8)  & $\to$ & quad (64)	\\\hline
    wl & word/short (16) & $\to$ & long (32)	\\\hline
    wq & word/short (16) & $\to$ & quad (64)	\\\hline
    lq & long (32) & $\to$ & quad (64)	\\\hline
\end{tabularx}
\end{table}


% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  %размер может быть определён по регистровому операнду.
GAS определяет размер по  регистровому операнду.
% Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
Такое поведение несовместимо с~оригинальным ассемблером AT\&T Unix, который предполагает, что отсутствие суффикса означает размер операнда $long$.
Эта несовместимость не влияет на компиляцию с~ЯВУ, так как компиляторы всегда выставляют суффиксы размера~\cite{Assembler-fsf}.

Если размер не удалось определить по операндам (то есть используются либо непосредственные операнды, либо расположенные в~памяти),
по умолчанию \modifyone[для основного набора команд]{} принимается размер $long$ (32 бита).
% Отсутствие суффикса чаще всего не вызывает ошибки компиляции,
Такая ситуация не всегда вызывает ошибку компиляции,
но 
\modifyone[в~некоторых случаях приводит к~странному результату.
Особенно внимательным надо быть при обработке командами FPU операндов, находящихся в~памяти,
так как при отсутствии суффикса размера 
для целых  операндов FPU используется размер $short$ (16~бит),
а~для вещественных "--- одинарная точность ($float$, 32~бита).]
{при обработке чисел с~плавающей запятой, находящихся в~памяти, приводит к~странному результату, так как по умолчанию используется операнд одинарной точности.}


\subsection{Мнемоники}
\epigraphcensored[\epigraph{
\begin{stanza}
Научный вестник,\\
пожалуйста, не пугайтесь!\\
Полный перечень\\
так называемых ругательств!
\end{stanza}
}{\Vvm[Клоп]}]
{\epigraph{\begin{stanza}
    Нет, я людей практически не ем...
\end{stanza}}
{О.\,Арефьева}}
\label{sec:att-mnemonic}

Первоначальные мнемонические обозначений команд процессора предлагаются
% предложена 
его разработчиками в~документации, описывающей набор команд.
В~дальнейшем ассемблеры в~основном используют именно их.
Большая часть мнемоник GAS (их базовые формы) также совпадает с~документацией Intel.

Тем не менее, часть обозначений различается.
В~частности, отличаются базовые формы команд копирования со знаковым расширением ($movs$ в~GAS, $movsx$ в~Intel)
и~копирования с~беззнаковым расширением  ($movz$ в~GAS, $movzx$ в~Intel)\modifyone[; подробнее они описаны в~разделе~\ref{sec:asm-conversion-mov}]{}.
\index{Команды!movs}%
\index{Команды!movz}%
\index{Команды!расширения}%
\index{Команды!удвоения разрядности $A$}%
\modifyone[Впрочем, для данных команд некоторые шестидесятичетырёхбитные версии GAS используют обозначения Intel; для этих версий мнемоники $movs$ и~$movz$ некорректны.]{}

% Кроме того, 
Синтаксис AT\&T предлагает для команд знакового расширения (их неявным аргументом всегда является регистр~$A$\modifyone[; подробнее в~разделе~\ref{sec:asm-conversion-A}]{}) обозначения, построенные по схеме $cStD$ (convert $S$ to $D$), 
где $S$ "--- суффикс размера источника, $D$ "---  суффикс размера или обозначение расположения (в~случае расширения в~пару регистров) приёмника.
В~документации Intel приведены другие обозначения: они построены по схеме $cSD$ или $cSDe$ и~используют другие обозначения размера\modifyone{ (раздел~\ref{sec:asm-conversion-A})}.
% https://sourceware.org/binutils/docs/as/i386_002dMnemonics.html
% The Intel-syntax conversion instructions
% 
%  ‘cbtw’   ‘cbw’ — sign-extend byte in ‘%al’ to word in ‘%ax’,
%  ‘cwtl’   ‘cwde’ — sign-extend word in ‘%ax’ to long in ‘%eax’,
%  ‘cwtd’   ‘cwd’ — sign-extend word in ‘%ax’ to long in ‘%dx:%ax’,
%  ‘cltd’   ‘cdq’ — sign-extend dword in ‘%eax’ to quad in ‘%edx:%eax’,
%  ‘cltq’   ‘cdqe’ — sign-extend dword in ‘%eax’ to quad in ‘%rax’ (x86-64 only),
%  ‘cqto’   ‘cqo’ — sign-extend quad in ‘%rax’ to octuple in ‘%rdx:%rax’ (x86-64 only), 
% 
% are called ‘cbtw’, ‘cwtl’, ‘cwtd’, ‘cltd’, ‘cltq’, and ‘cqto’ in AT&T naming. as accepts either naming for these instructions. 
% GAS поддерживает как вариант AT\&T, так и~вариант Intel.
\index{Команды!cbw/cbtw}%
\index{Команды!cwde/cwtl}%
\index{Команды!cwd/cwtd}%
\index{Команды!cdqe/cltq}%
\index{Команды!cqo/cqto}%
При программировании в~GAS с~использованием синтаксиса  AT\&T можно без ограничений использовать для команд расширения регистра~$A$
как вариант AT\&T, так и~вариант Intel.

Опкоды дальнего перехода (с~указанием сегмента и~абсолютного адреса) в~AT\&T соответствуют мнемоникам  \lstinline!lcall!\modifyone[/\lstinline!lret!]{} (long call\modifyone[/long return]{}) и~\lstinline!ljmp! (long jump), 
в~то время как Intel обозначает их как \lstinline!call far!\modifyone[/\lstinline!retf!]{} и~\lstinline!jump far!.
\modifyone[Для этих команд GAS также поддерживает оба варианта.]{}

Для несимметричных арифметических команд обработки чисел с~плавающей точкой (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
GAS использует те же мнемоники, что и~Intel, но при этом реализует качественно иное поведение %(подробнее в~разделе).
(раздел~\ref{sec:fpu-trouble-with-fsub}).
\index{Команды!fsub[p]}%
\index{Команды!fsubr[p]}%
\index{Команды!fdiv[p]}%
\index{Команды!fdivr[p]}%

В~шестидесятичетырёхбитном режиме команда загрузки шестидесятичетырёхбитного непосредственного значения в~регистр обозначается \lstinline!movabs! в~синтаксисе AT\&T (загрузка абсолютного адреса).
\index{Команды!movabs}%
Синтаксис Intel не выделяет единственную команду с~шестидесятичетырёхбитным непосредственным операндом из семейства команд пересылки и~обозначает её как \lstinline!mov!.

\subsection{Префиксы}
\epigraphcensored[
\epigraph{
\begin{stanza}[0mm]
И в тот же самый миг безмерность\\
Мне в грудь плеснула, как волна,\\
И понял я, что достоверность\\
Теперь навек обретена.\\
\end{stanza}
}{Н.\,C.\,Гумилёв}
]
{\epigraph{\begin{stanza}
%     Чудесны рифмы в Ваших одностишьях…
        Инструкция к ёлке: «товар несъедобен».
\end{stanza}}
{О.\,Арефьева}
}

Как уже было сказано, регистры и~непосредственные операнды обозначаются специальными префиксами.
Для ассемблера x86 имена {регистров} начинаются с~\lstinline!%!,
% (\lstinline!%eax!, \lstinline!%dl!);
% 
а~непосредственные значения (константы) отмечаются префиксом \lstinline!$!.
% , например,
% \lstinline!addl $5, %eax!
% (добавить константу 5 к~регистру $A$).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных. Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Префикс непосредственного операнда~\lstinline!$! указывается перед префиксом системы счисления (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!).

На платформах, отличных от x86 и~x86-64, могут использоваться другие префиксы для указания метода адресации операнда.
% В~частности, 

% Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

% \index{Адресация!непосредственная}%
% \index{Адресация!прямая}%
% Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
% \lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
% команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

% \paragraph{Вычисление адреса}
% 
% Вычисление адреса с~одновременным разыменованием
% $$
% *\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
% $$
% в~соответствии с~синтаксисом~AT\&T имеет вид
% {
% \lstset{language=}
% % There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
% \begin{lstlisting}
% displacement(base, offset, scalar multiplier)
% \end{lstlisting} 
% 
% где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% % в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% % где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).
% 
% В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% % \lstinline![base + displacement + offset * scalar multiplier]!.
% \begin{lstlisting}
% [base + displacement + offset * scalar multiplier]
% \end{lstlisting} 



% \subsection{Сравнение синтаксиса AT\&T и~Intel}
% \epigraph{\begin{stanza}
%     Ой, не тому угрозы ты отправил!
% \end{stanza}}
% {О.\,Арефьева}
% 
% % Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% % % 
% % % Синтаксис AT&T немного 
% % отличается от синтаксиса Intel, который используется, например, MASM. 
% % %
% % Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.
% 
% \cite{linux_parallel,}
% 
% % Рассмотрим 
% Сравним 
% \termin{AT\&T}
% 
% \begin{lstlisting}[numbers=none]
% movl $42, %eax
% 
% movl $0x10, %ebx
% 
% 
% lea  -0x30(%rcx,%rax,8), %eax
% movl (%ebx), %eax
% 
% movl $0xCCCCCCCC, %ecx
% 
% 
% movl 0xCCCCCCCC, %ecx
% \end{lstlisting}
% 
% 
% % -4(%ebp), Intel:  [ebp - 4]
% {} \termin{Intel}
% 
% \begin{lstlisting}[numbers=none]
% mov eax, 42
% 
% mov ebx, 10h
% mov ebx, 0x10 ; masm
% 
% lea eax, [rcx+rax*8-0x30]
% mov eax, dword ptr [ebx]
% 
% mov ecx, 0xCCCCCCCC   
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; masm}@*/
% mov ecx, ds:[0xCCCCCCCC]
% /*@\textcolor{red}{mov ecx, dword ptr [0xCCCCCCCC] ; nasm}@*/
% \end{lstlisting}

% \subsection{О}



\section{Основные команды}
\epigraph{
ЭТО не работает на восьмиразрядных машинах.
}{\ProgFolk}
\label{sec:asm-commands}



Основной набор команд x86 включает команды обработки целых чисел и~разнообразные команды управления вычислениями.
Полный список команд приведён в~первом томе руководства разработчика программного обеспечения для архитектур Intel 64 (так архитектура x86-64 называется в~документации Intel) и~IA-32~\cite{intelBasic}, а~подробное описание "--- во втором~\cite{intelInstructionSet}.
Также набор инструкций описан в~третьем томе руководства разработчика AMD~\cite{amd64Instructions}.

Структура команды такова, что
если у~команды два операнда, они не могут оба находиться в~памяти.
Таким образом, если указано, что %$src$ и~$dest$ 
операнды могут быть переменными в~памяти или регистрами,
то возможны комбинации регистр-память, память-регистр и~регистр-регистр.

Если не указано иное, используются следующие обозначения.
Операнд, принимающий значение (приёмник) 
может быть обозначен либо как~$dest$, если он может быть регистром или переменной в~памяти,
либо как~$dreg$ или $dmem$, если он может быть соответственно только регистром или только в~памяти.
% обозначается как~$dest$, неизменяемый операнд (источник) может быть обозначен как $src$, $arg$ или иным образом.
% $src$ "--- регистр, переменная в~памяти или непосредственное значение, $dest$ и~$arg$ "--- регистры или переменные в~памяти,
% $imm$ "--- непосредственно адресуемая константа, $mem$ "--- переменная в~памяти, $reg$ "--- регистр.
Неизменяемый операнд (источник) может быть обозначен как $src$ (регистр, переменная в~памяти или непосредственное значение),
$srm$ (регистр или переменная в~памяти), $sreg$ (регистр), $smem$ (переменная в~памяти).
% Неизменя
Непосредственно адресуемая константа обозначается как $imm$.

Для большинства команд
источник и~приёмник должны быть одного размера.
Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
% При необходимости в~обозначении операнда указывается конкретная разрядность (\texttt{reg8, reg16, reg32, reg64} и~т.\,п.).

Наиболее часто используемые команды доступны как в~тридцатидвухбитном, так и~в~шестидесятичетырёхбитном режимах (\lstinline!mov!, \lstinline!lea! и~т.\,д.);\index{Команды!mov}
\index{Команды!lea}
некоторые "--- только в~шестидесятичетырёхбитном (в~частности, \lstinline!movabs!).\index{Команды!movabs}
Некоторые команды тридцатидвухбитного режима недоступны в~шестидесятичетырёхбитном, но для аналогичных операций введены новые (\lstinline!syscall! вместо \lstinline!sysenter!).\index{Команды!sysenter}\index{Команды!syscall}


Есть и~такие команды, 
которые доступны в~тридцатидвухбитном режиме, но 
полностью исключены из~шестидесятичетырёхбитного\index{Шестидесятичетырёхбитный режим}.
В~частности, это команды коррекции  двоично-десятичной арифметики,\index{Арифметика!двоично-десятичная}
% ~\lstinline!daa! и~\lstinline!das!, 
проверка выхода за границы \lstinline!bound!, условный вызов прерывания \lstinline!into! и~другие~\cite{rsdn_bcd_64}.%
% В~данном пособии эти команды не описываются во избежание путаницы.
\index{Команды!bound}%
\index{Команды!into}%

% Также многие команды не упом
В~данном пособии описывается только малая  часть доступных команд x86.
В~частности, во избежание путаницы в~описание не вошли команды, полностью исключённые из шестидесятичетырёхбитного режима.


\subsection{Общие команды}
\label{sec:asm-commandsintro}
\epigraphcensored[
\epigraph{
\begin{stanza}
Дело земли "---\\ вертеться.\\
Литься "---\\
дело вод.
\end{stanza}
}{\Vvm[Молодая гвардия]}]
{\epigraph{
\begin{stanza}[0mm]
I like to move it, move it,\\
She like to move it, move it,\\
We like to move it, move it,\\
We like to move it!\\
\end{stanza}
}{Reel 2 Real}}

\index{Команды!nop}%
\index{Команды!mov}%
\index{Команды!lea}%
\index{Команды!push}%
\index{Команды!pop}%
% \index{Команды!call}%
% \index{Команды!ret}%

В~таблице~\ref{tab:asm-common-list} приведены некоторые наиболее употребительные команды x86-совместимых процессоров.%
\index{Команды!пересылки}%

\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-common.tex}

\end{table}

Наверное, самой популярной командой является команда пересылки %(move)
% \lstinline!mov источник, приёмник! 
% "--- присваивание \lstinline!приёмник = источник!
\lstinline!mov src, dest! "--- аналог оператора присваивания $dest = src$ языков высокого уровня.
Рассмотрим некоторые примеры её работы:
\begin{lstlisting}[numbers=none]
movl $4, %eax	// eax = 4
movb $42, %al	// al = 42
movl %eax, (%esi)	// *esi = eax
movl %eax, 4(%esi)	// *(esi+4 байта) = eax
movl $some_var, %eax	// eax = &some_var
movl $some_var+4, %eax	// eax = &some_var+4 байта
movl some_var, %eax	// eax = some_var
movl %eax, foo	// foo = eax
\end{lstlisting}

% \index{Команды!lea}%
Аналогом оператора получения адреса (оператор $\&$ в~C++) является команда \lstinline!lea!.
Если \lstinline!mov smem, dreg! загружает в~регистр~$dreg$ значение по адресу~$smem$, 
то  \lstinline!lea smem, dreg! загружает в~$dreg$ сам адрес~$smem$.

Например, следующая команда 
% использует все четыре параметра косвенной адресации и~
загружает в~$A$ значение  
$*\big(bp + 4D  - 4\big)$,
используя косвенную адресацию "--- вычисление адреса из четырёх компонент с~разыменованием:
% \lstinline!*(EBP - 4 + (EDX * 4))! 
% звёздочка "--- разыменование указателя, 
% (команда \lstinline!mov src, dest! загружает в~приёмник значение источника, \lstinline!l! "--- суффикс размера):
\begin{lstlisting}[numbers=none]
movl    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
Команда %\lstinline!lea src, dest! 
\lstinline!lea! 
загружает в~приёмник адрес источника, что компенсирует разыменование, то есть команда
\begin{lstlisting}[numbers=none]
leal    -4(%ebp, %edx, 4), %eax
\end{lstlisting} 
загружает в~$A$ значение  
$bp + 4D  - 4$.

Адрес статической переменной в~тридцатидвухбитном режиме (то есть при использованими прямой абсолютной адресации)\index{Адресация!прямая} может быть загружен в~регистр двумя способами "--- копированием адреса как тридцатидвухбитной константы или с~помощью вычисления адреса:
\begin{lstlisting}[numbers=none]
movl $msg, %esi	// si = &msg
leal  msg, %esi	// si = &msg
\end{lstlisting}
Непосредственным  операндом первой команды и~смещением без базы во второй будет абсолютный тридцатидвухбитный  адрес метки  \lstinline!msg!.
\index{Команды!mov}%
\index{Команды!lea}%

В~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} предпочтительной является прямая относительная ($rip$-relative) адресация.
В~этом случае загрузка должна осуществляться командой \lstinline!lea!:
\begin{lstlisting}[numbers=none]
lea msg(%rip), %rsi	// si = ip + (&msg - ip) = &msg
\end{lstlisting}
% Хотя метка \lstinline!msg:! в~обоих случаях выглядит одинаково
Смещением в~соответствующей команде будет не абсолютный шестидесятичетырёхбитный адрес метки  \lstinline!msg!, а~вычисленная ассемблером тридцатидвухбитная знаковая разность адреса \lstinline!msg! и~адреса следующей команды $ip$.

Использование в~данной команде вместо $rip$ любого другого регистра приведёт к~тому, что в~поле смещения будет записана не разность шестидесятичетырёхбитного адреса метки \texttt{msg} и~значения базового регистра, а~собственно адрес \texttt{msg}~\cite{how-to-use-rip-relative-addressing-in-a-64-bit-assembly-program}, причём усечённый до 32 бит:
\begin{lstlisting}[numbers=none]
lea msg(%rsp), %rsi	// si = sp + &msg
\end{lstlisting}
Таким образом, прямая относительная адресация\index{Адресация!прямая относительная} не является частным случаем косвенной\index{Адресация!косвенная}, хотя для их описания используется одна синтаксическая конструкция; эти виды адресации необходимо различать.

Если по какой-то причине требуется загрузить именно абсолютный шестидесятичетырёхбитный адрес как константу, это можно сделать командой \texttt{movabs:}\index{Команды!movabs}
\begin{lstlisting}[numbers=none]
movabs $msg, %rsi	// si = &msg
\end{lstlisting}
Команда \texttt{mov} в~шестидесятичетырёхбитном режиме может содержать не более чем тридцатидвухбитный непосредственный операнд.

Команда вычисления адреса~\lstinline!lea! также часто используются для арифметических вычислений, так как позволяет выполнить умножение и~сложение за один шаг, а~также выполняется намного быстрее, чем %команда беззнакового умножения~\lstinline!mul!:
команды умножения~\lstinline!mul/imul!:
\begin{lstlisting}[numbers=none]
leal    8(,%eax,4), %eax    // A = A*4 + 8   
leal    (%eax,%eax,2), %eax // A = A*2 + A = A*3
\end{lstlisting} 
В~отличие от «настоящих» арифметических команд, \lstinline!lea! не изменяет флагов.

\subsubsection{Работа со стеком}
\index{Команды!push}%
\index{Команды!pop}%
\index{Стек}

Для работы со стеком предназначены в~основном команды \lstinline!push! и ~\lstinline!pop!.
Они работают только с операндами размером 4 или 2 байта, то есть указатель вершины стека всегда выравнен на 2 байта (его начальное значение делается двоично-круглым).
В~GNU/Linux стек по соглашению выравнен по $long$ (на 4~байта).


% \lstinline!push источник! \\
Команда \lstinline!push src! помещает источник в~стек.
При этом указатель стека~$sp$ уменьшается на размер источника.

Таким образом, если попытаться смоделировать работу команды \lstinline!push! при помощи команды пересылки, 
то, в~частности
% \lstinline!pushl %eax! эквивалентна
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(eax)
% movl %eax, (%esp)// *esp = %eax
% \end{lstlisting}
% Здесь суффиксы 
\lstinline!pushl $13! (здесь суффикс~$l = long$ необходим, так как разрядность операнда невозможно определить без явного указания) 
эквивалентна последовательному уменьшению~$sp$ и~записи значения в~память:
\index{Команды!sub}%
\begin{lstlisting}[numbers=none]
sub  $4, %esp	 // esp -= sizeof(long)
movl $13, (%esp) // *esp = 13
\end{lstlisting}
% \begin{lstlisting}[numbers=none]
% pushl foo
% \end{lstlisting}
% \lstinline!pushl foo! эквивалентно
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(int)
% movl foo, %eax	// eax= foo
% movl %eax, (%esp)// *esp = eax
% \end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки неэффективна, так как она и~выполняется медленнее, чем~\lstinline!push!, и~занимает больше места в~памяти.
Тем не менее, %часто встречается задача 
иногда необходимо зарезервировать в~стеке место для локальных переменных, начальное значение которых пока неизвестно.
В~этом случае можно воспользоваться командой~\lstinline!sub $size, %esp!.



Команда~\lstinline!pop dest!
"--- извлечение значения из стека и~помещение его в~приёмник~$dest$ "---
увеличивает указатель стека~$sp$  на размер приёмника.

\index{Команды!add}%
Таким образом, \lstinline!popl %eax! можно также выполнить с~помощью команд
\begin{lstlisting}
movl (%esp), %eax // eax = *esp
add  $4, %esp     // esp += sizeof(int)
\end{lstlisting}
Комбинация команд изменения $sp$ и~пересылки здесь так же менее эффективна, чем~\lstinline!pop!.
При этом отдельная команда~\lstinline!add $size, %esp! для удаления элемента или набора элементов из стека «в~никуда»
используется очень часто.
Она быстрее, чем однократный вызов~\lstinline!pop!, так как не обращается к~памяти; короче множественного вызова~\lstinline!pop!,
а~также не требует указания приёмника.
%множественного 
% \lstinline!popl foo! эквивалентно
% \begin{lstlisting}
% movl (%esp), %eax // eax = *esp
% movl %eax, foo	// foo = eax
% addl $4, %esp	// esp += sizeof(int)
% \end{lstlisting}



% \subsection{Вызов и~возврат}
\subsection{Передача управления, вызов и~возврат}
% \epigraph{\begin{stanza}[0mm]
% Я пришёл сюда из-за дальних гор,\\
% Ибо ныне я знаю, что делать с собой.\\
% В шесть сторон кроплю, обхожу костёр,\\
% Подношу к губам горьких трав настой.\\
% \end{stanza}}{\Orgia}
\epigraphcensored[\epigraph{\begin{stanza}[0mm]
Он один остался в живых. 
Он вошёл сквозь контуры двери.\\
Он поднялся на башню. Он вышел в окно.\\
И он сделал три шага "---
и упал не на землю, а в небо. \\
Она взяла его на руки, потому что они были одно. \\
\end{stanza}
}{\Aquarium}]{
\epigraph{\begin{stanza}[0mm]
Deine Schritte kennt sie,
Deinen sch\"{o}nen Gang,\\
Alle Abend brennt sie,
Doch mich verga{\fontfamily{cmr}\selectfont\ss} sie lang\\
\hspace{\stanzaoddindent}Und sollte mir ein Leid gescheh'n\\
\hspace{\stanzaoddindent}Wer wird bei der Laterne stehen\\
\hspace{\stanzaoddindent}Mit dir Lili Marleen?\\
\end{stanza}
}{H. Leip}
}
\index{Команды!передачи управления}%
Команды передачи управления (таблица~\ref{tab:jcall-command-list}) делятся на две основные группы.
Некоторые из них просто замещают указатель команд новым адресом, то есть передают управление новому фрагменту кода аналогично оператору \lstinline!goto! языка C++. %; таким образом, выполнение продолжается с~н 
Другие перед передачей управления запоминают адрес следующей по счёту команды, так что затем можно вернуться к~выполнению последовательности команд.
Такие команды соответствуют вызовам разного рода подпрограмм (в~том числе функций, прерываний, системных вызовов); каждой из них соответствует своя команда возврата, которая должна находиться в~конце соответствующей подпрограммы.
\index{Системные вызовы}%


\begin{table}[!ht]
\caption{Команды передачи управления, вызова и~возврата}
\label{tab:jcall-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
jmp src	&	{Безусловный переход  по адресу $src$ ($goto~src$)}
\\\hline
jCC src	&	Условный переход по адресу $src$ (если верно условие $src$)
\\\hline
\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из функций}}\\\hline
call src
 & Вызов подпрограммы "--- помещает в~стек адрес следующей инструкции (адрес возврата) и~переходит по адресу $src$
\\\hline
ret [imm] & Возврат из подпрограммы "--- снимает со стека адрес возврата и~помещает его в~указатель команд.

Если указан параметр $imm$, снимает со стека ещё $imm$ байтов.
\\\hline
\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из программного прерывания}}\\\hline
int imm8 & Вызов прерывания с~номером~$imm8$ "--- помещает в~стек флаги $flags$, затем адрес возврата, после чего переходит к~обработчику прерывания $imm8$
\\\hline
iret  & Возврат из прерывания "---  снимает со стека адрес возврата и~флаги, возвращает к~прерванной программе
\\\hline

\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из системного вызова (32 бита)}}\\\hline
sysenter & Быстрый системный вызов
\\\hline
sysexit  & Возврат из  системного вызова
\\\hline

\multicolumn{2}{|c|}{\textbf{Вызов и~возврат из системного вызова (64 бита)}}\\\hline
syscall & Быстрый системный вызов
\\\hline
sysret  &  Возврат из  системного вызова
\\\hline
% \multicolumn{2}{|c|}{\textbf{Длинные (межсегментные) передача управления, вызов и~возврат}}\\\hline
% ljmp smem
%  & Безусловный переход
% \\\hline
% lcall smem
%  & Вызов подпрограммы
% \\\hline
% lret [imm] & Возврат из подпрограммы
% \\\hline
\end{tabularx}
\index{Команды!jmp}%
\index{Команды!jCC}%
\index{Команды!call}%
\index{Команды!ret}%
\index{Команды!int}%
\index{Команды!iret}%
\index{Команды!sysenter}%
\index{Команды!sysexit}%
\index{Команды!syscall}%
\index{Команды!sysret}%
\end{table}

\subsubsection{Простая передача управления}
\index{Команды!jmp}%
\index{Команды!jCC}%

К~командам «безвозвратной» передачи управления относятся команда безусловного перехода \lstinline$jmp src$ и~семейство команд условного перехода  \lstinline$jCC src$.
Команды условного перехода отличаются только тем, что передача управления осуществляется только при наличии некоторой комбинации флагов $CC$ в~регистре~$flags$.

Операнд команд передачи управления $src$ может быть непосредственным значением (обычно меткой $label$), регистром или памятью.
В~первом случае неявно используется прямая относительная адресация\index{Адресация!прямая относительная}, так что в~соответствующий машинный код включается не абсолютный адрес $label$, а~смещение относительно текущего указателя команд $label - ip$. Это позволяет получить переносимый код.

Если операнд команды перехода находится в~регистре или памяти% (обозначим его $srm$)
, то это "--- абсолютный адрес перехода.
Использование такой адресации позволяет выбирать адрес перехода во время выполнения программы.

\subsubsection{Вызов и~возврат}
\index{Подпрограммы}%

Команды вызова 
% сохраняют адрес той команды, которая следует за ней (адрес возврата),
% некоторые из них также сохраняют и~другие данные
используются для передачи управления {подпрограмме} "--- последовательности команд, завершающихся командой возврата.
Команды вызова и~возврата всегда бывают парными.

Любая команда вызова сохраняет в~определённом месте адрес той команды, которая следует за ней (адрес возврата),
некоторые из них также сохраняют и~другие данные (флаги, указатель стека и~т.\,д).
Парная к~ней команда возврата восстанавливает сохранённые элементы и~помещает  в~указатель команд адрес возврата.
Таким образом, после выполнения подпрограммы управление перейдёт обратно к~вызвавшей её программе и~продолжится именно с~той команды, которая следует за командой вызова.

Для вызова подпрограммы любого вида (функции или системного вызова) допустимо использовать только ту команду, которая является парной к~завершающей эту подпрограмму команде возврата. В~противном случае %управление перейдёт не 
% возврат невозможен
% при попытке возврата 
произойдёт крах.


Команды 
% \lstinline!call/ret! 
вызова и~возврата
не осуществляют передачу в~подпрограмму параметров и~возврат значения.
Эти действия выполняются вручную и~регламентируются соглашениями о~вызовах\modifyone[\strut{}
(подробнее механизм вызова рассматривается в~разделе~\ref{sec:calling-functions})]{}.

В~систему команд x86 входят три пары команд вызова/возврата.
\begin{enumerate}
\item Команды 
\lstinline!call/ret! предназначены для вызова функций и~процедур, описанных в~самой программе и~прикладных библиотеках.
\index{Команды!call}%
\index{Команды!ret}%

\item Команды 
\lstinline!int/iret! предназначены для программного обращения к~прерыванию.
\index{Команды!int}%
\index{Команды!iret}%

В~современной прикладной программе явный вызов программного прерывания обычно используется только для обращения к~ядру операционной системы (системного вызова\modifyone[, подробнее в~разделе~\ref{sec:sys-call}]{}).

\item Команды, предназначенные специально для системных вызовов.
\index{Команды!sysenter}%
\index{Команды!sysexit}%
\index{Команды!syscall}%
\index{Команды!sysret}%

В~тридцатидвухбитном режиме это \lstinline!sysenter/sysexit!, в~шестидесятичетырёхбитном\index{Шестидесятичетырёхбитный режим} "--- \lstinline!syscall/sysret!.

\end{enumerate}

\paragraph{Вызов и~возврат из функций}
\index{Команды!call}%
\index{Команды!ret}%
Вызов функции в~ассемблере выполняется командой \lstinline!call!.
Эта команда имеет один операнд "--- адрес подпрограммы в~памяти.

Команда \lstinline!call foo! сохраняет указатель команд в~стеке,\index{Стек}
управление передаётся $foo$.
% 
Возврат из подпрограммы выполняется командой 
\lstinline!ret!, которая должна находиться в~конце кода подпрограммы.
"--- управление передаётся адресу, снятому со~стека.

В~листинге~\ref{lst:gas:call-foo-ret} показана подпрограмма $foo()$, прибавляющая к~значению регистра $eax$ константу~$5$, а~также её вызов.

\begin{lstlisting}[caption={Функция и~её вызов}, label=lst:gas:call-foo-ret]
// Вызывающая программа
  movl $10, %eax
  call foo
  // теперь %eax == 15
...
// Функция foo()
foo:
  addl $5, %eax
  ret
 \end{lstlisting}

Так же, как и~для команд перехода \lstinline$jmp/jCC$, если операндом команды \lstinline!call! является метка $label$, неявно используется прямая относительная адресация\index{Адресация!прямая относительная} (в~машинный код включается смещение относительно текущего указателя команд $label - ip$),
а~если операнд в~регистре или памяти "--- это абсолютный адрес перехода, задаваемый соответственно регистровой или косвенной адресацией\index{Адресация!регистровая}\index{Адресация!косвенная}.

Вызов подпрограммы по указателю 
% в~регистре или памяти
применяется, в~частности, для реализации механизма виртуальных функций, адрес которых выбирается из таблицы виртуальных методов на этапе выполнения программы.

% При использовании соглашения cdecl непосредственно под адресом возврата располагается первый параметр.
% На 32-разрядной платформе с~восьмибитным байтом его адрес на 4 байта больше $sp$, то есть первый параметр равен \lstinline!4(%esp)!.
% % \begin{lstlisting}[numbers=none]
% % 4(%esp)   // *(ESP+4)
% % \end{lstlisting} 
% Если размер первого параметра также равен 4 байтам (в~частности, int на 32-разрядной платформе), то ко второму параметру можно обратиться как \lstinline!8(%esp)! и~так далее.

\paragraph{Вызов и~возврат из прерывания}
\index{Команды!int}%
\index{Команды!iret}%

Для вызова прерывания необходимо указать его восьмибитный номер~$imm8$ (то есть номера прерываний могут принимать значения от $0$ до $255$).
Каждому номеру прерывания соответствует специальный системный регистр, содержащий адрес обработчика этого прерывания.

Команда вызова прерывания \lstinline!int imm8! помещает в~стек сначала регистр флагов $flags$, затем адрес возврата.
Если обработчик выполняется с~привилегиями ядра операционной системы, в~специальном регистре сохраняется также указатель стека, так как система использует другой стек.
После этого управление передаётся обработчику прерывания $imm8$.

Команда возврата из прерывания \lstinline!iret! восстанавливает указатель стека (при необходимости), флаги и~передаёт управление по адресу возврата (из стека при этом извлекаются оба помещённых туда командой~\lstinline!int! машинных слова).


Необходимо отметить, что в~документации AMD команда вызова программного прерывания \lstinline!int! относится к~командам общего назначения, а~соответствующая команда возврата~\lstinline!iret! "--- к~системным~\cite{amd64Instructions}.

Один из номеров прерываний в~тридцатидвухбитных операционных системах обычно используется для системных вызовов.


\paragraph{Вызов и~возврат из системных вызовов}
\index{Команды!sysenter}%
\index{Команды!sysexit}%

Начиная с~Pentium II, доступна предложенная Intel команда \lstinline!sysenter!, %/sysexit (Intel)
ускоряющая обращение к~ядру.
\index{Команды!sysenter}%
% 
Адрес возврата и~другие сохраняемые данные помещаются командой \lstinline!sysenter! в~специальные регистры, что быстрее обращения к~памяти.
В~конце обработчика системного вызова их восстанавливает команда \lstinline!sysexit!.

В~шестидесятичетырёхбитном режиме  использование команды \lstinline!sysenter! невозможно.


Для быстрого обращения к~функциям ядра  в~шестидесятичетырёхбитном режиме\index{Шестидесятичетырёхбитный режим} применяется команда \lstinline!syscall!, %/sysret 
% (AMD, 64-битный режим Intel);
предложенная AMD.
\index{Команды!syscall}%
Она также сохраняет данные для возврата в~регистрах.
\index{Команды!syscall}%
Для возврата из системного вызова в~шестидесятичетырёхбитном режиме предназначена команда~\lstinline!sysret!.
\index{Команды!sysret}%

Отметим, что команда возврата из системного вызова (\lstinline!sysexit! или \lstinline!sysret!) используется только в~обработчике этого вызова, то есть в~коде ядра операционной системы.

\subsection{Обнуление регистра}
% \epigraph{\begin{limerick}
%     Жил один господин из Ливорно,\\
%     Он вкушал только крошки и зёрна,\\
%     Их клюя по привычке,\\
%     Как прочие птички\\
%     На лужках и аллеях Ливорно.\\
% \end{limerick}
% }
% {\Lear}
\epigraph{\begin{stanza}
Но он побрил лицо лифтом,\\
Он вышел в январь;\\
Он сосал бирюзу и ел кусками янтарь.
\end{stanza}}
{\Aquarium}


\index{Команды!обнуления регистра}%

% https://habrahabr.ru/post/183462/
% • XOR REG,REG
% • SUB REG,REG
% • PXOR/VPXOR XMMREG,XMMREG
% • PSUBB/W/D/Q XMMREG,XMMREG
% • VPSUBB/W/D/Q XMMREG,XMMREG
% • XORPS/PD XMMREG,XMMREG
% • VXORPS/PD YMMREG, YMMREG
% Более подробно – в Intel® 64 and IA-32 Architectures Optimization Reference Manual, страница 43. 
Исторически для обнуления регистров использовались команды побитового исключающего «или» с~одинаковыми операндами~\lstinline!xor %reg, %reg! и~вычитания регистра из самого себя~\lstinline!sub %reg, %reg!,
так как они выполнялись быстрее команды пересылки \lstinline!mov $0, %reg!, а~также занимали меньше места.
Зависимость по данным в~ранних моделях процессора не имела значения, так как вычисления не были конвейеризированы.

После введения конвейера традиция обнуления регистров командами \lstinline!xor! и~\lstinline!sub! сохранилась.
Поэтому в~современных моделях процессоров команды обнуления регистров (zero idioms) распознаются при декодировании 
и~выполняются как не имеющие зависимостей по данным.

% Начиная с~Pentiun~4, 
Таким образом, сейчас руководство по оптимизации Intel~\cite{intelOptimization} снова рекомендует использовать для обнуления регистров общего назначения команды:
\begin{lstlisting}
xor %reg, %reg
sub %reg, %reg
\end{lstlisting}
Для регистров расширения XMM распознаются следующие команды обнуления:
\begin{lstlisting}
xorps/pd  %xmmreg,  %xmmreg
pxor  %xmmreg,  %xmmreg
subps/pd  %xmmreg,  %xmmreg
psubb/w/d/q  %xmmreg,  %xmmreg
\end{lstlisting}
Для некоторых архитектур используются и~другие  команды обнуления регистров расширения X/Y/ZMM~\cite{intelOptimization}.

При этом команды \lstinline!xor! и~\lstinline!sub!, не распознающиеся как zero idioms, выполняются медленнее из-за зависимости по данным
(даже если результатом будет ноль).

% GENERAL OPTIMIZATION GUIDELINES
% 3-26
% 3.5.1.8  
% Clearing Registers and Dependency Breaking Idioms
% Code sequences that modifies partial register can ex
% perience some delay in its dependency chain, but 
% can be avoided by using dependency breaking idioms.
% In processors based on Intel Core microarchitecture, a number of instructions can help clear execution 
% dependency when software uses these instruction to clear register content to zero. The instructions 
% include:
% XOR REG, REG
% SUB REG, REG
% XORPS/PD XMMREG, XMMREG
% PXOR XMMREG, XMMREG
% SUBPS/PD XMMREG, XMMREG
% PSUBB/W/D/Q XMMREG, XMMREG
% In processors based on Intel microarchitecture code name Sandy Bridge, the instruction listed above plus 
% equivalent AVX counter parts are also zero idioms that can be used to break dependency chains. Further-
% more, they do not consume an issue port or an execut
% ion unit. So using zero id
% ioms are preferable than 
% moving 0’s into the register. The AVX equivalent zero idioms are:
% VXORPS/PD XMMREG, XMMREG
% VXORPS/PD YMMREG, YMMREG
% VPXOR XMMREG, XMMREG
% VSUBPS/PD XMMREG, XMMREG
% VSUBPS/PD YMMREG, YMMREG
% VPSUBB/W/D/Q XMMREG, XMMREG
% In Intel Core Solo and Intel Core Duo processors, the XO


\subsection{Команды целочисленной арифметики
% Основные арифметические команды
}
\index{Команды!арифметические}%
\epigraph{\begin{stanza}
Те, кто рисует нас, рисуют красным на сером.\\
Цвета как цвета, но я говорю о другом,\\
Если бы я умел это, я нарисовал бы тебя\\
Там, где зелёные деревья и золото на голубом. \\
\end{stanza}
}{\Aquarium}

Из-за ограниченного количества операндов в~системе команд x86 практически нет привычных по языкам высокого уровня неразрушающих арифметических операторов.
% Вместо них используются
Один из операндов, как правило, используется и~как исходное данное, и~как ячейка для записи результата.
\index{Команды!add}%
В~частности, аналогом ассемблерной команды сложения \lstinline!add src, dest! в~C++ будет не оператор «плюс», не изменяющий свои операнды ($dest = src_1 + src_2$), а~оператор «${+}{=}$» ($dest~ {+}{=} ~src$, то есть $dest = dest+src$).

Некоторые команды, предназначенные для обработки целых чисел, перечислены в~таблице~\ref{tab:ar-command-list}.
% Некоторые команды целочисленной арифметики перечислены в~таблице~\ref{tab:ar-command-list}.


\begin{table}[p]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar.tex}

\endgroup

\index{Команды!inc}%
\index{Команды!dec}%
\index{Команды!add}%
\index{Команды!adc}%
\index{Команды!sub}%
\index{Команды!cmp}%
\index{Команды!sbb}%
\index{Команды!neg}%

\index{Команды!mul}%
\index{Команды!imul}%
\index{Команды!div}%
\index{Команды!idiv}%

\index{Битовые сдвиги}%
\index{Команды!shl}%
\index{Команды!sal}%
\index{Команды!shr}%
\index{Команды!sar}%
\end{table}


\subsubsection{Команды сложения и~вычитания}

К~этой группе, кроме собственно сложения и~вычитания, относятся также команды инкремента, декремента и~изменения знака.

\index{Арифметика!знаковая}%
\index{Арифметика!беззнаковая}%
Как было сказано в~разделе~\ref{sec:digits-negcodes}, представление отрицательных чисел выбиралось так, чтобы 
знаковые  числа можно было складывать и~вычитать с~помощью беззнакового сумматора.
Соответственно, операции сложения и~вычитания не делятся на знаковые и~беззнаковые.
% Каждая из них выставляет как флаг знак
Команды из группы сложения и вычитания выставляют значения  
% флагов $OF, SF, ZF, AF, PF, CF,$ 
всех шести флагов состояния
соответственно результату,
так что программист, понимая, какого рода числа он обрабатывает, может выбрать для анализа нужные флаги.
% \begin{description}
% \item[CF] беззнаковое переполнение  (перенос из~старшего разряда)
% \item[ZF] результат равен нулю
% \item[SF] старший (знаковый) бит результата
% \item[OF] знаковое переполнение (перенос в~старший разряд, но не из него или наоборот)
% \end{description}

% Источник и~приёмник должны быть одного размера.
% Это может быть байт, два байта и~четыре байта (для шестидесятичетырёхбитных систем "--- до восьми байт).
% Более длинные числа 
Числа, разрядность которых превышает разрядность системы,
при необходимости можно складывать и~вычитать по частям.
Для этого вначале младшие части обрабатываются командами \lstinline!add/sub!, затем~к~остальным в~порядке возрастания адресов "---  \lstinline!adc/sbb!, учитывающие перенос из младшей части.
Части могут иметь любую разрядность (в~частности, шестибайтовые целые можно разбить на две части "---  четыре и~два байта или на шесть однобайтовых), но логичнее использовать четырёхбайтовые части на тридцатидвухбитной системе и~восьмибайтовые "--- на шестидесятичетырёхбитной.

\subsubsection{Вычисление линейной комбинации регистров}
\index{Команды!lea}%

Также для арифметических вычислений используется команда \lstinline!lea!, которая, в~соответствии с~возможностями косвенной адресации,
может рассчитать выражение~$r1 + \sigma\cdot r2 + \delta$ (может быть опущен любой из регистров и~любая из констант).
Команда \lstinline!lea! предназначена для манипуляций с~беззнаковыми данными (указателями),
но %в~том самом распространённом случае, когда 
смещение $\delta$ интерпретируется как знаковое.
Так как
разрядность $r1$ и~$r2$ совпадает с~разрядностью $dreg$, результат совпадает со знаковым.

В~отличие от «настоящих» арифметических команд, 
\lstinline!lea! не изменяет флагов.

\subsubsection{Команды умножения и~деления}
\index{Команды!mul}%
\index{Команды!imul}%
\index{Команды!div}%
\index{Команды!idiv}%

Самые старые команды умножения рассчитывают произведение заданного множителя~$srm$ на неявный операнд "--- регистр $A$ той же разрядности, что и~$srm$.
Разрядность произведения при этом вдвое больше разрядности множителей, так что младшая  половина $A\cdot srm$ помещается в~регистр~$A$ на место неявного множителя,
а~старшая "--- в~регистр~$D$ той же разрядности.
Исключением является случай с~восьмибитными множителями "--- так как на момент появления команд умножения уже существовали шестнадцатибитные регистры,
результат $al\cdot srm$ размещается в~$ax$ (таблица~\ref{tab:ar-command-muldiv}).
Старшая половина результата отличается для знаковой и~беззнаковой интерпретации множителей, так что существуют две команды описанного действия "--- \lstinline!mul! для беззнакового умножения и~\lstinline!imul! для знакового.
\index{Арифметика!знаковая}%
\index{Арифметика!беззнаковая}%
% Если старшую половину можно отбросить,
% % (она равна $0$ для \lstinline!mul! и~состоит только из копий знака для~\lstinline!imul!)
% сбрасываются оба флага~$CF$ и~$OF$,
% если в~старшей половине есть значащие биты, $CF$ и~$OF$ оба взводятся.
\begin{table}[!ht]
\begingroup
\small
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ar-muldiv.tex}

\endgroup
\end{table}

Введённая позже команда \lstinline!imul srm, dreg! рассчитывает только младшую половину произведения, а~она совпадает для знаковых и~беззнаковых чисел.
Таким образом, 
% \lstinline!imul srm, dreg! "--- умножение
двухоперандную форму команды~\lstinline!imul! можно использовать и~для знакового, и~для беззнакового умножения.

Трёхоперандная форма \lstinline!imul imm, srm, dreg! также рассчитывает только младшую половину произведения,
но перед этим константа \lstinline!imm! при необходимости расширяется.
Данная форма
соответствует двум опкодам "--- с~константой \lstinline!imm!, разрядность которой соответствует разрядности источника и~приёмника
(в~этом случае расширение не требуется)
и~с~восьмибитной константой \lstinline!imm8!~\cite{intelInstructionSet}.
Во втором случае случае \lstinline!imm8! расширяется как знаковое, поэтому трёхоперандную форму~\lstinline!imul! следует считать командой знакового умножения.

% Как двух-, так и~трёхоперандная форма 
Если произведение помещается в~младшей половине произведения, 
все формы команд \lstinline!mul/imul!
сбрасывают оба флага~$CF$ и~$OF$.
Если в~старшей половине есть значащие биты (для двух- и~трёхоперандной форм~\lstinline!imul! это значит, что результат некорректен),
оба этих флага взводятся~\cite{asmworld}.
Значения флагов нуля и~знака не определены~\cite{club155}.

Для %обратной операции "--- 
деления существуют только однооперандная форма.
Делимое (неявный операнд) всегда вдвое больше делителя (явного операнда~$srm$)
и~располагается в~паре регистров $D:A$ (старшая половина "--- в~$D$, младшая "--- в~$A$), кроме случая восьмибитного делителя  (таблица~\ref{tab:ar-command-muldiv}).
Необходимо помнить об этом и~корректно инициализировать регистр~$D$ перед делением.

Таким образом, команды  деления обратны однооперандной форме умножения.
Соответственно, деление также будет беззнаковым (\lstinline!div!) и~знаковым (\lstinline!idiv!).


После деления $D:A$ на $srm$ частное помещается на место младшей половины делимого (в~$A$), остаток "--- на место старшей половины (в~$D$).
Если старшая половина делимого содержит значащие биты, возможна ситуация, когда частное не помещается  в~отведённом для него регистре.
Соответственно, результат деления будет некорректным.


Умножение и~деление на $2^{times}$ ($times$ трактуется как беззнаковое число) может также быть выполнено с~помощью битовых сдвигов (раздел~\ref{sec:asm-bitwise}).
\index{Битовые сдвиги}%
\index{Арифметика!знаковая}%
\index{Арифметика!беззнаковая}%

\subsubsection{Расширение целых чисел}

\index{Расширение целых чисел}%
\index{Команды!movs}%
\index{Команды!movz}%
\index{Команды!расширения}%
\index{Команды!удвоения разрядности $A$}%

Также к~командам целочисленной арифметики можно отнести команды расширения (таблица~\ref{tab:ext-command-list}).


\begin{table}[!ht]
\begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-ext.tex}

\endgroup
\end{table}

Современная система команд x86 включает два вида команд, которые используются для расширения "--- пересылка из источника малой разрядности в~приёмник большей
и~удвоение разрядности неявного операнда~в~регистре~$A$.

Существует две команды пересылки с~расширением "--- \lstinline!movz! для беззнакового расширения (дополнения нулями)
и~\lstinline!movs! для знакового  (дополнения знаковым битом).
\label{sec:asm-conversion-mov}

% Приёмник $dreg$ может быть  только регистром, источник $srm$ может быть регистром или переменной в~памяти, размер $srm$ меньше~$dreg$.


При пересылке возможно увеличение разрядности более чем в~два раза, поэтому, если %хотя бы один операнд
источник находится в~памяти, для команды обязательно нужно указывать два суффикса (раздел~\ref{sec:att-suffixes}).

Также существует набор команд для удвоения разрядности неявного операнда в~регистре~$A$
(таблица~\ref{tab:asm-conversion}).
\label{sec:asm-conversion-A}

\begin{table}[!ht]
\caption{Мнемоники команд знакового расширения~$A$}
\label{tab:asm-conversion}
\small

\noindent\begin{tabularx}{\linewidth}{|c|cCC|cCC|}
\hline
\multirow{2}{*}{\thead{Размер}}	& \multicolumn{3}{c|}{Расширение в~регистр~$A$}	&	\multicolumn{3}{c|}{Расширение в~пару~$D:A$}	\\
\cline{2-7}
% \thead{Размер} & \thead{Действие} & \thead{Intel} & \thead{GAS} & \thead{Действие} &\thead{Intel} & \thead{GAS} \\\hline
		& \thead{Действие} & \thead{Intel} & \thead{AT\&T} & \thead{Действие} &\thead{Intel} & \thead{AT\&T} \\\hline
$8\to16$	&	$al\to ax$	& cbw 	& cbtw	&	\multicolumn{3}{c|}{---}	\\\hline
$16\to32$	&	$ax\to eax$	& cwde 	& cwtl	&	$ax\to dx:ax$		& cwd 	& cwtd	\\\hline
$32\to64$	&	$eax\to rax$	& cdqe 	& cltq	&	$eax\to edx:eax$	& cdq 	& cltd	\\\hline
$64\to128$	&	\multicolumn{3}{c|}{---}	&	$rax\to rdx:rax$	& cqo 	& cqto	\\\hline
\end{tabularx}
\index{Команды!cbw/cbtw}%
\index{Команды!cwde/cwtl}%
\index{Команды!cwd/cwtd}%
\index{Команды!cdqe/cltq}%
\index{Команды!cqo/cqto}%
\end{table}

Практически для всех случаев есть две команды "--- расширение %младшей части 
$A$ до $A$ вдвое большей разрядности 
и~расширение~$A$ до пары $D:A$.
Последний вариант необходимо  использовать перед командами, использующими пару регистров~$D:A$ как источник, в~частности, командами деления $(D:A)/srm$.

Для команд удвоения разрядности регистра~$A$ есть два набора мнемоник "--- исторически используемые в~ассемблере Unix \modifyone[(AT\&T)]{} и~предложенные Intel.

Мнемоники  AT\&T для команд удвоения разрядности регистра~$A$ строятся по  схеме $cStD$ (convert $S$ to $D$),
где~$S$ "--- размер источника, $D$ "--- размер приёмника или символ~$d$ для пары регистров (кроме \lstinline!cqto!).

Мнемоники Intel построены по одной из двух схем "--- $cSD$  или $cSDe$. 
Исторически на шестнадцатибитных машинах первыми доступными вариантами удвоения были $al \to ax$ и~$ax \to dx:ax$,  так что они получили имена без суффикса~$e$.
В~дальнейшем суффикс $e$ использовался для расширения $A \to A$, а~расширение $A \to D:A$ выполняется командой без суффикса.

Для команд удвоения разрядности $A$ GAS поддерживает оба набора мнемоник \modifyone["--- AT\&T и~Intel "---]{}  перечисленные в~таблице~\ref{tab:asm-conversion}.


Увеличить разрядность неявного операнда~$A$ более чем в~два раза с~помощью команд таблицы~\ref{tab:asm-conversion} можно только последовательным применением нескольких команд удвоения.

Все команды удвоения разрядности~$A$ выполняют знаковое расширение.
% 
Беззнаковое расширение $A \to D:A$ может быть выполнено явным обнулением регистра~$D$.
% В~случае расширения $A \to A$ можно обнулить $$

% Все команды расширения имеют различные мнемоники для синтаксиса AT\&T и~синтаксиса~Intel (раздел~\ref{sec:att-mnemonic}).

% Команды пересылки с~расширением в~синтаксисе Intel имеют дополнительный суффикс~\lstinline!x!.
% В~GAS 

% Мнемоники Intel "--- по схеме $cSD$ или $cSDe$.


% \FloatBarrier

\subsection{Битовые операции}
\epigraph{\begin{stanza}[0mm]
Она может двигать,\\
Она может двигать собой,\\
В полный рост "---\\
Она знает толк в полный рост
\end{stanza}
}{\Aquarium}
\label{sec:asm-bitwise}
\index{Поразрядные операции}%
\index{Команды!not}%
\index{Команды!and}%
\index{Команды!or}%
\index{Команды!xor}%
\index{Команды!test}%

\index{Битовые сдвиги}%
\index{Команды!shl}%
\index{Команды!sal}%
\index{Команды!shr}%
\index{Команды!sar}%

\index{Команды!rol}%
\index{Команды!ror}%
\index{Команды!rcl}%
\index{Команды!rcr}%

\index{Команды!bt}%
\index{Команды!btc}%
\index{Команды!bts}%
\index{Команды!btr}%

Некоторые команды, предназначенные для обработки битовых строк, перечислены в~таблице~\ref{tab:bit-command-list}.

\begin{table}[p]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/instr-bit.tex}

\end{table}

Система команд x86 включает поразрядные логические операции, все описанные в~разделе~\ref{sec:bitwise} битовые сдвиги, а~также команды выделения бита по номеру.

Поразрядные логические операции «и», «или», «не» и~«исключающее или» изменяют в~соответствии с~полученным результатом три флага состояния "--- флаги нуля, знака и~чётности.

Команды битового сдвига принимают два операнда: сдвигаемое значение $dest$ и~беззнаковое количество сдвигов~$times$.
Количество~$times$ может быть непосредственным значением или регистром~$cl$, причём даже в~шестидесятичетырёхбитных системах используются только младшие~шесть его бит (в~тридцатидвухбитных "--- пять).
\pagebreak[3]

При $times=1$ происходит сдвиг в~указанную сторону на один бит.
% При этом с~одного конца $dest$ освобождается ячейка, а
% один бит выходит за г
\index{Флаги!CF (переноса)}%
Значение бита, вышедшего за разрядную сетку, после выполнения команды заносится в~$CF$.
Освободившаяся с~другого конца $dest$ ячейка инициализируется в~соответствии с~видом сдвига.

При $times > 1$ однобитовый сдвиг повторяется $times$ раз.

Знаковый и~беззнаковый сдвиги используется для быстрого умножения и~деления на степени двойки.
% 
Сдвиги вправо эквивалентны соответственно знаковому (в~этом случае остаток предполагается неотрицательным как для положительных, так и~для отрицательных делимых) или беззнаковому делению на $2^{times}$.
В~случае однобитового сдвига (деления на два) остаток попадает в~$CF$.
Для б\'{о}льших значений сдвига остаток не вычисляется.

Сдвиг влево эквивалентен умножению на $2^{times}$, если результат умножения помещается в~$dest$. Если не помещается, старшая часть произведения теряется.

Кроме того, с~помощью  команд семейства \lstinline!btX! можно выделить отдельный бит числа.
Эти команды принимают два операнда "--- число-приёмник, один бит которого будет скопирован в~флаг~$CF$ и~затем изменён,
и~номер бита $idx$ "--- непосредственное значение или регистр.
Для младшего бита $idx=0$.
% При выполнении команды \lstinline!btX! значение бита  с~указанным номером заносится в~флаг~$CF$, 
% после чего этому биту числа присваивается новое значение.
Одна из команд семейства, \lstinline!bt!, не изменяет значение битов в~числе, но для единообразия её  операнд, из которого выделяется бит, также считается приёмником.

% \FloatBarrier




\subsection{Флаги}
\epigraphcensored[
\epigraph{
\begin{stanza}[0mm]
Грудью вперёд бравой!\\
Флагами небо оклеивай!
\end{stanza}
}{\Vvm[Левый марш]}]
{\epigraph{\begin{stanza}[0ex]
I can talk with you,\\
I can walk with you,\\
\hspace{\stanzaoddindent}All throughout your life;\\
Stay with you, smile on you,\\
\hspace{\stanzaoddindent}Light in your fire.\\
\end{stanza}}
{\Aquarium}
}
% \subsubsection{Установка, сохранение и~восстановление флагов}
% \subsubsection{Флаги}
\label{sec:asm-flags}
\index{Флаги!установка}%


Все арифметические команды устанавливают по результатам вычислений  флаги состояния.

% Команды группы сложения/вычитания устанавливают све шесть 
\index{Команды!арифметические}%
\index{Команды!inc}%
\index{Команды!dec}%
\index{Команды!add}%
% \index{Команды!adc}%
\index{Команды!sub}%
% \index{Команды!cmp}%
% \index{Команды!sbb}%
% \index{Команды!neg}%
\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!SF (знака)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!AF (коррекции)}%
Команды группы сложения/вычитания (\texttt{add/sub, inc/dec} и~т.\,д) выставляют все шесть флагов состояния $CF, PF, AF, ZF, SF, OF$ в~соответствии с~результатом:
\begin{itemize}
\item флаг нуля~$ZF$, если результат равен нулю;
\item флаг переноса (беззнакового переполнения)~$CF$ в~случае переноса/заёма за пределы разрядной сетки (беззнакового переполнения);
\item флаг знака~$SF$, если старший (знаковый) бит результата равен 1;
\item флаг знакового переполнения~$OF$, если произошло знаковое переполнение (перенос/заём из знакового бита, но не за пределы разрядной сетки, или наоборот);
\item флаг чётности $PF$, если количество единиц в~младшем байте результата чётно;
\item флаг вспомогательного переноса $AF$, если в~младшем байте был перенос между тетрадами.
\end{itemize}
При этом \lstinline!add $-1, dest! и~\lstinline!sub $1, dest! устанавливают флаги по-разному, в~частности, при сложении числа \lstinline!-1! (что на 32-разрядной платформе равно \lstinline!0xFFFFFFFF!)  с~нулём не происходит переноса в~старший бит ($OF=0$); при вычитании единицы из нуля возникает заём из старшего бита  ($OF=1$).

\index{Команды!not}%
\index{Команды!and}%
\index{Команды!or}%
\index{Команды!xor}%
% \index{Команды!test}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!SF (знака)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!AF (коррекции)}%
Побитовые команды (\lstinline!and, or, xor!) выставляют флаги $SF, ZF$ и~$PF$ в~соответствии с~результатом аналогично группе сложения/вычитания,
флаги переноса и~знакового переполнения сбрасываются: $CF = OF = 0$.
Значение флага~$AF$ не определено.

\index{Команды!mul}%
\index{Команды!imul}%
\index{Флаги!CF (переноса)}%
\index{Флаги!OF (переполнения)}%
Команды умножения выставляют флаги $CF=OF$ в~зависимости от того, выходит ли результат за разрядность множителей.
Значение остальных флагов не определено.
После команд деления все шесть флагов имеют неопределённое значение.

Существуют команды, которые только выставляют флаги и~не меняют значения своих операндов.
Они предназначены для сравнения чисел.
\index{Команды!сравнения}%
Это:
\begin{itemize}
\item \lstinline!cmp!
\index{Команды!cmp}%
"--- то же самое, что и~\lstinline!sub! (группа сложения/вычитания), но операнд-приёмник не изменяется (используется для сравнения целых чисел);
\item \lstinline!test!
\index{Команды!test}%
"--- то же самое, что и~\lstinline!and! (группа побитовых операций), но операнд-приёмник не изменяется (используется для сравнения битовых строк).
\end{itemize}

Основной набор инструкций x86 не содержит команд для обработки и,~в~частности, сравнения вещественных чисел.
Предназначенные для этого инструкции сравнения относятся к~набору команд FPU (раздел~\ref{sec:fpu-cmp}), но могут взаимодействовать с~регистром~$flags$.
\index{Команды!fcom}%
Вещественные числа можно сравнить командой \lstinline!fcom! и~подобными ей.
% Команда fcom имеет множество форм, аналогичных \lstinline!fsub!, а~также форму \lstinline!fcompp!, когда из стека выталкиваются оба операнда.
% Если суффикс \lstinline!p! не указан (\lstinline!fcom!), из стека ничего не выталкивается.
После сравнения флаги состояния сопроцессора копируются в~$flags$ (вручную или автоматически "--- в~зависимости от используемой команды сравнения) таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел:
$ZF$ указывает на равенство, $CF$ "--- на $dest<src$; кроме того, в~$PF$ копируется флаг несравнимости операндов. 
% , так что для команды .
% флаг $ZF$ соответствует нулевой 


 
Кроме того,  флаги можно установить или сбросить вручную 
с~помощью специальных команд или загрузив изменённый регистр~$flags$
(таблица~\ref{tab:flags-command-list}).
\begin{table}[!ht]
\small
\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/instr-flags.tex}
\index{Команды!stc}%
\index{Команды!clc}%
\index{Команды!cmc}%
\index{Команды!std}%
\index{Команды!cld}%
\index{Команды!sti}%
\index{Команды!cli}%
\index{Команды!lahf}%
\index{Команды!sahf}%
\index{Команды!pushf/pushfd/pushfq}%
\index{Команды!popf/popfd/popfq}%
\end{table}


% Кроме того, 
Младший байт регистра флагов, содержащий большую часть флагов состояния, можно загрузить для анализа в~регистр $ah$ командой~\lstinline!lahf! \ethm{(Load Flags into AH Register).} 
Обратная операция выполняется командой~\lstinline!sahf! \ethm{(Store AH into Flags).}
% 
Регистр $flags/eflags$ можно полностью поместить в~стек командами \lstinline!pushf/pushfd!, загрузить из стека "--- командами \lstinline!popf/popfd! соответственно.
% (таблица~\ref{tab:flags-command-list}).
При загрузке флагов из~$ah$ или стека зарезервированные биты не загружаются в~$flags$.




\subsection{Условные операторы}
\label{sec:asm-cc}
\epigraphcensored[\epigraph{
\begin{stanza}
Жезлом\\
правит,\\
чтоб вправо\\
шёл.\\
Пойду\\направо.\\
Очень хорошо.
\end{stanza}
}{\Vvm[Хорошо]}]
{\epigraph{\begin{stanza}
Я~могу быть бессмысленным,\\
Выбрать пути не те,\\
Но есть смелая истина\\
В~широте-долготе.\\
\end{stanza}}
{О.\,Арефьева}
}
\index{Команды!jCC}%
\index{Команды!setCC}%
\index{Команды!cmovCC}%
\index{Команды!fcmovCC}%

% Как было указано в~разделе~\ref{sec:flags}, 
Существует несколько семейств команд, действие которых определяется значением флагов состояния в~регистре~$flags$.
Это команды условного перехода \lstinline!jCC!, 
условной установки байта \lstinline!setCC! и~условной пересылки~\lstinline!cmovCC! и~\lstinline!fcmovCC!.
% (таблица~\ref{tab:cc-command-list}).
% 
% % Команды условного ветвления %\lstinline!jCC, setCC, loopCC!,
% % \lstinline!jCC!, 
% % условной установки байта \lstinline!setCC! и~условной пересылки~\lstinline!cmovCC! используют один или несколько флагов состояния, проверяя различные условия (таблица~\ref{tab:cc-command-list}).
% 
% \begin{table}[!ht]
% \caption{Условные команды}
% \label{tab:cc-command-list}
% 
% \small
% \def\normalsize{\small}
% \begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
% \hline
% \normalfont\thead{Команда} & \thead{Действие} 
% \\\hline
% jCC label	&	Переход по адресу $label$, если %установлено сочетание флагов 
% верно условие $CC$ (таблица~\ref{tab:jmp-command-list}) 	\\\hline
% setCC dest	&	Установка байта $dest = 1$, если %установлено сочетание флагов 
% верно  $CC$, и~$dest=0$ иначе	
% % 
% % $dest$ может быть однобайтовым регистром или переменной в~памяти
% \\\hline
% cmovCC src, dest	&	Присваивание $dest = src$, если %установлено сочетание флагов $CC$	\\\hline
% верно  $CC$ \\\hline
% fcmovCC \%st(i), \%st(0) & %Условная пересылка регистров~FPU 
% Присваивание  регистров~FPU  $st(0) = st(i)$, если %установлено сочетание флагов $CC$	\\\hline
% верно  $CC$
% (таблица~\ref{tab:fpu-fst-list}) \\\hline
% \end{tabularx}
% \end{table}

% \FloatBarrier

Команда~\lstinline!fcmovCC! относится к~набору команд FPU и~описана также в~разделе~\ref{sec:fcmovCC} (таблица~\ref{tab:fpu-fst-list}), но условие~$CC$ определяется значением регистра~$flags$,
а~не собственного регистра состояния~FPU.
% Соответственно,~\lstinline!fcmovCC! рассматривается в~данном разделе 

Мнемоники таких команд состоят из двух частей "--- общего для всех команд семейства обозначения действия (\lstinline!j! от \ethm{jump,} \lstinline!set! и~т.\,п.)
и~обозначения условия~$CC$.
Условие не может быть произвольным.
Существует определённый набор обозначений~$CC$, каждому из которых соответствует некоторое состояние флагов в~регистре $flags$ "--- условие.


\subsubsection{Условия}
\index{Флаги!проверка}%


Рассмотрим доступные варианты условий, их обозначения и~связь с~арифметическими операциями (таблица~\ref{tab:cc-list}). 


\begin{table}[p]
\small
\def\normalsize{\small}
\renewcommand\theadfont{\bfseries\footnotesize}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
% \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% \newcolumntype{H}{>{\raggedright\arraybackslash}X}
\providecommand{\att}[1]{{\emph{\textcolor{clGas}{\hfill #1}}}}

\newcolumntype{E}{m{0.71\linewidth}}%
% \newcolumntype{E}{l}%

\singlespacing
\renewcommand{\arraystretch}{1.2}

\LTXtable{\textwidth}{book/tables/cc-list.tex}

\index{Флаги!CF (переноса)}%
\index{Флаги!ZF (нуля)}%
\index{Флаги!SF (знака)}%
\index{Флаги!OF (переполнения)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!AF (коррекции)}%

\end{table}

Каждое из условий 
имеет некоторое буквенное обозначение~$CC$, приведённое в~первом столбце.
Одно и~то же условие может обозначаться по-разному, в~частности, «меньше или равно» "--- \lstinline!le! и~«не больше» "--- \lstinline!ng!,
но машинный код в~таких случаях одинаков.
Различные обозначения одного условия помещены в~одну ячейку таблицы и~разделяются косой чертой.

Мнемоники одного семейства с~разными условиями, в~частности, \lstinline!e! и~\lstinline!l!, ассемблируются в~разные машинные коды.


% соответствует некоторому 
Условие складывается из некоторой комбинации флагов состояния в~регистре $flags$,
указанной во втором столбце.
% 
Эти флаги определяются результатом последней  команды.
% Большинство из них выставляется только командами группы сложения/вычитания, в~частности, часто используемыми для реализации цикла командами \lstinline!inc/dec!.
% В~частности, 
% Команды группы сложения/вычитания (в~частности, часто используемыми для реализации цикла командами \lstinline!inc/dec!) выставляют все шесть флагов в~соответствии с~результатом.
% Команды умножения выставляют флаги $CF=OF$ в~зависимости от того, выходит ли результат за разрядность множителей.
% Побитовые команды выставляют флаги $SF, ZF$ и~$PF$ в~соответствии с~результатом.
% 
Различные виды арифметических команд  выставляют их в~соответствии с~полученным результатом.
\index{Команды!арифметические}%
\index{Команды!inc}%
\index{Команды!dec}%
% \index{Команды!add}%
% \index{Команды!adc}%
% \index{Команды!sub}%
% \index{Команды!cmp}%
% \index{Команды!sbb}%
% \index{Команды!neg}%
В~частности, команды группы сложения/вычитания (включая часто используемые для реализации цикла команды \lstinline!inc/dec!)
изменяют все шесть флагов состояния;
% \index{Команды!not}%
% \index{Команды!and}%
% \index{Команды!or}%
% \index{Команды!xor}%
% \index{Команды!test}%
побитовые команды "---  флаги $SF, ZF$ и~$PF$.
В~третьем столбце таблицы указаны свойства результата, приводящие к~подобному сочетанию флагов.


% \FloatBarrier

Часто перед условной командой вызывается команда сравнения \lstinline!cmp src, dest!, выставляющая флаги аналогично команде  \lstinline!sub src, dest! (то есть её результатом будет $dest-src$), но не изменяющая $dest$.
В~четвёртом столбце указаны соотношения между $dest$ и~$src$ для каждого условия.
Большинство обозначений условий образовано именно от них.


% Тем не менее
% \pagebreak[3]

Для беззнаковых операндов~$dest$ и~$src$ признаком отрицательности результата~$dest-src$ (то есть соотношения~$dest<src$)
будет заём в~старший бит при вычитании, то есть беззнаковое переполнение~$CF=1$.
Равенство операндов достигается при $dest-src=0$, что отмечается флагом нуля $ZF=1$.
Соответственно, $dest>src$ может быть, если $dest \not< src$ и~при этом $dest \neq src$, то есть $CF=ZF=0$.
Таким образом, любое соотношение между беззнаковыми операндами можно выразить через флаги~$CF$ и~$ZF$.

Чтобы отличить условия знакового и~беззнакового сравнения,
для беззнакового % сравнения
вместо термина «меньше» часто используется термин «ниже» \ethm{(below),} вместо «больше» "--- «выше» \ethm{(above).} 

Для знаковых %чисел отрицательность 
арифметических операций
знак результата невозможно определить только по знаковому биту (флагу $SF$), так как этот бит может быть искажён знаковым переполнением.
То есть если знак равен единице ($SF=1$), но в~процессе вычислений произошло знаковое переполнение ($OF=1$), то знаковый бит неверен и~результат на самом деле %неотрицателен
положителен.
Таким образом, результат будет отрицательным в~двух случаях: 
$\footnotesize
\left\{
\begin{array}{@{\,}l}
SF = 1\\
OF = 0
\end{array}
\right.
$ 
(знаковый бит "--- единица и~переполнения не было)
и~$\footnotesize
\left\{
\begin{array}{@{\,}l}
SF = 0\\
OF = 1
\end{array}
\right.
$
(было переполнение и~знаковый бит "--- ноль).
Обычно это условие записывается в~виде~$SF \neq OF$.
Соответственно, при~$SF=OF$ результат неотрицателен.

% Соответствующие обозначения 

% Кроме \lstinline!cmp!

% Флаг переноса~$CF$ используется многими командами «не по назначению»,
% поэтому, кроме обозначений \lstinline!b/nae! и nb/ae

% \FloatBarrier

% Условия для команд 
После сравнения вещественных чисел %и~выгрузки 
флаг вещественной несравнимости выгружается в~бит~$PF$ регистра~$flags$,
поэтому для команд условной пересылки вещественных чисел (и~только для них) условие $PF=1$ записывается как~\lstinline!u!.



\subsubsection{Условные и~безусловные переходы}
\index{Флаги!проверка}%
\index{Команды!jmp}%
\index{Команды!jCC}%

% \footnote{Использованы: 
% http://asmworld.ru/spravochnik-komand/jcond/,
% http://unixwiz.net/techtips/x86-jumps.html
% }

В~системе команд x86, а~соответственно, и~в~языке ассемблера, нет операторов, аналогичных операторам C++  \lstinline!if!, \lstinline!while!,  \lstinline!for! и~т.\,п.
Ветвления и~циклы реализуются при помощи команд условного и~безусловного перехода~\cite{asmworld}.

В~таблице~\ref{tab:jmp-command-list} приведены эти команды.
\index{Команды!передачи управления}%

\begin{table}[!ht]
\caption{Команды передачи управления}
\label{tab:jmp-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
jmp label	&	{Безусловный переход ($goto$)}
\\\hline
jCC label	&	Переход по адресу $label$, если верно условие $CC$ (%таблица~\ref{tab:cc-list}, 
кроме \texttt{u} и~\texttt{nu}) 	
\\\hline
\end{tabularx}
\end{table}


Безусловный переход \lstinline!jmp!
% \begin{lstlisting}
%   jmp label
% \end{lstlisting}
является аналогом оператора \lstinline!goto! языка C++ "--- передаёт управление команде по адресу $label$.

Команды условного перехода~\lstinline!jCC!
% \begin{lstlisting}
%   jCC label
% \end{lstlisting}
передают адресу $label$ при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~регистре $flags$).
Если условие не выполнено,  \lstinline!jCC! не делает ничего,  и~выполняется команда, следующая за \lstinline!jCC! по тексту программы.

Условие~$CC$ может быть любым из перечисленных в~таблице~\ref{tab:cc-list}, кроме \texttt{u} и~\texttt{nu} (но могут использоваться \texttt{p/pe} и~\texttt{np/po}).
В~частности, команда \lstinline!jnae label! \ethm{(jump if not above or equal)} передаст управление на метку~$label$ в~случае~\mbox{$CF=1$.}
Если перед командой условного перехода выполнялась команда \lstinline!cmp src, dest!, управление будет передано на метку~$label$ в~случае, если~$dest \not\geqslant src$ как беззнаковые числа.

Это условие эквивалентно $dest < src$.
Действительно, команды \lstinline!jnae! и~\lstinline!jb! \ethm{(jump if below)} имеют один и~тот же опкод. Также этот опкод соответствует мнемонике~\lstinline!jc! \ethm{(jump if carry).}

% Единственным аргументом команды перехода является метка команды, которая будет выполняться следующей всегда (безусловный переход) или при выполнении какого-либо условия (чаще всего при определённой комбинации флагов в~\lstinline!%eflags!).

% В~следующей таблице 
% В~таблице~\ref{tab:jmp-command-list}
% приведены некоторые команды условного перехода, соответствующие наиболее популярным условиям, а~также команда безусловного перехода \lstinline!jmp!.

% \begingroup
% \small
% \def\normalsize{\small}
% \renewcommand\theadfont{\bfseries\footnotesize}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% % \newcolumntype{E}[1]{>{\raggedright\arraybackslash}\tabularxcolumn{#1}}%
% % \newcolumntype{H}{>{\raggedright\arraybackslash}X}
% \providecommand{\jname}[1]{{\emph{\textcolor{olive}{#1}}}}
% \providecommand{\att}[1]{{\emph{\textcolor{magenta}{\hfill #1}}}}
% 
% \newcolumntype{E}{m{0.7\linewidth}}%
% 
% \singlespacing
% 
% \LTXtable{\textwidth}{book/tables/jmp-list.tex}
% 
% \endgroup

\index{Команды!loop}%
\index{Команды!loopCC}%
\index{Команды!jcxz}%
\index{Команды!jecxz}%
Кроме того, в~набор инструкций современных процессоров входят унаследованные от Intel 8086 команды псевдоцикла \lstinline!loop!, псевдоцикла с~анализом флага нуля \lstinline!loope/loopz! и~\lstinline!loopne/loopnz!, а~также такие команды условного перехода, как \lstinline!jcxz! и~\lstinline!jecxz! (переход, если регистр $cx/ecx$ равен нулю).
% Команды \lstinline!loopX метка! (
% Данные команды эквивалентны 
По своему действию команда \lstinline!loop label! эквивалентна  командам \lstinline!dec %ecx; jz label!, при этом \lstinline!loop! не меняет флаги $flags$. 
В~случае команд \lstinline!loope/loopz! и~\lstinline!loopne/loopnz! анализируется не только $cx/ecx$, но и~флаг нуля $ZF$ (управление на метку передаётся, если
% , кроме неравенства \lstinline!%cx/%ecx!  нулю, ещё флаг нуля (ZF) взведён или сброшен 
$\footnotesize
\left\{
\begin{array}{@{\,}l}
cx\neq0\\
ZF = 1
\end{array}
\right.
$
и~$\footnotesize
\left\{
\begin{array}{@{\,}l}
cx\neq0\\
ZF = 0
\end{array}
\right.
$
соответственно).

\index{Команды!dec}%
Эти команды были введены в~набор  8086 для получения более компактного кода (однобайтовая инструкция \lstinline!loop! заменяет связку двух однобайтовых \lstinline!dec+jz!) и~экономии дорогой памяти.
При этом пара инструкций \lstinline!dec+jz! выполняется быстрее \lstinline!loop!~\cite{agner_fog_optimizing_assembly,burdaev_kudiz_zzi}, легче читается и~позволяет организовывать вложенные циклы.
В~настоящее время оптимизация направлена на ускорение, соответственно,
использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать.

% Использования команд псевдоцикла \lstinline!loop!, \lstinline!loope/loopz!, \lstinline!loopne/loopnz! (а~также команд \lstinline!jcxz! и~\lstinline!jecxz!) следует избегать, так как они менее эффективны, чем комбинация сравнения и~условного перехода~\cite{agner_fog_optimizing_assembly}.
% % \footnote{Optimizing subroutines in assembly 
% % language.
% % An optimization guide for x86 platforms. 
% % By Agner Fog. Technical University of Denmark. }.

\subsubsection{Условная пересылка}
\index{Флаги!проверка}%
\index{Команды!условной пересылки}%
\index{Команды!jCC}%
\index{Команды!cmovCC}%
\index{Команды!mov}%
\index{Команды!movs}%
\index{Команды!movz}%
\index{Команды!fcmovCC}%

Для каждого условия~$CC$, кроме команды условного перехода \lstinline!jCC!,
% Для каждой команды условного перехода \lstinline!jCC! 
существует команда условной пересылки \lstinline!cmovCC src, dest!, выполняющая присваивание $dest = src$, если соответствующее условие верно.

В~таблице~\ref{tab:mov-command-list} показаны различные команды безусловной и~условной пересылки.

\begin{table}[!ht]
\caption{Команды пересылки данных}
\label{tab:mov-command-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
mov src, dest	&	Присваивание $dest = src$ %, $src$ "---  непосредственное значение, регистр или память одного размера с~$dest$
% $src \in \{imm, mem, reg\}, dest \in \{mem, reg\}$
\\\hline
\begin{tabular}{@{}l@{}}
movs srm, dreg\\movz srm, dreg
\end{tabular}	&	Присваивание $dreg = srm$ с~расширением %, $src$ "---  регистр или память 
% $src \in \{imm, mem, reg\}, dest \in \{mem, reg\}$
\\\hline
cmovCC srm, dreg	&	Присваивание $dreg = srm$, если верно  $CC$ (%таблица~\ref{tab:cc-list}, 
кроме \texttt{u} и~\texttt{nu}) \\\hline
fcmovCC \%st(i), \%st(0) & Присваивание  регистров~FPU  $st(0) = st(i)$, если верно  $CC$
 (\texttt{e, ne, b/nae, be/na, ae/nb, a/nbe,} \texttt{u} и~\texttt{nu})
\\\hline
setCC dest8	&	Присваивание $dest8 = \left\{\begin{array}{@{}ll}
1,& \text{если верно  $CC$ (кроме \texttt{u} и~\texttt{nu})}\\
0,& \text{иначе}
\end{array}\right.$ \\\hline
\end{tabularx}
\end{table}


Команды условной пересылки не полностью аналогичны \lstinline!mov!: источник может быть только регистром или в~памяти, приёмник "--- только регистром.
Пересылаемое значение  не может иметь размер 8 бит.

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
Для флагов, которые могут быть установлены командами сравнения FPU ($ZF, CF, PF$) существует также команда условной пересылки в~стеке FPU из $st(i)$ в~$st(0)$
\lstinline!fcmovCC  %st(i), %st(0)! (раздел \ref{sec:fcmovCC}, таблица~\ref{tab:fpu-mov-list}).



\subsubsection{Установка байта по условию}
\index{Флаги!проверка}%
\index{Команды!установки байта}%
\index{Команды!setCC}%

Для каждого условия~$CC$
% Для каждой команды условного перехода jCC 
существует команда установки байта по условию \lstinline!setCC dest8!, выполняющая присваивание $dest8 = 1$, если соответствующее условие верно, и~$dest8 = 0$ иначе.

% \section{Установка флагов}

Приёмник $dest8$ может быть как регистром, так и~переменной в~памяти, но только однобайтовыми.





\input{book/fragments/fpu}



\addquestion{Какой порядок операндов принят в~синтаксисе AT\&T?}


% \addquestion Знаковой или беззнаковой является операция инкремента?




% \addquestion{Какие вы знаете регистры общего назначения?}
% \addquestion{Какие вы знаете команды ассемблера x86?}
% \addquestion{Какие вы знаете флаги?}
% \addquestion{Какие регистры используются в~сопроцессоре для хранения операндов?}

\addquestion{Какие вы знаете команды передачи управления?}
\addquestion{Какие вы знаете команды  пересылки данных?}

\addquestion{Какие команды используются для обнуления регистра?}
\addquestion{Какие команды используются для выполнения арифметических операций над целыми числами?}

\addquestion{Какие команды используются для выполнения арифметических операций над вещественными числами?}



\addquestion{Какие команды используются для выполнения тригонометрических операций?}
\addquestion{Какие команды используются для сравнения вещественных чисел?}
\addquestion{Какие флаги регистра $flags$ содержат результат сравнения вещественных чисел?}


\printquestions
