



\chapter{Программирование на языке ассемблера}

% \epigraph{\begin{stanza}Ты с~умом и~со свечкой к~нему подступай,\\
%     С~упованьем и~крепкой дубиной,\\
%  Понижением акций ему угрожай\\
%   И~пленяй процветанья картиной...\end{stanza}
% }
% {\Snark}
\epigraph{\begin{limerick}
Удалой старичок из Салоников\\
Очень прыгать любил с~подоконников.\\
На вопрос: «Не опасно?»\\
Говорил он: «Прекрасно! "---\\
В~этом прелесть прыжков с~подоконников».
\end{limerick}
}
{\Lear}
\section{Особенности GNU Assembler}
\epigraph{\begin{stanza}
А~тот, кто сторожит баржу, спесив \\
И~вообще не святой;\\
Но тот, кто сторожит баржу, красив \\
Неземной красотой.\\
\end{stanza}}
{\Aquarium}

\footnote{Использованы материалы:
GCC-Inline-Assembly-HOWTO,
Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А.
Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
X86 Assembly/GAS Syntax
}


Пробельные символы "--- пробел и~табуляция

Комментарии  "--- /* в~стиле C */, // в~стиле C++
% #<не выражение> устаревший

Оператор оканчивается переводом строки или точкой с~запятой.
Перед оператором может быть метка.
\begin{lstlisting}[numbers=none]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}


\subsection{Основные директивы}

.globl (.global)
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает символ  доступным из других модулей

.func  $\ldots$  .endfunc включает отладочную информацию о~функции

{Директивы определения данных (.data)}


.byte %одно или несколько выражений, разделённых запятыми

.short

.int (.long)

.quad

.float
(.single)

.double %одно или несколько вещественных значений, разделённых запятыми

\begin{lstlisting}
foo: .int 0, 1, 2
bar: .double -8.7
\end{lstlisting}

.string (.asciz) %"строка" 
\begin{lstlisting}
msg: .string "Hello, world!\n"
\end{lstlisting}

.rept $\ldots$ .endr
\begin{lstlisting}
.rept 3     .long 0
.long 0     .long 0
.endr       .long 0
\end{lstlisting}




Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% 
% Синтаксис AT&T немного 
отличается от синтаксиса Intel, который используется, например, MASM. 
%
Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.

\paragraph{Порядок операндов}
% В~отличие от синтаксиса Intel, 
Инструкция GAS обычно имеет вид  
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.

В~частности, рассмотрим одну из наиболее употребительных мнемоник ассемблера "--- команду пересылки (копирования) \lstinline!mov!.
Она соответствует оператору присваивания языков высокого уровня.
Её операнды "--- источник и~приёмник.
В~синтаксисе Intel пересылка $dst = src$ имела бы вид \lstinline!mov dst, src!; в~используемом в~данном пособии синтаксисе AT\&T она имеет вид \lstinline!mov src, dst!.
% 
Например, команда \lstinline!movb $0x05, %al! помещает значение 5 в~регистр \lstinline!AL!.

\paragraph{Суффикс мнемоники}

Большая часть мнемоник соответствует не одной команде уровня архитектуры команд, а~целому семейству однотипных команд, которые выполняют одни и~те же действия над операндами различных размеров и, соответственно, имеют разные коды.

Размер операндов маркируется суффиксом, например, \lstinline!movl %edx, %eax!.

\noindent\begin{tabularx}{\linewidth}{|l|L|L|}
\hline
\thead{Суффикс} & \thead{Целые} & \thead{Вещественные} \\\hline
    b & byte (8 bit) &\\\hline
    s & short (16 bit integer) & single (32-bit floating point) \\\hline
    w & word (16 bit) &\\\hline
    l & long (32 bit integer) & double (64-bit floating point) \\\hline
    q & quad (64 bit) &\\\hline
    t & & ten bytes (80-bit floating point) \\\hline
\end{tabularx}
% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  размер может быть определён по регистровому операнду.
Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
% По умолчанию принимается 32-bit.

\paragraph{Префиксы}
Имена \emph{регистров} начинаются с~префикса \lstinline!%! (\lstinline!%eax!, \lstinline!%dl!).

\emph{Константы} отмечаются префиксом \lstinline!$!, например,
\lstinline!addl $5, %eax!
(добавить константу 5 к регистру \EAX).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!). Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

\index{Адресация!непосредственная}
\index{Адресация!прямая}
Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
\lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

\paragraph{Вычисление адреса}

Вычисление адреса с~одновременным разыменованием
$$
*\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
$$
в~соответствии с~синтаксисом~AT\&T имеет вид
{
\lstset{language=}
% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
\begin{lstlisting}
displacement(base, offset, scalar multiplier)
\end{lstlisting} 

где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).

В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
\begin{lstlisting}
[base + displacement + offset * scalar multiplier]
\end{lstlisting} 




\section{Минимальная программа на ассемблере}
\epigraph{\begin{stanza}Так скажем «Банзай», и~Бог с~ней, с~твердью;\\
Все, что прошло "--- сдадим в~утиль.\\
А~здесь у~нас в~центре циклона "---\\
Снежные львы и~полный штиль.\\
\end{stanza}}
{\Aquarium}





По умолчанию в~GCC программа (как на языке C/C++, так и~на языке ассемблера) собирается с~поддержкой стандартной библиотеки stdlib.
Соответственно, стартовой (главной) функцией программы является $int~main(int argc, char *argv[])$
 $int~main(int, char *[])$

% \section{Точка входа на ассемблере и~использование stdlib}

Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.

Минимальная программа с~использованием стандартной библиотеки stdlib:
\begin{lstlisting}
.globl main // точка входа (stdlib)
main:
     xorl %eax, %eax // EAX ^= EAX, то есть EAX = 0
     ret // return EAX
\end{lstlisting}
Команда ret, в~отличие от оператора return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах всегда подразумевается в~регистре \lstinline!%eax!, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр \lstinline!%eax! (в~данном случае это делается при помощи побитового исключающего «или»).

Эквивалент данной программы на С++  выглядит следующим образом:
\begin{lstlisting}
int main()
{
    return 0;
}
\end{lstlisting}

Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции \lstinline!printf! библиотеки stdlib
\begin{lstlisting}
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на ассемблере выглядит следующим образом:
\begin{lstlisting}
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    movl $0, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются. 

Параметры функции \lstinline!printf! в~соответствии с~соглашением cdecl передаются через стек (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).


Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению cdecl эти параметры передаются в~обратном порядке (то есть на вершине стека оказывается первый):
\begin{lstlisting}
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  movl $0, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~\lstinline!%esp!, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности, \lstinline!%eax!) меняется.



















\section{Ассемблерные вставки в~код C++}
\label{sec:asm-inline}
\epigraph{\begin{limerick}
Одна дама, живущая в~гавани,\\
возмечтала отправиться в~плаванье,\\
Но когда на дубу\\
поглядела в~трубу,\\
То решила "--- спокойнее в~гавани.\\
\end{limerick}
}
{\Lear}

\addquestion Каким ключевым словом открывается ассемблерная вставка?


Для вставки одной или нескольких инструкций ассемблера используется ключевое слово \lstinline!asm!.
% 
% В~разделе 
%  [dcl.asm]
%  стандарта C++ сказано
% «An asm declaration has the form
% asm-definition:
% \lstinline!asm ( string-literal ) ;!
% The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
% is used to pass information through the implementation to an assembler. — end note ]»

Стандарт C++ описывает %синтаксис ассемблерной вставки как
использование  \lstinline!asm! следующим образом:
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}
% содержимое круглых скобок 
конкретный вид \lstinline!string-literal! 
при этом не регламентируется.
% \lstinline!asm("assembly code");!
% 
Обычно такие вставки используются для передачи кода непосредственно ассемблеру.


% Так как ассемблерный код  не стандартизирован, синтаксис 
% Синтаксис 
Содержимое
таких вставок зависит как от архитектуры целевого аппаратного обеспечения (набор команд, регистров и~т.\,д.), так и~от компилятора (мнемоники команд, порядок операндов, синтаксис и~т.\,д.).

Используемая операционная система определяет {только} обращения \emph{непосредственно к~интерфейсам операционной системы} (системные вызовы Linux и~BSD, функции API Windows~т.\,п.).
% Если не использовать напрямую интерфейсы операционной системы, 
% а~вызывать, например, функции стандартной библиотеки С/С++, методы Qt или функции, описанные в~C/C++ части проекта, ассемблерная вставка будет работать под любой операционной системой, где есть нужный компилятор (и~Qt).
% http://www.linux.org.ru/forum/development/11701125
% вставка будет собираться и~работать под любой  операционной системой. 
Вычисления, а~также обращение к~стандартной библиотеке С или к~кроссплатформенным библиотекам типа Qt описываются одинаково под любой операционной системой.





\section{Синтаксис ассемблерных вставок в~GCC}

Ассемблерная вставка в~программу, собираемую компилятором GCC, может быть описана с~использованием двух ключевых слов: \lstinline!asm!  либо \lstinline!__asm__!%
~\cite{sysbin.com/files/lowlevel/gcc_inline_assembly.htm,
ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html,
ru.wikibooks.org/wiki/
}%
. 
Эти формы равнозначны и~используют одинаковый синтаксис. Форма \lstinline!__asm__! применяется, когда стандартное ключевое слово \lstinline!asm! конфликтует с~чем-либо в~программе.

\subsection{Базовая форма}
Базовая форма ассемблерной вставки выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    );
\end{lstlisting}
Ключевое слово volatile для базовой формы не оказывает никакого эффекта, так как такая вставка не оптимизируется компилятором никогда.

Например:
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX := ECX
\end{lstlisting}
или
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX := BH (байт)
\end{lstlisting}
Если код во вставке содержит более одной строки, то каждая строка помещается в~кавычки. 
Тем не менее, этого недостаточно для разделения инструкций.

\subsubsection{Разделение инструкций}

% Несколько 
При компиляции соседние строки ассемблерной вставки склеиваются, как склеиваются части любой строковой константы "--- точно так же, как в~объявлении вида
\begin{lstlisting}
    char *s = "abcd"
        "ABCD";
\end{lstlisting}
которое задаёт строку \lstinline!"abcdABCD"!, не разделённую посередине никаким символом.
То есть вставка
\begin{lstlisting}
asm ("movl %eax, %ebx"
     "movl $56, %esi");
\end{lstlisting}
На самом деле выглядит как
\begin{lstlisting}
asm ("movl %eax, %ebxmovl $56, %esi");
\end{lstlisting}
и~вызывает логичное сообщение о некорректном имени регистра «ebxmovl».

Таким образом, если во вставке необходимо использовать более одной инструкции, то  
в~конце каждой строки необходимо поместить суффикс \lstinline!\n! для разделения инструкций (если желательно иметь красивый выходной файл, можно использовать суффикс  \lstinline!\n\t!, если форматирование выходного файла безразлично "--- можно использовать вместо  \lstinline!\n! разделитель \lstinline";").
% \lstinline!\n\t!, чтобы сформированный компилятором ассемблерный файл был корректно отформатирован.
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movl %ecx, $label(%edx,%ebx,$4)\n"
     "movb %ah, (%ebx)");
\end{lstlisting}

\subsubsection{Доступные в~базовой форме вставки имена}

Внутри ассемблерной вставки можно обращаться по именам к~регистрам, а~также к~глобальным %и~статическим (то есть имеющим фиксированный адрес) <- не получается 
переменным программы:
\begin{lstlisting}
int n = 12;

int main(){
    asm ("incl n");
    cout << n <<endl;
    return 0;
}
\end{lstlisting}
% Параметры функций 
Локальные переменные функций размещаются компилятором в~стеке (причём не всегда в~порядке объявления), поэтому к~ним необходимо обращаться, используя \emph{расширенный ассемблер GCC,} а~именно \termin{параметры вставок.}
Необходимо также учитывать, что в~регистрах, используемых во вставке, ранее компилятором могла быть размещена какая-либо регистровая переменная.
В~этом случае компилятор не определяет автоматически, что регистр изменён, что может привести к~краху программы.

\warning{
На практике описанную выше базовую форму ассемблерных вставок \mbox{(без параметров)} не стоит использовать \emph{никогда}.

Только расширенная форма даёт возможность корректного взаимодействия с~программой на ЯВУ.
}
% Вставка "--- не функция.

% \subsection{Передача параметров в~ассемблерную вставку}
\subsection{Расширенная форма} %http://www.gamedev.ru/code/articles/gcc_inline_asm?page=3
\addquestion Как из ассемблерной вставки обратиться к~локальным переменным?

% http://www.ibm.com/developerworks/ru/library/l-linux_kernel_15/index.html
Синтаксис  вставки (расширенный) в~GCC может иметь две формы.

Первая выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}

% Ключевое слово const используется в~случае, когда выходные параметры зависят только от входных, что позволяет, в~частности, вынести блок за тело цикла при оптимизации.
% Один из случаев, когда const нельзя использовать "--- когда один из входных параметров интерпретируется как указатель. Значение по данному адресу может измениться, даже если сам адрес неизменен.

Ключевое слово volatile  
используется для того, чтобы указать компилятору, что вставляемый ассемблерный код может обладать побочными эффектами, поэтому попытки оптимизации могут привести к логическим ошибкам.
% В~частности, если необходимо не менять вставку местами с~дрк
% запрещает компилятору оптимизировать блок и~указывает вставить его как есть.

Вторая форма расширенной ассемблерной вставки имеет вид
\begin{lstlisting}[style=lstsmall]
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  

Ключевое слово goto указывает, что ассемблерный код может делать переходы на метки, перечисленные в~соответствующем разделе.

Обращение к~параметру-метке предваряется префиксом \lstinline!%l! (от \emph{label}), за которым идёт порядковый номер метки в~списке всех параметров; псевдоним для метки указать нельзя.
В~частности, данный код переходит к~метке \lstinline!carry:! (и~функция возвращает~1), если в~числе~$p1$ взведён бит с~номером~$p2$ (младший бит имеет нулевой номер).
\begin{lstlisting}[style=lstsmall]
asm goto (
    "btl %[BitIdx], %[Val]\n\t"
    "jc %l2"
    :: [Val]"r" (p1), [BitIdx]"r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда BT  копирует бит, номер которого передается вторым параметром, в~флаг CF.

% http://sysbin.com/files/lowlevel/gcc_inline_assembly.htm

Параметры указываются как \lstinline!%0!, \lstinline!%1! и~т.\,д. или как \lstinline!%[Value]!, где Value "--- определённый в~разделе %выходных 
параметров псевдоним (если параметр соответствует какой-либо переменной ЯВУ, то псевдоним может как совпадать, так и~не совпадать с~именем этой переменной).
% Примечание:е
Если в коде указаны параметры, которые, как и регистры, начинаются с префикса \lstinline'%', то регистры указываются с префиксом \lstinline'%%', например, \lstinline!%%eax!.

Общее количество параметров ограничено: $input + output + goto \leqslant 30$.


\subsubsection{Выходные параметры}

Раздел выходных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

% https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands
Описание выходного параметра
в~общем случае имеет вид:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cvariablename)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда.
Область определения такого псевдонима "--- вся ассемблерная вставка.
Псевдоним может быть любым допустимым идентификатором C++.
Два разных операнда не могут использовать один псевдоним.

Псевдоним выходного параметра может быть указан как ограничение расположения входного.
В этом случае параметр с~данным псевдонимом является входным и~выходным одновременно (как правило, это изменяемая во вставке переменная).

Если псевдоним не определён, используются номер операнда, начиная с~нуля: \lstinline!%0! для первого, \lstinline!%1! для второго и~т.\,д.
% \begin{lstlisting}[style=lstsmall]
% int x;
% asm
% (
%     "movl $12, %[x]\n"
%     :[x]"=rm"(x)
% );
% \end{lstlisting}

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для выходного параметра начинается с~символа \lstinline!=! (если значение параметра перезаписывается) %, после которого 
или \lstinline!+! (если значение параметра используется как для чтения, так и~для записи).

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

При выборе регистра для размещения выходного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++ (lvalue), куда будет записано значение выходного параметра (обычно имя переменной).

Если для выходного параметра указано размещение в~регистре и~имя соответствующей переменной, это не значит, что переменная обязательно будет размещена в~регистре.
Возможно, в~регистре будет сформировано выходное значение, которое затем будет скопировано в~локальную стековую переменную.

\end{description}
Например, данный фрагмент записывает константу 12 в~переменную~$x$:
\begin{lstlisting}[style=lstsmall]
int x;
asm
(
    "movl $12, %[x]\n"
    :[x]"=rm"(x)
);
\end{lstlisting}
начальное значение параметра \lstinline![x]! не определено.

Следующий фрагмент кода удваивает~$x$:
\begin{lstlisting}[style=lstsmall]
asm
(
    "addl %[x], %[x]\n"
    :[x]"+r"(x)
);
\end{lstlisting}
Символ  \lstinline!+! в~строке расположения указывает на то, что данный параметр является не чисто выходным, а~модифицируемым.
Начальное значение параметра \lstinline![x]! берётся из~выражения-приёмника, в~данном случае "--- переменной~$x$.
% Если бы ограничение расположения начиналось бы с~\lstinline!=!, начальное значение параметра было бы не определено.

\subsubsection{Входные параметры}

Раздел входных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

Описание входного параметра в~общем случае:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cexpression)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда, аналогично псевдонимам выходных параметров.

Если псевдоним не определён, используются номер операнда, начиная со следующего за последним выходным параметром.
Если есть два выходных параметра, то первый входной будет обозначен \lstinline!%2! и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для входного параметра не может начинаться ни с~\lstinline!=!, ни с~\lstinline!+!.

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

Если входной параметр должен располагаться там же, где один из выходных,
расположение также может быть указано цифрой или псевдонимом данного выходного параметра.

При выборе регистра для размещения входного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++, откуда берётся значение входного параметра (также может быть именем переменной).

\end{description}

Например, конструкция:
\begin{lstlisting}[style=lstsmall]
asm ("movl %0, %%eax"::"i"(1) : "%eax");
\end{lstlisting}
превратится после компиляции %в~ассемблерном коде 
в:
\begin{lstlisting}[style=lstsmall]
movl $1, %eax
\end{lstlisting}

Данный фрагмент эквивалентен \lstinline!foo += bar!:
\begin{lstlisting}[style=lstsmall]
int foo = 6, bar = 12;
asm ("addl %[bar], %[foo]"
    : [foo]"+r"(foo)
    : [bar]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
причём, если переменная foo не располагается в~регистре изначально, её значение будет скопировано в~регистр, а~после добавления bar результат будет скопирован обратно в~foo.


\subsubsection{Перезаписываемые элементы%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\#Clobbers}%,
% {https://ru.wikipedia.org/wiki/GCC\_Inline_Assembly#.C2.ABmemory.C2.BB\_.D0.B2\_clobber\_list}
}
}

Код в~ассемблерной вставке может прямо или косвенно изменять значения не только выходных параметров, но и прочих регистров.
Эти регистры перечисляются в~списке перезаписываемых (clobber) регистров.

В~частности, команда умножения в~своей классической форме (\lstinline!%eax = %eax*src!) записывает старшую часть произведения в~\lstinline"%edx".
\begin{lstlisting}[style=lstsmall]
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}

Если во вставке явно модифицируется какой-либо регистр (что не рекомендуется; в~случае, если нужен регистр для хранения временного значения, лучше объявить фиктивный входной параметр, как описано в~следующем подразделе), его также необходимо указать в~списке перезаписываемых элементов.
% \hyperref[sss:inline:tmpreg]{qq}
% \pagebreak[3]
% 
\begin{lstlisting}
asm ("movl %[One], %%eax"    
  ::[One]"i"(1)  
  : "%eax");	// movl $1, %eax
\end{lstlisting}
\pagebreak[3]

Неуказание таких регистров в~списке перезаписываемых, скорее всего, приведёт к~тому, что компилятор поместит один из параметров вставки или переменных ЯВУ в~этот же регистр и,~соответственно, к~непредсказуемому значению в~нём. 

Специальные аргументы для списка перезаписываемых регистров:
\begin{description}
\item["cc"]
показывает, что код изменяет регистр флагов.

Флаги изменяют все арифметические инструкции.


\begin{lstlisting}[style=lstsmall]
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}



\item["memory"]
показывает, что код меняет значение в~памяти (не считая явно указанных выходных параметров) "--- например, интерпретирует какой-либо из параметров как указатель.

\begin{lstlisting}[style=lstsmall]
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}


% Помимо простого указания компилятору, что ассемблерная вставка изменяет содержимое памяти, она ещё служит директивой Memory Barrier для компилятора. Это означает, что те операции обращений в память, которые стоят выше по коду, в результирующем машинном коде будут выполняться до тех, которые стоят ниже ассемблерной вставки. В случае многопоточной среды, когда от этого напрямую зависит риск возникновения race condition, это обстоятельство является существенным.

% Кроме указания компилятору на изменение памяти,
% барьер компилятора

При указании \lstinline!"memory"! в~списке перезаписываемых элементов все операции работы с~памятью, которые были в~программе до ассемблерной вставки, выполнятся до неё, а~те, что стоят в~программе после "--- будут после.
В~противном случае компилятор может поменять местами как операторы C++, так и~ассемблерные вставки.
\end{description}


\subsection{Практическое использование параметров}


\subsubsection{Временные регистры%
\footnote{Использованы материалы:
{http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}
}
}

% \labellocal{sss::tmpreg}
% \label{sss:inline:tmpreg}

Использовать под временные данные фиксированные регистры и~указывать их в~списке  перезаписываемых не вполне корректно.

Более правильным будет ввести фиктивный выходной параметр, размещаемый в~регистре (\lstinline!=r! или \lstinline!=&r!, либо более конкретное ограничение "--- подробнее указано в~разделе \ref{sec:Constraints}), так как это даст компилятору больше свободы при оптимизации.

В~тексте вставки можно использовать данный параметр для хранения произвольных временных данных.

% Так, в~программе 
% \begin{lstlisting}[style=lstsmall]
% int main()
% {
%     int a=77, b;
%     asm("movl %0, %%eax"::"d"(a));
%     asm("movl %%eax, %0":"=d"(b));
%     cout << b;
%     return 0;
% }
% \end{lstlisting}
% первая вставка записывает значение локальной переменной \lstinline!a! через регистр \EDX{} (\lstinline!"d"!) в~регистр \EAX;
% вторая "--- содержимое регистра \EAX{} записывает через регистр \EDX{} в~переменную \lstinline!b! (\lstinline!"=d"(b)!).
% То есть если вставки сохранят порядок после компиляции (что не гарантируется), программа копирует содержимое локальной переменной \lstinline!a! (77) в~локальную переменную \lstinline!b!, и~последующий оператор вывода выведет 77. 

Пересылка через временный регистр:
\begin{lstlisting}[style=lstsmall]
int src = 1, dst, tmp;
asm
(
    "movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);
\end{lstlisting}


\subsubsection{Модификация входных параметров}

Модифицировать входные параметры, не являющиеся одновременно и~выходными, \termin{нельзя}.

Если возникает необходимость изменить значение, переданное как входной параметр, оно должно быть описано ещё и~как выходной.


Рассмотрим код, который увеличивает переменную $foo$ на значение переменной $bar$.
В~данном случае $bar$ может быть только входным параметром, а~$foo$ "--- модифицируемым, то есть  одновременно и~входным, и~выходным.

В~следующем фрагменте неименованный параметр \lstinline!%0! является входным и~выходным одновременно (точнее, входной параметр \lstinline!%1! располагается там же, где и~выходной \lstinline!%0!).
Это определяется ограничением размещения входного параметра \lstinline!%1! "--- %вместо  ограничений 
там указан номер параметра \lstinline!%0!.
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
); // foo += bar
\end{lstlisting}
Аналогичные вычисления с~использованием именованных параметров (\lstinline![S]! здесь "--- %и~входной и~выходной параметр
выходной параметр в~регистре, и~в~том же регистре расположен неименованный входной параметр) выглядят следующим образом.
% \begin{lstlisting}[style=lstsmall]
% asm("addl %[A], %[X]\n"
%     : [X]"=r"(foo)
%     :"[X]"(foo), [A]"g" (bar)
%     :"cc"
% ); // foo += bar
% \end{lstlisting}
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
% Используя \lstinline![S]! как приёмник сложения, мы фактически модифицируем неименованный выходной параметр \lstinline!%1!
Мы используем  неименованный выходной параметр \lstinline!%1!, чтобы задать начальное значение входному~\lstinline![S]!.
В данном случае (входной параметр инициализируется исходным значением $foo$ "--- приёмника совмещённого с~ним выходного параметра~\lstinline![S]!) можно было и~не вводить дополнительный входной параметр, а~заменить описание% %ограничение расположения
~\lstinline![S]! на~\lstinline![S]"+r" (foo)!.


Описание параметра как выходного и~входного одновременно (точнее, однорасположенной пары параметров <<выходной-входной>>), в~частности, делает параметр сохраняющим предсказуемое значение на всём протяжении вставки.
Если такой параметр размещается в~регистре, никакой другой параметр данной вставки не будет помещён в~этот регистр.

Отличие такого описания параметра от выходного с~начальным значением (расположение которого начинается с~\lstinline!+!) "--- то, что источник начального значения  может отличаться от исходного значения назначения.
Так, следующий фрагмент кода устанавливает начальное значение параметра-регистра \lstinline![S]! нулём, а~значение этого регистра после завершения вставки записывается в~переменную~$foo$:
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}
% Если для инициализации выходного параметра не требуется значение, отличное от~исходного значения его приёмника,

Также для входного параметра, расположенного на месте выходного, можно задать отдельный псевдоним. %, так как %, в~отличие от 
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : [S_initial_value]"[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}


\subsubsection{Конфликт выходных и~входных долгоживущих параметров}

При размещении параметров в~регистрах компилятор считает, что входные параметры используются в~начале вставки, а~выходные "--- в~конце, \emph{после} использования всех входных.
Соответственно, <<только входные>> параметры часто располагаются в~тех же регистрах, что и~<<только выходные>>, чтобы освободить максимальное количество регистров для других переменных.

Это может привести к~конфликту, если какой-либо входной параметр используется в~конце вставки, после присваивания хотя бы одного из выходных параметров.
При размещении этих двух параметров в~одном регистре присваивание уничтожит оригинальное значение входного параметра.

В частности, данный фрагмент (вычисляющий $y = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$) в~случае размещения входного параметра \lstinline![Zero]! и~выходного \lstinline![y]! в~одном регистре работает некорректно ($y$ всегда равен $1$, так как инициализация выходного параметра  \lstinline![y]! единицей выполняется до чтения  входного параметра \lstinline![Zero]!, и~в~момент условного присваивания \lstinline!cmovll %[Zero], %[y]! регистр, где расположены оба этих параметра, равен $1$).
\begin{lstlisting}[style=lstsmall]
int x = 10, y;
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
); // y = 1 независимо от x
\end{lstlisting}
Это можно исправить, объявив \lstinline![y]! выходным параметром с~начальным значением (\lstinline!+! вместо \lstinline!=! в~расположении), хотя нам и~не требуется исходное значение переменной~$y$.
Такое ограничение не позволит компилятору совместить  какой-либо входной параметр с~\lstinline![y]!.
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"+r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
% 
Другой способ "--- явно указать, какой входной параметр следует расположить на месте выходного~\lstinline![y]!.
Здесь мы можем совместить с~\lstinline![y]! входной \lstinline![x]!, так как последнее чтение~\lstinline![x]! (сравнение \lstinline![x]! с~нулём) выполняется до инициализации~\lstinline![y]!:
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"[y]" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Оба этих способа позволяют разрешить конфликт и~получить корректное значение~$y$.
% $y = \left\{\begin{array}{ll}
% 1, & x \geqslant 0 \\
% 0, & x < 0 \\
% \end{array}\right.$

\subsection{%Типы размещения параметров% 
Ограничения на расположение операнда%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Constraints.html\#Constraints}
}
}
\label{sec:Constraints}

\addquestion Какие вы знаете ограничения на размещение параметров ассемблерных вставок?


% https://gcc.gnu.org/ml/gcc/1999-10n/msg00488.html
% Типы параметров:
Некоторые общие ограничения (типы размещения параметров):
\begin{description}
\item[r] "--- регистр; %- register
\item[m] "--- память; %- memory effective address
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); %- immediate value, 0..0xffffffff
\item[g] "--- память, регистр общего назначения или непосредственное значение (обычно этот тип эквивалентен \lstinline"rim"); %- general effective address
\item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
\end{description}

% But there are some i386-specific ones described in the processor-specific
% part of the manual and in more detail in GCC's i386.h:
Некоторые ограничения (типы), специфичные для i386 (определены в~файле i386.h GCC)
\begin{description}
\item[q] "--- регистр, который можно адресовать по байтам младшего слова (EAX, EBX, ECX, EDX); %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров  EDX:EAX;
\item[a, b, c, d, S, D] "--- регистры eax, ebx, ecx, edx, esi, edi соответственно;

\item[I..P] "--- машинно-зависимые ограничения для констант:
% \end{description}
% 
% Ограничения для констант:
% \begin{description}
% \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% %     ("i" would allow an address known only at link time)
\begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% \item[K] "--- Signed 8-bit integer constant. ?  255
% \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (сдвиги, которые может выполнить lea);
\item[N] "--- непосредственное значение в~диапазоне 0..255 (беззнаковое однобайтовое).
% \item[O] "--- непосредственное значение в~диапазоне 0..32
\end{description}
\end{description}

\printquestions

