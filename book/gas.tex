



\chapter{Программирование на языке ассемблера}

% \epigraph{\begin{stanza}Ты с~умом и~со свечкой к~нему подступай,\\
%     С~упованьем и~крепкой дубиной,\\
%  Понижением акций ему угрожай\\
%   И~пленяй процветанья картиной...\end{stanza}
% }
% {\Snark}
\epigraph{\begin{limerick}
Удалой старичок из Салоников\\
Очень прыгать любил с~подоконников.\\
На вопрос: «Не опасно?»\\
Говорил он: «Прекрасно! "---\\
В~этом прелесть прыжков с~подоконников».
\end{limerick}
}
{\Lear}
\section{Особенности GNU Assembler}
\epigraph{\begin{stanza}
А~тот, кто сторожит баржу, спесив \\
И~вообще не святой;\\
Но тот, кто сторожит баржу, красив \\
Неземной красотой.\\
\end{stanza}}
{\Aquarium}

\footnote{Использованы материалы:
GCC-Inline-Assembly-HOWTO,
Садыхов Р.Х., Поденок Л.П., Отвагин А.В., Глецевич И.И., Пынькин Д.А.
Средства параллельного программирования в ОС Linux: Учеб. пособие / Под ред. Р.Х. Садыхова. -- Мн.: ЕГУ, 2004. -- 475 с.,
X86 Assembly/GAS Syntax
}


Пробельные символы "--- пробел и~табуляция

Комментарии  "--- /* в~стиле C */, // в~стиле C++
% #<не выражение> устаревший

Оператор оканчивается переводом строки или точкой с~запятой.
Перед оператором может быть метка.
\begin{lstlisting}[numbers=none]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}


\subsection{Основные директивы}

.globl (.global)
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает символ  доступным из других модулей

.func  $\ldots$  .endfunc включает отладочную информацию о~функции

{Директивы определения данных (.data)}


.byte %одно или несколько выражений, разделённых запятыми

.short

.int (.long)

.quad

.float
(.single)

.double %одно или несколько вещественных значений, разделённых запятыми

\begin{lstlisting}
foo: .int 0, 1, 2
bar: .double -8.7
\end{lstlisting}

.string (.asciz) %"строка" 
\begin{lstlisting}
msg: .string "Hello, world!\n"
\end{lstlisting}

.rept $\ldots$ .endr
\begin{lstlisting}
.rept 3     .long 0
.long 0     .long 0
.endr       .long 0
\end{lstlisting}




Ассемблер из коллекции компиляторов GCC (GNU Assembler, gas), использует синтаксис AT\&T, принятый в Unix, и~%
% 
% Синтаксис AT&T немного 
отличается от синтаксиса Intel, который используется, например, MASM. 
%
Перечислим основные отличия. % синтаксиса GAS от синтаксиса Intel.

\paragraph{Порядок операндов}
% В~отличие от синтаксиса Intel, 
Инструкция GAS обычно имеет вид  
\begin{lstlisting}
mnemonic source, destination
\end{lstlisting} 
то есть
вначале указывается источник, затем приёмник.
Например, команда \lstinline!movb $0x05, %al! помещает значение 5 в~регистр \lstinline!AL!.

\paragraph{Суффикс мнемоники}

Размер операндов маркируется суффиксом, например, \lstinline!movl %edx, %eax!.

\noindent\begin{tabularx}{\linewidth}{|l|L|L|}
\hline
\thead{Суффикс} & \thead{Целые} & \thead{Вещественные} \\\hline
    b & byte (8 bit) &\\\hline
    s & short (16 bit integer) & single (32-bit floating point) \\\hline
    w & word (16 bit) &\\\hline
    l & long (32 bit integer) & double (64-bit floating point) \\\hline
    q & quad (64 bit) &\\\hline
    t & & ten bytes (80-bit floating point) \\\hline
\end{tabularx}
% If the suffix is not specified, and there are no memory operands for the instruction, GAS infers the operand size from the size of the destination register operand (the final operand).
Если суффикс не указан,  размер может быть определён по регистровому операнду.
Если при этом оба операнда "--- регистры, размер определяется по приёмнику.
% По умолчанию принимается 32-bit.

\paragraph{Префиксы}
Имена \emph{регистров} начинаются с~префикса \lstinline!%! (\lstinline!%eax!, \lstinline!%dl!).

\emph{Константы} отмечаются префиксом \lstinline!$!, например,
\lstinline!addl $5, %eax!
(добавить константу 5 к регистру \EAX).

Дополнительно возможны префиксы \lstinline!0x! для шестнадцатеричных констант, \lstinline!0! для восьмеричных и~\lstinline!0b! для двоичных (\lstinline!$0xFF!, \lstinline!$0577!, \lstinline!$0b101!). Десятичные константы записываются без ведущих нулей, шестнадцатеричные и~двоичные могут иметь ведущие нули после префикса.

Метки, в~частности, глобальные переменные, также являются константами "--- их значения равны адресу следующей за меткой команды или ячейки памяти.

\index{Адресация!непосредственная}
\index{Адресация!прямая}
Отсутствие префикса \lstinline!$! перед константой соответствует разыменованию указателя; поэтому
\lstinline!movl $foo, %eax! помещает адрес переменной \verb|foo| в~регистр \verb|eax|, а~команда \lstinline!movl foo, %eax! помещает в \verb|eax| содержимое переменной \verb|foo|;
команда \lstinline!movl $0, %eax! запишет в~регистр \verb|eax| нулевое значение, а~\lstinline!movl 0, %eax! вызовет ошибку из-за попытки чтения памяти по нулевому адресу.

\paragraph{Вычисление адреса}

Вычисление адреса с~одновременным разыменованием
$$
*\big(base + displacement + \mathit{offset} \cdot scalar\,multiplier\big)
$$
в~соответствии с~синтаксисом~AT\&T имеет вид
{
\lstset{language=}
% There are up to 4 parameters of an address operand that are presented in the syntax displacement(base register, offset register, scalar multiplier).
\begin{lstlisting}
displacement(base, offset, scalar multiplier)
\end{lstlisting} 

где \lstinline!base! и~\lstinline!offset! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (масштабный коэффициент "--- степень двойки).
% в~форме \lstinline!displacement(base register, offset register, scalar multiplier)!,
% где \lstinline!base register! и~\lstinline!offset register! "--- регистры, \lstinline!displacement! "--- целое число (смещение), \lstinline!scalar multiplier! "--- число (степень двойки).

В~соответствии с~синтаксисом Intel то же самое записывается в~более интуитивно понятной форме 
% \lstinline![base + displacement + offset * scalar multiplier]!.
\begin{lstlisting}
[base + displacement + offset * scalar multiplier]
\end{lstlisting} 




\section{Минимальная программа на ассемблере}
\epigraph{\begin{stanza}Так скажем «Банзай», и~Бог с~ней, с~твердью;\\
Все, что прошло "--- сдадим в~утиль.\\
А~здесь у~нас в~центре циклона "---\\
Снежные львы и~полный штиль.\\
\end{stanza}}
{\Aquarium}








% \section{Точка входа на ассемблере и~использование stdlib}

Точка входа в~программу (функция main) также может находиться в~ассемблерном модуле.

Минимальная программа с~использованием стандартной библиотеки stdlib:
\begin{lstlisting}
.globl main // точка входа (stdlib)
main:
     xorl %eax, %eax // EAX ^= EAX, то есть EAX = 0
     ret // return EAX
\end{lstlisting}
Команда ret, в~отличие от оператора return, не принимает возвращаемое значение как параметр.
Целый результат в~соответствии с~соглашениями о~вызовах всегда подразумевается в~регистре \lstinline!%eax!, поэтому, чтобы вернуть код успешного завершения программы (0), необходимо обнулить регистр \lstinline!%eax! (в~данном случае это делается при помощи побитового исключающего «или»).

Эквивалент данной программы на С++  выглядит следующим образом:
\begin{lstlisting}
int main()
{
    return 0;
}
\end{lstlisting}

Более сложная программа, выводящая на экран строку \lstinline?"Hello, world!\n"? с~помощью функции \lstinline!printf! библиотеки stdlib
\begin{lstlisting}
int main()
{
    printf("Hello, world!\n");
    return 0;
}\end{lstlisting}
на ассемблере выглядит следующим образом:
\begin{lstlisting}
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека  
    movl $0, %eax
    ret
\end{lstlisting}
Воспользоваться в~ассемблерной программе оператором вывода в~поток \lstinline!<<! и~потоком стандартного вывода \lstinline!std::cout! затруднительно из-за %непредсказуемого алгоритма 
декорирования имён.
Функции библиотеки stdlib описаны как C-функции, поэтому их имена не декорируются. 

Параметры функции \lstinline!printf! в~соответствии с~соглашением cdecl передаются через стек (\lstinline!pushl $msg!) перед вызовом функции, а~после завершения её работы вычищаются из стека вызывающей программой (\lstinline!popl %eax!% с~последующей перезаписью \lstinline!%eax!
).


Если необходимо передать функции вывода несколько параметров
\begin{lstlisting}
int foo = 13;
int main()
{
  printf("Переменные: %d %d\n", 19, foo);
  return 0;
}
\end{lstlisting}
по соглашению cdecl эти параметры передаются в~обратном порядке (то есть на вершине стека оказывается первый):
\begin{lstlisting}
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  movl $0, %eax
  ret    
\end{lstlisting}
Очистка стека здесь выполняется модификацией указателя стека~\lstinline!%esp!, так как три команды \lstinline!popl! выполнялись бы дольше.

Необходимо всегда помнить о~том, что после вызова функции значения многих регистров (в~частности, \lstinline!%eax!) меняется.



















\section{Ассемблерные вставки в~код C++}
\label{sec:asm-inline}
\epigraph{\begin{limerick}
Одна дама, живущая в~гавани,\\
возмечтала отправиться в~плаванье,\\
Но когда на дубу\\
поглядела в~трубу,\\
То решила "--- спокойнее в~гавани.\\
\end{limerick}
}
{\Lear}


Для вставки одной или нескольких инструкций ассемблера используется ключевое слово \lstinline!asm!.
% 
% В~разделе 
%  [dcl.asm]
%  стандарта C++ сказано
% «An asm declaration has the form
% asm-definition:
% \lstinline!asm ( string-literal ) ;!
% The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
% is used to pass information through the implementation to an assembler. — end note ]»

Стандарт C++ описывает %синтаксис ассемблерной вставки как
использование  \lstinline!asm! следующим образом:
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}
% содержимое круглых скобок 
конкретный вид \lstinline!string-literal! 
при этом не регламентируется.
% \lstinline!asm("assembly code");!
% 
Обычно такие вставки используются для передачи кода непосредственно ассемблеру.


% Так как ассемблерный код  не стандартизирован, синтаксис 
% Синтаксис 
Содержимое
таких вставок зависит как от архитектуры целевого аппаратного обеспечения (набор команд, регистров и~т.\,д.), так и~от компилятора (мнемоники команд, порядок операндов, синтаксис и~т.\,д.).

Используемая операционная система определяет {только} обращения \emph{непосредственно к~интерфейсам операционной системы} (системные вызовы Linux и~BSD, функции API Windows~т.\,п.).
% Если не использовать напрямую интерфейсы операционной системы, 
% а~вызывать, например, функции стандартной библиотеки С/С++, методы Qt или функции, описанные в~C/C++ части проекта, ассемблерная вставка будет работать под любой операционной системой, где есть нужный компилятор (и~Qt).
% http://www.linux.org.ru/forum/development/11701125
% вставка будет собираться и~работать под любой  операционной системой. 
Вычисления, а~также обращение к~стандартной библиотеке С или к~кроссплатформенным библиотекам типа Qt описываются одинаково под любой операционной системой.





\section{Синтаксис ассемблерных вставок в~GCC}

Ассемблерная вставка в~программу, собираемую компилятором GCC, может быть описана с~использованием двух ключевых слов: \lstinline!asm!  либо \lstinline!__asm__!%
~\cite{sysbin.com/files/lowlevel/gcc_inline_assembly.htm,
ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html,
ru.wikibooks.org/wiki/
}%
. 
Эти формы равнозначны и~используют одинаковый синтаксис. Форма \lstinline!__asm__! применяется, когда стандартное ключевое слово \lstinline!asm! конфликтует с~чем-либо в~программе.

\subsection{Базовая форма}
Базовая форма ассемблерной вставки выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    );
\end{lstlisting}
Ключевое слово volatile для базовой формы не оказывает никакого эффекта, так как такая вставка не оптимизируется компилятором никогда.

Например:
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX := ECX
\end{lstlisting}
или
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX := BH (байт)
\end{lstlisting}
Если код во вставке содержит более одной строки, то каждая строка помещается в~кавычки. 
Тем не менее, этого недостаточно для разделения инструкций.

\subsubsection{Разделение инструкций}

% Несколько 
При компиляции соседние строки ассемблерной вставки склеиваются, как склеиваются части любой строковой константы "--- точно так же, как в~объявлении вида
\begin{lstlisting}
    char *s = "abcd"
        "ABCD";
\end{lstlisting}
которое задаёт строку \lstinline!"abcdABCD"!, не разделённую посередине никаким символом.
То есть вставка
\begin{lstlisting}
asm ("movl %eax, %ebx"
     "movl $56, %esi");
\end{lstlisting}
На самом деле выглядит как
\begin{lstlisting}
asm ("movl %eax, %ebxmovl $56, %esi");
\end{lstlisting}
и~вызывает логичное сообщение о некорректном имени регистра «ebxmovl».

Таким образом, если во вставке необходимо использовать более одной инструкции, то  
в~конце каждой строки необходимо поместить суффикс \lstinline!\n! для разделения инструкций (если желательно иметь красивый выходной файл, можно использовать суффикс  \lstinline!\n\t!, если форматирование выходного файла безразлично "--- можно использовать вместо  \lstinline!\n! разделитель \lstinline";").
% \lstinline!\n\t!, чтобы сформированный компилятором ассемблерный файл был корректно отформатирован.
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movl %ecx, $label(%edx,%ebx,$4)\n"
     "movb %ah, (%ebx)");
\end{lstlisting}

\subsubsection{Доступные в~базовой форме вставки имена}

Внутри ассемблерной вставки можно обращаться по именам к~регистрам, а~также к~глобальным %и~статическим (то есть имеющим фиксированный адрес) <- не получается 
переменным программы:
\begin{lstlisting}
int n = 12;

int main(){
    asm ("incl n");
    cout << n <<endl;
    return 0;
}
\end{lstlisting}
% Параметры функций 
Локальные переменные функций размещаются компилятором в~стеке (причём не всегда в~порядке объявления), поэтому к~ним необходимо обращаться, используя \emph{расширенный ассемблер GCC,} а~именно \termin{параметры вставок.}
Необходимо также учитывать, что в~регистрах, используемых во вставке, ранее компилятором могла быть размещена какая-либо регистровая переменная.
В~этом случае компилятор не определяет автоматически, что регистр изменён, что может привести к~краху программы.

\warning{
На практике описанную выше базовую форму ассемблерных вставок \mbox{(без параметров)} не стоит использовать \emph{никогда}.

Только расширенная форма даёт возможность корректного взаимодействия с~программой на ЯВУ.
}
% Вставка "--- не функция.

% \subsection{Передача параметров в~ассемблерную вставку}
\subsection{Расширенная форма} %http://www.gamedev.ru/code/articles/gcc_inline_asm?page=3

% http://www.ibm.com/developerworks/ru/library/l-linux_kernel_15/index.html
Синтаксис  вставки (расширенный) в~GCC может иметь две формы.

Первая выглядит следующим образом:
\begin{lstlisting}[style=lstsmall]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}

% Ключевое слово const используется в~случае, когда выходные параметры зависят только от входных, что позволяет, в~частности, вынести блок за тело цикла при оптимизации.
% Один из случаев, когда const нельзя использовать "--- когда один из входных параметров интерпретируется как указатель. Значение по данному адресу может измениться, даже если сам адрес неизменен.

Ключевое слово volatile  
используется для того, чтобы указать компилятору, что вставляемый ассемблерный код может обладать побочными эффектами, поэтому попытки оптимизации могут привести к логическим ошибкам.
% В~частности, если необходимо не менять вставку местами с~дрк
% запрещает компилятору оптимизировать блок и~указывает вставить его как есть.

Вторая форма расширенной ассемблерной вставки имеет вид
\begin{lstlisting}[style=lstsmall]
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  

Ключевое слово goto указывает, что ассемблерный код может делать переходы на метки, перечисленные в~соответствующем разделе.

Обращение к~параметру-метке предваряется префиксом \lstinline!%l! (от \emph{label}), за которым идёт порядковый номер метки в~списке всех параметров; псевдоним для метки указать нельзя.
В~частности, данный код переходит к~метке \lstinline!carry:! (и~функция возвращает~1), если в~числе~$p1$ взведён бит с~номером~$p2$ (младший бит имеет нулевой номер).
\begin{lstlisting}[style=lstsmall]
asm goto (
    "btl %[BitIdx], %[Val]\n\t"
    "jc %l2"
    :: [Val]"r" (p1), [BitIdx]"r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда BT  копирует бит, номер которого передается вторым параметром, в~флаг CF.

% http://sysbin.com/files/lowlevel/gcc_inline_assembly.htm

Параметры указываются как \lstinline!%0!, \lstinline!%1! и~т.\,д. или как \lstinline!%[Value]!, где Value "--- определённый в~разделе %выходных 
параметров псевдоним (если параметр соответствует какой-либо переменной ЯВУ, то псевдоним может как совпадать, так и~не совпадать с~именем этой переменной).
% Примечание:е
Если в коде указаны параметры, которые, как и регистры, начинаются с префикса \lstinline'%', то регистры указываются с префиксом \lstinline'%%', например, \lstinline!%%eax!.

Общее количество параметров ограничено: $input + output + goto \leqslant 30$.


\subsubsection{Выходные параметры}

Раздел выходных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

% https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands
Описание выходного параметра
в~общем случае имеет вид:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cvariablename)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда.
Область определения такого псевдонима "--- вся ассемблерная вставка.
Псевдоним может быть любым допустимым идентификатором C++.
Два разных операнда не могут использовать один псевдоним.

Псевдоним выходного параметра может быть указан как ограничение расположения входного.
В этом случае параметр с~данным псевдонимом является входным и~выходным одновременно (как правило, это изменяемая во вставке переменная).

Если псевдоним не определён, используются номер операнда, начиная с~нуля: \lstinline!%0! для первого, \lstinline!%1! для второго и~т.\,д.
% \begin{lstlisting}[style=lstsmall]
% int x;
% asm
% (
%     "movl $12, %[x]\n"
%     :[x]"=rm"(x)
% );
% \end{lstlisting}

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для выходного параметра начинается с~символа \lstinline!=! (если значение параметра перезаписывается) %, после которого 
или \lstinline!+! (если значение параметра используется как для чтения, так и~для записи).

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

При выборе регистра для размещения выходного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++ (lvalue), куда будет записано значение выходного параметра (обычно имя переменной).

Если для выходного параметра указано размещение в~регистре и~имя соответствующей переменной, это не значит, что переменная обязательно будет размещена в~регистре.
Возможно, в~регистре будет сформировано выходное значение, которое затем будет скопировано в~локальную стековую переменную.

\end{description}
Например, данный фрагмент записывает константу 12 в~переменную~$x$:
\begin{lstlisting}[style=lstsmall]
int x;
asm
(
    "movl $12, %[x]\n"
    :[x]"=rm"(x)
);
\end{lstlisting}
начальное значение параметра \lstinline![x]! не определено.

Следующий фрагмент кода удваивает~$x$:
\begin{lstlisting}[style=lstsmall]
asm
(
    "addl %[x], %[x]\n"
    :[x]"+r"(x)
);
\end{lstlisting}
Символ  \lstinline!+! в~строке расположения указывает на то, что данный параметр является не чисто выходным, а~модифицируемым.
Начальное значение параметра \lstinline![x]! берётся из~выражения-приёмника, в~данном случае "--- переменной~$x$.
% Если бы ограничение расположения начиналось бы с~\lstinline!=!, начальное значение параметра было бы не определено.

\subsubsection{Входные параметры}

Раздел входных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

Описание входного параметра в~общем случае:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cexpression)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда, аналогично псевдонимам выходных параметров.

Если псевдоним не определён, используются номер операнда, начиная со следующего за последним выходным параметром.
Если есть два выходных параметра, то первый входной будет обозначен \lstinline!%2! и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для входного параметра не может начинаться ни с~\lstinline!=!, ни с~\lstinline!+!.

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

Если входной параметр должен располагаться там же, где один из выходных,
расположение также может быть указано цифрой или псевдонимом данного выходного параметра.

При выборе регистра для размещения входного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++, откуда берётся значение входного параметра (также может быть именем переменной).

\end{description}

Например, конструкция:
\begin{lstlisting}[style=lstsmall]
asm ("movl %0, %%eax"::"i"(1) : "%eax");
\end{lstlisting}
превратится после компиляции %в~ассемблерном коде 
в:
\begin{lstlisting}[style=lstsmall]
movl $1, %eax
\end{lstlisting}

Данный фрагмент эквивалентен \lstinline!foo += bar!:
\begin{lstlisting}[style=lstsmall]
int foo = 6, bar = 12;
asm ("addl %[bar], %[foo]"
    : [foo]"+r"(foo)
    : [bar]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
причём, если переменная foo не располагается в~регистре изначально, её значение будет скопировано в~регистр, а~после добавления bar результат будет скопирован обратно в~foo.


\subsubsection{Перезаписываемые элементы%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\#Clobbers}%,
% {https://ru.wikipedia.org/wiki/GCC\_Inline_Assembly#.C2.ABmemory.C2.BB\_.D0.B2\_clobber\_list}
}
}

Код в~ассемблерной вставке может прямо или косвенно изменять значения не только выходных параметров, но и прочих регистров.
Эти регистры перечисляются в~списке перезаписываемых (clobber) регистров.

В~частности, команда умножения в~своей классической форме (\lstinline!%eax = %eax*src!) записывает старшую часть произведения в~\lstinline"%edx".
\begin{lstlisting}[style=lstsmall]
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}

Если во вставке явно модифицируется какой-либо регистр (что не рекомендуется; в~случае, если нужен регистр для хранения временного значения, лучше объявить фиктивный входной параметр, как описано в~следующем подразделе), его также необходимо указать в~списке перезаписываемых элементов.
% \hyperref[sss:inline:tmpreg]{qq}
% \pagebreak[3]
% 
\begin{lstlisting}
asm ("movl %[One], %%eax"    
  ::[One]"i"(1)  
  : "%eax");	// movl $1, %eax
\end{lstlisting}
\pagebreak[3]

Неуказание таких регистров в~списке перезаписываемых, скорее всего, приведёт к~тому, что компилятор поместит один из параметров вставки или переменных ЯВУ в~этот же регистр и,~соответственно, к~непредсказуемому значению в~нём. 

Специальные аргументы для списка перезаписываемых регистров:
\begin{description}
\item["cc"]
показывает, что код изменяет регистр флагов.

Флаги изменяют все арифметические инструкции.


\begin{lstlisting}[style=lstsmall]
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}



\item["memory"]
показывает, что код меняет значение в~памяти (не считая явно указанных выходных параметров) "--- например, интерпретирует какой-либо из параметров как указатель.

\begin{lstlisting}[style=lstsmall]
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}


% Помимо простого указания компилятору, что ассемблерная вставка изменяет содержимое памяти, она ещё служит директивой Memory Barrier для компилятора. Это означает, что те операции обращений в память, которые стоят выше по коду, в результирующем машинном коде будут выполняться до тех, которые стоят ниже ассемблерной вставки. В случае многопоточной среды, когда от этого напрямую зависит риск возникновения race condition, это обстоятельство является существенным.

% Кроме указания компилятору на изменение памяти,
% барьер компилятора

При указании \lstinline!"memory"! в~списке перезаписываемых элементов все операции работы с~памятью, которые были в~программе до ассемблерной вставки, выполнятся до неё, а~те, что стоят в~программе после "--- будут после.
В~противном случае компилятор может поменять местами как операторы C++, так и~ассемблерные вставки.
\end{description}


\subsection{Практическое использование параметров}


\subsubsection{Временные регистры%
\footnote{Использованы материалы:
{http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}
}
}

% \labellocal{sss::tmpreg}
% \label{sss:inline:tmpreg}

Использовать под временные данные фиксированные регистры и~указывать их в~списке  перезаписываемых не вполне корректно.

Более правильным будет ввести фиктивный выходной параметр, размещаемый в~регистре (\lstinline!=r! или \lstinline!=&r!, либо более конкретное ограничение "--- подробнее указано в~разделе \ref{sec:Constraints}), так как это даст компилятору больше свободы при оптимизации.

В~тексте вставки можно использовать данный параметр для хранения произвольных временных данных.

% Так, в~программе 
% \begin{lstlisting}[style=lstsmall]
% int main()
% {
%     int a=77, b;
%     asm("movl %0, %%eax"::"d"(a));
%     asm("movl %%eax, %0":"=d"(b));
%     cout << b;
%     return 0;
% }
% \end{lstlisting}
% первая вставка записывает значение локальной переменной \lstinline!a! через регистр \EDX{} (\lstinline!"d"!) в~регистр \EAX;
% вторая "--- содержимое регистра \EAX{} записывает через регистр \EDX{} в~переменную \lstinline!b! (\lstinline!"=d"(b)!).
% То есть если вставки сохранят порядок после компиляции (что не гарантируется), программа копирует содержимое локальной переменной \lstinline!a! (77) в~локальную переменную \lstinline!b!, и~последующий оператор вывода выведет 77. 

Пересылка через временный регистр:
\begin{lstlisting}[style=lstsmall]
int src = 1, dst, tmp;
asm
(
    "movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);
\end{lstlisting}


\subsubsection{Модификация входных параметров}

Модифицировать входные параметры, не являющиеся одновременно и~выходными, \termin{нельзя}.

Если возникает необходимость изменить значение, переданное как входной параметр, оно должно быть описано ещё и~как выходной.


Рассмотрим код, который увеличивает переменную $foo$ на значение переменной $bar$.
В~данном случае $bar$ может быть только входным параметром, а~$foo$ "--- модифицируемым, то есть  одновременно и~входным, и~выходным.

В~следующем фрагменте неименованный параметр \lstinline!%0! является входным и~выходным одновременно (точнее, входной параметр \lstinline!%1! располагается там же, где и~выходной \lstinline!%0!).
Это определяется ограничением размещения входного параметра \lstinline!%1! "--- %вместо  ограничений 
там указан номер параметра \lstinline!%0!.
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
); // foo += bar
\end{lstlisting}
Аналогичные вычисления с~использованием именованных параметров (\lstinline![S]! здесь "--- %и~входной и~выходной параметр
выходной параметр в~регистре, и~в~том же регистре расположен неименованный входной параметр) выглядят следующим образом.
% \begin{lstlisting}[style=lstsmall]
% asm("addl %[A], %[X]\n"
%     : [X]"=r"(foo)
%     :"[X]"(foo), [A]"g" (bar)
%     :"cc"
% ); // foo += bar
% \end{lstlisting}
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
% Используя \lstinline![S]! как приёмник сложения, мы фактически модифицируем неименованный выходной параметр \lstinline!%1!
Мы используем  неименованный выходной параметр \lstinline!%1!, чтобы задать начальное значение входному~\lstinline![S]!.
В данном случае (входной параметр инициализируется исходным значением $foo$ "--- приёмника совмещённого с~ним выходного параметра~\lstinline![S]!) можно было и~не вводить дополнительный входной параметр, а~заменить описание% %ограничение расположения
~\lstinline![S]! на~\lstinline![S]"+r" (foo)!.


Описание параметра как выходного и~входного одновременно (точнее, однорасположенной пары параметров <<выходной-входной>>), в~частности, делает параметр сохраняющим предсказуемое значение на всём протяжении вставки.
Если такой параметр размещается в~регистре, никакой другой параметр данной вставки не будет помещён в~этот регистр.

Отличие такого описания параметра от выходного с~начальным значением (расположение которого начинается с~\lstinline!+!) "--- то, что источник начального значения  может отличаться от исходного значения назначения.
Так, следующий фрагмент кода устанавливает начальное значение параметра-регистра \lstinline![S]! нулём, а~значение этого регистра после завершения вставки записывается в~переменную~$foo$:
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}
% Если для инициализации выходного параметра не требуется значение, отличное от~исходного значения его приёмника,

Также для входного параметра, расположенного на месте выходного, можно задать отдельный псевдоним. %, так как %, в~отличие от 
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : [S_initial_value]"[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}


\subsubsection{Конфликт выходных и~входных долгоживущих параметров}

При размещении параметров в~регистрах компилятор считает, что входные параметры используются в~начале вставки, а~выходные "--- в~конце, \emph{после} использования всех входных.
Соответственно, <<только входные>> параметры часто располагаются в~тех же регистрах, что и~<<только выходные>>, чтобы освободить максимальное количество регистров для других переменных.

Это может привести к~конфликту, если какой-либо входной параметр используется в~конце вставки, после присваивания хотя бы одного из выходных параметров.
При размещении этих двух параметров в~одном регистре присваивание уничтожит оригинальное значение входного параметра.

В частности, данный фрагмент (вычисляющий $y = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$) в~случае размещения входного параметра \lstinline![Zero]! и~выходного \lstinline![y]! в~одном регистре работает некорректно ($y$ всегда равен $1$, так как инициализация выходного параметра  \lstinline![y]! единицей выполняется до чтения  входного параметра \lstinline![Zero]!, и~в~момент условного присваивания \lstinline!cmovll %[Zero], %[y]! регистр, где расположены оба этих параметра, равен $1$).
\begin{lstlisting}[style=lstsmall]
int x = 10, y;
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
); // y = 1 независимо от x
\end{lstlisting}
Это можно исправить, объявив \lstinline![y]! выходным параметром с~начальным значением (\lstinline!+! вместо \lstinline!=! в~расположении), хотя нам и~не требуется исходное значение переменной~$y$.
Такое ограничение не позволит компилятору совместить  какой-либо входной параметр с~\lstinline![y]!.
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"+r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
% 
Другой способ "--- явно указать, какой входной параметр следует расположить на месте выходного~\lstinline![y]!.
Здесь мы можем совместить с~\lstinline![y]! входной \lstinline![x]!, так как последнее чтение~\lstinline![x]! (сравнение \lstinline![x]! с~нулём) выполняется до инициализации~\lstinline![y]!:
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"[y]" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Оба этих способа позволяют разрешить конфликт и~получить корректное значение~$y$.
% $y = \left\{\begin{array}{ll}
% 1, & x \geqslant 0 \\
% 0, & x < 0 \\
% \end{array}\right.$

\subsection{%Типы размещения параметров% 
Ограничения на расположение операнда%
\footnote{Использованы материалы:
{https://gcc.gnu.org/onlinedocs/gcc/Constraints.html\#Constraints}
}
}
\label{sec:Constraints}

% https://gcc.gnu.org/ml/gcc/1999-10n/msg00488.html
% Типы параметров:
Некоторые общие ограничения (типы размещения параметров):
\begin{description}
\item[r] "--- регистр; %- register
\item[m] "--- память; %- memory effective address
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); %- immediate value, 0..0xffffffff
\item[g] "--- память, регистр общего назначения или непосредственное значение (обычно этот тип эквивалентен \lstinline"rim"); %- general effective address
\item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
\end{description}

% But there are some i386-specific ones described in the processor-specific
% part of the manual and in more detail in GCC's i386.h:
Некоторые ограничения (типы), специфичные для i386 (определены в~файле i386.h GCC)
\begin{description}
\item[q] "--- регистр, который можно адресовать по байтам младшего слова (EAX, EBX, ECX, EDX); %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров  EDX:EAX;
\item[a, b, c, d, S, D] "--- регистры eax, ebx, ecx, edx, esi, edi соответственно;

\item[I..P] "--- машинно-зависимые ограничения для констант:
% \end{description}
% 
% Ограничения для констант:
% \begin{description}
% \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% %     ("i" would allow an address known only at link time)
\begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% \item[K] "--- Signed 8-bit integer constant. ?  255
% \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (сдвиги, которые может выполнить lea);
\item[N] "--- непосредственное значение в~диапазоне 0..255 (беззнаковое однобайтовое).
% \item[O] "--- непосредственное значение в~диапазоне 0..32
\end{description}
\end{description}





\section{Простые вычисления}
\epigraph{\begin{stanza}
Затем, не помня, где я~есть,\\
Я~этому задире\\
Все повторял, пытаясь сесть,\\
Что пять плюс два, конечно, шесть,\\
А~два плюс пять "--- четыре.\\
\end{stanza}}
{Льюис Кэрролл}

\section{Ветвления и~циклы}
\epigraph{\begin{limerick}
Старичок из далёкого Таллинна\\
о~египетских грезил разваллинах.\\
Он до пальмы добрался,\\
он на пальму забрался,\\
И~ему хорошо и~без Таллинна.\\
\end{limerick}
}
{\Lear}






\section{Программирование нелинейных алгоритмов}

\epigraph{\begin{stanza}
В~действительности всё не так, как на самом деле.
\end{stanza}}
{%Станислав Ежи Лец (а~может быть, и~Антуан де Сент-Экзюпери)
% уже фольклор
}


\subsection{Условие с~операторами в~одной ветви}

Пусть необходимо заменить значение целой знаковой переменной $x$ нулём, если   оно отрицательно.
$$x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$$

Построим схему алгоритма (рис.~\ref{ris:if}, а) для решения этой задачи.

В~отличие от операторов  \lstinline!if! большинства языков высокого уровня,
ветвь, где должны выполняться операторы, лучше сделать ветвью «нет» (обход части программы).

Построим по данной схеме программу. Каждому  блоку процесса здесь будет соответствовать линейный фрагмент кода; блок решения завершится условным переходом по метке; точка соединения двух потоков соответствует метке  (рис.~\ref{ris:if}, б).


\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\coordinate[right=  of is_positive] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);

\node[block,on chain=alg_start, join={node[right]{нет}}] (is_positive_no_op) {$x = 0$};
\coordinate[below = of is_positive_no_op] (to_end);

\path[blockarrow] (is_positive_yes) |- (to_end);
\node[terminator, on chain=alg_start, below = of to_end, join/.style=blockarrow] (end) {Конец}; % Удаляет линию вообще
\path[blockarrow] (is_positive_no_op) -- (end);


\coordinate[right=  of is_positive_yes] (asm_coord);

% \node[asm] at (start-|asm_coord) {
%   \begin{lstlisting}
%   int x;
%   asm
%   (
%       "movl $12, %[X]\n"
%       :[X]"=rm"(x)
%   );
%   \end{lstlisting}
%   };

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = -6;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge end_check\n"
\end{lstlisting}
};
\node[asm] at (is_positive_no_op-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[X]\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  : [X]"+rm"(x)
  : : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};

\end{tikzpicture}
}

\caption{Алгоритм и~реализация ветвления}
\label{ris:if}
\end{illustration}

% Данную задачу можно также решить с~помощью команд условной пересылки:
Для более быстрой реализации подобных ветвлений (присваивания по условию) начиная с~Pentium Pro добавлены команды  условной пересылки:
\begin{lstlisting}[style=lstsmall]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "cmovngel %[Zero], %[X]\n"
  : [X]"+r"(x)
  : [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Так как источником для команды cmovXXX не может быть константа, вводится входной параметр \lstinline![Zero]!, расположенный в~памяти или регистре и~равный нулю.

\subsection{Условие с~операторами в~двух ветвях}

Пусть в~зависимости от условия необходимо выполнить один из двух операторов:
$$y(x) = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$$

% Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи, выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, в).
% 
% Потоки, выходящие за пределы основной линии "--- условные и~безусловные  переходы, точки входа таких потоков-переходов в~основной вертикальный поток "--- метки.


Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи и~затем выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б).


\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\tikzset{every join/.style=blockarrow}

\coordinate[right= of is_positive, on chain=if_yes] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);
\node[block,on chain=if_yes] (yes_op) {$y = 1$};

\coordinate[left=  of is_positive, on chain=if_no] (is_positive_no);
\path[blockline] (is_positive) -- node[auto] {нет} (is_positive_no);
\node[block,on chain=if_no] (no_op) {$y = 0$};

\coordinate[below = of yes_op] (to_end_y);

\coordinate[on chain=alg_end, join/.style={}] (to_end) at (to_end_y-|start);
\path[blockline] (yes_op) |- (to_end);
\path[blockline] (no_op) |- (to_end);

\node[terminator, on chain=alg_end, below = of to_end] (end) {Конец};
% \path[blockarrow] (to_end) -- (end);



\tikzset{every join/.style=blockline}


\coordinate[right= 6em of yes_op] (squeeze_coord);

\node[terminator,on chain=squeeze_start] (start2) at (start-|squeeze_coord) {Начало};

\node[decision,on chain=squeeze_start] (is_positive2) {$x\geqslant0$};

\node[block,   on chain=squeeze_start, join={node[right]{нет}}] (no_op2) {$y = 0$};
\coordinate[on chain=squeeze_start] (to_end_no2);


\coordinate[right= of is_positive2] (is_positive_yes2);
\path[blockline] (is_positive2) -- node[auto] {да} (is_positive_yes2);
\tikzset{every join/.style=nodraw}
\coordinate[on chain=squeeze_start] (non-used);

\coordinate[on chain=squeeze_start, join/.style={}] (to_yes2);
\node[block,   on chain=squeeze_start, join/.style={}] (yes_op2) {$y = 1$};
\tikzset{every join/.style=blockline}

\coordinate[on chain=squeeze_start] (to_end_yes2);
% \coordinate[on chain=squeeze_start] (non-used2);

\node[terminator, on chain=squeeze_start, join/.style={}] (end2) {Конец};

\path[blockarrow] (is_positive_yes2) |- (to_yes2) -- (yes_op2);

\coordinate[left=of yes_op2] (from_no_to_end2);
\path[blockline] (to_end_no2) -| (from_no_to_end2);
\path[blockarrow] (from_no_to_end2) |- (to_end_yes2);
\path[blockarrow] (to_end_yes2) -- (end2);



\coordinate[right=  of is_positive_yes2] (asm_coord);

\node[asm] at (start2-|asm_coord) {
\begin{lstlisting}
int x = -6, y;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive2-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge setting_1\n"
\end{lstlisting}
};

\node[asm] at (to_yes2-|asm_coord) {
\begin{lstlisting}
"setting_1:\n"
\end{lstlisting}
};

\node[asm] at (yes_op2-|asm_coord) {
\begin{lstlisting}
  "movl $1, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (no_op2-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (to_end_no2-|asm_coord) {
\begin{lstlisting}
  "jmp end_check\n"
\end{lstlisting}
};

\node[asm] at (to_end_yes2-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end2.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  :[Y]"=rm"(y)
  :[X]"rm" (x)  
  : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (end2|-lettersline) {б)};
\node at (asm-end|-lettersline) {в)};


\end{tikzpicture}
}

\caption{Алгоритм и~реализация ветвления}
\label{ris:if-else}
\end{illustration}

Сопоставим каждому блоку одну или несколько команд ассемблера.
В~этом случае излом потока (отход от базовой вертикали без ветвления) будет соответствовать безусловному переходу, блок решения включает условный переход, а~точки входа боковых потоков-переходов в~основной вертикальный поток соответствуют меткам (рис.~\ref{ris:if-else}, в).
\pagebreak[3]


Данную задачу также можно  решить с~помощью команд условной пересылки.
Для подобного задания такая реализация будет компактнее и~быстрее. 

\begin{lstlisting}
int x = 10, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $1, %[Y]\n"
  "cmovll %[Zero], %[Y]\n"
  : [Y]"+r"(y)
  : [X]"rm"(x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Здесь параметр \lstinline![Y]! объявлен как выходной с~начальным значением, хотя, казалось бы, его исходное значение нам не требуется.
Это сделано, чтобы компилятор не совместил его с~входным параметром  \lstinline![Zero]! (совмещение с~входным параметром \lstinline![X]! не повредит выполнению, так как значение \lstinline![X]! используется только для сравнения с~литералом \lstinline!$0!, до первого присваивания \lstinline![Y]!).
Если %не указать \lstinline![Y]! в~списке входных и~он 
\lstinline![Y]! будет совмещён с~\lstinline![Zero]!, мы всегда получим на выходе $y=1$.

\pagebreak[3]

Для данных значений ($y$ равен либо нулю, либо единице) задачу можно  решить и~с~помощью команды условной установки байта.
\begin{lstlisting}
int x = -7, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $0, %[Y]\n"
  "setgeb %[Y]\n"
  :[Y]"=m"(y)
  :[X]"rm"(x)
  : "cc"
);
\end{lstlisting}
Здесь мы записываем ноль в~четырёхбайтовую переменную  \lstinline![Y]!, находящуюся в~памяти, а~затем устанавливаем по условию её младший байт (так как платформа x86 использует  порядок байтов Intel, адрес младшего байта \lstinline![Y]! совпадает с~адресом \lstinline![Y]!).
Оба возможных значения $y$ неотрицательны, поэтому дополнение нулями является корректным расширением и~для знаковой, и~для беззнаковой их~интерпретации.

Также можно было установить по условию регистр  \Reg{AL} и~специальными командами расширить его вначале до \Reg{AX}, а~затем до~\Reg{EAX}.

При использовании для $y$ однобайтового типа \lstinline!char! вместо четырёхбайтового \lstinline!int! расширение не будет нужным.

\pagebreak[3]

% \subsection{Цикл с~предусловием}
\subsection{Цикл}

Пусть необходимо найти сумму двоичных цифр беззнакового числа $x$.


% Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, а), реализован цикл с~предусловием) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, б).

Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:while}, а), реализован цикл с~предусловием). 
При соединении блоков немного отступим от требований ЕСПД 
(стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости)
и~отделим точку, где боковой поток случая $CF\neq 0$ входит в~основную вертикаль, от~точки, где поток отходит от вертикали, чтобы перейти назад к~началу итерации.
Расположение этих точек выберем так, чтобы поток основной вертикали на каждом её участке шёл в~естественном направлении "--- сверху вниз (это не только позволяет не~рисовать стрелку для обозначения направления, но и~соответствует выполнению %программы 
кода, не включающего команд передачи управления).



\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\tikzstyle{asm}	= [text width=16em,text badly ragged, anchor=west]

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[block,on chain=alg_start] (init) {$count = 0$};

\coordinate[on chain=alg_start] (to_shift);
\tikzset{every join/.style=blockarrow}
\node[decision,on chain=alg_start] (is_zero) {$x=0$};
\tikzset{every join/.style=blockline}
\node[block,on chain=alg_start, join={node[right]{нет}}] (shift) {
$CF = x \& 1$

$x = (x>>1)$
};

\node[decision,on chain=alg_start] (is_last_bit) {$CF=1$};
\node[block,on chain=alg_start, join={node[right]{да}}] (inc) {$count = count+1$};
\coordinate[on chain=alg_start] (from_no_to_next_iter);
\coordinate[on chain=alg_start] (to_next_iter);
\tikzset{every join/.style=blockarrow}
\coordinate[left = of current bounding box] (to_next_iter_middle);
\path[blockarrow] (to_next_iter) -| (to_next_iter_middle) |- (to_shift);

\tikzset{every join/.style=nodraw}
% \coordinate[on chain=alg_start] (non-used);
\coordinate[on chain=alg_start] (to_end);
\node[terminator, on chain=alg_start] (end) {Конец};


\coordinate[right= of is_last_bit] (is_no_last_bit);
\path[blockarrow] (is_last_bit) -- node[auto] {нет} (is_no_last_bit) |- (from_no_to_next_iter);



\coordinate[right= of is_zero-|is_no_last_bit] (is_zero_yes);
\path[blockarrow] (is_zero) -- node[auto] {да} (is_zero_yes) |- (to_end) -- (end);



\coordinate[right=  of current bounding box] (asm_coord);

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = 7, count;
asm
(
\end{lstlisting}
};

\node[asm] at (to_shift-|asm_coord) {
\begin{lstlisting}
"begin_iteration:\n"
\end{lstlisting}
};
\node[asm] at (init-|asm_coord) {
\begin{lstlisting}
  "xorl %[Count], %[Count]\n"
\end{lstlisting}
};
\node[asm] at (shift-|asm_coord) {
\begin{lstlisting}
  "shrl $1, %[X]\n"
\end{lstlisting}
};
\node[asm] at (is_zero-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "je end_loop\n"
\end{lstlisting}
};
\node[asm] at (is_last_bit-|asm_coord) {
\begin{lstlisting}
  "jnc end_iteration\n"
\end{lstlisting}
};
\node[asm] at (inc-|asm_coord) {
\begin{lstlisting}
  "incl %[Count]\n"
\end{lstlisting}
};

\node[asm] at (from_no_to_next_iter-|asm_coord) {
\begin{lstlisting}
"end_iteration:\n"
  "jmp begin_iteration\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_loop:\n"
\end{lstlisting}
};

\node[asm] at (end-|asm_coord) (asm-end) {
\begin{lstlisting}
:[Count]"=rm"(count),[X]"+rm"(x)
: : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};


\end{tikzpicture}
}

\caption{Алгоритм и~реализация цикла}
\label{ris:while}
\end{illustration}

Теперь сопоставим каждому блоку одну или несколько команд ассемблера.
Отход потока от базовой вертикали будет соответствовать команде перехода, точки входа боковых потоков в~основной вертикальный  "--- меткам 
(рис.~\ref{ris:while}, б).

Цикл с~постусловием будет отличаться только на этапе построения схемы алгоритма.

Цикл с~параметром, как и~в~C/C++, можно реализовать как цикл с~предусловием.





















\section{Массивы}
\epigraph{\begin{limerick}
Жил один старичок из Пенджаба,\\
Ему на ногу прыгнула жаба,\\
Впавши в~ярость и~гнев,\\
Он позвал сорок дев, "---\\
Чтобы выгнать всех жаб из Пенджаба.
\end{limerick}
}
{\Lear}



% \section{Одномерные массивы}
\index{Массивы!одномерные}

Массив "---  структура данных в~виде набора однородных компонент (элементов массива), расположенных в памяти непосредственно друг за другом (независимо от настроек выравнивания). 
Элемент с~наименьшим индексом располагается по младшему адресу.
% 
Доступ к~отдельным элементам массива осуществляется с помощью индексации, то есть через ссылку на массив с~указанием номера (индекса) нужного элемента. 


В~языке C++ наименьший индекс массива всегда равен $0$, а~имя массива %фактически 
является константным указателем на его начало.
Таким образом, адрес $i$-го элемента массива $M$ равен $M + i\cdot size$, где~$size$ "--- размер одного элемента и,~в~случае, когда длина массива не равна нулю, может быть определён как \lstinline!sizeof(M[0])!.
% Если массив содержит элементы простых типов 
Для большинства простых типов
(\lstinline!char, bool, short, int, long, long long, float, double, size_t, ptrdiff_t, void*!)
этот размер как на 32-, так и~на 64-битной платформе равен~$1, 2, 4$ или~$8$.

Соответственно, в~ассемблере для получения элемента массива (если элементы массива имеют размер~$1, 2, 4$ или~$8$) будут использованы три из~четырёх компонент эффективного адреса \lstinline!displacement(base, index, multiplier)! "---  база (адрес начала массива~$M$), индекс и~масштаб (размер~элемента).
\index{Адресация!косвенная}

В~частности, адрес $i$-го элемента массива  $M$ из~чисел типа \lstinline!int! на 32-разрядных и~многих 64-разрядных платформах равен $M + i\cdot 4$, и~элемент будет записан как~\lstinline!(M, i, 4)!. При этом база~$M$ и~индекс~$i$ должны быть 32-разрядны (на соответствующей платформе) и~располагаться в~регистрах:
\begin{lstlisting}
const int N = 8;
int M[N], i = 0;
asm
(
"movl $0, (%[M], %[I], 4)\n"
:[I]"+r"(i)
:[M]"r"(M)
:"memory"
);
\end{lstlisting}
Так как мы модифицируем во вставке элементы массива (а~не сами параметры \lstinline![I]! и~\lstinline![M]!), необходимо указать в~списке перезаписываемых элементов специальное значение \lstinline!"memory"!.

В~приведённом выше коде на тип~\lstinline!int! у~элементов~массива указывают как суффикс~\lstinline!l! у~команды, так и~масштаб~\lstinline!4! при вычислении адреса.
Обе характеристики важны: попытка опустить суффикс команды приведёт к~ошибке, так как ни один из операндов~команды~\lstinline!mov! здесь не является регистром и,~следовательно, не имеет определённого размера. %, по которому можно было бы понять разрядность команды

Также %обе характеристики 
суффикс и~вычисление адреса
должны соответствовать друг другу: хотя  команды~\lstinline!movw $0, (%[M], %[I], 4)! и~\lstinline!movl $0, (%[M], %[I], 2)! синтаксически корректны и~не вызовут ошибок компиляции\footnote{Ошибка возможна при использовании здесь суффикса~\lstinline!s! вместо~\lstinline!w!, хотя в~целом они оба для команд CPU равноправны и~обозначают 16-битное целое, так как существует отдельная команда~\lstinline!movs! с~поведением, отличным от~\lstinline!mov!},  обе они при обработке массива из элементов типа~\lstinline!int! некорректны по смыслу.
Команда~\lstinline!movw $0, (%[M], %[I], 4)! запишет по адресу~$M[i]$ 16-битный ноль, который инициализирует только младшие два байта из четырёх%, зарезервированных за~$M[i]$
; таким образом, значение элемента~$M[i]$ останется неопределённым. % и,~фактически, элемент  
Команда~\lstinline!movl $0, (%[M], %[I], 2)! перезапишет не~$M[i]$, а~либо элемент~$M[i/2]$ (для чётного~$i$), либо два старших байта 
% половину 
одного элемента и~два младших следующего  (для нечётного~$i$).

Избавиться от явного указания суффикса и~масштаба можно, используя модификаторы параметров:
\begin{lstlisting}
const int N = 8;
short M[N];
int i = 3;
asm
(
"mov%z[el_type] $0, (%[M], %[I], %c[el_size])\n"
:[I]"+r"(i)
:[M]"r"(M), [el_size]"i"(sizeof(M[0])), [el_type]"m"(M[0])
: "memory"
);
\end{lstlisting}
Такой код будет компилироваться и~выполняться корректно для любого типа элементов массива~$M$, причём для типа~\lstinline!short! выбирается тот из синонимичных суффиксов, который не вызовет неоднозначности с~командой~\lstinline!movs!.
К~сожалению, это потребовало введения двух новых входных параметров: константа~\lstinline![el_size]! для масштаба~\lstinline!sizeof(M[0])! и~\lstinline![el_type]!, равный~\lstinline!M[0]!, для определения суффикса размера (так как ни один из ранее использованных параметров
"--- ни указатель~$M$, ни индекс~$i$ "---
в~общем случаем не совпадает~по размеру с~элементом массива%: $M$ "--- указатель, индекс~$i$ "--- \lstinline!size_t!, то есть их размер определяется платформой и~компилятором, а~не типом элемента
).

Масштаб, равный~$1$, может быть опущен.
Таким образом, если размер элемента равен~$1$, то адрес $i$-го элемента массива  $M$ равен $M + i$ и~сам элемент может быть записан и~как~\lstinline!(M, i, 1)!, и~как~\lstinline!(M, i)!.

Если размер~$size$ элемента отличен от~$1, 2, 4$ или~$8$, он не может быть масштабом при вычислении адреса; таким образом, смещение $i$-го элемента относительно начала массива%, равное $i\cdot size$, 
$$
\mathit{offset} = i\cdot size % без \mathit{} между ff дырка
$$
необходимо вычислить отдельно и~затем получить элемент как~\lstinline!(M, offset)!.
% Смещение 
Так как элементы массива, как правило, обрабатываются в~цикле, это можно сделать последовательным сложением % начального адреса
с~$size$ на каждой итерации.

\subsection{Многомерные массивы}
\index{Массивы!многомерные}

Если массивы с~одним индексом естественно отображаются на~одномерное адресное пространство памяти, 
то о~расположении элементов двумерного массива необходимо условиться дополнительно.

В~большинстве ЯВУ элементы статических многомерных массивов располагаются в~памяти так, что при движении от начала массива по возрастанию адресов быстрее всего меняется последний индекс. После того, как последний индекс достигнет максимального значения, увеличивается предпоследний и~так далее.

В~частности, статические двумерные массивы (матрицы) развёрнуты в~одномерный по строкам "--- сначала идёт вся нулевая строка, затем вся первая и~так далее, то есть в~массиве
\index{Массивы!матрицы}
\begin{lstlisting}
const int I = 8, J = 8;
int M[I][J];
\end{lstlisting}
адрес элемента~$M[i][j]$ равен~$M+(i\cdot J +j)\cdot size$, где $size = $\lstinline$sizeof(M[0][0])$.

При обработке всех элементов матрицы можно рассматривать её как одномерный длины~$I\cdot J$, так как все её элементы однородны и~расположены в~памяти непосредственно друг за другом. 
В~этом случае %эффективный 
индекс элемента~$M[i][j]$ в~этом массиве $index = i\cdot J +j$.
Обратное преобразование (расщепление при необходимости эффективного индекса на номера строки и~столбца) выглядит следующим образом: 
$$
\left\{
\begin{array}{l}
i = index / J\\
j = index \Mod J
\end{array}
\right.
$$
и~может быть выполнено одной командой беззнакового деления.

Динамические массивы, \index{Массивы!динамические}
память под которые выделяется из кучи с~помощью оператора new[] или функций *alloc() и~освобождается delete[]/free(), могут быть только одномерными.
При необходимости размещения в~куче многомерного массива программист вручную либо разворачивает его в~длинный одномерный, либо размещает в~древоподобной структуре данных из нескольких небольших одномерных массивов.
Способ обращения к~элементу в~таком случае зависит от способа организации данных.








\section{Структуры}
\epigraph{\begin{limerick}
Говорил бородатый старик:\\
«Я~совсем от покоя отвык "---\\
Шебуршат, как в~гнезде,\\
У~меня в~бороде\\
Две совы, утка, дрозд и~кулик!»
\end{limerick}
}
{\Lear}




% \section{Доступ к~элементам массивов в~памяти}
% \section{Временн\'{ы}е характеристики памяти}
\section{Выравнивание данных}


Хотя оперативная память "--- устройство с~произвольным доступом, то есть возможно читать значения по любым адресам в~любом порядке, время доступа различается в~зависимости от расположения данных.
% 
Конкретные особенности временн\'{ы}х характеристик обращения к~оперативной памяти зависят от особенностей процессора и~чипсета.


Тем не менее, есть несколько общих правил, позволяющих не потерять в~производительности слишком сильно.

\begin{enumerate}

\item Выравнивание.
Фактически процессор не работает с~данными, взятыми напрямую из оперативной памяти.
При чтении данные поступают в~сверхоперативную память (кэш); изменения вначале фиксируются в~кэше, затем попадают в~оперативную память.
Обмен между памятью и~кэшем производится пакетами, длина которых %различна для разного аппаратного обеспечения, но 
составляет от~$32$ до~$128$ байт.
% и~всегда составляет круглое (равное~$2^r$) количество байт. 
Начало пакета кратно его длине.
% 
Таким образом, если элемент попадает на границу таких блоков-пакетов, для его загрузки потребуется два запроса к~памяти.

% читаются и~записываются в~оперативную память

Чтобы избежать таких ситуаций, достаточно (хотя и~не всегда необходимо), чтобы граница между элементами в~памяти была кратна определённому числу.

% \cite{nezumi-memory} Техника оптимизации программ. Эффективное использование памяти
\noindent\begin{tabularx}{\linewidth}{|l@{~}L|L@{~}l|}
\hline
\multicolumn{2}{|c|}{\thead{Размер данных}} & \multicolumn{2}{c|}{\thead{Граница}} \\\hline
1 байт &(8 бит) & Произвольная  &\\\hline
2 байта &(16 бит) & Кратная 2 байтам  &\\\hline
4 байта &(32 бита) & Кратная 4 байтам  &\phantom{4 байта} \\\hline
8 байт &(64 бита) & Кратная 8 байтам  &\\\hline
10 байт &(80 бит) & Кратная 16 байтам  &\\\hline
16 байт &(128 бит) & Кратная 16 байтам  &\\\hline
\end{tabularx}
% \bigskip

По умолчанию в~C++ размер простых типов (кроме $long~double$) соответствует этим значениям.
Десятибайтовый тип $long~double$ может иметь размер ($sizeof$) как 16, так и~12 байт; в~последнем случае он выравнивается на 4~байта (а~компилятор MS~VC полагает $long~double = double$, таким образом и~размер, и~величина выравнивания там равны~8).


\item Обход %большого количества 
последовательно расположенных элементов в~порядке возрастания адресов выполняется быстрее, чем в~обратном.

\end{enumerate}


\section{Структуры и~объекты}

Структуры и~объекты в~C++ сочетают в~себе несколько в~общем случае разнородных компонент (полей), расположенных в~определённом порядке.
Доступ к~отдельным полям структуры на ЯВУ осуществляется по имени.
При обработке на языке ассемблера придётся использовать смещение поля относительно начала структуры, которое будет зависеть не только от состава структуры, но и~от компилятора и~его настроек. 

Обычно поля следуют в~порядке объявления и~начало поля %типа $T$ 
кратно некоторой величине, значение которой для конкретного поля/типа, а~также текущей версии и~настроек в~GCC можно получить с~помощью оператора \lstinline!__alignof__! (синтаксис аналогичен \lstinline$sizeof$).
При этом между началом одного поля и~концом предыдущего может образоваться промежуток, также промежуток может образоваться после последнего элемента структуры.
Соответственно, размер структуры может быть больше суммы размеров её полей; также размер структуры может меняться от перестановки полей между собой.
% При описании структур и~

% неверно
% По умолчанию на x86 максимальное значение кратности выравнивания (часто называемое просто выравниванием) равно~4. 
% В~этом случае данные размера 4~байта и~более выравниваются на~4~байта, то есть адрес начала такой переменной или поля будет кратен~4.
% Двухбайтовые данные выравниваются на~2, однобайтовые "--- на~1~байт.

{
% Уменьшить
Изменить
максимальную кратность выравнивания (часто называемую просто выравниванием) в~GCC можно с~помощью флага компиляции~\lstinline$-fpack-struct[=n]$.
Также GCC для совместимости с~компиляторами MS Windows поддерживает набор директив препроцессора \lstinline$#pragma pack$, позволяющих задать различную кратность выравнивания для различных определений типов:
\sloppy

}

% https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Structure-Packing-Pragmas.html
\begin{itemize}
\item \lstinline$#pragma pack(n)$ %simply sets the new alignment.
просто устанавливает новое значение выравнивания;

\item \lstinline$#pragma pack()$ %sets the alignment to the one that was in effect when compilation started (see also command-line option -fpack-struct[=n] see Code Gen Options).
возвращает выравнивание по умолчанию (возможно, заданное~\lstinline$-fpack-struct[=n]$);

\item \lstinline$#pragma pack(push[,n])$ %pushes the current alignment setting on an internal stack and then optionally sets the new alignment.
сохраняет текущее выравнивание во внутреннем стеке и,~при заданном~$n$, устанавливает новое значение

\item \lstinline$#pragma pack(pop)$ %restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and finalized by a single #pragma pack(pop). 
восстанавливает выравнивание из вершины внутреннего стека (и~удаляет эту запись оттуда).
\end{itemize}
Не рекомендуется 
уменьшать кратность выравнивания, 
%изменять настройки выравнивания%(особенно директивой \lstinline$#pragma pack$, %позволяющей получить несовместимый результат без изменения описания
% приводящей к~несовместимости одинаково описанных структур)
% , 
так как это может замедлить работу программы или даже нарушить её работоспособность.
При необходимости записи структуры в~файл для избавления от дыр неопределённого размера лучше воспользоваться покомпонентной записью.

Для придания размеру дыр определённости необходимо по возможности описывать поля структуры в~таком порядке (и,~возможно, добавить ещё несколько неиспользуемых полей), чтобы границы между полями независимо от настроек выравнивания совпадали с~рекомендуемыми значениями.




\section{Минимальная программа без stdlib}
\epigraph{\begin{limerick}
Старичок так следил за осанкой,\\
что питался лишь только овсянкой.\\
Но однажды съел лишку,\\
положив в~неё мышку,\\
И~серьёзно испортил осанку.\\
\end{limerick}
}
{\Lear}


\nsection{Контрольные вопросы}
% \epigraph{\begin{stanza}И~со свечкой искали они, и~с~умом,\\
% С~упованьем и~крепкой дубиной,\\
% Понижением акций грозили притом\\
% И~пленяли улыбкой невинной.\\
% \end{stanza}
% }
% {\Snark}





\section{Вопросы}
\begin{enumerate}
% \item Знаковой или беззнаковой является операция инкремента?
\item Каким ключевым словом открывается ассемблерная вставка?

\item Как из ассемблерной вставки обратиться к~локальным переменным?

\item Какие вы знаете ограничения на размещение параметров ассемблерных вставок?




\item Как располагаются в~памяти элементы массива?
\item Как найти размер массива, зная размер элемента и~их количество?
\item Что такое выравнивание полей структуры?
\item Зачем нужно выравнивание данных?

\end{enumerate}












