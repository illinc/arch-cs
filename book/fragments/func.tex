
\section{Подпрограммы и~функции}
\label{sec:calling-functions}
% \epigraph{\begin{stanza}[0mm]
% Как мне найти тебя, когда прожекторы прямо в~лицо?
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}
Если ты рододендрон "---\\
Твое место в окне.\\
Если ты истинный якорь "---\\
Давай, брат, лежи на дне.\\
Но если ты хочешь войти "---\\
Придётся выйти вовне. \\
\end{stanza}
}{\Aquarium}

Как сказано в~разделе~\ref{sec:compilation-functions}, одним из способов соединения кода на различных языках программирования является 
% совместная компиляция модулей и~
вызов внешних функций, описанных в~модулях, соединяемых с~головным на этапе компоновки.

Функции языка высокого уровня являются частным случаем \termin{подпрограмм} "--- последовательностей команд, завершающихся командой возврата.
\index{Подпрограммы}%
% 
% Для вызова функции используется команда \lstinline!call!, которая помещает в~стек адрес возврата из функции, а~затем передаёт управление вызываемой функции; для возврата "--- команда \lstinline!ret!, которая передаёт управление адресу, снятому со стека.
Для вызова подпрограммы используется команда \lstinline!call!, которая помещает в~стек адрес возврата, а~затем передаёт управление на начало вызываемой подпрограммы; для возврата управления вызывающей программе "--- команда \lstinline!ret!, которая передаёт управление адресу, снятому со стека.

Таким образом, п%
% П
ри вызове внешних функций необходимо решить четыре основные задачи.
% 
Первые две связаны с~возможностью связать вызов функции из одного модуля с~её описанием в~другом на стадии компоновки;
третья и~четвёртая требуются для корректного взаимодействия вызывающей программы и~функции на этапе выполнения.

\begin{enumerate}
\item Имена функций (как вызываемых из данного модуля, так и~тех, которые описаны в~данном модуле и~могут быть вызваны извне) должны быть видимы для компоновщика.

Для этого используются ключевое слово \lstinline!extern! в~C++ и~директива \lstinline!.globl! в~языке ассемблера.

\item Имя одной и~той же функции на этапе компоновки должно выглядеть одинаково как в~том модуле, где она описана, так и~в~том, где она вызывается.

Для этого необходимо отказаться от такой возможности языка C++, как перегрузка (она приводит к~декорированию имён)
% , и~описывать внешние функции как C-функции.
с~помощью дополнительной строки \lstinline!"C"! для ключевого слова \lstinline!extern!.
Кроме того, многие версии операционной системы Microsoft Windows требуют от компиляторов дополнительно искажать имена; это необходимо компенсировать вручную при помощи макросов.

\item Параметры должны помещаться вызывающей программой именно туда, где их будет искать вызываемая функция; возвращаемое значение функции также должно оказаться на том месте, где его ожидает вызывающая программа.

% Для этого обе стороны должны соблюдать так называемые соглашения о~вызовах.
Для языков высокого уровня протокол взаимодействия вызывающей и~вызываемой программ называется соглашением о~вызовах.
Используемое соглашение определяется платформой, операционной системой, языком высокого уровня, компилятором, а~также специальными ключевыми словами при описании функции.
Соответственно, функцией можно назвать подпрограмму, следующую необходимому соглашению о~вызове.

\item Функция перед возвратом должна удалить из стека все те данные, которые она поместила поверх адреса возврата, и~ни в~коем случае не удалять больше, чем поместила.

Баланс стека должен быть сохранён, иначе во время возврата из функции управление будет передано не туда (а~именно "--- по адресу, равному значению в~текущей вершине стека), что приведёт к~некорректной работе программы и,~возможно, к~её краху.
\end{enumerate}

Рассмотрим процесс взаимодействия вызывающей программы и~функции подробнее.

\subsection{Требования к~вызовам функций}
\label{sec:asm-calling-conventions}

\epigraph{\begin{stanza}[0mm]
И может быть мы сразу друг друга поймём,\\
Если у нас один и тот же разъём.
\end{stanza}}
{\Aquarium}

% Функции 
К~механизму вызова 
подпрограммы
% функции
(в~различных языках используется также термины «функция», «метод», «процедура») 
можно сформировать ряд требований.
\begin{enumerate}
\item Возможность передачи управления на произвольный адрес.
\item Возврат управления назад после завершения подпрограммы.
\item Вложенные вызовы подпрограмм.
\item Сохранение и~восстановление регистров вызывающей программы.
\item Передача заданного количества аргументов.
\item Возврат значения. % (часто подпрограмму, способную возвращать).
% \item Передача и~возврат структур.
\item Выделение и~освобождение памяти под локальные переменные подпрограмм.
\end{enumerate}
В~системе команд x86 реализованы только первые три из них.
Обеспечить выполнение остальных можно только в~том случае, если вызывающая и~вызываемая программа «договорятся», где будут находиться передаваемые  аргументы и~локальные переменные.



В~некоторых источниках считается, что функцией можно назвать только подпрограмму, написанную на языке высокого уровня.
При этом подпрограмма, написанная на ассемблере и~соответствующая используемому в~данном языке высокого уровня соглашению о~вызове,
может быть вызвана наравне с~написанными на ЯВУ.
Таким образом, логичнее считать термин «функция» либо синонимом подпрограммы,
либо обозначать им подпрограмму, соответствующую одному из общепринятых соглашений.


% \subsection{Модули и~функции на ассемблере}
% \subsection{Вызов подпрограммы}
% \subsection{Подпрограммы на ассемблере}
% \subsection{Вызов подпрограммы на ассемблере}
\subsection{Механизм вызова подпрограммы}
\index{Подпрограммы!вызов}%
\label{sec:asm-func}
\epigraph{
Что такое заклинание, понятно всем.\\Это когда говоришь "--- а оно случается.
% 
% Нет, как-то ненаучно вышло. Заглянем в трактат профессора Югоруса Лужжа «Основные направления развития всеобщего магического образования на 1975-2125 годы»:
% 
% «Заклинание "--- вербализованная модуляция унитарного магического воздействия, подкрепленная спорадически сознательным, а иногда эмерджентным импульсом психофизиологического характера».
% 
% Вот.
% 
% А так было все понятно…
% 
% Сейчас попробуем объяснить. «Вербализованный» "--- это значит «словами», «модуляция» "--- это… ну… то сильнее, то слабее…
% 
% Ладно, все равно слово «эмерджентный» авторы даже руками показать не смогут. Вернемся к прежнему определению. Из него следует, что достаточно что-то произнести, и что-то случится. В такой, наиболее общей форме определение верно абсолютно: что бы вы ни произнесли, где-нибудь что-нибудь случится.
% 
% Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{Жвалевский/Мытько}
% \index{Вызов функций}%
\index{Стек}%
\index{Команды!push}%
\index{Команды!pop}%
\index{Команды!call}%
\index{Команды!ret}%


% Вызов подпрограммы (функции или процедуры) можно разбить на последовательность следующих действий.
% \begin{enumerate}
% \item Передача параметров.
% \item Сохранение адреса возврата.
% \item Передача управления вызываемой подпрограмме.
% \item Выполнение вызываемой подпрограммы.
% \item Подготовка возвращаемого значения.
% \item Возвращение управления вызывающей программе.
% \end{enumerate}


% Соответственно, к~механизму вызова подпрограммы можно сформировать ряд требований.
% \begin{enumerate}
% \item Возможность передачи управления на произвольный адрес.
% \item Возврат управления назад после завершения подпрограммы.
% \item Вложенные вызовы подпрограмм.
% \item Сохранение и~восстановление регистров вызывающей программы.
% \item Передача заданного количества аргументов.
% \item Передача и~возврат структур.
% \item Выделение и~освобождение памяти под локальные переменные подпрограмм.
% \end{enumerate}

% В~системе команд x86 реализованы только первые три из них.

В~системе команд x86 для реализации механизма подпрограмм используются всего две команды:
\begin{itemize}
\item команда вызова подпрограммы \lstinline!call!, единственным аргументом которой является адрес начала подпрограммы;
\item команда возврата из подпрограммы \lstinline!ret!.
\end{itemize}
Пусть следующая команда, расположенная по адресу $c_i$ "--- \lstinline!call f!
(рис.~\ref{ris:call-stack}, а).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-abv}
}

\caption{Изменение указателя стека командами вызова и~возврата}
\label{ris:call-stack}
\end{illustration}%
Команда \lstinline!call! помещает в~стек адрес следующей по порядку команды $c_{i+1}$ "--- \termin{адрес возврата,}
после чего в~указатель команд~$ip$ помещается адрес~$f$, так что эта команда становится следующей для исполнения процессором
(рис.~\ref{ris:call-stack}, б).
Когда в~процессе исполнения подпрограммы~$f$ встретится команда \lstinline!ret!
(рис.~\ref{ris:call-stack}, в),
\index{Слово!машинное}%
из стека извлекается верхнее машинное слово "--- там должен быть адрес возврата "--- и~помещается в~указатель команд~$ip$
(рис.~\ref{ris:call-stack}, г).
Соответственно, выполнение вызывающей программы продолжится со следующей за  \lstinline!call! команды.  

\subsubsection{Локальные переменные}
\index{Стек}

Как уже говорилось в~разделе~\ref{sec:stack-segment}, локальные переменные подпрограммы хранятся в~стеке;
также программист или оптимизирующий компилятор может поместить часть локальных переменных в~регистрах общего назначения.
Это не предписано системой команд, но является общепринятым.

Так как память под локальные переменные подпрограммы выделяется подпрограммой после %её вызова
передачи управления на её начало, 
эти переменные будут расположены в~стеке над адресом возврата (так как стек растёт вниз "--- по меньшим адресам).
Для выделения и~освобождения памяти под переменные служат 
\index{Подпрограммы!пролог}%
\index{Подпрограммы!эпилог}%
специальные фрагменты кода в~начале и~в~конце подпрограммы "--- пролог и~эпилог соответственно.

Современные компиляторы 
% сразу после 
помещают в~пролог команду уменьшения указателя стека $sp$ на величину, равную общему объёму локальных переменных, помещаемых в~стеке
(рис.~\ref{ris:call-stack-var-sp}, а) и~б).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-var-sp-abv}
}
\index{Стек}

\caption{Размещение локальных переменных в~стеке оптимизирующим компилятором}
\label{ris:call-stack-var-sp}
\end{illustration}%
В~эпилоге указатель $sp$ увеличивается на ту же величину (рис.~\ref{ris:call-stack-var-sp}, в) и~г),
так что к~моменту выхода из подпрограммы на вершине стека окажется адрес возврата (рис.~\ref{ris:call-stack-var-sp}, г).
\index{Стек}

% После этого локальные переменные можно 
Адреса локальных переменных можно выразить через $sp$.
В~процессе выполнения программы указатель $sp$ может меняться% (в~частности, для размещения)
, в~этом случае необходимо соответственно корректировать смещения переменных относительно $sp$.
Также,  %если в~процессе выполнения в~стеке резервировалась память под новые локальные
если код подпрограммы нарушает баланс стека,
может понадобиться скорректировать величину, добавляемую к~$sp$ в~эпилоге.

Ранние компиляторы сохраняли в~регистре~$bp$ значение $sp$ до резервирования памяти под локальные переменные.
Это позволяло адресовать переменные относительно $bp$ и~не корректировать смещение, а~в~эпилоге восстановить значение~$sp$ из~$bp$
(рис.~\ref{ris:call-stack-var-bp}, а)--д).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-var-bp-abv}
}

\caption{Размещение локальных переменных в~стеке (устаревший вариант)}
\label{ris:call-stack-var-bp}
\end{illustration}%
Это удлиняло пролог и~эпилог за счёт необходимости сохранять и~восстанавливать исходное значение~$bp$.
Кроме того, при этом невозможно использовать~$bp$ для других целей.

Размещение локальных переменных происходит внутри вызываемой подпрограммы и~не затрагивает данные вызывающей программы.
При ручном программировании можно использовать как современную, так и~устаревшую форму пролога и~эпилога;
если все локальные переменные размещены в~регистрах, пролог и~эпилог вообще не требуются.

Следует отметить два момента:
\begin{itemize}
\item при компиляции с~языка высокого уровня порядок локальных переменных в~стеке может не совпадать с~порядком их объявления;
\item содержимое резервируемой в~стеке памяти, как и~начальное значение регистров, не определено, поэтому локальные переменные обязательно нужно инициализировать.
\end{itemize}

\subsubsection{Параметры и~возвращаемое значение}
\index{Стек}

Параметры  также могут передаваться в~подпрограмму через стек или регистры.
Вызывающая программа должна разместить параметры в~условленных местах до того, как управление будет передано подпрограмме.
Соответственно, параметры, передаваемые через стек, окажутся под адресом возврата, то есть будут иметь б\'{о}льшие адреса.

Возвращаемое значение функции не может передаваться вызывающей подпрограмме через стек, так как %оно должно быть записано на своё место до команды \lstinline!ret!, 
% возвращающей
% а~
% к~моменту возврата 
при выполнении команды~\lstinline!ret!
в~стеке не должно остаться ничего после адреса возврата.
Соответственно, возвращаемое значение может передаваться в~вызывающую подпрограмму только через регистр.

Иногда значение, которое, согласно синтаксису языка высокого уровня, является возвращаемым, не может быть размещено в~регистре (в~частности, это может быть объект).
В~этом случае зарезервированное для него место (или его адрес) фактически передаётся как ещё один параметр.


Таким образом, «настоящее» возвращаемое значение может быть только числом.
Если это целое число или указатель, 
в~программах для x86
для возврата используется регистр~$A$.
% если  разрядность результата превышает разрядность платформы "--- пара регистров $D:A$ (старшая часть в~$D$, младшая в~$A$).
% 
Вещественное значение возвращается через вершину стека математического сопроцессора $st(0)$.

% В~языке высокого уровня функция может возвращать только одно значение.



\subsection{Соглашения о~вызовах}
\label{sec:calling-conventions}
\epigraph{
Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{Жвалевский/Мытько}




% \footnote{Использованы материалы:
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.
% }
\index{Подпрограммы!соглашения о~вызовах}%

{Соглашение о~вызовах} определяет протокол взаимодействия вызывающей и~вызываемой программ;
в~частности, необходимо согласовать следующие правила.
% \vspace{-1\parskip}
\begin{enumerate}
\item Способ передачи параметров (через стек,\index{Стек} через регистры, смешанный; а~также используемые регистры и~их порядок).
\item Порядок размещения параметров в~стеке 
(%прямой порядок, или 
порядок Pascal подразумевает, что первый параметр помещается в~стек первым, 
% обратный порядок, или 
порядок C "--- что первый параметр помещается последним, непосредственно перед адресом возврата).
\item Как передаётся указатель $this%/self
$ (для методов объекта).

\item Какие регистры могут изменяться подпрограммой.
% Если 

\item Кто очищает стек и~сохраняет/восстанавливает регистры.

\item Инструкции вызова и возврата из подпрограмм.
\item Возврат значения из подпрограммы (функции).
\end{enumerate}



На платформе x86 для вызова и~возврата из подпрограммы используются соответственно команды \lstinline!call! и~\lstinline!ret!;
а~значение обычно возвращается через регистр~$A$.
Параметры обычно передаются либо через стек, либо смешанным способом: первые из тех, что можно разместить в~отведённых регистрах, передаются через регистры,
оставшиеся "--- через стек.
% Если 

% Возвращаемое значение:
% % \vspace{-1\parskip}
% \begin{enumerate}
% \item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
% \item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
% \end{enumerate}

Остальные пункты по-разному реализованы в~различных языках, компиляторах,  операционных системах
и~для различной разрядности.
% Также для передачи 
Подробно эти различия рассмотрены в~исследовании Агнера Фога~\cite{agner_fog_calling_conventions}.

% \subsubsection{}
В~таблице~\ref{tab:calling-conventions-32} приведены наиболее популярные соглашения о~вызовах, используемые на 32-битных платформах.
Регистры для передачи параметров используются в~указанном порядке.
Если столбец «Параметры в~регистрах» пуст, все параметры передаются через стек.\index{Стек}
Указатель $this$ обычно передаётся первым параметром.

\begin{table}[!ht]

\caption{Тридцатидвухбитные соглашения о~вызовах}
\label{tab:calling-conventions-32}

\renewcommand\theadfont{\bfseries\small}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}

% \scriptsize
% \footnotesize

\singlespacing
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|>{\theadfont}M{6em}|l|l|L|%L|
}
\hline
Соглашение &\tdhead{Параметры\\в~регистрах}	&\theadlong{Порядок}	&\theadlong{Очистка стека}	\\\hline
cdecl		&	&	C	&	вызывающая программа	\\\hline
pascal		&	&	Pascal	&	функция			\\\hline
winapi (stdcall)&	&	C	&	функция			\\\hline
gnu		&	&	C	&	this "--- функция, \mbox{остальные "---  вызывающая программа}	\\\hline
gnu fastcall		&	$ecx, edx$	&	C	&	функция	\\\hline
gnu regparm (3)		&	$eax, edx, ecx$	&	C	&	функция	\\\hline
Borland fastcall	&	$ecx, edx$	&	Pascal	&	функция	\\\hline
Microsoft fastcall	&	$ecx, edx$	&	C	&	функция	\\\hline
\end{tabularx}
\end{table}

Для соглашения gnu regparm можно указать количество параметров в~регистрах (от одного до трёх).

Кроме того, регистры делятся на те, которые подпрограмма может изменять по своему усмотрению 
(соответственно, если они используются в~вызывающей программе, вызывающей программе необходимо сохранить их перед обращение к подпрограмме и~восстановить после того, как подпрограмма закончит работу)
и~те, которые должны сохранить своё значение 
(если в~подпрограмме потребуется использовать один из таких регистров, то сохранить и~потом восстановить их исходное значение должна сама подпрограмма).

Согласно Фогу,  в~тридцатидвухбитных программах, как в~Microsoft Windows, так и~в~Unix-подобных операционных системах (GNU/Linux, BSD, Mac~OS~X),
подпрограмма может изменять 
регистры
$eax, ecx, edx,$ регистры сопроцессора $st(0)-st(7)$
и~регистры расширений $xmm/ymm/zmm.$
Неприкосновенными должны остаться $ebx, ebp$ и~$esi, edi.$

На~шестидесятичетырёхбитных платформах применяется всего два соглашения о~вызовах (таблица~\ref{tab:calling-conventions-64}).
К~сожалению, они несовместимы между собой.
Также для разных платформ теперь различается набор регистров, которые могут изменяться в~подпрограмме.
% В~таблице~\ref{tab:calling-conventions-64} приведены соглашения о~вызовах, используемые на 64-битных платформах.
Регистры для передачи параметров используются в~указанном порядке.
Указатель $this$ передаётся первым параметром.

\begin{table}[!ht]

\caption{Шестидесятичетырёхбитные соглашения о~вызовах}\index{Шестидесятичетырёхбитный режим}
\label{tab:calling-conventions-64}

\renewcommand\theadfont{\bfseries\footnotesize}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{@{}l@{}}#1\end{tabular}}}}

\singlespacing
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|L|L|l|L|L|L|
}
\hline
\theadlong{Соглашение} &\tdhead{Параметры\\в~регистрах}	&\tikz[baseline]\node[rotate=90] {\theadlong{Порядок}};	&\theadlong{Очистка стека}	
&\tdhead{Изменяемые\\регистры}	&	%\tdhead{Неприкосновенные\\регистры}
\tdhead{Неизменяемые\\регистры}
\\\hline
{\theadfont Microsoft Windows,} компиляторы MinGW, Microsoft, Intel	&	
% $rcx/zmm0,$
% $rdx/zmm1,$
% $r8/zmm2,$
% $r9/zmm3$
\begin{tabular}{@{}>{$}c<{$}@{$/$}>{$}c<{$}@{}}
rcx&zmm0,\\
rdx&zmm1,\\
r8&zmm2,\\
r9&zmm3 \\
\end{tabular}
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$ $r8{-}r11,$ $st(0){-}st(7),$ 
$x/y/zmm,$
кроме младших частей $6{-}15$
&
$rbx, rbp,$ $rsi, rdi,$ $r12{-}r15,$ $xmm6{-}xmm15$
\\\hline
% Unix-подобные (
{\theadfont GNU/Linux, BSD, Mac~OS~X,} компиляторы GCC, Intel	&	
% $rdi, rsi,$
% $rdx, rcx,$ 
% $r8, r9,$ 
\begin{tabular}{@{}>{$}c<{$}@{$~$}>{$}c<{$}@{}}
rdi,& rsi,\\
rdx,& rcx,\\
r8, & r9,\\
\end{tabular}
$zmm0{-}zmm7$
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$  $rsi, rdi,$ $r8{-}r11,$ $st(0){-}st(7),$ $x/y/zmm$
&
$rbx, rbp,$ $r12{-}r15$ 
\\\hline
\end{tabularx}
\end{table}

Как видно из таблицы~\ref{tab:calling-conventions-64}, в~64-битном режиме под разными операционными системами в~подпрограмме необходимо сохранять и~восстанавливать разные регистры.


\subsubsection{Вызов подпрограммы в~GAS}

На тридцатидвухбитной платформе в~GCC используются 
соглашения о~вызове gnu, cdecl, gnu fastcall, gnu regparm (0--3).
Для внешних функций с~отключённым декорированием  (\lstinline!extern "C"!)
применяется только cdecl, то есть: % все параметры передаются через стек.
\begin{itemize}%[wide=\parindent]

\item размещение аргументов исключительно \emph{в~стеке,}\index{Стек} без использования регистров, причём аргументы, меньшие 4 байт, расширяются до 4 байт;

\item размещение аргументов в~стеке %\emph{справа налево,} так 
таким образом,
что первый аргумент оказывается на вершине стека;
% (после вызова первый аргумент находится непосредственно под адресом возврата, как показано на рис.~\ref{ris:cdecl-stack});

\item очистка стека выполняется \emph{вызывающей программой,} так что
в~функции 
аргументы должны не сниматься со стека, а~копироваться оттуда.


\end{itemize}
Размещение аргументов в~стеке {справа налево} и~очистка стека вызывающей программой позволяет определить функции с~переменным количеством аргументов, такие, как  \lstinline!printf! и~\lstinline!scanf! из стандартной библиотеки \lstinline!C!, но надо помнить о~небезопасности таких функций.

% Адрес возврата принято передавать через стек
При вызове функции в~стек сначала помещаются аргументы в~соответствии с~соглашением о~вызовах, 
а~затем команда вызова кладёт сверху адрес возврата.
Соответственно, когда функция получает управление, 
% http://trubetskoy1.narod.ru/arttranslate/FuncCallPart2_1.html
то первые четыре байта по адресу, хранящемуся в~$sp$, будут содержать адрес возврата. 
Далее идут аргументы функции. При использовании соглашения о~вызовах \lstinline!cdecl!
непосредственно за адресом возврата (по адресу $sp + 4$) будет находиться первый параметр,
% следующие 4 байта (т.\,е. 4 байта по адресу $\text{\ESP} + 4$) будут содержать первый параметр, 
% в четырёх байтах по адресу $\text{\ESP} + 8$ будет второй параметр
за ним идёт второй 
и~т.\,д. (рис.~\ref{ris:cdecl-stack})

\begin{illustration}
\resizebox{\approvedImageWidth}{!}{
\schemafont
\input{book/drawings/cdecl-stack}
}

\caption{Параметры и~адрес возврата в~соглашении cdecl}
\label{ris:cdecl-stack}
\end{illustration}%

Регистры $B, bp, si, di$ не~должны изменяться подпрограммой.
% 
Возврат значения по возможности выполняется через регистры:
\begin{itemize}
\item $eax$, если результат "--- указатель или целое число до 4 байт (если результат меньше 4~байт, старшую часть $eax$ необходимо обнулить);
\item пара регистров $edx:eax$, если результат "--- целое число размером 8~байт;
\item вершина стека сопроцессора, если результат "--- вещественное число;

если результат не помещается в~регистры, возвращается указатель на него (через $eax$).
\end{itemize}

На шестидесятичетырёхбитной платформе в~GCC для любых функций,
в~том числе внешних  с~отключённым декорированием  (\lstinline!extern "C"!),
используется соглашение, соответствующее операционной системе.


\subsection{Описание функций на ассемблере}
\label{sec:gas-functions}
\epigraph{
Итак, в~предыдущих главах вы узнали о~сути колдовства, секрете вечного счастья и~основных правилах техники безопасности. 
}{Жвалевский/Мытько}

Пусть требуется описать функцию, рассчитывающую для целых беззнаковых чисел $x,y$ значение $z = 1 + x/8 + y$.
%
На языке высокого уровня она будет иметь вид, приведённый в~листинге~\ref{lst:sample:foo.cpp}.
\begin{lstlisting}[caption=Функция на языке C++, label=lst:sample:foo.cpp]
unsigned foo(unsigned x, unsigned y)
{
    return 1 + x/8 + y;
};
\end{lstlisting}

Так как делитель $8 = 2^3$ является степенью двойки, деление $x/8$ можно заменить беззнаковым сдвигом $x >> 3$.

В~принципе, если функция предназначена для использования внутри ассемблерного файла и~гарантированно не будет вызываться языком высокого уровня, она может и~не соответствовать стандартным соглашениям о~вызове.
% Это может использоваться для реализации 
Таким образом, можно реализовать собственные нестандартные соглашения, %связывающие 
позволяющие, в~частности, передать параметры через регистры даже на тридцатидвухбитной платформе или вернуть несколько результатов в~разных регистрах.

Тем не менее, если нестандартного поведения от функции не требуется, лучше использовать стандартные соглашения,
так как в~перспективе может понадобиться вызвать функцию из модуля на ЯВУ.

\subsubsection{Описание функции (cdecl)}

% На тридцатидвухбитной платформе 
% Соответственно, в~
Пусть используемая платформа тридцатидвухбитна и~используется соглашение cdecl.
Тогда на ассемблере код, рассчитывающий и~возвращающий значение $z = 1 + x/8 + y = x/8+y+1$, в~простейшем случае выглядит как в~листинге~\ref{lst:sample:foo.S}.

\begin{lstlisting}[caption=Простейшая функция на ассемблере, label=lst:sample:foo.S]
foo:
  movl 4(%esp), %eax	// eax = x
  shrl $3, %eax		// eax >>= 3
  addl 8(%esp), %eax	// eax +=y
  incl %eax		// ++eax
  ret		// возврат управления вызывающей программе
\end{lstlisting}

% Директива \lstinline!.globl! делает функцию   $sqr()$ видимой для внешних модулей.
В~первой строке находится метка, показывающая начало функции $foo()$.

Параметры, в~соответствии с~соглашением cdecl, находятся в~стеке;\index{Стек}
при этом стек в~GNU/Linux по умолчанию выравнен по $long$, то есть любое не более чем тридцатидвухбитное значение должно занимать 32 бита.

Таким образом, на вершине стека (ячейка \lstinline!(%esp)!) находится адрес возврата; 
в~ячейке памяти, смещённой на четыре байта относительно вершины стека $sp$\index{Стек} (по адресу $sp + 4$, что обозначается как \lstinline!4(%esp)!) "--- первый параметр $x$, 
по адресу $sp+8$ (ячейка \lstinline!8(%esp)!) "--- второй параметр $y$.
Оба параметра тридцатидвухбитны.
% , так что %расширение не требуется.
% их размер совпадает с~размером 

Команда \lstinline!movl 4(%esp), %eax! копирует (move) четырёхбайтовый (что обозначается суффиксом~$l$, то есть $long$) параметр $x$  в~регистр~$eax$. 
\index{Команды!mov}%
Следующая команда выполняет беззнаковый, или логический сдвиг вправо (shift right) на три бита, что эквивалентно беззнаковому делению на $8$.
После этого к~$eax$ добавляются параметр $y$ и~единица.

Возвращаемое значение, согласно соглашению, cdecl, должно находиться в~регистре $eax$;
результат вычислений находится именно там. 
В~стеке нет ничего над адресом возврата, поэтому далее
% Затем 
следует возврат из функции (ret).


% Функция $sqr()$ принимает единственный параметр $x$ типа $int$ (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком),
% то есть этот параметр занимает четыре байта и~должен непосредственно следовать за адресом возврата (то есть находиться по адресу $sp+4$).
% % т.\,е. четыре байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $sp + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.
% 
% % Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, 
% После умножения результат %(квадрат аргумента)
% $x^2$
% находится в~регистре~$A$,
% через который и нужно вернуть значение.
% Таким образом, сразу после команды умножения можно выйти из функции командой \lstinline!ret!.

\subsubsection{Вызов функции (cdecl)}

Вызов описанной функции, в~частности, расчёт значения $foo(17, 2)$, выглядит следующим образом (листинг~\ref{lst:sample:call-foo}).
\begin{lstlisting}[caption=Вызов функции $foo()$, label=lst:sample:call-foo]
pushl $2	// второй параметр
pushl $17	// первый параметр
call foo	// вызов подпрограммы foo
add $8, %esp	// очистка стека от параметров
\end{lstlisting}


Команда \lstinline!call!, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
Она только помещает в~стек\index{Стек} адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.

Таким образом, перед вызовом функции командой \lstinline$call$ параметры необходимо вручную поместить  туда, где их ожидает увидеть подпрограмма.
Для соглашения cdecl они должны находиться в~стеке. %, куда помещаются командой push 
% в~обратном порядке.
Соответственно, фактические параметры $17$ и~$2$ нужно загрузить в~стек как четырёхбайтовые целые числа, что и~делает команда \lstinline!pushl!.

После завершения работы такой функции параметры необходимо вручную удалить из стека;
для этого к~указателю стека добавляется общий размер параметров "--- восемь байта.

Возвращаемое значение типа $unsigned~int$ можно найти, в~соответствии с~соглашением о~вызове, в~регистре~$A$ ($eax$).

\subsubsection{Сохранение изменяемых функцией регистров}

Если вызывающая подпрограмма хранит какие-то долгоживущие данные в~регистре, изменяемом подпрограммой 
(для тридцатидвухбитных соглашений это $eax, ecx, edx,$ регистры сопроцессора $st(0)-st(7)$
и~регистры расширений $xmm/ymm/zmm$), их необходимо сохранить перед вызовом функции
и~восстановить после её завершения.

В~частности, в~листинге~\ref{lst:sample:call-foo-savereg} сохраняется и~восстанавливается регистр $eax$.
Так как в~этом регистре по соглашению после выхода из функции содержится её возвращаемое значение, оно (если оно требуется вызывающей программе) должно быть скопировано или использовано до восстановления оригинального значения $eax$.

\begin{lstlisting}[caption=Вызов функции $foo()$ с~сохранением $eax$, label=lst:sample:call-foo-savereg]
z: .long 0
...
pushl %eax	// сохранение eax
pushl $2	// второй параметр
pushl $17	// первый параметр
call foo	// вызов подпрограммы foo
add $8, %esp	// очистка стека от параметров
movl %eax, z	// z = foo()
popl %eax	// восстановление eax
\end{lstlisting}

При этом значение регистров, которые по соглашению могут быть изменены функцией, необходимо сохранять, даже если текущая реализация конкретной функции $foo()$ их не меняет (в~следующей версии функции они могут быть использованы).

Наилучшим выходом будет %не использовать изменяемые функциями регистры для хранения долгоживущих переменных.
использовать изменяемые функциями регистры только как временные
и~не хранить там долгоживущие переменные.

\subsubsection{Локальные переменные}

Пусть требуется использовать в~функции $foo()$ локальную переменную $t$.
Например, зададим вначале  $t=1$, затем добавим к~этому значению $x/8$ и~$y$
(хотя для таких простых вычислений введение переменной в~памяти явно избыточно, данная функция не использует даже всех разрешённых по соглашению регистров).
Получим листинг~\ref{lst:sample:foo-t}.

\begin{lstlisting}[caption=Функция с локальной переменной, label=lst:sample:foo-t]
foo:
  pushl $1	// пролог: t = 1
  
  movl 8(%esp), %eax	// eax = x
  shrl $3, %eax		// eax >>= 3
  addl %eax, (%esp)	// t += eax (t = 1 + x/8)
  
  movl 12(%esp), %eax	// eax = y
  addl %eax, (%esp)	// t += eax (t = 1 + x/8 + y)

  movl (%esp), %eax	// eax = t
  add $4, %esp	// эпилог: уничтожение t
  ret
\end{lstlisting}

У функции появляются пролог и~эпилог. В~листинге~\ref{lst:sample:foo-t} показана современная форма пролога и~эпилога, когда все локальные переменные и~параметры адресуются через $sp$.

Так как указатель стека~$sp$ изменён, смещения параметров относительно $sp$ также изменились.

\subsection{Импорт функций из модулей на ассемблере в~код на C++}
\label{sec:gas-extern}

\epigraph{
Вы представляете, какой жест при взмахе волшебной палочкой выглядит наиболее эффектно, куда~её~направлять в~начальной фазе ворожбы и~куда~прятаться, если она вдруг заработает.
}{Жвалевский/Мытько}

   
% \section{Подключение модуля на ассемблере к~C++-проекту}
% \index{Подключение модуля на ассемблере}%
Функции, описанные в~ассемблерном модуле, необходимо описать в~коде C++ как внешние (\lstinline!extern!).
После спецификатора \lstinline!extern!, согласно стандарту C++, могут быть указаны строки \lstinline!"C++"! (подразумевается по умолчанию) или \lstinline!"C"! (различные компиляторы могут поддерживать и~иные строки) для указания компоновщику, какой язык использовался при написании внешней функции.
Конкретные свойства таких функций не описываются в~стандарте. На практике \lstinline!"C++"! подразумевает %декорирование (mangling) имён функций
искажение имён функций до неузнаваемости (что подробнее описано в~%предыдущем 
разделе~\ref{sec:mangling})
и~передачу параметров по возможности через регистры, что реализуется в~разных компиляторах по-разному.
% 
Указание \lstinline!"C"! %на практике
уменьшает искажение имён и~для тридцатидвухбитных платформ
подразумевает соглашение о~вызовах \lstinline!cdecl!.

Рассмотрим функцию $int~sqr(int~x)$, вычисляющую квадрат целого числа на тридцатидвухбитной платформе GNU/Linux~\cite{opennet.ru/base/dev/from_c_to_asm}.
% \lstset{language=[Motorola68k]Assembler}
Текст ассемблерного модуля \programname{sqr.S} с~текстом функции
% \footnote{
% Использованы материалы статьи Hiran Ramankutty «От C к~Ассемблеру», перевод: Андрей Киселев
% } 
% находится в~файле \programname{sqr.S} % (так как здесь нет необходимости в~препроцессинге, можно было использовать также имя \programname{sqr.s})
приведён в~листинге~\ref{lst:sqr.S}.

\index{Команды!ret}%
\index{Команды!mov}%
\index{Команды!imul}%
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
\end{lstlisting}

% В~следующей строке находится метка, показывающая начало этой функции.
% 
% Команда \lstinline!movl 4(%esp), %eax! копирует (move) четыре байта (что обозначается суффиксом~$l$) из ячейки памяти, смещённой на четыре байта относительно вершины стека $sp$\index{Стек} (по адресу $sp + 4$), в~регистр~$A$. 
% \index{Команды!mov}%
% Следующая команда выполняет умножение $A ~{*}{=}~ A$.
% Затем следует возврат из функции.



Функция $sqr()$ копирует единственный параметр $x$ типа $int$ (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком)
из стека в~регистр $eax$, затем умножает $eax$ сам на себя и~возвращает управление вызывающей программе.
% то есть этот параметр занимает четыре байта и~должен непосредственно следовать за адресом возврата (то есть находиться по адресу $sp+4$).
% % т.\,е. четыре байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $sp + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.

% % Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, 
% После умножения результат %(квадрат аргумента)
% $x^2$
% находится в~регистре~$A$,
% через который и нужно вернуть значение.
% Таким образом, сразу после команды умножения можно выйти из функции командой \lstinline!ret!.

% Если в~файле несколько функций, можно указать для отладчика их границы.
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S:endfunc]
% .globl sqr
% .func sqr
%         sqr:
%                 movl 4(%esp), %eax
%                 imull %eax, %eax
%                 ret
% .endfunc
% \end{lstlisting}
% Парные директивы .func  $\ldots$  .endfunc не влияют ни на что, кроме добавления некоторой отладочной информации при сборке в~отладочном режиме.
% В~режиме Release игнорируются.

% В~шестидесятичетырёхбитном GNU/Linux  тип $int$ часто 32-битен
% $di$
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
% .globl sqr
%         sqr:
%                 movl %edi, %eax
%                 imull %eax, %eax
%                 ret
% \end{lstlisting}

Директива \lstinline!.globl! делает функцию   $sqr()$ видимой для внешних модулей.


Основной файл \programname{main.cpp} содержит импорт функции  $sqr()$ %как \lstinline!extern "C"!
и~её вызов
из головной функции $main()$.
% Функция \lstinline!sqr! может использоваться так же, как и~функция, описанная на языке C++ (кроме перегрузки).
\begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:main.cpp]
#include <iostream>

using namespace std;
extern "C" int sqr(int x);

int main()
{
    int x=2, y;
    y = sqr(x);
    cout << y <<endl;
    return 0;
}
\end{lstlisting}

Для импорта функции из другого объектного файла здесь она описана как внешняя (\lstinline!extern "C"!).
% 
В~GNU/Linux имена внешних C-функций не искажаются, поэтому в~модулях \programname{main.cpp} и~\programname{sqr.S}
используется одно и~то же имя~$sqr()$.





% \subsection{Импорт внешних функций в~подпрограмму на ассемблере}
\subsection{Импорт функций из модулей на C++ в~код на ассемблере}
% \subsection{Экспорт функций из C++}

\epigraph{
Если заклинание не сработало нужным образом, обратитесь к разработчику. Возможно, вы неправильно его активировали (заклинание, а~не~разработчика).
}{Жвалевский/Мытько}


Подпрограмма на ассемблере может обращаться не только к~другим подпрограммам из того же модуля на ассемблере, 
но и~к~внешним, в~частности, к~функциям, из других объектных файлов проекта или к~стандартной библиотеке stdlib.

Для того, чтобы функция, описанная на языке C++, была доступна для экспорта в~другие модули, используется ключевое слово extern, как и~для импорта внешних функций (для отключения декорирования также используется \lstinline!extern "C"!):
% \begin{lstlisting}
% /*@\colorbox{codestronghighlight}{extern "C"{}}@*/
% __attribute__((__cdecl__)) 
% int /*@\colorbox{codehighlight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
\begin{lstlisting}[caption=Файл \programname{bar.cpp}, label=lst:demangle:bar.cpp]
extern "C" int bar(int x)
{
    return 3*x+1;
};
\end{lstlisting}
% Декорирование C++-функций делает их имена неопознаваемыми, поэтому на практике при экспорте функций лучше использовать только "C" 
% Соглашение о~вызове на всякий случай указано явно с~использованием ключевого слова \lstinline!__attribute__!, но чаще всего для использования cdecl достаточно\lstinline!extern "C"!. 

Для импорта функции в~ассемблере не требуется никаких директив, достаточно знать её имя.
% \begin{lstlisting}
% pushl $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}

\index{Команды!push}%
\index{Команды!call}%
\index{Команды!add}%
\begin{lstlisting}[caption=Фрагмент файла \programname{main.S}, label=lst:main.S]
pushl $1
call bar
add $4, %esp
\end{lstlisting}
Приведённый фрагмент кода рассчитывает $bar(1)$.
% 
% Команда \lstinline!call!, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
% Она только помещает в~стек\index{Стек} адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.
% 
% Таким образом, перед вызовом функции командой \lstinline$call$ параметры необходимо вручную поместить  туда, где их ожидает увидеть подпрограмма.
% Для соглашения cdecl они должны находиться в~стеке. %, куда помещаются командой push 
% % в~обратном порядке.
% Соответственно, единицу нужно загрузить в~стек как четырёхбайтовое целое число, что и~делает команда \lstinline!pushl $1!.
% 
% После завершения работы такой функции параметры необходимо вручную удалить из стека;
% для этого к~указателю стека добавляется размер параметров "--- четыре байта.
% 
% % 
% Возвращаемое значение типа $int$ можно найти, в~соответствии с~соглашением о~вызове, в~регистре~$A$.

% Необходимо всегда помнить о~том, что после вызова функции значения многих регистров меняется.

Здесь также во всех модулях используется одно и~то же имя $bar$,
так как 
в~GNU/Linux имена внешних C-функций не искажаются.

Все функции стандартной библиотеки C (stdlib) описаны как  внешние C-функции, поэтому их также можно, аналогично функции $bar()$, вызывать по оригинальному (в~GNU/Linux "--- вообще неискажённому) имени.

При вызове функции с~несколькими параметрами необходимо помнить, что
в~соответствии с~соглашением cdecl они должны находиться в~стеке в~обратном порядке.\index{Стек}
\begin{lstlisting}[caption={Вывод двух чисел на экран}, label=lst:demangle:printf]
fmt: .string "Переменные: %d, %d\n"
foo: .int 13
...
pushl foo	// Значение foo в стек
pushl $19	// Значение 19 в стек
pushl $fmt	// Адрес строки fmt в стек
call printf
addl $3*4, %esp // Три четырёхбайтовых числа из стека  
\end{lstlisting}
Приведённый код выведет на экран сообщение «Переменные: 19, 13».


\subsection{Искажение имён при компиляции}
\label{sec:mangling}
\epigraph{
"--* Как вы его зовете?

"--* Штырь.

"--* Ну и~имечко!

"--* А~что такое? Уменьшительное от Алджернон.
}{П.\,Г.\,Вудхауз}


Имена функций, задаваемые программистом, в~процессе компиляции искажаются;
наиболее заметные изменения связаны с~процессом \termin{декорирования} (name mangling).\index{Декорирование}
Механизм декорирования имён отсутствовал в~языке~C.
Язык C++, в~отличие от C, поддерживает перегрузку функций, то есть программа, написанная на C++, 
может содержать множество функций, носящих одно и~то же имя.
При этом на этапе компоновки для корректной сборки программы у~каждой функции должно быть уникальное имя.
Соответственно, на этапе компиляции в~имя каждой функции включается информация о~всех её параметрах (явных и~неявных),
причём так, что в~изменённом  имени используются только допустимые символы.

Алгоритм декорирования не стандартизирован;
различные компиляторы для различных платформ используют разные схемы.

Декорирование имён можно отключить вместе с~возможностью перегрузки,
объявив функцию  внешней C-функцией \lstinline!extern "C"!.
Большинство современных операционных систем вообще не искажает имён таких функций.
% но на некоторых платформах искажение имён 
В~Microsoft Windows к~имени функции даже при отключённом декорировании
может быть приписан префикс или суффикс.
Конкретный способ искажения зависит от разрядности, компилятора и~версии Windows.

Чаще всего в~Microsoft Windows при компиляции к~именам добавляется  префикс \lstinline!_! (ведущее нижнее подчёркивание).
Имена функций стандартной библиотеки stdlib  также подвергаются искажению (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).
На некоторых (но не на всех) 64-разрядных версиях Microsoft Windows при использовании GCC имена не искажаются.

Если имя функции искажается компилятором,
описанный в~предыдущих разделах код вызовет ошибку компоновки.\index{Компоновка}


% Также \lstinline!extern "C"! подразумевает
% % \item 
% \emph{отсутствие декорирования имён,} % "--- имена функций воспринимаются линкером «как есть»
% % что позволяет не задумываться о~том, как имя, используемое линкером, складывается из имени, данного разработчиком и~характеристик аргументов функции,
% % но делает невозможной перегрузку таких функций.
% что  в~GNU/Linux значит, что имена не будут изменяться компилятором вообще;
% в~Microsoft Windows искажение имён зависит от разрядности, компилятора и~версии Windows.
% Чаще всего при компиляции к~именам добавляется  префикс \lstinline!_!



Если используемый компилятор для данной платформы изменяет имена внешних C-функций, %упоминаемых в~модулях C++, 
например, добавляет префикс \lstinline!_!, как в~случае gcc (mingw) под Microsoft Windows, то ссылка на внешнюю функцию %\lstinline!sqr! 
\lstinline!extern "C" int sqr(int x)!, упоминаемую в~некотором cpp-файле, %к~моменту компоновки 
в~соответствующем объектном файле
будет выглядеть как \lstinline!_sqr!.
Таким образом, для корректной компоновки под Microsoft Windows имя данной функции в~объектном файле, полученном из ассемблерного модуля,  также должно быть \lstinline!_sqr!.
Так как на этапе ассемблирования имена не искажаются ни на какой платформе,
это означает, что в~ассемблерном модуле имя также должно выглядеть как  \lstinline!_sqr!.

При этом в~других операционных системах имена не искажаются,
так что для корректной компоновки в~GNU/Linux имя этой же функции должно выглядеть как \lstinline!sqr!.

Если речь идёт об импорте в~C++ функции, описанной на ассемблере, 
то в~ассемблерном файле можно указать оба варианта имени (листинг~\ref{lst:demangle:sqr:S}).
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:demangle:sqr:S]
% /*@\colorbox{clExportLight}{.globl sqr}@*/
% /*@\colorbox{clExportLight}{.globl \_sqr}@*/
% /*@\colorbox{clFuncnameLight}{sqr:}@*/
% /*@\colorbox{clFuncnameLight}{\_sqr:}@*/
%   movl 4(%esp), %eax
%   imull %eax, %eax
%   ret
% \end{lstlisting}
\begin{lstlisting}[caption=Файл \programname{sqr.S}: экспорт вариантов без искажения и~с~ним, label=lst:demangle:sqr:S]
.globl sqr
.globl _sqr
sqr:
_sqr:
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
В~этом случае код на C++  (листинг~\ref{lst:main.cpp}) соберётся с~модулем~\ref{lst:demangle:sqr:S} как под GNU/Linux или BSD,
так и~под Microsoft Windows,
но это не лучшее решение.
% \begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:demangle:sqr:cpp]
% #include <iostream>
% 
% using namespace std;
% /*@\colorbox{clExportLight}{extern "C"{} int sqr(int x);}@*/
% 
% int main()
% {
%   cout << /*@\colorbox{clFuncnameLight}{sqr(2)}@*/ << endl;
%   return 0;
% }
% \end{lstlisting}




% \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.
% % Имена 
% % C++ искорёжены почти до неузнаваемости, C — у меня сохранены, а у вас, если статья Фога не ошибатеся, к ним приписывается префикс _: _Sqr вместо Sqr (и было бы __Sqr вместо _Sqr, но такой функции в C++-программе нет).
% В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
% Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
% (в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).
% 
% Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
% В~статье Агнера Фога 
% «Calling conventions for different C++ compilers and operating systems»~\cite{agner_fog_calling_conventions}
% приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
% В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
% На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).






В~случае импорта в~программу на ассемблере функции из модуля на C++, в~частности, % одной из функций stdlib
% или 
функции $int~bar(int~x)$, описанной в~листинге~\ref{lst:demangle:bar.cpp},
уже невозможно описать два имени одновременно.
% \begin{lstlisting}[caption=Файл \programname{unit.cpp}, label=lst:demangle:unit:cpp]
% /*@\colorbox{clExportLight}{extern "C"{}}@*/ int /*@\colorbox{clFuncnameLight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
Вызов подобной функции из программы на ассемблере
будет выглядеть как \lstinline!call bar! под GNU/Linux или BSD и~как~\lstinline!call _bar! под тридцатидвухбитными и~некоторыми шестидесятичетырёхбитными версиями  Microsoft Windows.

Как правило, программа  вызывает 
% функции, импортированные из  модулей на C++, и~функции stdlib
% не в~одном месте, 
подобные функции из множества мест,
так что править её вручную затруднительно.

% Можно описать два варианта вызова с~помощью директив условной компиляции.
% Определим макрос-флаг \lstinline!#define ISPREFIX!, если имена искажаются 
% \begin{lstlisting}[caption=Фрагмент файла \programname{main.S}, label=lst:main.S]
% #ifdef ISPREFIX
% call _bar
% #else
% call bar
% #endif\end{lstlisting}

% 
% Фрагмент main.S (GNU/Linux, BSD)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}
% 
% Фрагмент main.S (MS Windows)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{\_bar}@*/
% addl $4, %esp
% \end{lstlisting}

Кроссплатформенности в~этом случае можно достичь использованием макросов для искажения имён в~\programname{.S}-файле вручную.
Опишем макрос~\lstinline!FUNC_NAME! с~параметром $s$ "--- именем функции, который либо добавляет к~$s$ ведущее подчёркивание
(тогда его нужно описать как~\lstinline!#define FUNC_NAME(s) _##s!),
либо ничего с~$s$ не делает (\lstinline!#define FUNC_NAME(s) s!)
и~вместо имени функции, например, $bar$, будем указывать \lstinline!FUNC_NAME(bar)!.

% В~этом случае для переноса с~GNU/Linux на Microsoft Windows в~случае 32-разрядных систем достаточно будет закомментировать 
% 
% для искажающих имена версий Microsoft Windows и~как~ для остальных операционных систем,
% будет преобразовывать имена в~необходимый вид.
% В~этом случае при переносе программы %с~GNU/Linux на 
% достаточно будет изменить описание макроса, чтобы
% вызов~\lstinline!call FUNC_NAME(bar)! или~\lstinline!call FUNC_NAME(printf)! всегда был корректным.

В~случае тридцатидвухбитных систем подчёркивание необходимо добавлять при работе под  Microsoft Windows
и~не нужно для остальных операционных систем.
Для этого можно воспользоваться предопределённым макросом препроцессора~\lstinline!_WIN32!:
\begin{lstlisting}
#ifdef _WIN32
#define FUNC_NAME(s) _##s
#else
#define FUNC_NAME(s) s
#endif 
\end{lstlisting}
Данное определение можно поместить в~начало ассемблерного файла с~расширением~\programname{.S}
или в~файл, включаемый в~него директивой \lstinline!#include!. %, так как 

После этого макрос~\lstinline!FUNC_NAME! можно применять для искажения имён во всех случаях
"--- при экспорте имени функции:
\index{Команды!mov}%
\index{Команды!imul}%
\begin{lstlisting}[caption=Файл \programname{sqr.S}: кроссплатформенный экспорт, label=lst:demangle:sqr:S:FUNC_NAME]
.globl FUNC_NAME(sqr)
FUNC_NAME(sqr):
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
при импорте:
\index{Команды!push}%
\index{Команды!call}%
\index{Команды!add}%
\begin{lstlisting}[caption=Фрагмент файла \programname{main.S}: кроссплатформенный импорт, label=lst:demangle:main.S:FUNC_NAME]
pushl $1
call FUNC_NAME(bar)
add $4, %esp
\end{lstlisting}
или при вызове библиотечных функций:
\begin{lstlisting}[caption={Вывод двух чисел на экран}, label=lst:demangle:printfS:FUNC_NAME]
pushl foo	// Значение foo в стек
pushl $19	// Значение 19 в стек
pushl $fmt	// Адрес строки fmt в стек
call FUNC_NAME(printf)
addl $3*4, %esp // Три четырёхбайтовых числа из стека  
\end{lstlisting}

Шестидесятичетырёхбитный перенос функций из GNU/Linux в~Microsoft Windows или наоборот сложнее.
Во-первых, не все шестидесятичетырёхбитные версии Microsoft Windows искажают имена, так что нужный вариант макроса \lstinline!FUNC_NAME!, возможно, придётся выбирать вручную.
Во-вторых,
если на тридцатидвухбитных платформах для внешних C-функций использовалось соглашение cdecl, 
то здесь 
% в~шестидесятичетырёхбитных платформах используются разные
соглашения для разных операционных систем разные, 
так что для достижения кроссплатформенности придётся 
описать два варианта копирования параметров из регистров,
воспользовавшись директивами условной компиляции.

% В~дальнейшем все примеры будут рассматриваться без учёта искажения имён.


\addquestion{Какие~вы знаете соглашения о~вызове?}
% \addquestion{Как подключить к~проекту используемой вами IDE модуль на ассемблере?}
\addquestion{Как импортировать ассемблерную функцию в~проект на C++?}
