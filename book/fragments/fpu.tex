


\section{Математический сопроцессор}
\label{sec:asm-fpu}
\index{FPU}
\epigraphcensored[
\epigraph{\begin{stanza}[0mm]
Но что ж: бог длинноты в кольце нашел уют, \\
И птицы вечности в кольце поют.\\
\end{stanza}}
{\Khlebnikov}
]{
\epigraph{
"--*  Фапофадофажди, "--- сказала Алиса Пашке, пользуясь старым школьным кодом. "--- Фамыфаосфатафанемфася фаодфани.

"--*  Фапофанял, "--- ответил Пашка.

"--*  Фавлефасу, "--- сказала Алиса.
}
{Кир.\,Булычёв}}


% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX
% }  

Команды расширения FPU, или математического сопроцессора, предназначены для обработки числовых данных в~формате с~плавающей точкой.

% Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой.
% % 
% Первый математический сопроцессор для линейки x86 "--- FPU 8087 "--- был выпущен в~1980 году.
% Он представлял собой отдельную микросхему, устанавливаемую в~специальный сокет на системной плате.
% Взаимодействие с~основным процессором выполнялось в~основном через оперативную память.
% 
% % Использование сопроцессора 8087 ускоряло вычисления с плавающей точкой, но, так как сопроцессор мог отсутствовать, 
% Начиная с~процессора i486DX математический сопроцессор интегрирован в~процессор.
% При этом сопроцессор долгое время (вплоть до линейки микропроцессоров Atom) имел почти независимое ядро, так что обработка целых чисел CPU и~вещественных FPU могла выполняться параллельно.
% % С одной стороны, это позволяло
% Из-за этого в~систему команд была введена команда ожидания завершения работы сопроцессора, а~многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
% В~современных  процессорах FPU настолько плотно интегрирован с~ядром CPU, что их параллельная работа невозможна и~ожидание не требуется.


FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.

Регистры FPU образуют стек с~плавающей вершиной.
Соответственно, система команд FPU идеологически отличается от основной системы команд.
Хотя бы одним из операндов 

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы.
Все мнемонические обозначения начинаются с~символа \lstinline!f! (FPU).
Вторая буква мнемонического обозначения
(если она не является частью имени действия, как в~\lstinline!finit!\index{Команды!finit})
% может определять % 
определяет
тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item \lstinline!i! "--- целое двоичное число со знаком;

\item \lstinline!b! "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы для арифметических команд обозначает вещественное число.
\end{itemize}

Последняя буква \lstinline!p! в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная \lstinline!pp! "---  из стека извлекаются оба операнда). 
Размер операнда в~памяти, если он используется, задаётся суффиксом команды в~соответствии с~правилами синтаксиса~\Att.

Команды FPU не могут иметь непосредственных операндов %или операндов-регистров основного процессора. 
и,~за исключением команды выгрузки слова состояния, не могут работать с~регистрами основного процессора. 
Если не указано иное, используются следующие обозначения.
Операнд-приёмник
может быть обозначен либо как~$dest$, если он может быть регистром сопроцессора или переменной в~памяти либо как $dmem$, если он может быть только в~памяти.
Операнд-источник может быть обозначен как $src$ (регистр сопроцессора или переменная в~памяти) или $smem$ (переменная в~памяти).




\subsection{Внутреннее представление чисел}
\index{Представление вещественных чисел!с~плавающей запятой}%
\index{Представление вещественных чисел!расширенной точности}%
% \epigraph{\begin{stanza}[0ex]
% Походка, стан кошачий,\\
% Драконий хвост наждачный,\\
% А крылья "--- из удачи впридачу.\\
% \end{stanza}}
% {О.\,Арефьева}
\epigraph{\begin{stanza}
Мое сердце из масти,\\ 
Кровь "--- диэтиламид;\\
Не надо смотреть на меня, \\
Потому что иначе ты вымрешь, как вид.\\
\end{stanza}
}{\Aquarium}
\index{Мантисса}\index{Порядок}

% IEEE 754

% http://stackoverflow.com/questions/612507/what-are-the-applications-benefits-of-an-80-bit-extended-precision-data-type
Значения в~сопроцессоре представлены в %80-битном формате 
% (с~двойной расширенной точностью соответственно IEEE 754-1985~\cite{ieeeFloat1985rus}).
% Этот формат исключён из современной версии стандарта IEEE 754~\cite{ieeeFloat2008}, но из-за соображений совместимости формат данных FPU не изменился.
нестандартном 80-битном формате с~плавающей запятой,
называемом форматом с~двойной расширенной (или просто расширенной) точностью, описанном в~разделе~\ref{sec:digits:floatpoint}.

Нормализованное двоичное представление вещественного числа имеет вид~\cite{urov,av-assembler-asm-real-normalization}:
\begin{equation}
\label{eq:float-rus}
(-1)^s \cdot 2^p \cdot \mu, ~~ %0 \leqslant \mu < 1
0,1_2 \leqslant \mu < 1
\end{equation}
где
% $0,1_2 \leqslant \mu < 1$ нормализованное число,
% \\
% $0 \leqslant \mu < 0,1_2$ денормализованное число.
$p$ "--- порядок числа, $\mu$ "--- мантисса, $s$ определяет знак.
Таким образом, все значащие разряды мантиссы находятся в~дробной части.
Старший из них (следующий сразу после запятой) для нормализованного числа всегда равен единице.

Старший бит 80-битного формата "--- знак~$s$,
порядок занимает следующие 15 бит и~представляется кодом с~избытком $2^{14}-2$ %(см. раздел~\ref{sec:digits-negcodes}),
(так называемый смещённый порядок).
% % то есть соответствующее поле содержит натуральный двоичный код числа~$p + 2^{14}$,
% мантисса занимает 64 бита, % и~представляется натуральным кодом
% причём её представление  включает ведущую единицу (рис.~\ref{ris:fpu_digits}),
В~оставшиеся 64 бита записывается дробная часть мантиссы, включая ведущую единицу.

В~частности, единица в~нормализованном представлении имеет вид~$(-1)^0 \cdot 2^1\cdot 0,1_2$.
Тогда значение смещённого порядка (после добавления избытка) будет равно $2^{14}-1$:
$$
\begin{array}{rrrr}
1 = (-1)^0 \cdot 2^1\cdot 0,1_2 &\to &\regfloat[fill=none]{0}{2^{14}-1}{100...} &=\\
% = 0~~0\underbrace{11...11}_{14 \text{единиц}}%\,1111\,1111\,1111
% ~~\underbrace{100...}_{64 \text{бита}}
&=& \regfloat[fill=none]{0}{011...11}{100...} &\\
\end{array}
$$
% После 
Таким образом, %шестнадцатеричное представление вещественного числа 
вещественное число расширенной точности, равное единице, имеет вид
\lstinline$3FFF$\,\lstinline$8000$\,~\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$.
Это подтверждает исследование с~помощью отладчика.

Значение порядка, состоящее из пятнадцати нулей, зарезервировано под специальные значения, таким образом, 
минимально возможное значение порядка корректного вещественного числа имеет вид $00...001$ и~равно~$p_{min} = 1 + \left(-2^{14}+2\right) = -2^{14}+3$.
Соответственно, минимальное положительное  число, представимое в~нормализованном виде в~%80-битном формате FPU, 
формате расширенной точности,
равно 
$X_{min} = 2^{p_{min}} \cdot 0,1_2 = 2^{-2^{14}+2} = $ \lstinline$0001$\,\lstinline$8000...00$.
Числа в~диапазоне $(0, X_{min})$ представляются в~виде $2^{p_{min}} \cdot \mu, ~~ 0 < \mu < 0,1_2$ и~называются \termin{денормализованными}.
В~поле смещённого порядка таких чисел при этом записываются нули.
В~частности, $\frac{X_{min}}{2} = 2^{p_{min}} \cdot 0,01_2 = 2^{p_{min}-1} \cdot 0,1_2$, но представляется это число как \lstinline$0000$\,\lstinline$4000...00$, 
% хотя порядок 
в~чём можно убедиться при помощи отладчика.
Если попытаться прочесть такую запись как корректное число, то получим нулевой знаковый бит, нулевой смещённый порядок, что соответствует порядку $p_{min}-1$, 
и~мантиссу $0,0100..._2$, то есть $(-1)^0 \cdot 2^{p_{min}-1}\cdot 0,01_2 = \frac{X_{min}}{4}$, что неверно.
Денормализованные числа "--- один из видов \termin{специальных значений,} которые нельзя раскодировать по общему правилу.
% Если попытаться 

Представление отрицательных вещественных чисел, в~том числе из диапазона $(-X_{min}, 0)$ ,
отличается от представления их модулей только знаковым битом.


Как было сказано в~разделе~\ref{sec:digits:floatpoint},
в~некоторых источниках нормализованной формой мантиссы считается число, включающее один разряд целой части и~63 бита дробной~\cite{intelBasic}
или целое беззнаковое 64-битное число с~единицей в~старшем разряде~\cite{ieeeFloat1985rus}.\index{Мантисса}\index{Порядок}
% 
Обе этих трактовки приводят к~тому же самому двоичному представлению, что и~описанная выше.

% В~зарубежных источниках то же самое представление вещественных чисел в~FPU интерпретируется иначе~\cite{intelBasic} (хотя суть от этого не меняется).
% % 
% Там считается, что мантисса нормализованного числа включает целую часть (рис.~\ref{ris:fpu_digits-en}).
% \begin{illustration}
% \includegraphics[width=\linewidth]{X86_Extended_Floating_Point_Format_ru}
% \caption{Внутренний 80-битный формат сопроцессора в~зарубежной интерпретации}
% \label{ris:fpu_digits-en}
% \end{illustration}
% % \begin{equation}
% % \label{eq:float-en}
% % (-1)^s \cdot 2^{\tilde{p}} \cdot \widetilde{\mu},~~ 1 \leqslant \widetilde{\mu} < 10_2
% % \end{equation}
% % % тогда нормализованные числа соответствуют мантиссам $1 \leqslant \widetilde{\mu} < 10_2$,
% 
% Соответственно, в~зарубежной трактовке мантисса $\widetilde{\mu}$ числа 
% 
% Такое представление, как указано в~разделе~\ref{sec:digits:floatpoint}, не влияет на 
% двоичное представление
% % мантисса будет 
% % нормализованные числа
% % тогда денормализованные числа соответствуют мантиссам $0 \leqslant \widetilde{\mu} < 1$.

% Формы~\eqref{eq:float-rus} и~\eqref{eq:float-en} взаимно однозначно соответствуют друг другу:
% $$
% \left\{
% \begin{array}{lll}
% \tilde{p} &=& p - 1\\
% \widetilde{\mu} &=& 2\cdot \mu\\
% \end{array}
% \right.
% $$
% Так как двоичная запятая не может быть сохранена в~регистре~$r_i$, а~только \emph{подразумевается} на той или иной позиции,
% двоичное представление мантиссы в~формах~\eqref{eq:float-rus} и~\eqref{eq:float-en} \emph{полностью совпадает.}
% Порядок~$\tilde{p}$ формы~\eqref{eq:float-en}, %в~этом случае 
% соответственно,
% записывается с~избытком $2^{14} -1$, так что полученное значение смещённого порядка в~результате также совпадает с~формой~\eqref{eq:float-rus}.
% Таким образом, двоичное представление одинаковых чисел (как нормализуемых в~формате расширенной точности, так и~денормализованных) одинаково и~не зависит от формы нормализованного представления.

\subsubsection{Виды значений}
\label{sec:valueclasses}
\index{Мантисса}\index{Порядок}

Регистры сопроцессора могут содержать следующие значения:
\begin{itemize}
\item  вещественные числа "--- порядок не равен $0$ и~не состоит из всех единиц, %то есть не равен 0x7FFF
% целая часть мантиссы равна 1; %, корректно представимые
старший бит мантиссы равен~$1$;
\item денормализованные вещественные числа "--- порядок и~%целая часть
старший бит мантиссы равны $0$, но мантисса не равна нулю;
\item нули ($+0,0$ и~$-0,0$, в~соответствии со знаковым битом) "--- порядок и~мантисса равны нулю;
\item бесконечности ($+\infty$ и~$-\infty$, в~соответствии со знаковым битом, обозначаются как \lstinline!+inf! и~\lstinline!-inf!) "--- порядок состоит из всех единиц, 
% целая часть мантиссы "--- единица, дробная часть равна нулю;
старший бит мантиссы "--- единица, остальные равны нулю;
\item нечисла двух типов:
\begin{itemize}
\item сигнальные нечисла (при  появлении такого значения в~стеке генерируется исключение недействительной операции);
\item тихие нечисла (не генерируют исключения, но результат вычислений с~операндом-нечислом "--- тоже нечисло):
\begin{itemize}
\item вещественная неопределённость\index{Неопределённость вещественная} $nan$ (знаковый бит не имеет значения) "--- порядок состоит из всех единиц, 
% целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные нули;
\item другие тихие нечисла "--- порядок состоит из всех единиц, %целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные "--- не все нули;\index{Мантисса}\index{Порядок}

\end{itemize}
\end{itemize}
\item недопустимые значения.
\end{itemize}
Начиная с~80387 некоторые ранее недопустимые значения стали нечислами различного типа, и~наоборот "--- многие недопустимые для современных сопроцессоров значения были корректными нечислами в~ранних дискретных моделях.

Если один из операндов равен произвольному тихому нечислу, он интерпретируется как вещественная неопределённость\index{Неопределённость вещественная}.
Если вещественная неопределённость является результатом операции, она может быть равной только описанному значению $nan$.

% Регистр состояний SW содержит слово состояния FPU.
% Регистр управления CW содержит управляющие биты и~маски.
% 
% Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.
% 
% Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.



\subsection{Возможные форматы экспорта-импорта}
\epigraph{\begin{stanza}
У меня есть что-то, я могу поделиться с тобой.\\
И это алая дверь.
\end{stanza}
}{\Aquarium}

Регистры сопроцессора могут содержать только вещественные числа расширенной точности или специальные значения формата расширенной точности.
Тем не менее, при
выгрузке значений из стека возможно преобразовать их в~различные форматы трёх основных видов "---  с~плавающей запятой, целые двоичные и~целые двоично-десятичные\index{Представление знаковых целых чисел!двоично-десятичное}%
.

Соответственно, при явной загрузке значений из памяти в~стек \modifyone[FPU]{}
или выполнении вычислений с~операндом в~памяти
возможен экспорт значений из этих форматов.

\subsubsection{Форматы с~плавающей запятой}
\index{Представление вещественных чисел!с~плавающей запятой}%

FPU поддерживает импорт и~экспорт в~стандартные форматы с~плавающей запятой одинарной %(32 бита, $float$) 
и~двойной %(64 бита, $double$) 
точности, соответствующие стандарту IEEE 754-2008.
Также возможен импорт-экспорт в~нестандартный 80-битный формат двойной расширенной точности, совпадающий с~внутренним представлением чисел FPU.

Конкретный выбор формата определяется суффиксом команды (раздел~\ref{sec:att-suffixes}).
Суффикс $s$  соответствует одинарной точности (32 бита, $float$), $l$ "--- двойной (64 бита, $double$), $t$ "--- нестандартному формату расширенной точности (80 бит, для GCC \modifyone[этот формат соответствует типу]{"---} $long~double$).

Если суффикс \modifyone[размера]{} не указан, используется одинарная точность ($float$).

\subsubsection{Целые форматы}
\index{Представление знаковых целых чисел}%

Поддерживается  импорт и~экспорт в~двоичные знаковые целые форматы от~двух до восьми байт.
\modifyone[При экспорте значение округляется в~соответствии с~текущими настройками FPU.]{}
Отрицательные числа представлены %, как принято для целых чисел, 
в~дополнительном коде.

Выбор формата определяется суффиксом команды (раздел~\ref{sec:att-suffixes}).
Суффикс $s$  соответствует короткому целому (16 бит, $short$), $l$ "--- длинному (32 бита, $long$ и~чаще всего~$int$), $q$ "--- четверному (64 бита, $long~long$).

Если суффикс \modifyone[размера]{} не указан, \modifyone[число импортируется или экспортируется как короткое (16-битное) знаковое целое, в~большинстве реализаций языка C++ соответствующее типу $short$.]{используется одинарная точность ($float$).}


\subsubsection{Двоично-десятичный формат}
\index{Представление знаковых целых чисел!двоично-десятичное}%

FPU поддерживает экспорт и~импорт только в~один вид двоично-десятичных  чисел "--- это 80-битный  упакованный целый BCD-формат в~виде значения со знаком.

Всего такое число занимает десять байт.
Старший из них "--- знаковый.
Его старший бит хранит знак числа "--- ноль соответствует положительному числу, единица "--- отрицательному.
Младшие семь бит знакового байта не имеют значения.
% 
Остальные девять байтов содержат модуль числа в~виде \modifyone[восемнадцати]{18} упакованных десятичных цифр.

Таким образом, BCD-формат FPU, как и~форматы с~плавающей запятой, включает два нуля: $+0$ и~$-0$.





% \subsection{Набор инструкций x87}
\subsection{Общие команды x87}
\epigraph{\begin{stanza}
Багровый и белый пришли в мои песни.\\
Мы здесь не ради парада.\\
Мы стоим вместе и падаем вместе;\\
И я буду петь тебе, если ты будешь рада.\\
\end{stanza}
}{\Aquarium}
% http://www.studfiles.ru/preview/4034449/

Исторически набор команд FPU включает команды для начальной настройки сопроцессора, а~также для синхронизации с~центральным процессором.
В~настоящее время 
% начальная настройка выполняется операционной системой, 
синхронизация не требуется.
% , так как FPU интегрирован в~

\subsubsection{Сброс сопроцессора}
\index{Команды!finit}%

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Так как ранние модели сопроцессора были отдельными устройствами, 
перед началом работы было необходимо определить, есть ли сопроцессор в~системе, и, в~случае его наличия, инициализировать сопроцессор.
Для инициализации предназначена команда \lstinline!finit! "--- сброс сопроцессора.

Команда \lstinline!finit! восстанавливает значения по умолчанию в~регистрах $cw$, $sw$, $tw$, а~начиная с~80387 "--- $fip$ и~$fdp$. Управляющее слово инициализируется значением \lstinline$0x037F$ (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на $0$, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Слово состояния обнуляется ($top = 0$, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~слове тегов $tw$. Регистры $fip$ и~$fdp$ обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.


\subsubsection{Ожидание синхронизации}
\index{Команды!fwait/wait}%

Оригинальный арифметический сопроцессор, выполненный в~виде отдельной микросхемы, мог работать параллельно с~центральным процессором.
Для их синхронизации использовалась команда \lstinline!wait/fwait!.
Этим мнемоникам соответствует один и~тот же машинный код.
% , который применялся для 
Эта команда приостанавливает работу либо FPU, либо центрального процессора "--- в~зависимости от того, какой из них «вырвался вперёд»
"--- и~ждёт отстающего.
% Выполнение программы 
Кроме того, многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
Мнемоника команды без ожидания отличается префиксом~\lstinline!n! после префикса FPU~\lstinline!f!, например, \lstinline!fnstsw! и~\lstinline!fstsw!.
При этом, согласно документации Intel, машинный код команды без префикса~\lstinline!n! состоит из кода команды \lstinline!wait/fwait! и~кода команды с~префиксом~\lstinline!n!. %, то есть основной
В~частности, команда~\lstinline!fstsw! полностью эквивалентна последовательности \texttt{fwait + fnstsw}.

\index{Команды!nop}%
В~современных  процессорах параллельная работа команд FPU и~основного набора невозможна, так что команда \lstinline!wait/fwait! эквивалентна \lstinline!nop!.
Соответственно, из двух команд "--- с~префиксом~\lstinline!n! и~без "--- в~настоящее время необходимо выбирать вариант с~префиксом.


% \subsection{Загрузка и~выгрузка данных}
% \subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}
\subsection{Загрузка, выгрузка и~пересылка данных}
% \epigraph{\begin{stanza}
% Но будь ты хоть роллс-ройс "--- всё равно стоять в пробке.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}[0mm]
 И падут предо мною преграды стекла,\\
Я смогу без препятствий входить в зеркала!\\
\end{stanza}}{\Orgia}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
Также невозможно загрузить в~стек произвольную константу.

Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти.
В~частности, листинг~\ref{lst:asm:fpu:x+a} показывает вычисление значение выражения $x+a$ и~запись результата в~$y$.
Параметры (как входные \texttt{[X]} и~\texttt{[A]}, так и~выходной~\texttt{[Y]}) расположены в~памяти.
\modifyone[К~константе~$a$ (значению входного параметра \texttt{[A]}) применён модификатор \texttt{volatile}, чтобы компилятор не оптимизировал её и~разместил в~памяти, как и~необходимо.]{}

\begin{lstlisting}[style=lstsmall, caption={Вычисление $y = x+a$ вставкой в~код C++}, label=lst:asm:fpu:x+a]
const volatile double a = 12;
double x = 1, y;
asm(
    "fldl %[X]\n"  // st(0) = %[X]
    "faddl %[A]\n" // st(0) = %[X] + %[A]
    "fstpl %[Y]\n" // %[Y] = %[X] + %[A], стек пуст
    :[Y]"=m"(y)
    :[X]"m"(x), [A]"m"(a)
    :"cc"
);
\end{lstlisting}
\index{Команды!fld}%
\index{Команды!fadd[p]}%
\index{Команды!fst[p]}%

В~списке  перезаписываемых регистров GCC не позволяет описывать элементы стека сопроцессора.
Это %, как правило, 
не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

Если вычисления должны быть не вставкой в~код C++, а~частью программы на ассемблере, все числа, включая константы (кроме, может быть, тех, для загрузки которых есть специальные команды), необходимо разместить в~памяти.
\begin{lstlisting}[style=lstsmall, caption={Вычисление $y = x+a$}, label=lst:asm:fpu:x+a:noinline]
.data
a: .double 12
x: .double 1
y: .double
.text
  fldl x
  faddl a
  fstpl y
\end{lstlisting}
\index{Команды!fld}%
\index{Команды!fadd[p]}%
\index{Команды!fst[p]}%

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).





\subsubsection{Загрузка данных в~стек сопроцессора}
\index{Команды!FPU!загрузки}%

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций \lstinline!f*ld! (таблица~\ref{tab:fpu-fld-list}).
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение $st(0)$.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры
\begin{table}[!ht]
% \caption{Команды загрузки данных в~стек сопроцессора}
% \label{tab:fpu-fld-list}
% \begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-fld-list.tex}

% \endgroup
\index{Команды!fld}%
\index{Команды!fild}%
\index{Команды!fbld}%
\index{Команды!fldz}%
\index{Команды!fld1}%
\index{Команды!fldpi}%
\index{Команды!fldl2t}%
\index{Команды!fldl2e}%
\index{Команды!fldlg2}%
\index{Команды!fldln2}%

\end{table}

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.


\subsubsection{Выгрузка данных из~стека сопроцессора}
\index{Команды!FPU!выгрузки}%
\index{Команды!FPU!пересылки}%


Для выгрузки данных из~стека сопроцессора предназначен набор инструкций \lstinline!f*st[p]! (таблица~\ref{tab:fpu-fst-list}).

\begin{table}[!ht]

\begingroup
\small
% \def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-fst-list.tex}

\endgroup

\index{Команды!fst[p]}%
\index{Команды!fist[p]}%
\index{Команды!fbst[p]}%

\end{table}



Ниже показан пример использования команд загрузки и~выгрузки (листинг~\ref{lst:asm:fpu:ldst}).

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Последовательная загрузка и~выгрузка данных}, label=lst:asm:fpu:ldst]
double x = 5.7, y;
float f;
long double l;
int i = 10;

asm(                //          st(0),st(1),st(2),st(3)
    "fldl %[x]\n"   // в стеке: [x]
    "fldz\n"        // в стеке: 0,    [x]
    "fld1\n"        // в стеке: 1,    0,    [x]
    "fildl %[i]\n"  // в стеке: [i],  1,    0,    [x]
    "fstps %[f]\n"  // в стеке: 1,    0,    [x]       [f] = [i] 
    "fstpt %[l]\n"  // в стеке: 0,    [x]             [l] = 1   
    "fstpl %[y]\n"  // в стеке: [x]                   [y] = 0   
    "fistpl %[i]\n" // стек пуст                      [i] = [x]

    :[y]"=m"(y), [i]"+m"(i), [f]"=m"(f), [l]"=m"(l)
    :[x]"m"(x)
    :"cc"
)

#define PRINT(val) cout << #val << " = " << val << "  ";

PRINT(x)
PRINT(y)
PRINT(i)
PRINT(f)
PRINT(l)
\end{lstlisting}
Вначале в~стек сопроцессора последовательно загружаются четыре значения:
вещественная переменная двойной точности $x = 5,7$, константы "--- ноль и~единица, а~также целое 32-битное число $i = 10$.
% При загрузке данных из памяти размер источника определяется суффиксом. 
% Команда $fldl$ загружает из памяти длинное вещественное значение (64-битное, $double$),
% $fildl$ "--- длинное целое (32-битное, $int$).

После загрузки всех четырёх значений в~стеке сопроцессора находятся следующие значения:
$$
\begin{array}{l}
st(0) =10= i \\
st(1) = 1 \\
st(2) = 0 \\
st(3)= 5,7 = x \\
\end{array}
$$
Все они внутри стека хранятся в~80-битном вещественном формате.

Затем верхнее значение $st(0)$, равное последнему загруженному значению~$i = 10$, выталкивается из стека и~записывается по адресу параметра $[f]$, преобразованное в~вещественное число одинарной точности.
% (суффикс $s$ для вещественных команд обозначает короткое вещественное число, то есть 32-битное $float$).
Новое значение вершины стека $st(0)$ после выталкивания %значения $10$
"--- единица. Соответственно, изменятся и~обозначения более глубоких элементов стека: $st(1) = 0$ и~$st(2) = x$.

Затем новое значение вершины стека, равное единице, выталкивается в~параметр~$[l]$ как 80-битное число (суффикс $t$ "--- $ten~bytes$, что для компиляторов GCC соответствует типу $long~double$).
Ноль выталкивается из стека и~записывается в~$[y]$ как число двойной точности.
Последний оператор выталкивает значение~$x$ в~параметр~$[i]$ как длинное целое ($int$), после чего стек остаётся пустым.
Значение $5,7$ округляется в~соответствии с~текущими настройками округления, в~данном случае "--- к~ближайшему, то есть получим $[i]=6$.

Соответственно, результат отладочной печати в~конце листинга выглядит следующим образом:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, numbers=none]
x = 5.7  y = 0  i = 6  f = 10  l = 1 
\end{lstlisting}

Используя команды выгрузки или загрузки из памяти, необходимо внимательно следить за суффиксами команд.
% , так как только по суффиксу определяется размер "--- единственная
В~вышеописанном примере команда \lstinline!fstp %[y]! не вызвала бы ошибки ни во время компиляции, ни во время выполнения, но переменная $y$ получила бы весьма странное значение.
По умолчанию (без указания суффикса) \lstinline$fstp$ записывает снятое с~вершины стека значение как вещественное число одинарной точности, то есть из 64 бит переменной $y$ будут перезаписаны только первые 32, причём в~формате, не соответствующем типу $double$.

\subsubsection{Пересылка данных внутри стека сопроцессора}
\label{sec:fcmovCC}
\index{Флаги!проверка}%
\index{Команды!условной пересылки}%
% \index{Команды!FPU!пересылки}%

Для пересылки данных внутри стека сопроцессора можно использовать команды \lstinline!fld st(i)! для загрузки копии значения $st(i)$ в~вершину стека
и~\lstinline!fst st(i)! для помещения значения $st(0)$ в~ранее пустую ячейку~$st(i)$.
Кроме того, существует две специализированные команды (таблица~\ref{tab:fpu-mov-list}).

\begin{table}[!ht]
\caption{Команды пересылки данных~FPU}
\label{tab:fpu-mov-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
fcmovCC \%st(i), \%st(0) & Присваивание   $st(0) = st(i)$, если верно  $CC$
 (\texttt{e, ne, b/nae, be/na, ae/nb, a/nbe,} \texttt{u} и~\texttt{nu})
\\\hline
fxch & Меняет местами  $st(0)$ и~$st(1)$
\\
fxch \%st(i)
& Меняет местами  $st(0)$ и~$st(i)$
\\\hline
\end{tabularx}

\index{Команды!fcmovCC}%
\index{Команды!fxch}%

\end{table}


Команда условного копирования~\lstinline!fcmovCC! использует как условие флаги регистра~$flags$,
а~не регистра состояния~$sw$.
При этом для неё доступны 
не все  условия~$CC$, перечисленные в~таблице~\ref{tab:cc-list},
и~даже не все синонимы доступных условий.
Используемые условия перечислены в~таблице~\ref{tab:fpu-cc-list}.
% Таблица~\ref{tab:fpu-cc-list} содержит доступные для условного копирования условия.

\begin{table}[!ht]
\small\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/fpu-cc-list.tex}
\end{table}

% После сравнения вещественных чисел 
% После сравнения флаги состояния сопроцессора копируются в~$flags$ (вручную или автоматически "--- в~зависимости от используемой команды сравнения) таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел:
% $ZF$ указывает на равенство, $CF$ "--- на $dest<src$; кроме того, в~$PF$ копируется флаг несравнимости операндов. 

Условия~\lstinline!fcmovCC! включают те биты регистра флагов~$flags$, которые могут быть прямо или косвенно (путём сохранения слова состояния~$sw$ и~загрузки его части в~$flags$) установлены командами сравнения FPU, то есть флаги $ZF, CF, PF$.

Команда обмена регистров \lstinline!fxch! на самом деле не копирует данные, а~переименовывает регистры, так что её выполнение практически не занимает времени.
Так как большинство команд работает с~вершиной стека, переименование регистров  с~помощью~\lstinline!fxch! часто бывает удобным.


\subsubsection{Загрузка и~выгрузка управляющих регистров}

Содержимое управляющих регистров также может быть сохранено в~памяти (таблица~\ref{tab:fpu:ld-st-spec}).

\begin{table}[!ht]
\caption{Команды загрузки и~выгрузки управляющих регистров~FPU}
\label{tab:fpu:ld-st-spec}

\small
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|}
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
fnstcw dmem16	&	Выгрузка управляющего слова~$cw$ в~память  \\\hline
fldcw smem16	&	Загрузка управляющего слова~$cw$ из памяти  \\\hline
fnstsw dest16	&	Выгрузка (разрушающая) слова состояния~$sw$ в~память или регистр~$ax$ \\\hline
\end{tabularx}
\index{Команды!fnstcw}%
\index{Команды!fldcw}%
\index{Команды!fnstsw}%
\end{table}

Управляющее слово можно как выгрузить в~память по заданному адресу, так и~загрузить из неё.

Слово состояния сопроцессора  можно только сохранить в~память,  а~также в~регистр~$ax$ (и~только в~этот регистр).

\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
После выгрузки слова состояния~$sw$ командой~\lstinline$fnstsw$ теряется значение специальных флагов~$C0{-}C3$.

% Приёмник 
% Сохранение состояния сопроцессора с~последующей загрузкой его в~регистр~$flags$ может применяться при сравнении вещественных чисел.
% 
% \subsection{Арифметические и~трансцендентные команды}
% \epigraph{\begin{stanza}
% Ещё раз напьюсь\\
% Этой бесконечной воды...\\
% И двинусь дальше\\
% Вслед за пламенем Зелёной Звезды.\\
% \end{stanza}
% }{\Aquarium}
% 
% Основное назначение FPU "--- производить вычисления; соответственно, данный раздел наиболее объёмен.
% 
% Сопроцессор поддерживает шесть форм для команд, выполняющих четыре действия арифметики над различными типами операндов.
% При этом  реализация несимметричных операций (вычитания и~деления) качественно отличается от ассемблеров с~синтаксисом Intel.
% 
% Также существует множество команд, выполняющих более сложные действия.
% Их формы не так разнообразны, а~неявным операндом является вершина стека~$st(0)$ и,~при необходимости, $st(1)$.

\subsection{Основные арифметические команды}
\index{Команды!FPU!арифметические}%
\epigraph{\begin{stanza}[0ex]
 Объясните  мне,  где  теперь  правда,  где  ложь, \\
 где  жало  змеи, где пылающий   уголь,  где  тюрьма.
\end{stanza}}
{\Aquarium}

\index{Команды!fadd[p]}%
\index{Команды!fmul[p]}%
\index{Команды!fsub[p]}%
\index{Команды!fsubr[p]}%
\index{Команды!fdiv[p]}%
\index{Команды!fdivr[p]}%
\index{Команды!fiadd[p]}%
\index{Команды!fimul[p]}%
\index{Команды!fisub[p]}%
\index{Команды!fisubr[p]}%
\index{Команды!fidiv[p]}%
\index{Команды!fidivr[p]}%

Основные арифметические команды сопроцессора выполняют базовые бинарные арифметические операции "--- сложение, вычитание, умножение и~деление.
Хотя бы один операнд должен быть %в~стеке сопроцессора.
в~вершине стека сопроцессора~$st(0)$.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.
Приёмник должен быть в~стеке сопроцессора, но не обязательно на его вершине. %, таким образом, .


Каждая из основных арифметических команд может быть записана в~нескольких формах. %, подробнее описанных в~следующем подразделе.
Они различаются  положением источника и~приёмника, также некоторые из форм после вычисления результата выталкивают источник из стека сопроцессора, что обозначается суффиксом~\lstinline!p!.

\subsubsection{Обозначения основных арифметических команд}

Четырём арифметическим операциям в~FPU соответствует шесть различных %команд
операций. %и~может быть
При этом каждой из симметричных относительно перестановки операндов арифметических операций
"--- сложению и~вычитанию "--- соответствует по одной операции FPU: сложение \lstinline!fadd! и~умножение \lstinline!fmul!.
Несимметричным операциям "--- вычитанию и~делению "--- соответствует по две операции FPU, отличающиеся порядком операндов.
Это соответственно прямое вычитание \lstinline!fsub! и~обратное вычитание~\lstinline!fsubr!, а~также прямое деление \lstinline!fdiv! и~обратное деление~\lstinline!fdivr! (таблица \ref{tab:fpu-ar-list}).



\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arcommon-mnemlist.tex}

*
%Один из операндов всегда находится на вершине стека~$st(0)$.
% Обозначим другой операнд как~$x$.
$\xi$ "--- операнд, не лежащий на~вершине стека.

Может быть как источником, так и~приёмником, в~зависимости от используемой формы.

\index{Команды!fadd[p]}%
\index{Команды!fmul[p]}%
\index{Команды!fsub[p]}%
\index{Команды!fsubr[p]}%
\index{Команды!fdiv[p]}%
\index{Команды!fdivr[p]}%
\index{Команды!fiadd[p]}%
\index{Команды!fimul[p]}%
\index{Команды!fisub[p]}%
\index{Команды!fisubr[p]}%
\index{Команды!fidiv[p]}%
\index{Команды!fidivr[p]}%
\end{table}

Все формы основных арифметических команд используют два явно или неявно заданных операнда.
Один из них всегда в~вершине стека~$st(0)$, другой (обозначим его~$\xi$) может быть в~памяти или в~регистре~$st(i)$.
Кроме того, один из этих операндов является приёмником~$dest$, второй "--- источником~$src$.

% 
% Мнемоника команды состоит из префикса FPU \lstinline!f!, опционального 

\warning{\index{Синтаксис!AT\&T}%
Внимание!

Ассемблер Unix исторически использовал для основных арифметических команд FPU те же мнемонические обозначения, что и~предложенные Intel, но другую семантику операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
% в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel %и~большинстве учебников.
и~учебниках, описывающих синтаксис Intel.
}

% \subsubsection{Различие арифметических команд Intel и~\Att}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
% всегда
% , в~том числе
% в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
\label{sec:fpu-trouble-with-fsub}
% в~таком случае 
% для двух регистров
вычисляет $st(0) - \xi$ 
% независимо от того, какой из этих регистров является приёмником
даже в~том случае, если приёмником является $\xi$.
% (это возможно, если~$xi$ "--- регистр~$st(i)$).
В~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры. 
Обратное вычитание~\lstinline!fsubr! вычисляет $\xi - st(0)$.



% Соответственно, шесть форм команды прямого вычитания \lstinline$fsub$ и~обратного вычитания \lstinline$fsubr$ в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-fsub-r-typelist}.
% 
% \begin{table}[!ht]
% \caption{Прямое и~обратное вычитание в~синтаксисе \Att}
% \label{tab:fpu-fsub-r-typelist}
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-fsub-r-typelist.tex}
% 
% \end{table}


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!~\cite{trouble-with-fsub}.
Анализ сгенерированного компилятором из коллекции GCC кода это подтверждает.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.
% 
% Приёмником, в~соответствии с~синтаксисом \Att, является второй аргумент.
% Если команда вызывается с~одним аргументом или без них, то приёмником является $st(0)$, что соответствует документации Intel.
% Таким образом,
% % Соответственно, 
% шесть форм несимметричных операций (вычитания и~деления) в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-att-r-typelist}.
% 
% \begin{table}[!ht]
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-att-r-typelist.tex}
% 
% \end{table}
% 
Такое поведение в~случае сочетания синтаксиса AT\&T и~платформы x86 в~некоторых источниках описывается как баг GCC~\cite{sourceware-i386_002dBugs}, но из соображений совместимости с~имеющимся кодом меняться не будет.
% Из-за него, кроме всего прочего, в~GCC для всех основных арифметических команд доступна <<нелегальная>> седьмая форма записи, например, \lstinline!fsubp %st(i), %st(0)!.
% Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)! (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
% Подобную некорректную форму лучше не использовать.

% Также большинство ассемблеров поддерживает формы \lstinline!fXXX %st(i)! и~\lstinline!fXXXp %st(i)!


Поведение Intel и~GAS совпадает в~тех случаях, когда приёмником является~$st(0)$, в~том числе в~ситуациях, когда источник находится в~памяти.
% 
Также поведение Intel и~GAS полностью совпадает для симметричных операций "--- сложения и~умножения.


\subsubsection{Формы основных арифметических команд}

Согласно документации Intel, сопроцессор использует шесть  форм~\cite{frolov} основных арифметических команд (таблица~\ref{tab:fpu-arcommon-typelist}).
% На самом деле 
Строка XXX соответствует выполняемой операции %и~может быть
(\lstinline!add!, \lstinline!sub!, \lstinline!subr!, \lstinline!mul!, \lstinline!div!, \lstinline!divr!).


\begin{table}[!htpb]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arcommon-typelist.tex}

\end{table}
% \FloatBarrier

Если посмотреть на опкоды этих форм~\cite{intelInstructionSet}, видно, что опкод формы без параметров \lstinline!fXXXp!
полностью совпадает с~опкодом формы с~двумя параметрами~\lstinline!fXXXp %st(0), %st(1)!.
% то есть практически форм пять.
Напротив, формы \lstinline!f[i]add smem! для различной разрядности источника~$smem$ имеют по два различных опкода.

% \newcommand{\faddform}[1]{\hspace*{0pt}\rlap{{#1}}\phantom{\texttt{faddp \%st(0), \%st(i)}}}


% Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
% Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
В~частности, для операции сложения \lstinline!fadd! возможны следующие формы:
\begin{alphenumerate}[wide=\parindent]
\item \lstinline!faddp!
выполняет сложение $st(1) = st(0) + st(1)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(0)$	
(эквивалент \lstinline!faddp %st(0), %st(1)!);
\item \lstinline!fadd  smem!	"--- $st(0) = st(0) + \text{вещественное}~smem$;
\item \lstinline!fiadd smem!	"--- $st(0) = st(0) + \text{целое}~smem$;
\item \lstinline!fadd  %st(i), %st(0)!	"--- $st(0) = st(0) + st(i)$;
\item \lstinline!fadd  %st(0), %st(i)! "--- $st(i) = st(0) + st(i)$;
\item \lstinline!faddp %st(0), %st(i)!\ "---\ $st(i) = st(0) + st(i)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{alphenumerate}


Большинство ассемблеров, в~частности, GAS, поддерживает
и~некоторые дополнительные формы основных арифметических команд,
оба операнда которых находятся в~стеке.
В~частности,
для формы без операндов \lstinline!fXXXp! практически во всех ассемблерах принят синоним~\lstinline!fXXX!.
% Форма \lstinline!fXXX! без аргумента допустима (эквивалентна \lstinline!fXXXp!), но,~
Но,  так как мнемоника без суффикса~\lstinline!p! не~отражает выполняемое выталкивание $st(0)$  из~стека, её использование не~рекомендуется.

Кроме того, по аналогии с~\lstinline!fXXX smem! поддерживается
% для всех основных арифметических команд  форму 
форма \lstinline!fXXX %st(i)!
с~приёмником в~$st(0)$, а~также \lstinline!fXXXp %st(i)! с~приёмником изначально в~$st(i)$, а~после выталкивания $st(0)$ "--- в~$st(i-1)$.

% Из-за него, кроме всего прочего, 
В~GAS, кроме всего прочего, доступна 
<<нелегальная>> %седьмая 
форма записи~\lstinline!fXXXp %st(i), %st(0)!, например, \lstinline!fsubp %st(i), %st(0)!.
Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)!.
% (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), 
% то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
% Подобную некорректную форму лучше не использовать.

Подобные формы лучше не использовать из-за неочевидности расположения операндов.
При этом неуказание части операндов в~программе не даёт преимущества в~исполняемом файле, так как любая форма
% арифметической команды с~операндами в~регистрах FPU 
из перечисленных дополнительных форм арифметических команд
будет ассемблироваться в~тот же опкод, что и~форма с~двумя явно указанными операндами.

\subsubsection{Практическое использование основных арифметических команд}

Ниже показано использование основных арифметических команд для расчёта значения выражения $x + \frac{1}{i} + a \cdot \pi$.
% 
Так как используется GAS, команда \lstinline!fdivr! без операндов рассчитывает %прямое деление 
$st(1)/st(0)$, после чего источник $st(0)$ выталкивается из стека FPU.

В~листинге~\ref{lst:asm:fpu:add-mul-foo} приведена функция \lstinline$double foo(double x, int i, double a)$, соответствующая соглашению о~вызове cdecl (см.~раздел~\ref{sec:calling-conventions}).
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = x + \frac{1}{i} + a \cdot \pi$ как функция}, label=lst:asm:fpu:add-mul-foo]
.globl foo
foo:                   //          st(0),    st(1),   st(2),   st(3)
  fldl 4(%esp)         // в стеке: x                           
  fldpi                // в стеке: pi,       x                 
  fld1                 // в стеке: 1,        pi,      x        
  fildl 12(%esp)       // в стеке: i,        1,       pi,      x
  fdivr                // в стеке: 1/i,      pi,      x        
  fldl  16(%esp)       // в стеке: a,        1/i,     pi,      x
  fmulp %st(0), %st(2) // в стеке: 1/i,      pi*a,    x        
  faddp                // в стеке: 1/i+pi*a, x                 
  faddp                // в стеке: 1/i+pi*a+x (результат)
\end{lstlisting}
Операнды, в~соответствии с~тридцатидвухбитным соглашением cdecl, передаются в~стеке %основного процессора
в~памяти
(первый параметр $x$ находится по адресу $sp+4$ и~занимает восемь байт, так что следующий параметр, $i$, располагается по адресу $\&x+8 = sp + 4 + 8 = sp+12$ и~$a$ "--- по адресу $sp+16$), поэтому их можно загрузить командами \lstinline!f*ld! в~стек регистров FPU.
Возвращаемое вещественное значение, согласно тому же соглашению, передаётся в~$st(0)$, поэтому оно не выталкивается после вычислений.

Далее показан 
тот же код расчёта значения выражения $x + \frac{1}{i} + a \cdot \pi$, 
оформленный как вставка в~программу на C++,
где $x$, $i$ и~$a$ "--- значения переменных (листинг~\ref{lst:asm:fpu:add-mul}).

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = x + \frac{1}{i} + a \cdot \pi$ как вставка}, label=lst:asm:fpu:add-mul]
const volatile double a = 0.01;
double x = 5, y;
int i = 10;
asm(                           //          st(0),    st(1), st(2), st(3)
    "fldl %[x]\n"              // в стеке: x
    "fldpi\n"                  // в стеке: pi,       x
    "fld1\n"                   // в стеке: 1,        pi,    x
    "fildl %[i]\n"             // в стеке: i,        1,     pi,    x
    "fdivr\n"                  // в стеке: 1/i,      pi,    x
    "fldl  %[A]\n"             // в стеке: A,        1/i,   pi,    x
    "fmulp %%st(0), %%st(2)\n" // в стеке: 1/i,      pi*A,  x
    "faddp\n"                  // в стеке: 1/i+pi*A, x
    "faddp\n"                  // в стеке: 1/i+pi*A+x
    "fstpl %[y]\n"             // y = 1/i + pi*A + x, стек пуст

    :[y]"=m"(y)
    :[x]"m"(x), [A]"m"(a), [i]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}
Приведённый код "--- не единственный способ расчёта значения указанного выражения.
% Как порядок вычислений, так и~используемые команды могут различаться.
В~зависимости от того, в~каком порядке программист будет рассчитывать компоненты выражения, может различаться как порядок команд, так и~сами команды (в~частности, возможно использование прямого деления \lstinline!fdiv!, а~не обратного \lstinline!fdivr!).


\subsection{Дополнительные арифметические и~трансцендентные команды}
\epigraphcensored[\epigraph{\begin{stanza}
Тарелки не влетали в окно,\\и все мои слова оставались со мной.\\
\end{stanza}
}{\Aquarium}]{\epigraph{\begin{stanza}[0ex]
Кто бы ты ни был, куда б ты ни шёл,\\
Ты неподвижен "--- ты ось круговерти.\\
\end{stanza}}
{О.\,Арефьева}}

% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX} 


Дополнительные арифметические и~трансцендентные команды~\cite{zubkov, intelInstructionSet} работают с~вершиной стека $st(0)$ и,~при необходимости, с~$st(1)$. Для них не указывают явных операндов. % и~соответствующих пяти форм.
Соответственно, каждая из команд этой группы имеет только одну форму.


Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице \ref{tab:fpu-arex-list}.
\index{Команды!FPU!трансцендентные}%
\index{Команды!FPU!дополнительные}%

\begin{table}[p]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arex-list.tex}

\index{Команды!fabs}%
\index{Команды!fsqrt}%
\index{Команды!fptan}%
\index{Команды!fpatan}%
\index{Команды!fsincos}%
\index{Команды!fsin}%
\index{Команды!fcos}%
\index{Команды!fscale}%
\index{Команды!f2xmi}%
\index{Команды!fyl2x}%
\index{Команды!fyl2xp1}%
\index{Команды!fprem1}%

\end{table}


Использование этих команд не перезаписывает значения, лежащие в~стеке ниже неявных аргументов. 
Если у~команды только один аргумент в~$st(0)$ и~один результат, результат записывается в~$st(0)$ на место аргумента.
Если у~команды один аргумент в~$st(0)$ и~два результата (\lstinline$fptan$, \lstinline$fsincos$ и т.\,д.), то один из результатов помещается в~$st(0)$, второй затем помещается в~стек сверху (так что первый результат оказывается в~$st(1)$, второй "--- в~$st(0)$).
% В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом (или наоборот "--- с~одним аргументом $st(0)$ и~двумя результатами)
% изменятся номера нижележащих значений, но ни одно значение, кроме аргументов, не исчезнет и~не появится ни одной «дырки».
% Если результатом выполнения команды являются два числа, а~аргументом "--- $st(0)$, одно из %них 
% полученных значений заменяет аргумент в~$st(0)$, другое помещается сверху, так что 

В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом
чаще всего результат помещается в~$st(1)$, затем $st(0)$ выталкивается из стека, так что после этой операции результат оказывается в~$st(0)$. 
Таким образом, результат замещает собой аргументы (в~таблице~\ref{tab:fpu-arex-list} такая ситуация соответствует обозначению $\big[st(1)\to st(0)\big]$ для результата).

Иногда (в~частности, \lstinline$fscale$) команда с~двумя аргументами в~$st(0)$ и~$st(1)$ записывает результат в~$st(0)$, оставляя аргумент в~$st(1)$ в~стеке.

Результат трансцендентных и~тригонометрических команд (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда помечается как неточный (исключительная ситуация {\#Р}).
\index{Команды!FPU!трансцендентные}%
\index{Команды!fptan}%
\index{Команды!fsincos}%
\index{Команды!fsin}%
\index{Команды!fcos}%
\index{Команды!f2xmi}%
\index{Команды!fyl2x}%
\index{Команды!fyl2xp1}%
\index{Команды!fpatan}%


Пример использования тригонометрических команд для расчёта значения выражения $a\cdot\cos(x) + \sin(x)$ показан в~листинге~\ref{lst:asm:fpu:sinsos}.

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = a\cdot\cos(x) + \sin(x)$}, label=lst:asm:fpu:sinsos]
const volatile double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[X]\n"   // st(0) = %[X]
    "fsincos\n"     // st(0) = cos(%[X]),       st(1) = sin(%[X])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[X]),  st(1) = sin(%[X])
    "faddp\n"        // st(0) = %[A]*cos(%[X]) + sin(%[X])
    "fstpl %[Y]\n"  // %[Y] = %[A]*cos(%[X]) + sin(%[X]), стек пуст

    :[Y]"=m"(y)
    :[X]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
Если операнд выходит за эти пределы, флаг $C2$ устанавливается \modifyone[в~единицу]{в 1}, значение $st(0)$ и~стек не изменяются. 


\begin{modifyonelong}
Частичный арктангенс \lstinline!fpatan! отличается от математического определения арктангенса тем, что принимает два аргумента, соответствующие координатам некоторой точки
$\footnotesize
\left\{
\begin{array}{@{\,}l}
st(0) = x\\
st(1) = y
\end{array}
\right.
$ 
и~возвращает результат в~диапазоне $[-\pi, \pi]$, равный азимуту заданной точки $(x, y)$. 
Соответственно, знаки аргументов определяют квадрант результата.
% (знак результата равен знаку $st(1)$).

Чтобы получить результат в~диапазоне $(-\frac{\pi}{2}, \frac{\pi}{2})$, то есть в~соответствии с~математическим определением $arctg(x)$,
необходимо задать точку в~первом или четвёртом квадрантах, то есть с~положительной абсциссой "--- $\footnotesize
\left\{
\begin{array}{@{\,}l}
st(0) = 1\\
st(1) = x
\end{array}
\right.
$.

Остальные обратные тригонометрические функции  можно получить с~помощью команды \lstinline!fpatan! 
% и~прямых тригонометрических функций 
и~арифметических команд,
используя основное тригонометрическое тождество и~задавая координаты соответствующих точек.
% задавая точки в~необходимых квадрантах.
\index{Команды!fpatan}%
\end{modifyonelong}


\subsection{Сравнение вещественных чисел}
\label{sec:fpu-cmp}
\epigraph{\begin{stanza}[0mm]
Я крушу зеркала, чтоб не видеть, как смотрит двойник; \\
Зеркала, разбиваясь, сочатся багровым и алым.\\
\end{stanza}}{\Orgia}

FPU включает несколько семейств команд сравнения вещественных чисел.
Все они сравнивают приёмник $st(0)$ с~некоторым источником $src$. 
По аналогии с~командой целочисленного сравнения можно сказать, что анализируется знак разности~$st(0)-src$.
Так как приёмником является~$st(0)$, поведение команд сравнения не различается для GAS и~Intel.

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
Некоторые из них помещают результат в~слове состояния~$sw$, откуда его надо вручную копировать в~регистр флагов~$flags$ (при этом осмысленное значение приобретают $ZF, CF, PF$)\modifyone[. Они поддерживаются, но считаются устаревшими.
Более современные команды сравнения помещают результат]{,
некоторые "---} непосредственно во флагах $ZF, CF, PF$ регистра~$flags$.

Также система команд FPU включает~\lstinline!fxam!, которая определяет вид значения в~$st(0)$ в~соответствии с~разделом~\ref{sec:valueclasses}.
\index{Команды!fxam}%

Знак нуля при сравнении не учитывается, то есть считается, что 	$-0=+0$.


\subsubsection{Команды сравнения}
% \footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается

% \index{Команды!сравнения!вещественных чисел}%
\index{Команды!FPU!сравнения}%

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

% В~таблице~\ref{tab:fpu-cmp-list} приводится сводная информация по семействам команд сравнения FPU.
Все команды сравнения вещественных чисел~\cite{club155} сравнивают вершину стека "--- приёмник $st(0)$ с~другим операндом  "--- источником $src$
% , который может 
(таблица~\ref{tab:fpu-cmp-list}).

\begin{table}[ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-list.tex}
\index{Команды!fcom[p[p]]}%
\index{Команды!fucom[p[p]]}%
\index{Команды!ficom[p]}%
\index{Команды!ftst}%
\index{Команды!fcomi[p]}%
\index{Команды!fucomi[p]}%

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\end{table}

По результатам сравнения  (в~соответствии со знаком разности~$st(0)-src$) устанавливается значение трёх флагов:
% флаг отрицательности, флаг нуля и~флаг несравнимости 
% в~соответствии с~таблицей~\ref{tab:fpu-cmp-flags}.
отрицательности, нуля и~несравнимости (таблица~\ref{tab:fpu-cmp-flags}).
Операнды считаются несравнимыми, если хотя бы один из них "--- тихое нечисло 
% (обычно 
(любые тихие нечисла как операнды команд обрабатываются, как
вещественная неопределённость~$nan$\index{Неопределённость вещественная},
поэтому обычно говорят, что операнды несравнимы, если хотя бы один из них равен $nan$).

\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}

\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\end{table}

Действие команд сравнения одинаково для синтаксиса AT\&T и~синтаксиса Intel.
% 
Мнемоника может включать суффикс~\lstinline!p!, в~этом случае приёмник~$st(0)$ после сравнения выталкивается из стека.
Если явный операнд не задан (то есть источником считается~$st(1)$), может также использоваться суффикс \lstinline!pp! "--- в~этом случае после сравнения из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$.
% 
Если источник задан явно и~находится в~памяти, необходимо указывать также суффикс размера по тем же правилам, что и~для арифметических команд.

Если хотя бы одно из сравниваемых значений "--- нечисло,
для б\'{о}льшей части команд сравнения (без префикса~\lstinline!u!) это недействительная арифметическая операция \#IA.
Если соответствующее исключение не замаскировано (раздел~\ref{sec:fpu:cw-mask}), работа программы прерывается,
% так что флаг несравнимости не устанавливается.
если замаскировано "--- устанавливается флаг несравнимости.
% 
\index{Команды!fucom[p[p]]}%
\index{Команды!fucomi[p]}%
Команды неупорядоченного сравнения, мнемоники которых включают префикс~\lstinline!u!,
% после префикса FPU~\lstinline!f!,
% не генерируют исключений при сравнении тихих нечисел,  в~частности, вещественной неопределённости, так что флаг несравнимости для~$nan$ устанавливается при любом наборе масок в~управляющем слове~$cw$.
считают операцию сравнения с~тихим нечислом,  в~частности, вещественной неопределённостью\index{Неопределённость вещественная}, действительной, и~устанавливают в~этом случае флаг несравнимости.
% вне зависимости от маски~$IM$.
% 
Если хотя бы одно из сравниваемых значений "--- неподдерживаемое значение или сигнальное нечисло, операция сравнения недействительна (\#IA) для всех команд.

По набору используемых флагов команды сравнения делятся на две группы "--- часть их выставляет биты слова состояния~$sw$ ($C3, C0$ и~$C2$),
часть "--- биты регистра~$flags$ ($CF, ZF$ и~$PF$).
\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

В~слове состояния сопроцессора~$sw$ результат сохраняют
команды сравнения оригинального FPU 8087 и~80387.
% (\texttt{fcom, fcomp, fcompp, ftst}) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (\texttt{fucom, fucomp, fucompp}).
% % , не генерирующее исключений при сравнении некоторых нечисел, 
% сохраняют результат сравнения в~биты $C3, C0$ и,~в~случае несравнимости операндов, в~бит~$C2$ слова состояния.
% % \pagebreak[3]
% Для анализа результата сравнения
% в~этом случае
% % вещественных чисел в~ранних (отдельных) моделях сопроцессора было 
% необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  
% \pagebreak[3]
% После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.
%  
В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.
% 
\index{Команды!fcomi[p]}%
\index{Команды!fucomi[p]}%
Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (\texttt{fcomi, fcomip, fucomi, fucomip}), которые напрямую устанавливают флаги $ZF, CF, PF$ в~$flags$.
% Эти команды не изменяют биты $C0,  C3, C2$ регистра~$sw$.
% и~не дублируют туда результат сравнения.
Неиспользуемые три флага состояния $flags$ сбрасываются в~$0$; биты $C0, C2,  C3$ слова состояния сопроцессора не изменяются.
\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% \subsubsection{Флаги сравнения}
% % \subsubsection{Сравнение вещественных чисел}
% \index{Флаги!установка}%
% 
% Команды сравнения выставляют значения трёх флагов в~соответствии с~результатом сравнения $st(0)$ и~$src$ (знаком разности~$st(0)-src$):
% флаг отрицательности, флаг нуля и~флаг несравнимости (таблица~\ref{tab:fpu-cmp-flags}).
% 
% 
% \begin{table}[!ht]
% \small\def\normalsize{\small}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% \LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}
% \end{table}


Если при сравнении целых чисел \modifyone[в~регистре~$flags$]{} выставляется значение %флагов из того же набора,
тех же флагов, которые выставляются по результатам арифметических действий,
то в~FPU %флаги сравнения и~флаги, выставляемые при вычислениях, разделены.
% Арифметические и~трансцендентные команды влияют на флаги исключительных ситуаций;
% команды сравнения "--- на специальную группу флагов.
флаги, выставляемые \modifyone[устаревшими]{} командами сравнения\modifyone[~в~слове состояния~$sw$]{}, отличаются от тех, что устанавливаются, в~частности, при вычитании.

\subsubsection{Анализ результатов сравнения}

Условные команды, даже из набора FPU, не могут анализировать флаги слова состояния FPU~$sw$.
Соответственно, если используется одна из \modifyone[устаревших]{старых} команд сравнения, сохраняющая результат в~$cw$, после её выполнения
% Для анализа результата сравнения
% в~этом случае
% % вещественных чисел в~ранних (отдельных) моделях сопроцессора было 
необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  


Это выполняется в~два этапа:
\begin{itemize}
\item 
% \index{Команды!fstsw}%
\index{Команды!fnstsw}%
\index{Команды!sahf}%
слово состояния $sw$ выгружается в~регистр $ax$ 
% командами \lstinline!fstsw! (проверяет на наличие отложенных необработанных исключений) или~\lstinline!fnstsw! (также данные команды могут выгрузить $sw$  в~память);
командой~\lstinline!fnstsw!;
\item старший байт $ax$ загружается в~младший байт регистра флагов $flags$ командой \lstinline!sahf!.
\end{itemize}

% \subsubsection{Соответствие битов слова состояния FPU и~$flags$}

% 
% 
% В~таблице~\ref{tab:fpu-status} представлено краткое описание структуры слова состояния, а~также соответствие старшего байта слова состояния сопроцессора $sw$ и~младшего байта регистра флагов основного процессора~$flags$.
% 
% % \colorlet{csControl}{green!50}
% % \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% % \colorlet{csSystem}{blue!20!red!10}
% 
% 
% \begin{table}[!ht]
% \caption{Слово состояния FPU}
% \label{tab:fpu-status}
% \footnotesize
% 
% \begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% % № 	& 	&Название 	\\\hline
% \multicolumn{3}{c}{$sw$}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
% &\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
% \rowcolor{clFlagExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}$flags$, fnstsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
% \\\hline
% \rowcolor{clFlagStatus}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
% \rowcolor{clFlagStatus}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
% \rowcolor{clFlagStatus}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
% \rowcolor{clFlagSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
% \rowcolor{clFlagSystem}12 	& 	&&\cellcolor{clFlagStatus}4 	&\cellcolor{clFlagStatus}AF 	&\cellcolor{clFlagStatus}Auxiliary Carry Flag\\
% \rowcolor{clFlagSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
% \rowcolor{clFlagStatus}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
% \rowcolor{clFlagExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
% \end{tabularx}
% \end{table}
% 
% \pagebreak[3]
% %слово состояния $sw$ могло быть выгружено в~память или регистр $ax$ командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки $sw$ в~регистр $ax$ его старший байт загружал
% 
% % Таким образом, после выполнения команды сравнения (%и~%пары команд 
% % % \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% % % или при использовании совместимых с~ними 
% % при использовании совместимых с~ранними моделями 
% % команд %f*com[p[p]]
% % без суффикса~\lstinline!i! 
% % необходимы также \lstinline!fnstsw %ax! + \lstinline!sahf!)
% % результат  можно 
% % анализировать как результат сравнения беззнаковых целых чисел.
% % 
% % 
% % После этого значение $C3$ помещается в~аналогичный ему по смыслу флаг нуля $ZF$ ($st(0) - src = 0$), $C0$ "--- в~флаг переноса~$CF$ ($st(0) - src < 0$),
% % то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
% % Бит несравнимости $C2$ попадает на место флага чётности~$PF$. 
% 
% Как видно из таблицы, 
При загрузке старшего байта~$sw$ во~$flags$
флаг отрицательности~$C0$ помещается во флаг беззнакового переполнения~$CF$,
флаг нуля~$C3$ "--- в~аналогичный ему по смыслу $ZF$,
а~флаг несравнимости $C2$ "--- во флаг чётности $PF$. 
Другие флаги младшего байта~$flags$ получают фактически неопределённое значение.
% 
Таким образом, результат можно анализировать как результат сравнения беззнаковых целых чисел.
\index{Флаги!ZF (нуля)}%
\index{Флаги!CF (переноса)}%
\index{Флаги!PF (чётности)}%
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% 
% % После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% % Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.

Результат современных команды сравнения, напрямую устанавливающих флаги $ZF, CF, PF$ и~обнуляющих остальные флаги состояния в~регистре~$flags$,
можно анализировать как результат сравнения беззнаковых целых чисел без дополнительных действий.


\subsubsection{Определение вида значения}


Кроме команд сравнения, анализирующих разность двух значений $st(0)-src$ как число,
набор команд FPU включает также команду~\lstinline!fxam!, которая анализирует тип содержимого вершины стека (нормальное число, ноль, бесконечность, денормализованное число и~т.\,д.).
% При этом определяются
Эта команда достаточно старая, поэтому записывает результат в~слово состояния FPU.

Команда~\lstinline!fxam! выставляет  в~соответствии с~значением~$st(0)$
все четыре специальных флага $C0-C3$ слова состояния $sw$
 (таблица~\ref{tab:fpu-xam-flags}).
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% \FloatBarrier
\bottompagebreak[8ex]

\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-xam-flags.tex}

\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C1}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%
\index{Неопределённость вещественная}%
\end{table}

% \bottompagebreak


% \bottompagebreak[80mm]

% регистром тегов (в~частности, теги определяют, пуст ли регистр $r_{top}$, соответствующий вершине стека~$st(0)$) и~содержимым~$r_{top}$
 
Флаг~$C1$ всегда устанавливается равным знаковому биту~%$r_{top}$, даже если согласно тегам этот регистр пуст или 
$st(0)$, даже
если в~нём находится значение, не имеющее знака (вещественная неопределённость\index{Неопределённость вещественная} или недопустимое значение).
% \bottompagebreak
Необходимо отметить, что при загрузке флагов FPU в~регистр~$flags$ бит $C1$ попадает на зарезервированный разряд и,~соответственно, игнорируется.

% Флаги сравнения $C0, C3, C2$ получают значения в~соответствии с~таблицей~\ref{tab:fpu-xam-flags}.

Команда~\lstinline!fxam! корректно работает даже при пустом стеке.
Если регистр данных $r_{top}$, соответствующий вершине стека, помечен в~регистре тегов~$tw$ как пустой, % (то есть ), 
флаги  $C0, C3, C2$ получают значения, указанные в~последней строке таблицы~\ref{tab:fpu-xam-flags},
а~$C2$ "--- значение знакового бита~$r_{top}$.

Если $st(0)$ не пуст, флаги  $C0, C3, C2$ соответствуют виду содержащегося в~нём значения (\modifyone[более подробно виды значений FPU описаны в~разделе]{раздел}~\ref{sec:valueclasses}).
\index{Флаги!FPU!C0}%
\index{Флаги!FPU!C2}%
\index{Флаги!FPU!C3}%

% Конечным значениям~$st(0)$ соответствует нулевое значение~$C0$