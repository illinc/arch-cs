


\section{Математический сопроцессор}
\label{sec:asm-fpu}

\epigraph{
"--*  Фапофадофажди, "--- сказала Алиса Пашке, пользуясь старым школьным кодом. "--- Фамыфаосфатафанемфася фаодфани.

"--*  Фапофанял, "--- ответил Пашка.

"--*  Фавлефасу, "--- сказала Алиса.
}
{Кир.\,Булычёв}


% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX
% }  



Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой.
% 
Первый математический сопроцессор для линейки x86 "--- FPU 8087 "--- был выпущен в~1980 году.
Он представлял собой отдельную микросхему, устанавливаемую в~специальный сокет на системной плате.
Взаимодействие с~основным процессором выполнялось в~основном через оперативную память.

% Использование сопроцессора 8087 ускоряло вычисления с плавающей точкой, но, так как сопроцессор мог отсутствовать, 
Начиная с~процессора i486DX математический сопроцессор интегрирован в~процессор.
При этом сопроцессор долгое время (вплоть до линейки микропроцессоров Atom) имел почти независимое ядро, так что обработка целых чисел CPU и~вещественных FPU могла выполняться параллельно.
% С одной стороны, это позволяло
Из-за этого в~систему команд была введена команда ожидания завершения работы сопроцессора, а~многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
В~современных  процессорах FPU настолько плотно интегрирован с~ядром CPU, что их параллельная работа невозможна и~ожидание не требуется.


FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.

% Регистры FPU образуют стек с~плавающей вершиной.
% Система команд FPU идеологически отличается от основной системы команд.

\subsection{Регистры сопроцессора}
\epigraph{\begin{stanza}
    А руки всегда непохожи на ноги...\\
\end{stanza}}
{О.\,Арефьева}


% 
% Восемь 80-разрядных регистров, образующих стек (кольцевой буфер).


FPU x87 предоставляет восемь 80-разрядных регистров для хранения данных и~шесть вспомогательных регистров~\cite{intelBasic}.
При обращении к~ним в~GAS надо указывать тот же префикс~\lstinline!%!, что и~для регистров основного процессора (CPU).

\begin{illustration}
% \includegraphics[width=\approvedImageWidth]{fpu_reg}

\resizebox{\linewidth}{!}
{
\input{book/drawings/fpureg}
}

\caption{Регистры FPU}
\label{ris:fpu_reg}
\end{illustration}

% Регистры данных ($R0$--$R7$) не адресуются по именам, как регистры основного процессора. 
% Вместо этого эти восемь регистров рассматриваются как стек, вершина которого называется $st(0)$, а~более глубокие элементы "--- $st(1)$, $st(2)$ и~так далее до $st(7)$. 
% Если, например, в~какой-то момент времени регистр $R5$ называется $st(0)$, то после записи в~этот стек числа оно будет записано в~регистр $R4$, который станет называться $st(0)$, $R5$ станет называться $st(1)$ и~т.\,д.~\cite{zubkov}.
% ^^^ прямая цитата

Восемь регистров данных, согласно документации Intel~\cite{intelBasic}, носят имена $r_0-r_7$, но обратиться к~ним по этим именам невозможно.
Они образуют стек с~плавающей вершиной, построенный по принципу кольцевого буфера.
К~регистру, находящемуся сейчас в~вершине стека, можно обратиться как к~$st(0)$; если стек содержит более одного элемента, то к~более глубоким элементам можно обращаться по именам $st(1)$, $st(2)$ и~так далее до $st(7)$~\cite{zubkov}. 
Регистры данных сопроцессора хранят вещественные числа в~80-битном расширенном формате.
Мантисса занимает 64 бита, порядок "--- 15 бит, под знак отводится один бит.

Шестнадцатибитный регистр (слово) тегов $tw$ (Tag Word, также используется сокращение $twr$ "--- Tag Word Register)  хранит состояние регистров данных.
Каждому регистру $r_0-r_7$ соответствует два бита слова тегов (рис.~\ref{ris:fpu-tw}):
\begin{alphenumerate}
\item $00$ "--- в~соответствующем регистре корректное ненулевое значение;
\item $01$ "--- в~регистре ноль;
\item $10$ "--- в~регистре специальное значение: некорректное значение (\lstinline$nan$ или значение, не соответствующее формату вещественного числа с~расширенной точностью), бесконечность или денормализованное число; % Special: invalid (NaN, unsupported), infinity, or denormal
\item $11$ "--- регистр пуст.
\end{alphenumerate}
\begin{illustration}

\resizebox{\linewidth}{!}{\input{book/drawings/fpureg-tw}}

\caption{Слово тегов FPU}
\label{ris:fpu-tw}
\end{illustration}
Если регистр $r_i$ помечен в~слове тегов как пустой, его значение при этом  может быть каким угодно "--- попытка чтения из него приведёт к~ошибке стека.

Флаги математического сопроцессора разбиты на два шестнадцатибитных регистра (рис.~\ref{ris:fpu-sw-cw}) "--- 
управляющие флаги составляют управляющее слово $cw$ (Control Word, также $cwr$),
флаги состояния сгруппированы в~слово состояния "--- $sw$ (Status Word, также $swr$).

\begin{illustration}
% \includegraphics[width=\linewidth,keepaspectratio,valign=t]{swr}
% 
% \includegraphics[width=\linewidth,keepaspectratio,valign=t]{cwr}

\resizebox{\linewidth}{!}
{
\input{book/drawings/fpureg-sw-cw}
}

\caption{Слово состояния и~управляющее слово FPU}
\label{ris:fpu-sw-cw}
\end{illustration}

Управляющее слово содержит 
шесть масок исключений ($IM{-}PM$),
поле управления точностью $PC$,
и~поле управления округлением $RC$.
% Исключением

Слово состояния отображает  текущее состояние сопроцессора после выполнения последней команды.
Младший байт слова состояния
включает %флаг $IE$, соответствующей незамаскированному исключению,   
семь флагов, показывающих корректность операций ($IE{-}SF$) и~флаг $ES$, показывающий, что сбой не только был, но и привёл к~прерыванию.
Старший байт включает
флаги $C0{-}C3$, хранящие результаты сравнения чисел,
% Также слово состояния содержит 
а~также трёхбитный текущий номер вершины стека $top$.
Последний бит~$B$ в~настоящее время не используется.

%  ТОР "--- указатель  вершины стека.
%  шесть флагов исключительных ситуаций;


Таким образом, стек сопроцессора организован с~помощью восьми регистров данных $r_0-r_7$, соответствующих восьми полей слова тегов~$tag(0){-}tag(7)$ и~поля~$top$ слова состояния.
Вершина стека $st(0)$ находится в~регистре $r_{top}$, обозначение $st(1)$ получает следующий регистр~$r_{top+1}$ и так далее.
За $r_7$ по принципу кольцевого буфера следует $r_0$.
На рис.~\ref{ris:fpu-r-st} показаны соотношения между физическими $r_i$ и~логическими $st(i)$ именами регистров данных сопроцессора при различных значениях номера вершины стека $top$.


% \begin{illustration}
% \includegraphics[width=\linewidth,keepaspectratio,valign=c]{fpu_push_pop}
% \caption{Стек FPU}
% \label{ris:fpu-r-st}
% \end{illustration}

\begin{illustration}
\resizebox{\linewidth}{!}
{
\input{book/drawings/fpu-top-change}
}

\caption{Стек FPU}
\label{ris:fpu-r-st}
\end{illustration}

Положение дна стека определяется словом тегов $tw$ (первый пустой регистр).



После инициализации стек пуст.
% В~начале работы стек пуст. 
После завершения вычислений (перед выходом из функции или ассемблерной вставки) его также необходимо оставить пустым. 
Если функция возвращает вещественное значение через стек сопроцессора, в~стеке не должно остаться ничего, кроме возвращаемого значения.

Для вычислений хотя бы один операнд должен быть загружен в~стек сопроцессора.





% Last Instruction Opcode intelBasic
Два 48-битных регистра указателей (на последнюю команду "---  FPU Instruction Pointer, $fip$, в~некоторых источниках также~$ipr$~\cite{urov} и~последний загруженный операнд  Data (Operand) Pointer, $fdp$, также~$dpr$), а~также десятибитный регистр кода операции последней неуправляющей команды (FPU Opcode Register, $fop$) используются в~обработке исключений для определения места сбоя.

\subsubsection{Исключения сопроцессора}

Во время работы сопроцессора возможны ситуации, когда по какой-то причине невозможно корректно выполнить требуемые вычисления.
Подобные ситуации называются исключительными ситуациями, или просто исключениями FPU.


Рассмотрим исключения FPU подробнее.

\paragraph{\#I} Недействительная операция (Invalid operation).
Может быть стековой ошибкой~\textbf{\#IS}  или недопустимой арифметической операцией~\textbf{\#IA}.


\paragraph{\#IS} Стековая ошибка (Stack Fault) "--- попытка записи в~полностью заполненный стек или чтения из пустой ячейки стека.


Недействительной арифметической операцией~\textbf{(\#IA)} считается операция, проводимая над некорректными аргументами.
В~этом случае может также возникнуть одна из следующих пяти ситуаций.

\paragraph{\#D} Денормализованный операнд (Denormalized operand) "--- выполнение арифметической операции над денормализованным числом или загрузке такого числа в~стек.

\paragraph{\#Z} Деление на ноль (Zero Divide) "--- деление на ноль.

\paragraph{\#О} Переполнение  порядка (Overflow) "--- порядок результата выходит за максимально допустимое значение.
% 
Для команд выгрузки из стека \lstinline!f*st! переполнение возможно в~том случае, если размер порядка приёмника недостаточен.

\paragraph{\#U} Антипереполнение, или исчезновения порядка (Underflow) "--- порядок результата выходит за минимально допустимое значение (денормализованный результат).

\paragraph{\#Р} Неточный результат (Precision) "--- результат невозможно точно представить в~формате назначения (например, $\frac{1}{3}$, $\sqrt{2}$).

Команды вычисления трансцендентных функций (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда приводят к~неточному результату.




\paragraph{Маски исключений}
\label{sec:fpu:cw-mask}
% Из рассмотренных выше флагов ошибки первые шесть соответствуют некорректно выполненным вычислениям "--- так называемым исключительным ситуациям, или исключениям FPU.
% % 
% На подобные ситуации FPU может реагировать двояко: помещать на место результата специальное значение (нечисло) или инициировать прерывание вычислений.

Если в~языках высокого уровня термин «исключение» подразумевает прерывание нормального хода программы и~переход к~обработчику,
то FPU на некоторые (арифметические) исключения может реагировать двояко: помещать на место результата специальное значение (нечисло) или инициировать прерывание вычислений.

Поведением FPU управляют шесть масок исключений ($IM{-}PM$),
расположенных в~первых шести битах управляющего слова~$cw$.
На тех же местах  в~слове состояния~$sw$ располагаются соответствующие флаги $IE{-}PE$.

Если бит маски установлен в~единицу, то соответствующее исключительная ситуация не вызывает прерывания выполнения программы (то есть того, что обычно и~называется в~языке высокого уровня исключением).
Такое исключение называется замаскированным.

Стековую ошибку замаскировать невозможно.


\paragraph{Флаги сопроцессора}
\index{Флаги!сопроцессора}

Математический сопроцессор имеет собственный регистр флагов "--- слово состояния $sw$.
Аналогично $flags$, биты слова состояния сопроцессора представляют те или иные характеристики последней операции сопроцессора~\cite{intelBasic, club155}.

На рис.~\ref{ris:fpu-sw-cw} показано расположение семи флагов ошибок разных видов, флага суммарной ошибки
и~флагов $C0{-}C3$, хранящих результат сравнения чисел специальными командами.
% 
Команды вещественной арифметики не выставляют флаги $C0{-}C3$.

% Рассмотрим флаги ошибок подробнее.
% 
% \paragraph{IE (бит 0)} Флаг недействительной операции (Invalid operation).
% Устанавливается в~единицу при выполнении недопустимой стековой (в~этом случае устанавливается также флаг $SF$) или арифметической операции.
% 
% Недействительной арифметической операцией считается операция, проводимая над некорректными аргументами.
% В~этом случае могут быть установлены также флаги $DE$, $ZE$, $OE$, $UE$ или $PE$.
% 
% \paragraph{DE (бит 1)} Флаг денормализованного операнда (Denormalized operand).
% Устанавливается в~единицу при выполнении арифметической операции над денормализованным числом или загрузке такого числа в~стек.
% 
% \paragraph{ZE (бит 2)} Флаг деления на ноль (Zero Divide).
% Устанавливается в~единицу при делении на ноль.
% 
% \paragraph{ОЕ (бит 3)} Флаг переполнения порядка (Overflow).
% Устанавливается в~единицу, если порядок результата выходит за максимально допустимое значение.
% % 
% Для команд выгрузки из стека \lstinline!f*st! переполнение возможно в~том случае, если размер порядка приёмника недостаточен.
% 
% \paragraph{UE (бит 4)} Флаг антипереполнения, или исчезновения порядка (Underflow).
% Устанавливается в~единицу, если порядок результата выходит за минимально допустимое значение (денормализованный результат).
% 
% \paragraph{РЕ (бит 5)} Флаг неточного результата (Precision).
% Устанавливается в~единицу, если результат невозможно точно представить в~формате назначения (например, $\frac{1}{3}$, $\sqrt{2}$).
% 
% Команды вычисления трансцендентных функций (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда приводят к~неточному результату.
% 
% \paragraph{SF (бит 6)} Флаг стековой ошибки (Stack Fault).
% Устанавливается в~единицу при попытке записи в~полностью заполненный стек или чтения из пустой ячейки стека.

Первые семь битов слова состояния соответствуют исключениям FPU.
% 
Каждой исключительной ситуации соответствует свой флаг ошибки,
который устанавливается в~единицу при возникновении этой исключительной ситуации.

% \newcommand{\flagbit}[1]{\hspace*{0pt}\rlap{\textbf{#1}}\hspace{6em}}
\newcommand{\flagbit}[1]{\hspace*{0pt}\rlap{\textbf{#1}}\phantom{\textbf{ОE (бит 3)}}}

% \begin{description}
\flagbit{IE (бит 0)} "--- флаг недействительной операции.

Устанавливается в~единицу при выполнении недопустимой стековой (в~этом случае устанавливается также флаг $SF$) или арифметической операции.
В~последнем случае могут быть установлены также флаги $DE$, $ZE$, $OE$, $UE$ или $PE$.

\flagbit{DE (бит 1)} "--- флаг денормализованного операнда.

\flagbit{ZE (бит 2)} "--- флаг деления на ноль.

\flagbit{ОE (бит 3)} "--- флаг переполнения порядка.

\flagbit{UE (бит 4)} "--- флаг антипереполнения, или исчезновения порядка.

\flagbit{РE (бит 5)} "--- флаг неточного результата.

\flagbit{SF (бит 6)} "--- флаг стековой ошибки.
% \end{description}

Также по результатам операции выставляется флаг суммарной ошибки, которому не соответствует ни одно из исключений.

% \begin{description}[WW (бит W)]
\flagbit{ES (бит 7)} "--- флаг суммарной ошибки (Error Summary Status).

Он равен единице, если возникает хотя бы одно незамаскированное исключение.
% Таким образом, если не замаскировано ни одно из исключений, 
% \end{description}

В~некоторых источниках говорится, что $ES$ равен единице  в~том случае, когда в~разрядах $0...6$ есть хотя бы одна единица~\cite{mikroprocessorniesistemi2002}.
Это в~общем случае неверно.
Если какое-то исключение замаскировано% (например, в~C++ деление на ноль не приводит к~исключению)
, $ES$ не дублирует состояние соответствующего флага.

В~частности,  в~C++ деление на ноль не должно приводить к~прерыванию работы программы, поэтому соответствующее исключение при настройке сопроцессора стартовым кодом маскируется.

Соответственно, при попытке деления единицы на ноль, как можно убедиться при помощи отладчика, результат принимает специальное значение $inf$ ($+\infty$), устанавливается флаг $ZE$, но
флаг $ES$ не устанавливается.

\begin{lstlisting}[caption={Деление $y = \frac{1}{0}$}, label=lst:asm:fpu:zerodivide]
double y;
asm(
    "fld1\n"
    "fldz\n"
    "fdivrp\n"
    "fstpl %[y]\n"
    :[y]"=m"(y)
);
\end{lstlisting}




\subsection{Внутреннее представление чисел}
\index{Представление данных!вещественных!расширенной точности}
% \epigraph{\begin{stanza}[0ex]
% Походка, стан кошачий,\\
% Драконий хвост наждачный,\\
% А крылья "--- из удачи впридачу.\\
% \end{stanza}}
% {О.\,Арефьева}
\epigraph{\begin{stanza}
Мое сердце из масти,\\ 
Кровь "--- диэтиламид;\\
Не надо смотреть на меня, \\
Потому что иначе ты вымрешь, как вид.\\
\end{stanza}
}{\Aquarium}

% IEEE 754

% http://stackoverflow.com/questions/612507/what-are-the-applications-benefits-of-an-80-bit-extended-precision-data-type
Значения в~сопроцессоре представлены в %80-битном формате 
% (с~двойной расширенной точностью соответственно IEEE 754-1985~\cite{ieeeFloat1985rus}).
% Этот формат исключён из современной версии стандарта IEEE 754~\cite{ieeeFloat2008}, но из-за соображений совместимости формат данных FPU не изменился.
нестандартном 80-битном формате с~плавающей запятой,
называемом форматом с~двойной расширенной (или просто расширенной) точностью, описанном в~разделе~\ref{sec:digits:floatpoint}.

Нормализованное двоичное представление вещественного числа имеет вид~\cite{urov,av-assembler-asm-real-normalization}:
\begin{equation}
\label{eq:float-rus}
(-1)^s \cdot 2^p \cdot \mu, ~~ %0 \leqslant \mu < 1
0,1_2 \leqslant \mu < 1
\end{equation}
где
% $0,1_2 \leqslant \mu < 1$ нормализованное число,
% \\
% $0 \leqslant \mu < 0,1_2$ денормализованное число.
$p$ "--- порядок числа, $\mu$ "--- мантисса, $s$ определяет знак.
Таким образом, все значащие разряды мантиссы находятся в~дробной части.
Старший из них (следующий сразу после запятой) для нормализованного числа всегда равен единице.

Старший бит 80-битного формата "--- знак~$s$,
порядок занимает следующие 15 бит и~представляется кодом с~избытком $2^{14}-2$ %(см. раздел~\ref{sec:digits-negcodes}),
(так называемый смещённый порядок).
% % то есть соответствующее поле содержит натуральный двоичный код числа~$p + 2^{14}$,
% мантисса занимает 64 бита, % и~представляется натуральным кодом
% причём её представление  включает ведущую единицу (рис.~\ref{ris:fpu_digits}),
В~оставшиеся 64 бита записывается дробная часть мантиссы, включая ведущую единицу.

В~частности, единица в~нормализованном представлении имеет вид~$(-1)^0 \cdot 2^1\cdot 0,1_2$.
Тогда значение смещённого порядка (после добавления избытка) будет равно $2^{14}-1$:
$$
\begin{array}{rrrr}
1 = (-1)^0 \cdot 2^1\cdot 0,1_2 &\to &\regfloat[fill=none]{0}{2^{14}-1}{100...} &=\\
% = 0~~0\underbrace{11...11}_{14 \text{единиц}}%\,1111\,1111\,1111
% ~~\underbrace{100...}_{64 \text{бита}}
&=& \regfloat[fill=none]{0}{011...11}{100...} &\\
\end{array}
$$
% После 
Таким образом, %шестнадцатеричное представление вещественного числа 
вещественное число расширенной точности, равное единице, имеет вид
\lstinline$3FFF$\,\lstinline$8000$\,~\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$.
Это подтверждает исследование с~помощью отладчика.

Значение порядка, состоящее из пятнадцати нулей, зарезервировано под специальные значения, таким образом, 
минимально возможное значение порядка корректного вещественного числа имеет вид $00...001$ и~равно~$p_{min} = 1 + \left(-2^{14}+2\right) = -2^{14}+3$.
Соответственно, минимальное положительное  число, представимое в~нормализованном виде в~%80-битном формате FPU, 
формате расширенной точности,
равно 
$X_{min} = 2^{p_{min}} \cdot 0,1_2 = 2^{-2^{14}+2} = $ \lstinline$0001$\,\lstinline$8000...00$.
Числа в~диапазоне $(0, X_{min})$ представляются в~виде $2^{p_{min}} \cdot \mu, ~~ 0 < \mu < 0,1_2$ и~называются \termin{денормализованными}.
В~поле смещённого порядка таких чисел при этом записываются нули.
В~частности, $\frac{X_{min}}{2} = 2^{p_{min}} \cdot 0,01_2 = 2^{p_{min}-1} \cdot 0,1_2$, но представляется это число как \lstinline$0000$\,\lstinline$4000...00$, 
% хотя порядок 
в~чём можно убедиться при помощи отладчика.
Если попытаться прочесть такую запись как корректное число, то получим нулевой знаковый бит, нулевой смещённый порядок, что соответствует порядку $p_{min}-1$, 
и~мантиссу $0,0100..._2$, то есть $(-1)^0 \cdot 2^{p_{min}-1}\cdot 0,01_2 = \frac{X_{min}}{4}$, что неверно.
Денормализованные числа "--- один из видов \termin{специальных значений,} которые нельзя раскодировать по общему правилу.
% Если попытаться 

Представление отрицательных вещественных чисел, в~том числе из диапазона $(-X_{min}, 0)$ ,
отличается от представления их модулей только знаковым битом.


Как было сказано в~разделе~\ref{sec:digits:floatpoint},
в~некоторых источниках нормализованной формой мантиссы считается число, включающее один разряд целой части и~63 бита дробной~\cite{intelBasic}
или целое беззнаковое 64-битное число с~единицей в~старшем разряде~\cite{ieeeFloat1985rus}.
% 
Обе этих трактовки приводят к~тому же самому двоичному представлению, что и~описанная выше.

% В~зарубежных источниках то же самое представление вещественных чисел в~FPU интерпретируется иначе~\cite{intelBasic} (хотя суть от этого не меняется).
% % 
% Там считается, что мантисса нормализованного числа включает целую часть (рис.~\ref{ris:fpu_digits-en}).
% \begin{illustration}
% \includegraphics[width=\linewidth]{X86_Extended_Floating_Point_Format_ru}
% \caption{Внутренний 80-битный формат сопроцессора в~зарубежной интерпретации}
% \label{ris:fpu_digits-en}
% \end{illustration}
% % \begin{equation}
% % \label{eq:float-en}
% % (-1)^s \cdot 2^{\tilde{p}} \cdot \widetilde{\mu},~~ 1 \leqslant \widetilde{\mu} < 10_2
% % \end{equation}
% % % тогда нормализованные числа соответствуют мантиссам $1 \leqslant \widetilde{\mu} < 10_2$,
% 
% Соответственно, в~зарубежной трактовке мантисса $\widetilde{\mu}$ числа 
% 
% Такое представление, как указано в~разделе~\ref{sec:digits:floatpoint}, не влияет на 
% двоичное представление
% % мантисса будет 
% % нормализованные числа
% % тогда денормализованные числа соответствуют мантиссам $0 \leqslant \widetilde{\mu} < 1$.

% Формы~\eqref{eq:float-rus} и~\eqref{eq:float-en} взаимно однозначно соответствуют друг другу:
% $$
% \left\{
% \begin{array}{lll}
% \tilde{p} &=& p - 1\\
% \widetilde{\mu} &=& 2\cdot \mu\\
% \end{array}
% \right.
% $$
% Так как двоичная запятая не может быть сохранена в~регистре~$r_i$, а~только \emph{подразумевается} на той или иной позиции,
% двоичное представление мантиссы в~формах~\eqref{eq:float-rus} и~\eqref{eq:float-en} \emph{полностью совпадает.}
% Порядок~$\tilde{p}$ формы~\eqref{eq:float-en}, %в~этом случае 
% соответственно,
% записывается с~избытком $2^{14} -1$, так что полученное значение смещённого порядка в~результате также совпадает с~формой~\eqref{eq:float-rus}.
% Таким образом, двоичное представление одинаковых чисел (как нормализуемых в~формате расширенной точности, так и~денормализованных) одинаково и~не зависит от формы нормализованного представления.

\subsubsection{Виды значений}
\label{sec:valueclasses}

Регистры сопроцессора могут содержать следующие значения:
\begin{itemize}
\item  вещественные числа "--- порядок не равен $0$ и~не состоит из всех единиц, %то есть не равен 0x7FFF
% целая часть мантиссы равна 1; %, корректно представимые
старший бит мантиссы равен~$1$;
\item денормализованные вещественные числа "--- порядок и~%целая часть
старший бит мантиссы равны $0$, но мантисса не равна нулю;
\item нули ($+0,0$ и~$-0,0$, в~соответствии со знаковым битом) "--- порядок и~мантисса равны нулю;
\item бесконечности ($+\infty$ и~$-\infty$, в~соответствии со знаковым битом, обозначаются как \lstinline!+inf! и~\lstinline!-inf!) "--- порядок состоит из всех единиц, 
% целая часть мантиссы "--- единица, дробная часть равна нулю;
старший бит мантиссы "--- единица, остальные равны нулю;
\item нечисла двух типов:
\begin{itemize}
\item сигнальные нечисла (при  появлении такого значения в~стеке генерируется исключение недействительной операции);
\item тихие нечисла (не генерируют исключения, но результат вычислений с~операндом-нечислом "--- тоже нечисло):
\begin{itemize}
\item вещественная неопределённость \lstinline!nan! (знаковый бит не имеет значения) "--- порядок состоит из всех единиц, 
% целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные нули;
\item другие тихие нечисла "--- порядок состоит из всех единиц, %целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные "--- не все нули;
\end{itemize}
\end{itemize}
\item недопустимые значения.
\end{itemize}
Начиная с~80387 некоторые ранее недопустимые значения стали нечислами различного типа, и~наоборот "--- многие недопустимые для современных сопроцессоров значения были корректными нечислами в~ранних дискретных моделях.

% Регистр состояний SW содержит слово состояния FPU.
% Регистр управления CW содержит управляющие биты и~маски.
% 
% Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.
% 
% Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.

\subsection{Возможные форматы экспорта-импорта}
\epigraph{\begin{stanza}
У меня есть что-то, я могу поделиться с тобой.\\
И это алая дверь.
\end{stanza}
}{\Aquarium}

Регистры сопроцессора могут содержать только вещественные числа расширенной точности или специальные значения формата расширенной точности.
Тем не менее, при
выгрузке значений из стека возможно преобразовать их в~различные форматы трёх основных видов "---  с~плавающей запятой, целые двоичные и~целые двоично-десятичные.

Соответственно, при явной загрузке значений из памяти в~стек 
или выполнении вычислений с~операндом в~памяти
возможен экспорт значений из этих форматов.

\subsubsection{Форматы с~плавающей запятой}

FPU поддерживает импорт и~экспорт в~стандартные форматы с~плавающей запятой одинарной %(32 бита, $float$) 
и~двойной %(64 бита, $double$) 
точности, соответствующие стандарту IEEE 754-2008.
Также возможен импорт-экспорт в~нестандартный 80-битный формат двойной расширенной точности, совпадающий с~внутренним представлением чисел FPU.

Конкретный выбор формата определяется суффиксом команды (раздел~\ref{sec:att-suffixes}).
Суффикс $s$  соответствует одинарной точности (32 бита, $float$), $l$ "--- двойной (64 бита, $double$), $t$ "--- нестандартному формату расширенной точности (80 бит, для GCC "--- $long~double$).

Если суффикс не указан, используется одинарная точность ($float$).

\subsubsection{Целые форматы}

Поддерживается  импорт и~экспорт в~двоичные знаковые целые форматы от~двух до восьми байт.
Отрицательные числа представлены %, как принято для целых чисел, 
в~дополнительном коде.

Выбор формата определяется суффиксом команды (раздел~\ref{sec:att-suffixes}).
Суффикс $s$  соответствует короткому целому (16 бит, $short$), $l$ "--- длинному (32 бита, $long$ и~чаще всего~$int$), $q$ "--- четверному (64 бита, $long~long$).
Если суффикс не указан, используется одинарная точность ($float$).


\subsubsection{Двоично-десятичный формат}

FPU поддерживает экспорт и~импорт только в~один вид двоично-десятичных  чисел "--- это 80-битный  упакованный целый BCD-формат в~виде значения со знаком.

Всего такое число занимает десять байт.
Старший из них "--- знаковый.
Его старший бит хранит знак числа "--- ноль соответствует положительному числу, единица "--- отрицательному.
Младшие семь бит знакового байта не имеют значения.
% 
Остальные девять байтов содержат модуль числа в~виде 18 упакованных десятичных цифр.

Таким образом, BCD-формат FPU, как и~форматы с~плавающей запятой, включает два нуля: $+0$ и~$-0$.


% \subsection{Набор инструкций x87}
\subsection{Общие команды x87}
\epigraph{\begin{stanza}
Багровый и белый пришли в мои песни.\\
Мы здесь не ради парада.\\
Мы стоим вместе и падаем вместе;\\
И я буду петь тебе, если ты будешь рада.\\
\end{stanza}
}{\Aquarium}
% http://www.studfiles.ru/preview/4034449/

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы.
Все мнемонические обозначения начинаются с~символа \lstinline!f! (FPU).
Вторая буква мнемонического обозначения определяет тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item \lstinline!i! "--- целое двоичное число со знаком;

\item \lstinline!b! "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы "--- вещественное число.
\end{itemize}

Последняя буква \lstinline!p! в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная \lstinline!pp! "---  из стека извлекаются оба операнда). 

Команды FPU не могут иметь непосредственных операндов или операндов-регистров основного процессора. 
Если не указано иное, используются следующие обозначения.
Операнд-приёмник
может быть обозначен либо как~$dest$, если он может быть регистром сопроцессора или переменной в~памяти либо как $dmem$, если он может быть только в~памяти.
Операнд-источник может быть обозначен как $src$ (регистр сопроцессора или переменная в~памяти) или $smem$ (переменная в~памяти).

\subsubsection{Сброс сопроцессора}

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Так как ранние модели сопроцессора были отдельными устройствами, 
перед началом работы было необходимо определить, есть ли сопроцессор в~системе, и, в~случае его наличия, инициализировать сопроцессор.
Для инициализации предназначена команда \lstinline!finit! "--- сброс сопроцессора.

Команда \lstinline!finit! восстанавливает значения по умолчанию в~регистрах $cw$, $sw$, $tw$, а~начиная с~80387 "--- $fip$ и~$fdp$. Управляющее слово инициализируется значением \lstinline$0x037F$ (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на $0$, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Слово состояния обнуляется ($top = 0$, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~слове тегов $tw$. Регистры $fip$ и~$fdp$ обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.


\subsubsection{Ожидание синхронизации}

Оригинальный арифметический сопроцессор, выполненный в~виде отдельной микросхемы, мог работать параллельно с~центральным процессором.
Для их синхронизации использовалась команда \lstinline!wait/fwait!.
Этим мнемоникам соответствует один и~тот же машинный код.
% , который применялся для 
Эта команда приостанавливает работу либо FPU, либо центрального процессора "--- в~зависимости от того, какой из них «вырвался вперёд»
"--- и~ждёт отстающего.
% Выполнение программы 
Кроме того, многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
Мнемоника команды без ожидания отличается префиксом~\lstinline!n! после префикса FPU~\lstinline!f!, например, \lstinline!fnstsw! и~\lstinline!fstsw!.
При этом, согласно документации Intel, машинный код команды без префикса~\lstinline!n! состоит из кода команды \lstinline!wait/fwait! и~кода команды с~префиксом~\lstinline!n!. %, то есть основной
В~частности, команда~\lstinline!fstsw! полностью эквивалентна последовательности \texttt{fwait + fnstsw}.

В~современных  процессорах параллельная работа команд FPU и~основного набора невозможна, так что команда \lstinline!wait/fwait! эквивалентна \lstinline!nop!.
Соответственно, из двух команд "--- с~префиксом~\lstinline!n! и~без "--- в~настоящее время необходимо выбирать вариант с~префиксом.


% \subsection{Загрузка и~выгрузка данных}
% \subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}
\subsection{Загрузка, выгрузка и~пересылка данных}
% \epigraph{\begin{stanza}
% Но будь ты хоть роллс-ройс "--- всё равно стоять в пробке.
% \end{stanza}}
% {\Aquarium}
\epigraph{\begin{stanza}[0mm]
 И падут предо мною преграды стекла,\\
Я смогу без препятствий входить в зеркала!\\
\end{stanza}}{С. Калугин}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
% 
Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти.
В~частности, листинг~\ref{lst:asm:fpu:x+a} показывает вычисление значение выражения $x+a$ и~запись результата в~$y$.
Параметры (как входные \texttt{[X]} и~\texttt{[A]}, так и~выходной~\texttt{[Y]}) расположены в~памяти.

\begin{lstlisting}[style=lstsmall, caption={Вычисление $y = x+a$}, label=lst:asm:fpu:x+a]
const double a = 12;
double x = 1, y;
asm(
    "fldl %[X]\n"  // st(0) = %[X]
    "faddl %[A]\n" // st(0) = %[X] + %[A]
    "fstpl %[Y]\n" // %[Y] = %[X] + %[A], стек пуст
    :[Y]"=m"(y)
    :[X]"m"(x), [A]"m"(a)
    :"cc"
);
\end{lstlisting}

В~списке  перезаписываемых регистров GCC не позволяет описывать элементы стека сопроцессора.
Это %, как правило, 
не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).





\subsubsection{Загрузка данных в~стек сопроцессора}
\index{Команды!сопроцессора!загрузки}

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций \lstinline!f*ld! (таблица~\ref{tab:fpu-fld-list}).
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение $st(0)$.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры
\begin{table}[!ht]
% \caption{Команды загрузки данных в~стек сопроцессора}
% \label{tab:fpu-fld-list}
% \begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-fld-list.tex}

% \endgroup

\end{table}

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.


\subsubsection{Выгрузка данных из~стека сопроцессора}
\index{Команды!сопроцессора!выгрузки}
\index{Команды!сопроцессора!пересылки}


Для выгрузки данных из~стека сопроцессора предназначен набор инструкций \lstinline!f*st[p]! (таблица~\ref{tab:fpu-fst-list}).

\begin{table}[!ht]

\begingroup
\small
% \def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-fst-list.tex}

\endgroup
\end{table}



Ниже показан пример использования команд загрузки и~выгрузки (листинг~\ref{lst:asm:fpu:ldst}).

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Последовательная загрузка и~выгрузка данных}, label=lst:asm:fpu:ldst]
double x = 5.7, y;
float f;
long double l;
int i = 10;

asm(                //          st(0),st(1),st(2),st(3)
    "fldl %[x]\n"   // в стеке: [x]
    "fldz\n"        // в стеке: 0,    [x]
    "fld1\n"        // в стеке: 1,    0,    [x]
    "fildl %[i]\n"  // в стеке: [i],  1,    0,    [x]
    "fstps %[f]\n"  // в стеке: 1,    0,    [x]       [f] = [i] 
    "fstpt %[l]\n"  // в стеке: 0,    [x]             [l] = 1   
    "fstpl %[y]\n"  // в стеке: [x]                   [y] = 0   
    "fistpl %[i]\n" // стек пуст                      [i] = [x]

    :[y]"=m"(y), [i]"+m"(i), [f]"=m"(f), [l]"=m"(l)
    :[x]"m"(x)
    :"cc"
)

#define PRINT(val) cout << #val << " = " << val << "  ";

PRINT(x)
PRINT(y)
PRINT(i)
PRINT(f)
PRINT(l)
\end{lstlisting}
Вначале в~стек сопроцессора последовательно загружаются четыре значения:
вещественная переменная двойной точности $x = 5,7$, константы "--- ноль и~единица, а~также целое 32-битное число $i = 10$.
% При загрузке данных из памяти размер источника определяется суффиксом. 
% Команда $fldl$ загружает из памяти длинное вещественное значение (64-битное, $double$),
% $fildl$ "--- длинное целое (32-битное, $int$).

После загрузки всех четырёх значений в~стеке сопроцессора находятся следующие значения:
$$
\begin{array}{l}
st(0) =10= i \\
st(1) = 1 \\
st(2) = 0 \\
st(3)= 5,7 = x \\
\end{array}
$$
Все они внутри стека хранятся в~80-битном вещественном формате.

Затем верхнее значение $st(0)$, равное последнему загруженному значению~$i = 10$, выталкивается из стека и~записывается по адресу параметра $[f]$, преобразованное в~вещественное число одинарной точности.
% (суффикс $s$ для вещественных команд обозначает короткое вещественное число, то есть 32-битное $float$).
Новое значение вершины стека $st(0)$ после выталкивания %значения $10$
"--- единица. Соответственно, изменятся и~обозначения более глубоких элементов стека: $st(1) = 0$ и~$st(2) = x$.

Затем новое значение вершины стека, равное единице, выталкивается в~параметр~$[l]$ как 80-битное число (суффикс $t$ "--- $ten~bytes$, что для компиляторов GCC соответствует типу $long~double$).
Ноль выталкивается из стека и~записывается в~$[y]$ как число двойной точности.
Последний оператор выталкивает значение~$x$ в~параметр~$[i]$ как длинное целое ($int$), после чего стек остаётся пустым.
Значение $5.7$ округляется в~соответствии с~текущими настройками округления.

Соответственно, результат отладочной печати в~конце листинга выглядит следующим образом:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, numbers=none]
x = 5.7  y = 0  i = 6  f = 10  l = 1 
\end{lstlisting}

Используя команды выгрузки или загрузки из памяти, необходимо внимательно следить за суффиксами команд.
% , так как только по суффиксу определяется размер "--- единственная
В~вышеописанном примере команда \lstinline!fstp %[y]! не вызвала бы ошибки ни во время компиляции, ни во время выполнения, но переменная $y$ получила бы весьма странное значение.
По умолчанию (без указания суффикса) \lstinline$fstp$ записывает снятое с~вершины стека значение как вещественное число одинарной точности, то есть из 64 бит переменной $y$ будут перезаписаны только первые 32, причём в~формате, не соответствующем типу $double$.

\subsubsection{Пересылка данных внутри стека сопроцессора}
\label{sec:fcmovCC}
\index{Флаги!проверка}
\index{Команды!условной пересылки}
% \index{Команды!сопроцессора!пересылки}

Для пересылки данных внутри стека сопроцессора можно использовать команды \lstinline!fld st(i)! для загрузки копии значения $st(i)$ в~вершину стека
и~\lstinline!fst st(i)! для помещения значения $st(0)$ в~ранее пустую ячейку~$st(i)$.
Кроме того, существует две специализированные команды (таблица~\ref{tab:fpu-mov-list}).

\begin{table}[!ht]
\caption{Команды пересылки данных~FPU}
\label{tab:fpu-mov-list}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
fcmovCC \%st(i), \%st(0) & Присваивание   $st(0) = st(i)$, если верно  $CC$
 (\texttt{e, ne, b/nae, be/na, ae/nb, a/nbe,} \texttt{u} и~\texttt{nu})
\\\hline
fxch & Меняет местами  $st(0)$ и~$st(1)$
\\
fxch \%st(i)
& Меняет местами  $st(0)$ и~$st(i)$
\\\hline
\end{tabularx}
\end{table}


Команда условного копирования~\lstinline!fcmovCC! использует как условие флаги регистра~$flags$,
а~не регистра состояния~$sw$.
При этом для неё доступны 
не все  условия~$CC$, перечисленные в~таблице~\ref{tab:cc-list},
и~даже не все синонимы доступных условий.
Используемые условия перечислены в~таблице~\ref{tab:fpu-cc-list}.
% Таблица~\ref{tab:fpu-cc-list} содержит доступные для условного копирования условия.

\begin{table}[!ht]
\small\def\normalsize{\small}
\LTXtable{\textwidth}{book/tables/fpu-cc-list.tex}
\end{table}

% После сравнения вещественных чисел 
% После сравнения флаги состояния сопроцессора копируются в~$flags$ (вручную или автоматически "--- в~зависимости от используемой команды сравнения) таким образом, что результат сравнения можно анализировать так же, как для целых беззнаковых чисел:
% $ZF$ указывает на равенство, $CF$ "--- на $dest<src$; кроме того, в~$PF$ копируется флаг несравнимости операндов. 

Условия~\lstinline!fcmovCC! включают те биты регистра флагов~$flags$, которые могут быть прямо или косвенно (путём сохранения слова состояния~$sw$ и~загрузки его части в~$flags$) установлены командами сравнения FPU, то есть флаги $ZF, CF, PF$.

Команда обмена регистров \lstinline!fxch! на самом деле не копирует данные, а~переименовывает регистры, так что её выполнение практически не занимает времени.
Так как большинство команд работает с~вершиной стека, переименование регистров  с~помощью~\lstinline!fxch! часто бывает удобным.


\subsubsection{Загрузка и~выгрузка управляющих регистров}

Содержимое управляющих регистров также может быть сохранено в~памяти (таблица~\ref{tab:fpu:ld-st-spec}).

\begin{table}[!ht]
\caption{Команды загрузки и~выгрузки управляющих регистров~FPU}
\label{tab:fpu:ld-st-spec}

\small
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|}
\hline
\normalfont\thead{Команда} & \thead{Действие} 
\\\hline
fnstcw dmem16	&	Выгрузка управляющего слова~$cw$ в~память  \\\hline
fldcw smem16	&	Загрузка управляющего слова~$cw$ из памяти  \\\hline
fnstsw dest16	&	Выгрузка (разрушающая) слова состояния~$sw$ в~память или регистр~$ax$ \\\hline
\end{tabularx}
\end{table}

Управляющее слово можно как выгрузить в~память по заданному адресу, так и~загрузить из неё.

Слово состояния сопроцессора  можно только сохранить в~память,  а~также в~регистр~$ax$ (и~только в~этот регистр).

После выгрузки слова состояния~$sw$ командой~\lstinline$fnstsw$ теряется значение специальных флагов~$C0-C3$.

% Приёмник 
% Сохранение состояния сопроцессора с~последующей загрузкой его в~регистр~$flags$ может применяться при сравнении вещественных чисел.
% 
% \subsection{Арифметические и~трансцендентные команды}
% \epigraph{\begin{stanza}
% Ещё раз напьюсь\\
% Этой бесконечной воды...\\
% И двинусь дальше\\
% Вслед за пламенем Зелёной Звезды.\\
% \end{stanza}
% }{\Aquarium}
% 
% Основное назначение FPU "--- производить вычисления; соответственно, данный раздел наиболее объёмен.
% 
% Сопроцессор поддерживает шесть форм для команд, выполняющих четыре действия арифметики над различными типами операндов.
% При этом  реализация несимметричных операций (вычитания и~деления) качественно отличается от ассемблеров с~синтаксисом Intel.
% 
% Также существует множество команд, выполняющих более сложные действия.
% Их формы не так разнообразны, а~неявным операндом является вершина стека~$st(0)$ и,~при необходимости, $st(1)$.

\subsection{Основные арифметические команды}
\index{Команды!сопроцессора!арифметические}
\epigraph{\begin{stanza}[0ex]
 Объясните  мне,  где  теперь  правда,  где  ложь, \\
 где  жало  змеи, где пылающий   уголь,  где  тюрьма.
\end{stanza}}
{\Aquarium}
Основные арифметические команды сопроцессора выполняют базовые бинарные арифметические операции "--- сложение, вычитание, умножение и~деление.
Хотя бы один операнд должен быть %в~стеке сопроцессора.
в~вершине стека сопроцессора~$st(0)$.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.
Приёмник должен быть в~стеке сопроцессора, но не обязательно на его вершине. %, таким образом, .


Каждая из основных арифметических команд может быть записана в~нескольких формах. %, подробнее описанных в~следующем подразделе.
Они различаются  положением источника и~приёмника, также некоторые из форм после вычисления результата выталкивают источник из стека сопроцессора, что обозначается суффиксом~\lstinline!p!.

\subsubsection{Обозначения основных арифметических команд}

Четырём арифметическим операциям в~FPU соответствует шесть различных %команд
операций. %и~может быть
При этом каждой из симметричных относительно перестановки операндов арифметических операций
"--- сложению и~вычитанию "--- соответствует по одной операции FPU: сложение \lstinline!fadd! и~умножение \lstinline!fmul!.
Несимметричным операциям "--- вычитанию и~делению "--- соответствует по две операции FPU, отличающиеся порядком операндов.
Это соответственно прямое вычитание \lstinline!fsub! и~обратное вычитание~\lstinline!fsubr!, а~также прямое деление \lstinline!fdiv! и~обратное деление~\lstinline!fdivr! (таблица \ref{tab:fpu-ar-list}).

Все формы основных арифметических команд используют два явно или неявно заданных операнда.
Один из них всегда в~вершине стека~$st(0)$, другой (обозначим его~$\xi$) может быть в~памяти или в~регистре~$st(i)$.
Кроме того, один из этих операндов является приёмником~$dest$, второй "--- источником~$src$.



\begin{table}[!ht]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arcommon-mnemlist.tex}

*
%Один из операндов всегда находится на вершине стека~$st(0)$.
% Обозначим другой операнд как~$x$.
$\xi$ "--- операнд, не лежащий на~вершине стека.

Может быть как источником, так и~приёмником, в~зависимости от используемой формы.

\end{table}

% 
% Мнемоника команды состоит из префикса FPU \lstinline!f!, опционального 

\warning{ 
Внимание!

Ассемблер Unix исторически использовал для основных арифметических команд FPU те же мнемонические обозначения, что и~предложенные Intel, но другую семантику операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
% в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel %и~большинстве учебников.
и~учебниках, описывающих синтаксис Intel.
}

% \subsubsection{Различие арифметических команд Intel и~\Att}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
% всегда
% , в~том числе
% в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
\label{sec:fpu-trouble-with-fsub}
% в~таком случае 
% для двух регистров
вычисляет $st(0) - \xi$ 
% независимо от того, какой из этих регистров является приёмником
даже в~том случае, если приёмником является $\xi$.
% (это возможно, если~$xi$ "--- регистр~$st(i)$).
В~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры. 
Обратное вычитание~\lstinline!fsubr! вычисляет $\xi - st(0)$.



% Соответственно, шесть форм команды прямого вычитания \lstinline$fsub$ и~обратного вычитания \lstinline$fsubr$ в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-fsub-r-typelist}.
% 
% \begin{table}[!ht]
% \caption{Прямое и~обратное вычитание в~синтаксисе \Att}
% \label{tab:fpu-fsub-r-typelist}
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-fsub-r-typelist.tex}
% 
% \end{table}


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!~\cite{trouble-with-fsub}.
Анализ сгенерированного компилятором из коллекции GCC кода это подтверждает.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.
% 
% Приёмником, в~соответствии с~синтаксисом \Att, является второй аргумент.
% Если команда вызывается с~одним аргументом или без них, то приёмником является $st(0)$, что соответствует документации Intel.
% Таким образом,
% % Соответственно, 
% шесть форм несимметричных операций (вычитания и~деления) в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-att-r-typelist}.
% 
% \begin{table}[!ht]
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-att-r-typelist.tex}
% 
% \end{table}
% 
Такое поведение в~случае сочетания синтаксиса AT\&T и~платформы x86 в~некоторых источниках описывается как баг GCC~\cite{sourceware-i386_002dBugs}, но из соображений совместимости с~имеющимся кодом меняться не будет.
% Из-за него, кроме всего прочего, в~GCC для всех основных арифметических команд доступна <<нелегальная>> седьмая форма записи, например, \lstinline!fsubp %st(i), %st(0)!.
% Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)! (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
% Подобную некорректную форму лучше не использовать.

% Также большинство ассемблеров поддерживает формы \lstinline!fXXX %st(i)! и~\lstinline!fXXXp %st(i)!


Поведение Intel и~GAS совпадает в~тех случаях, когда приёмником является~$st(0)$, в~том числе в~ситуациях, когда источник находится в~памяти.
% 
Также поведение Intel и~GAS полностью совпадает для симметричных операций "--- сложения и~умножения.


\subsubsection{Формы основных арифметических команд}

Согласно документации Intel, сопроцессор использует шесть  форм~\cite{frolov} основных арифметических команд (таблица~\ref{tab:fpu-arcommon-typelist}).
% На самом деле 
Строка XXX соответствует выполняемой операции %и~может быть
(\lstinline!add!, \lstinline!sub!, \lstinline!subr!, \lstinline!mul!, \lstinline!div!, \lstinline!divr!).


\begin{table}[!htpb]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arcommon-typelist.tex}

\end{table}
% \FloatBarrier

Если посмотреть на опкоды этих форм~\cite{intelInstructionSet}, видно, что опкод формы без параметров \lstinline!fXXXp!
полностью совпадает с~опкодом формы с~двумя параметрами~\lstinline!fXXXp %st(0), %st(1)!.
% то есть практически форм пять.
Напротив, формы \lstinline!f[i]add smem! для различной разрядности источника~$smem$ имеют по два различных опкода.

% \newcommand{\faddform}[1]{\hspace*{0pt}\rlap{{#1}}\phantom{\texttt{faddp \%st(0), \%st(i)}}}


% Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
% Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
В~частности, для операции сложения \lstinline!fadd! возможны следующие формы:
\begin{alphenumerate}[wide=\parindent]
\item \lstinline!faddp!
выполняет сложение $st(1) = st(0) + st(1)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(0)$	
(эквивалент \lstinline!faddp %st(0), %st(1)!);
\item \lstinline!fadd  smem!	"--- $st(0) = st(0) + \text{вещественное}~smem$;
\item \lstinline!fiadd smem!	"--- $st(0) = st(0) + \text{целое}~smem$;
\item \lstinline!fadd  %st(i), %st(0)!	"--- $st(0) = st(0) + st(i)$;
\item \lstinline!fadd  %st(0), %st(i)! "--- $st(i) = st(0) + st(i)$;
\item \lstinline!faddp %st(0), %st(i)!\ "---\ $st(i) = st(0) + st(i)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{alphenumerate}


Большинство ассемблеров, в~частности, GAS, поддерживает
и~некоторые дополнительные формы основных арифметических команд,
оба операнда которых находятся в~стеке.
В~частности,
для формы без операндов \lstinline!fXXXp! практически во всех ассемблерах принят синоним~\lstinline!fXXX!.
% Форма \lstinline!fXXX! без аргумента допустима (эквивалентна \lstinline!fXXXp!), но,~
Но,  так как мнемоника без суффикса~\lstinline!p! не~отражает выполняемое выталкивание $st(0)$  из~стека, её использование не~рекомендуется.

Кроме того, по аналогии с~\lstinline!fXXX smem! поддерживается
% для всех основных арифметических команд  форму 
форма \lstinline!fXXX %st(i)!
с~приёмником в~$st(0)$, а~также \lstinline!fXXXp %st(i)! с~приёмником изначально в~$st(i)$, а~после выталкивания $st(0)$ "--- в~$st(i-1)$.

% Из-за него, кроме всего прочего, 
В~GAS, кроме всего прочего, доступна 
<<нелегальная>> %седьмая 
форма записи~\lstinline!fXXXp %st(i), %st(0)!, например, \lstinline!fsubp %st(i), %st(0)!.
Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)!.
% (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), 
% то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
% Подобную некорректную форму лучше не использовать.

Подобные формы лучше не использовать из-за неочевидности расположения операндов.
При этом неуказание части операндов в~программе не даёт преимущества в~исполняемом файле, так как любая форма
% арифметической команды с~операндами в~регистрах FPU 
из перечисленных дополнительных форм арифметических команд
будет ассемблироваться в~тот же опкод, что и~форма с~двумя явно указанными операндами.



Ниже показан 
пример использования 
основных арифметических команд для расчёта значения выражения $x + \frac{1}{i} + a \cdot \pi$, где $x$ и~$i$ "--- значения переменных (листинг~\ref{lst:asm:fpu:add-mul}).
% 
Так как используется GAS, \lstinline!fdivr! рассчитывает %прямое деление 
$st(1)/st(0)$, после чего источник $st(0)$ выталкивается из стека.

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = \frac{1}{i} + a \cdot \pi$}, label=lst:asm:fpu:add-mul]
const double a = 0.01;
double x = 5, y;
int i = 10;
asm(                           //          st(0),    st(1), st(2), st(3)
    "fldl %[x]\n"              // в стеке: x
    "fldpi\n"                  // в стеке: pi,       x
    "fld1\n"                   // в стеке: 1,        pi,    x
    "fildl %[i]\n"             // в стеке: i,        1,     pi,    x
    "fdivr\n"                  // в стеке: 1/i,      pi,    x
    "fldl  %[A]\n"             // в стеке: A,        1/i,   pi,    x
    "fmulp %%st(0), %%st(2)\n" // в стеке: 1/i,      pi*A,  x
    "faddp\n"                  // в стеке: 1/i+pi*A, x
    "faddp\n"                  // в стеке: 1/i+pi*A+x
    "fstpl %[y]\n"             // y = 1/i + pi*A + x, стек пуст

    :[y]"=m"(y)
    :[x]"m"(x), [A]"m"(a), [i]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}
Приведённый код "--- не единственный способ расчёта значения указанного выражения.
% Как порядок вычислений, так и~используемые команды могут различаться.
В~зависимости от того, в~каком порядке программист будет рассчитывать компоненты выражения, может различаться как порядок команд, так и~сами команды.


\subsection{Дополнительные арифметические и~трансцендентные команды}
\epigraph{\begin{stanza}[0ex]
Кто бы ты ни был, куда б ты ни шёл,\\
Ты неподвижен "--- ты ось круговерти.\\
\end{stanza}}
{О.\,Арефьева}

% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX} 


Дополнительные арифметические и~трансцендентные команды~\cite{zubkov, intelInstructionSet} работают с~вершиной стека $st(0)$ и,~при необходимости, с~$st(1)$. Они не имеют явных операндов. % и~соответствующих пяти форм.
Соответственно, каждая из команд этой группы имеет только одну форму.


Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице \ref{tab:fpu-arex-list}.
\index{Команды!сопроцессора!трансцендентные}
\index{Команды!сопроцессора!дополнительные}

\begin{table}[p]
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-arex-list.tex}

\end{table}


Использование этих команд не перезаписывает значения, лежащие в~стеке ниже неявных аргументов. 
Если у~команды только один аргумент в~$st(0)$ и~один результат, результат записывается в~$st(0)$ на место аргумента.
Если у~команды один аргумент в~$st(0)$ и~два результата (\lstinline$fptan$, \lstinline$fsincos$ и т.\,д.), то один из результатов помещается в~$st(0)$, второй затем помещается в~стек сверху (так что первый результат оказывается в~$st(1)$, второй "--- в~$st(0)$).
% В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом (или наоборот "--- с~одним аргументом $st(0)$ и~двумя результатами)
% изменятся номера нижележащих значений, но ни одно значение, кроме аргументов, не исчезнет и~не появится ни одной «дырки».
% Если результатом выполнения команды являются два числа, а~аргументом "--- $st(0)$, одно из %них 
% полученных значений заменяет аргумент в~$st(0)$, другое помещается сверху, так что 

В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом
чаще всего результат помещается в~$st(1)$, затем $st(0)$ выталкивается из стека, так что после этой операции результат оказывается в~$st(0)$. 
Таким образом, результат замещает собой аргументы (в~таблице~\ref{tab:fpu-arex-list} такая ситуация соответствует обозначению $\big[st(1)\to st(0)\big]$ для результата).

Иногда (в~частности, \lstinline$fscale$) команда с~двумя аргументами в~$st(0)$ и~$st(1)$ записывает результат в~$st(0)$, оставляя аргумент в~$st(1)$ в~стеке.

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
% Если операнд выходит за эти пределы, флаг С2 устанавливается в 1, значение st(0) и~стек не изменяются. 



Пример использования тригонометрических команд для расчёта значения выражения $a\cdot\cos(x) + \sin(x)$ показан в~листинге~\ref{lst:asm:fpu:sinsos}.

\begin{lstlisting}[style=lstsmall,xleftmargin=0mm, caption={Расчёт $y = a\cdot\cos(x) + \sin(x)$}, label=lst:asm:fpu:sinsos]
const double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[X]\n" // st(0) = %[X]
    "fsincos\n"     // st(0) = cos(%[X]), st(1) = sin(%[X])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[X]), st(1) = sin(%[X])
    "fadd\n"        // st(0) = %[A]*cos(%[X]) + sin(%[X])
    "fstpl %[Y]\n"// %[Y] = %[A]*cos(%[X]) + sin(%[X]) стек пуст

    :[Y]"=m"(y)
    :[X]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}

\subsection{Сравнение вещественных чисел}
\label{sec:fpu-cmp}
\epigraph{\begin{stanza}[0mm]
Я крушу зеркала, чтоб не видеть, как смотрит двойник; \\
Зеркала, разбиваясь, сочатся багровым и алым.\\
\end{stanza}}{С. Калугин}

FPU включает несколько семейств команд сравнения вещественных чисел.
Все они сравнивают приёмник $st(0)$ с~некоторым источником $src$. 
По аналогии с~командой целочисленного сравнения можно сказать, что анализируется знак разности~$st(0)-src$.
Так как приёмником является~$st(0)$, поведение команд сравнения не различается для GAS и~Intel.


Некоторые из них помещают результат в~слове состояния~$sw$, откуда его надо вручную копировать в~регистр флагов~$flags$ (при этом осмысленное значение приобретают $ZF, CF, PF$),
некоторые "--- непосредственно во флагах $ZF, CF, PF$ регистра~$flags$.

Также система команд FPU включает~\lstinline!fxam!, которая определяет вид значения в~$st(0)$ в~соответствии с~разделом~\ref{sec:valueclasses}.

Знак нуля при сравнении не учитывается, то есть считается, что 	$-0=+0$.


\subsubsection{Команды сравнения}
% \footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается

\index{Команды!сравнения!вещественных чисел}
\index{Команды!сопроцессора!сравнения}

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

% В~таблице~\ref{tab:fpu-cmp-list} приводится сводная информация по семействам команд сравнения FPU.
Все команды сравнения вещественных чисел~\cite{club155} сравнивают вершину стека "--- приёмник $st(0)$ с~другим операндом  "--- источником $src$
% , который может 
(таблица~\ref{tab:fpu-cmp-list}).

\begin{table}[ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-list.tex}
\end{table}

По результатам сравнения  (в~соответствии со знаком разности~$st(0)-src$) устанавливается значение трёх флагов:
% флаг отрицательности, флаг нуля и~флаг несравнимости 
% в~соответствии с~таблицей~\ref{tab:fpu-cmp-flags}.
отрицательности, нуля и~несравнимости (таблица~\ref{tab:fpu-cmp-flags}).
Операнды считаются несравнимыми, если хотя бы один из них "--- тихое нечисло (обычно 
вещественная неопределённость~$nan$).

\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}
\end{table}

Действие команд сравнения одинаково для синтаксиса AT\&T и~синтаксиса Intel.
% 
Мнемоника может включать суффикс~\lstinline!p!, в~этом случае приёмник~$st(0)$ после сравнения выталкивается из стека.
Если явный операнд не задан (то есть источником считается~$st(1)$), может также использоваться суффикс \lstinline!pp! "--- в~этом случае после сравнения из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$.
% 
Если источник задан явно и~находится в~памяти, необходимо указывать также суффикс размера по тем же правилам, что и~для арифметических команд.

Если хотя бы одно из сравниваемых значений "--- нечисло,
для б\'{о}льшей части команд сравнения (без префикса~\lstinline!u!) это недействительная арифметическая операция \#IA.
Если соответствующее исключение не замаскировано (раздел~\ref{sec:fpu:cw-mask}), работа программы прерывается,
% так что флаг несравнимости не устанавливается.
если замаскировано "--- устанавливается флаг несравнимости.
% 
Команды неупорядоченного сравнения, мнемоники которых включают префикс~\lstinline!u!,
% после префикса FPU~\lstinline!f!,
% не генерируют исключений при сравнении тихих нечисел,  в~частности, вещественной неопределённости, так что флаг несравнимости для~$nan$ устанавливается при любом наборе масок в~управляющем слове~$cw$.
считают операцию сравнения с~тихим нечислом,  в~частности, вещественной неопределённостью, действительной, и~устанавливают в~этом случае флаг несравнимости.
% вне зависимости от маски~$IM$.
% 
Если хотя бы одно из сравниваемых значений "--- неподдерживаемое значение или сигнальное нечисло, операция сравнения недействительна (\#IA) для всех команд.

По набору используемых флагов команды сравнения делятся на две группы "--- часть их выставляет биты слова состояния~$sw$ ($C3, C0$ и~$C2$),
часть "--- биты регистра~$flags$ ($CF, ZF$ и~$PF$).

В~слове состояния сопроцессора~$sw$ результат сохраняют
команды сравнения оригинального FPU 8087 и~80387.
% (\texttt{fcom, fcomp, fcompp, ftst}) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (\texttt{fucom, fucomp, fucompp}).
% % , не генерирующее исключений при сравнении некоторых нечисел, 
% сохраняют результат сравнения в~биты $C3, C0$ и,~в~случае несравнимости операндов, в~бит~$C2$ слова состояния.
% % \pagebreak[3]
% Для анализа результата сравнения
% в~этом случае
% % вещественных чисел в~ранних (отдельных) моделях сопроцессора было 
% необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  
% \pagebreak[3]
% После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.
%  
В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.
% 
Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (\texttt{fcomi, fcomip, fucomi, fucomip}), которые напрямую устанавливают флаги $ZF, CF, PF$ в~$flags$.
% Эти команды не изменяют биты $C0,  C3, C2$ регистра~$sw$.
% и~не дублируют туда результат сравнения.
Неиспользуемые три флага состояния $flags$ сбрасываются в~$0$; биты $C0, C2,  C3$ слова состояния сопроцессора не изменяются.

% \subsubsection{Флаги сравнения}
% % \subsubsection{Сравнение вещественных чисел}
% \index{Флаги!установка}
% 
% Команды сравнения выставляют значения трёх флагов в~соответствии с~результатом сравнения $st(0)$ и~$src$ (знаком разности~$st(0)-src$):
% флаг отрицательности, флаг нуля и~флаг несравнимости (таблица~\ref{tab:fpu-cmp-flags}).
% 
% 
% \begin{table}[!ht]
% \small\def\normalsize{\small}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% \LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}
% \end{table}


Если при сравнении целых чисел выставляется значение %флагов из того же набора,
тех же флагов, которые выставляются по результатам арифметических действий,
то в~FPU %флаги сравнения и~флаги, выставляемые при вычислениях, разделены.
% Арифметические и~трансцендентные команды влияют на флаги исключительных ситуаций;
% команды сравнения "--- на специальную группу флагов.
флаги, выставляемые командами сравнения, отличаются от тех, что устанавливаются, в~частности, при вычитании.

\subsubsection{Анализ результатов сравнения}

Условные команды, даже из набора FPU, не могут анализировать флаги слова состояния FPU~$sw$.
Соответственно, если используется одна из старых команд сравнения, сохраняющая результат в~$cw$, после её выполнения
% Для анализа результата сравнения
% в~этом случае
% % вещественных чисел в~ранних (отдельных) моделях сопроцессора было 
необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  


Это выполняется в~два этапа:
\begin{itemize}
\item 
% \index{Команды!fstsw}
\index{Команды!fnstsw}
\index{Команды!sahf}
слово состояния $sw$ выгружается в~регистр $ax$ 
% командами \lstinline!fstsw! (проверяет на наличие отложенных необработанных исключений) или~\lstinline!fnstsw! (также данные команды могут выгрузить $sw$  в~память);
командой~\lstinline!fnstsw!;
\item старший байт $ax$ загружается в~младший байт регистра флагов $flags$ командой \lstinline!sahf!.
\end{itemize}

% \subsubsection{Соответствие битов слова состояния FPU и~$flags$}



В~таблице~\ref{tab:fpu-status} представлено краткое описание структуры слова состояния, а~также соответствие старшего байта слова состояния сопроцессора $sw$ и~младшего байта регистра флагов основного процессора~$flags$.

% \colorlet{csControl}{green!50}
% \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% \colorlet{csSystem}{blue!20!red!10}


\begin{table}[!ht]
\caption{Слово состояния FPU}
\label{tab:fpu-status}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{$sw$}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}$flags$, fnstsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{clFlagStatus}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{clFlagStatus}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{clFlagSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{clFlagSystem}12 	& 	&&\cellcolor{clFlagStatus}4 	&\cellcolor{clFlagStatus}AF 	&\cellcolor{clFlagStatus}Auxiliary Carry Flag\\
\rowcolor{clFlagSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{clFlagExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\end{table}

\pagebreak[3]
%слово состояния $sw$ могло быть выгружено в~память или регистр $ax$ командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки $sw$ в~регистр $ax$ его старший байт загружал

% Таким образом, после выполнения команды сравнения (%и~%пары команд 
% % \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% % или при использовании совместимых с~ними 
% при использовании совместимых с~ранними моделями 
% команд %f*com[p[p]]
% без суффикса~\lstinline!i! 
% необходимы также \lstinline!fnstsw %ax! + \lstinline!sahf!)
% результат  можно 
% анализировать как результат сравнения беззнаковых целых чисел.
% 
% 
% После этого значение $C3$ помещается в~аналогичный ему по смыслу флаг нуля $ZF$ ($st(0) - src = 0$), $C0$ "--- в~флаг переноса~$CF$ ($st(0) - src < 0$),
% то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
% Бит несравнимости $C2$ попадает на место флага чётности~$PF$. 

Как видно из таблицы, при загрузке старшего байта~$sw$ во~$flags$
флаг отрицательности~$C0$ помещается во флаг беззнакового переполнения~$CF$,
флаг нуля~$C3$ "--- в~аналогичный ему по смыслу $ZF$,
а~флаг несравнимости $C2$ "--- во флаг чётности $PF$. 
Другие флаги младшего байта~$flags$ получают фактически неопределённое значение.
% 
Таким образом, результат можно анализировать как результат сравнения беззнаковых целых чисел.


% После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
% Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.

Результат современных команды сравнения, напрямую устанавливающих флаги $ZF, CF, PF$ и~обнуляющих остальные флаги состояния в~регистре~$flags$,
можно анализировать как результат сравнения беззнаковых целых чисел без дополнительных действий.


\subsubsection{Определение вида значения}


Кроме команд сравнения, анализирующих разность двух значений $st(0)-src$ как число,
набор команд FPU включает также команду~\lstinline!fxam!, которая анализирует содержимое вершины стека.
% При этом определяются

Команда~\lstinline!fxam! выставляет  в~соответствии с~значением~$st(0)$
все четыре специальных флага $C0-C3$ слова состояния $sw$
 (таблица~\ref{tab:fpu-xam-flags}).



% \bottompagebreak[80mm]

% регистром тегов (в~частности, теги определяют, пуст ли регистр $r_{top}$, соответствующий вершине стека~$st(0)$) и~содержимым~$r_{top}$
 
Флаг~$C2$ всегда устанавливается равным знаковому биту~%$r_{top}$, даже если согласно тегам этот регистр пуст или 
$st(0)$, даже
если в~нём находится значение, не имеющее знака (вещественная неопределённость или неподдерживаемое значение).
% \bottompagebreak

Флаги сравнения $C0, C3, C2$ получают значения в~соответствии с~таблицей~\ref{tab:fpu-xam-flags}.

% \FloatBarrier
\bottompagebreak[8ex]

\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-xam-flags.tex}
\end{table}

% \bottompagebreak

Команда~\lstinline!fxam! корректно работает даже при пустом стеке.
Если регистр данных $r_{top}$, соответствующий вершине стека, помечен в~регистре тегов~$tw$ как пустой, % (то есть ), 
флаги  $C0, C3, C2$ получают значения, указанные в~последней строке таблицы~\ref{tab:fpu-xam-flags},
а~$C2$ "--- значение знакового бита~$r_{top}$.

Если $st(0)$ не пуст, флаги  $C0, C3, C2$ соответствуют виду содержащегося в~нём значения (раздел~\ref{sec:valueclasses}).

% Конечным значениям~$st(0)$ соответствует нулевое значение~$C0$