% восстанавливаем стиль block
\input{\COMMONPATH/4espdblocks.tex}



% \section{Простые вычисления}
% \epigraph{
% Конструктор Трурль построил однажды мыслящую машину "--- девятиэтажную; окончив самую важную работу, он покрыл машину белым лаком, 
% наугольники покрасил в~лиловый цвет, пригляделся потом издали и~добавил еще небольшой узорчик на фасаде, а~там, где можно было вообразить лоб машины, провёл тонкую оранжевую чёрточку и, очень довольный собой, небрежно посвистывая, задал порядка ради сакраментальный вопрос: сколько будет дважды два?
% }{С.\,Лем}



% \section{Ветвления и~циклы}






\section{Программирование нелинейных алгоритмов и~взаимодействие со структурами данных}
\label{sec:asm-alg}

\epigraph{\begin{stanza}
В~действительности всё не так, как на самом деле.
\end{stanza}}
{%Станислав Ежи Лец (а~может быть, и~Антуан де Сент-Экзюпери)
% уже фольклор
Приписывается Станиславу~Ежи~Лецу и~Антуану~де~Сент-Экзюпери.
Фольклор, в~общем
}

В~языках высокого уровня существуют
% такие алгоритмические конструкции, как ветвления и~циклы,
операторы цикла и~условные операторы,
используемые для реализации нелинейных алгоритмов.
% Они, как и~
% Язык ассемблера не
Система машинных команд предлагает 
только команды условного и~безусловного перехода 
(хотя в~наборе команд x86 есть команда \lstinline!loop!, 
\index{Команды!loop}%
она 
% также является командой условного перехода, а~не цикла, 
не является полноценным аналогом цикла,
к~тому же не рекомендуется к~использованию из-за медленной работы).

Тем не менее, с~помощью команд перехода можно реализовать все нелинейные алгоритмические конструкции,
а~режим косвенной адресации позволяет обращаться к~элементам составных структур данных.
% 
Для визуализации нелинейных алгоритмов воспользуемся схемами программы~\cite{espd-alg}.

\subsection{Условие с~операторами в~одной ветви}
\epigraph{\begin{stanza}[0mm]
Мне нужно было всё, а иначе "--- нет.\\
Образцовый нищий, у Галери Лафайет;\\
Но я смотрел на эту ветку сорок пять лет,\\
\hspace{\stanzaoddindent}В конце концов, она взяла и взлетела. \\
\end{stanza}}
{\Aquarium}

Пусть необходимо заменить значение целой знаковой переменной $x$ нулём, если   оно отрицательно.
\begin{equation}
\label{eq:asm-alg:if}
x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.
\end{equation}

На языке C++ код, решающий эту задачу, будет использовать условный оператор (листинг~\ref{lst:asm:alg:if-cpp}).
\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if}, C++}, label=lst:asm:alg:if-cpp]
if (x < 0)
{
  x = 0;
}
\end{lstlisting}

Так как условный оператор включает только ветвь «да», а~в~ней "--- только простой оператор присваивания,
эту конкретную задачу можно решить с~помощью команд условной пересылки.
Начиная с~Pentium Pro, %добавлены команды  условной пересылки: Для более быстрой реализации подобных ветвлений (присваивания по условию) 
это наиболее быстрый способ присваивания по условию.

Кроме того, 
можно воспользоваться командой условного перехода для обхода кода ветви «да» в~случае, когда условие не выполнено.
Этот способ не только поддерживается начиная с~оригинального 8086, но и~универсален.
Так можно реализовать условный оператор со сколь угодно сложным кодом внутри.


\subsubsection{Условная пересылка}
\index{Команды!cmp}%
\index{Команды!cmovCC}%


% Данную задачу можно также решить с~помощью команд условной пересылки:
% Для более быстрой реализации подобных ветвлений (присваивания по условию) начиная с~Pentium Pro добавлены команды  условной пересылки:
Сравним $x$ с~нулём (оценим знак разности $x -0$).
Присваивание необходимо выполнить в~случае, когда $x < 0$ как знаковое.
Это соответствует условию~\lstinline!l! (\ethm{if less}) или, что то же самое, \lstinline!nge! (\ethm{if not greater or equal}).
С учётом размера типа~$int$ можно также добавить суффикс размера~\lstinline!l! (листинг~\ref{lst:asm:alg:if-cmov}).

\begin{lstlisting}[style=lstsmall, caption={Условие \eqref{eq:asm-alg:if}, \texttt{cmovCC}}, label=lst:asm:alg:if-cmov]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "cmovngel %[Zero], %[X]\n"
  : [X]"+r"(x)
  : [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Так как источником для команды \lstinline!cmovCC! не может быть константа, вводится входной параметр \lstinline![Zero]!, расположенный в~памяти или регистре и~равный нулю.

\subsubsection{Обход части операторов с~помощью команд условного перехода}

Построим схему алгоритма (рис.~\ref{ris:if}, а) для решения этой задачи.

\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\coordinate[right=  of is_positive] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);

\node[block,on chain=alg_start, join={node[right]{нет}}] (is_positive_no_op) {$x = 0$};
\coordinate[below = of is_positive_no_op] (to_end);

\path[blockarrow] (is_positive_yes) |- (to_end);
\node[terminator, on chain=alg_start, below = of to_end, join/.style=blockarrow] (end) {Конец}; % Удаляет линию вообще
\path[blockarrow] (is_positive_no_op) -- (end);


\coordinate[right=  of is_positive_yes] (asm_coord);

% \node[asm] at (start-|asm_coord) {
%   \begin{lstlisting}
%   int x;
%   asm
%   (
%       "movl $12, %[X]\n"
%       :[X]"=rm"(x)
%   );
%   \end{lstlisting}
%   };

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = -6;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "cmpl $0, %[X]\n"
  "jge end_check\n"
\end{lstlisting}
};
\node[asm] at (is_positive_no_op-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "movl $0, %[X]\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end.south-|asm_coord) (asm-end) {
\begin{lstlisting}[firstnumber=last]
  : [X]"+rm"(x)
  : : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};

\end{tikzpicture}
}
\index{Команды!cmp}%
\index{Команды!jCC}%

\caption{Алгоритм и~реализация ветвления с~операторами в~одной ветви}
\label{ris:if}
\end{illustration}


В~отличие от операторов  \lstinline!if! большинства языков высокого уровня,
ветвь, где должны выполняться операторы, лучше сделать ветвью «нет» (таким образом, по ветви «да» будет выполняться обход части программы).

Построим по данной схеме программу  (рис.~\ref{ris:if}, б). 
Основная вертикаль схемы будет соответствовать последовательности команд в~памяти,
потоки, отходящие от вертикали "--- командам передачи управления,
потоки, входящие в~основную вертикаль "--- меткам, на которые передаётся управление.
Если команда не является командой передачи управления, после неё выполняется непосредственно следующая, что соответствует движению вниз по основной вертикали.

Каждому  блоку процесса здесь будет соответствовать линейный фрагмент кода (строка 6); 
блок решения включает установку флагов и~завершится условным переходом по метке (строки 4-5); точка соединения двух потоков соответствует метке на строке~7.

Подобным способом можно реализовать условный оператор со сколь угодно объёмным кодом только в~одной ветви.
Необходимый код помещается на место строки~7, между командой условного обхода ветви и~соответствующей меткой.


\subsection{Условие с~операторами в~двух ветвях}
\epigraph{\begin{stanza}[0mm]
Человеческая жизнь имеет более одного аспекта;\\
В городе Таганроге есть два Звёздных проспекта...\\
\end{stanza}}
{\Aquarium}
Пусть в~зависимости от условия необходимо выполнить один из двух операторов:
\begin{equation}
\label{eq:asm-alg:if-else}
y(x) = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.
\end{equation}


На языке C++ код, решающий эту задачу, будет использовать условный оператор с~двумя ветвями (листинг~\ref{lst:asm:alg:if-else-cpp}).
\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if-else}, C++}, label=lst:asm:alg:if-else-cpp]
if (x >= 0)
{
  y = 1;
}
else
{
  y = 0;
}
\end{lstlisting}
Из-за специфического кода ветвей данную задачу можно решить на ассемблере тремя способами.

\subsubsection{Условная установка байта}
\index{Команды!cmp}%
\index{Команды!setCC}%

% Для данных значений (
Так как 
$y$ равен либо нулю, либо единице, задачу можно  решить с~помощью команды условной установки байта.

Единичное значение $y$ соответствует случаю, когда $x \geqslant 0$ как знаковое (\ethm{if greater or equal}), то есть мнемоника условия может быть записана как \lstinline!ge!.

\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if-else}, \texttt{setCC}}, label=lst:asm:alg:if-else-setCC]
int x = -7, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $0, %[Y]\n"
  "setgeb %[Y]\n"
  :[Y]"=m"(y)
  :[X]"rm"(x)
  : "cc"
);
\end{lstlisting}
Здесь мы записываем ноль в~четырёхбайтовую переменную  \lstinline![Y]!, находящуюся в~памяти (это не изменяет флагов), а~затем устанавливаем по условию её младший байт (так как платформа x86 использует  порядок байтов Intel, адрес младшего байта \lstinline![Y]! совпадает с~адресом \lstinline![Y]!).
Оба возможных значения $y$ неотрицательны, поэтому дополнение нулями является корректным расширением и~для знаковой, и~для беззнаковой их~интерпретации.

Также можно было 
использовать для хранения параметра \lstinline![Y]! регистр~$A$,
установить по условию байт  $al$ и~специальными командами расширить его вначале до $ax$, а~затем до четырёхбайтового~$eax$.

При использовании для $y$ однобайтового типа \lstinline!char! вместо четырёхбайтового \lstinline!int! расширение не будет нужным.



\subsubsection{Условная пересылка}
\index{Команды!cmp}%
\index{Команды!cmovCC}%


Данную задачу также можно  решить с~помощью команд условной пересылки.
Для подобного задания такая реализация будет компактнее и~быстрее. 
% \pagebreak[3]

\begin{lstlisting}[caption={Условие \eqref{eq:asm-alg:if-else}, \texttt{cmovCC}}, label=lst:asm:alg:if-else-cmovCC]
int x = 10, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $1, %[Y]\n"
  "cmovll %[Zero], %[Y]\n"
  : [Y]"+r"(y)
  : [X]"rm"(x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Здесь параметр \lstinline![Y]! объявлен как выходной с~начальным значением, хотя, казалось бы, его исходное значение нам не требуется.
Это сделано, чтобы компилятор не совместил его с~входным параметром  \lstinline![Zero]! (совмещение с~входным параметром \lstinline![X]! не повредит выполнению, так как значение \lstinline![X]! используется только для сравнения с~литералом \lstinline!$0!, до первого присваивания \lstinline![Y]!).
Если %не указать \lstinline![Y]! в~списке входных и~он 
\lstinline![Y]! будет совмещён с~\lstinline![Zero]!, мы всегда получим на выходе $y=1$.

\pagebreak[3]

\subsubsection{Обход части операторов с~помощью команд условного перехода}

% Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи, выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, в).
% 
% Потоки, выходящие за пределы основной линии "--- условные и~безусловные  переходы, точки входа таких потоков-переходов в~основной вертикальный поток "--- метки.


Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи и~затем выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б).

\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\tikzset{every join/.style=blockarrow}

\coordinate[right= of is_positive, on chain=if_yes] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);
\node[block,on chain=if_yes] (yes_op) {$y = 1$};

\coordinate[left=  of is_positive, on chain=if_no] (is_positive_no);
\path[blockline] (is_positive) -- node[auto, swap] {нет} (is_positive_no);
\node[block,on chain=if_no] (no_op) {$y = 0$};

\coordinate[below = of yes_op] (to_end_y);

\coordinate[on chain=alg_end, join/.style={}] (to_end) at (to_end_y-|start);
\path[blockline] (yes_op) |- (to_end);
\path[blockline] (no_op) |- (to_end);

\node[terminator, on chain=alg_end, below = of to_end] (end) {Конец};
% \path[blockarrow] (to_end) -- (end);



\tikzset{every join/.style=blockline}


\coordinate[right= 6em of yes_op] (squeeze_coord);

\node[terminator,on chain=squeeze_start] (start2) at (start-|squeeze_coord) {Начало};

\node[decision,on chain=squeeze_start] (is_positive2) {$x\geqslant0$};

\node[block,   on chain=squeeze_start, join={node[right]{нет}}] (no_op2) {$y = 0$};
\coordinate[on chain=squeeze_start] (to_end_no2);


\coordinate[right= of is_positive2] (is_positive_yes2);
\path[blockline] (is_positive2) -- node[auto] {да} (is_positive_yes2);
\tikzset{every join/.style=nodraw}
\coordinate[on chain=squeeze_start] (non-used);

\coordinate[on chain=squeeze_start, join/.style={}] (to_yes2);
\node[block,   on chain=squeeze_start, join/.style={}] (yes_op2) {$y = 1$};
\tikzset{every join/.style=blockline}

\coordinate[on chain=squeeze_start] (to_end_yes2);
% \coordinate[on chain=squeeze_start] (non-used2);

\node[terminator, on chain=squeeze_start, join/.style={}] (end2) {Конец};

\path[blockarrow] (is_positive_yes2) |- (to_yes2) -- (yes_op2);

\coordinate[left=of yes_op2] (from_no_to_end2);
\path[blockline] (to_end_no2) -| (from_no_to_end2);
\path[blockarrow] (from_no_to_end2) |- (to_end_yes2);
\path[blockarrow] (to_end_yes2) -- (end2);



\coordinate[right=  of is_positive_yes2] (asm_coord);

\node[asm] at (start2-|asm_coord) {
\begin{lstlisting}
int x = -6, y;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "cmpl $0, %[X]\n"
  "jge setting_1\n"
\end{lstlisting}
};

\node[asm] at (no_op2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "movl $0, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (to_end_no2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "jmp end_check\n"
\end{lstlisting}
};


\node[asm] at (to_yes2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"setting_1:\n"
\end{lstlisting}
};

\node[asm] at (yes_op2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "movl $1, %[Y]\n"
\end{lstlisting}
};


\node[asm] at (to_end_yes2-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end2.south-|asm_coord) (asm-end) {
\begin{lstlisting}[firstnumber=last]
  :[Y]"=rm"(y)
  :[X]"rm" (x)  
  : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (end2|-lettersline) {б)};
\node at (asm-end|-lettersline) {в)};


\end{tikzpicture}
}
\index{Команды!cmp}%
\index{Команды!jCC}%
\index{Команды!jmp}%

\caption{Алгоритм и~реализация ветвления}
\label{ris:if-else}
\end{illustration}

Схема на рис.~\ref{ris:if-else}, б)  не вполне соответствует  ЕСПД
(стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости, так как схемы алгоритмов предназначены в~основном для чтения человеком)
но при таком расположении можно однозначно сопоставить расположение блоков на схеме и~расположение команд в~памяти.

У~схемы на рис.~\ref{ris:if-else}, а) два возможных варианта «вертикализации» "--- изображённый на рис.~\ref{ris:if-else}, б)
и~тот, где ветвь «да» окажется выше ветви «нет». Эти варианты равноправны и~оба приведут к~одинаково корректным, но различным между собой программам.
В~данном разделе рассматривается вариант рис.~\ref{ris:if-else}, б).

Сопоставим каждому блоку одну или несколько команд ассемблера.
В~этом случае излом потока (отход от базовой вертикали без ветвления) будет соответствовать безусловному переходу, блок решения включает вычисление условия и~условный переход, а~точки входа боковых потоков-переходов в~основной вертикальный поток соответствуют меткам (рис.~\ref{ris:if-else}, в).
% \pagebreak[3]

\index{Команды!jCC}%
Таким образом, код ветви «нет», расположенной на базовой вертикали первой, обходится с~помощью команды условного перехода, если условие $x \geqslant 0$ верно (\texttt{ge}, строка~5),
а~в~конце, после собственно кода ветви, вставлена команда безусловного перехода к~первой команде, которая будет выполнена независимо от условия, чтобы после ветви «нет» выполнение естественным путём не перешло к~ветви «да» (переход к~метке \texttt{end\_check:}, строка~7).
Сразу после этого начинается код ветви «нет» (метка \texttt{setting\_1}, строка~8). %; после её завершения 

Описанный способ наиболее универсален и~позволяет реализовать условный оператор со сколь угодно объёмным кодом ветвей.
Необходимый код ветвей «нет» и~«да» заместит соответственно строки~6 и~9.



% \subsection{Цикл с~предусловием}
\subsection{Цикл}
\epigraph{\begin{stanza}
Достаточно бросить здесь спичку, и огня будет уже не унять\\
В джунглях. 
\end{stanza}
}{\Aquarium}

Цикл "--- единственн%ый оператор языков 
ая алгоритмическая конструкция
высокого уровня,
позволяющая передать управление назад.
Соответственно, цикл на ассемблере можно реализовать только с~помощью команд передачи управления.


Пусть необходимо найти сумму двоичных цифр беззнакового числа $x$.


% Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, а), реализован цикл с~предусловием) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, б).

Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:while}, а), реализован цикл с~предусловием). 



\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\tikzstyle{asm}	= [text width=16em,text badly ragged, anchor=west]

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[block,on chain=alg_start] (init) {$count = 0$};

\coordinate[on chain=alg_start] (to_shift);
\tikzset{every join/.style=blockarrow}
\node[decision,on chain=alg_start] (is_zero) {$x=0$};
\tikzset{every join/.style=blockline}
\node[block,on chain=alg_start, join={node[right]{нет}}] (shift) {
$CF = x \And 1$

$x = (x>>1)$
};

\node[decision,on chain=alg_start] (is_last_bit) {$CF=1$};
\node[block,on chain=alg_start, join={node[right]{да}}] (inc) {$count = count+1$};
\coordinate[on chain=alg_start] (from_no_to_next_iter);
\coordinate[on chain=alg_start] (to_next_iter);
\tikzset{every join/.style=blockarrow}
\coordinate[left = of current bounding box] (to_next_iter_middle);
\path[blockarrow] (to_next_iter) -| (to_next_iter_middle) |- (to_shift);

\tikzset{every join/.style=nodraw}
% \coordinate[on chain=alg_start] (non-used);
\coordinate[on chain=alg_start] (to_end);
\node[terminator, on chain=alg_start] (end) {Конец};


\coordinate[right= of is_last_bit] (is_no_last_bit);
\path[blockarrow] (is_last_bit) -- node[auto] {нет} (is_no_last_bit) |- (from_no_to_next_iter);



\coordinate[right= of is_zero-|is_no_last_bit] (is_zero_yes);
\path[blockarrow] (is_zero) -- node[auto] {да} (is_zero_yes) |- (to_end) -- (end);



\coordinate[right=  of current bounding box] (asm_coord);

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = 7, count;
asm
(
\end{lstlisting}
};

\node[asm] at (to_shift-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"begin_iteration:\n"
\end{lstlisting}
};
\node[asm] at (init-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "xorl %[Count], %[Count]\n"
\end{lstlisting}
};
\node[asm] at (is_zero-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "cmpl $0, %[X]\n"
  "je end_loop\n"
\end{lstlisting}
};

\node[asm] at (shift-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "shrl $1, %[X]\n"
\end{lstlisting}
};

\node[asm] at (is_last_bit-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "jnc end_iteration\n"
\end{lstlisting}
};
\node[asm] at (inc-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
  "incl %[Count]\n"
\end{lstlisting}
};

\node[asm] at (from_no_to_next_iter-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_iteration:\n"
  "jmp begin_iteration\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}[firstnumber=last]
"end_loop:\n"
\end{lstlisting}
};

\node[asm] at (end-|asm_coord) (asm-end) {
\begin{lstlisting}[firstnumber=last]
:[Count]"=rm"(count),[X]"+rm"(x)
: : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};


\end{tikzpicture}
}
\index{Команды!xor}%
\index{Команды!shr}%
\index{Команды!cmp}%
\index{Команды!inc}%
\index{Команды!jmp}%
\index{Команды!jCC}%

\caption{Алгоритм и~реализация цикла}
\label{ris:while}
\end{illustration}

При соединении блоков ещё немного отступим от требований ЕСПД 
% (стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости)
и~отделим точку, где боковой поток случая $CF\neq 0$ входит в~основную вертикаль, от~точки, где поток отходит от вертикали, чтобы перейти назад к~началу итерации.
Расположение этих точек выберем так, чтобы поток основной вертикали на каждом её участке шёл в~естественном направлении "--- сверху вниз (это не только позволяет не~рисовать стрелку для обозначения направления, но и~соответствует выполнению %программы 
кода, не включающего команд передачи управления).


Теперь сопоставим каждому блоку одну или несколько команд ассемблера.
Отход потока от базовой вертикали будет соответствовать команде перехода, точки входа боковых потоков в~основной вертикальный  "--- меткам 
(рис.~\ref{ris:while}, б).

Цикл с~постусловием будет отличаться только на этапе построения схемы алгоритма.

Цикл с~параметром можно реализовать либо как цикл с~предусловием, как и~в~C/C++,
либо как цикл с~постусловием.

При этом, если счётчик цикла не является одновременно индексом массива в~памяти, имеет смысл
% организовать цикл
инициализировать счётчик максимальным значением $i = i_{max}$ и~уменьшать его на каждом шаге $i = i-1$.
Это позволит избавиться от команды сравнения, так как команды декремента и~вычитания не только изменяют операнд $i$, но и~выставляют флаги.
При переходе от~ненулевого значения к~$0$ получим $ZF=1$, при переходе от неотрицательного значения, в~частности нуля, к~отрицательному "--- $CF=1$ и~$SF\neq OF$.




















\subsection{Массивы}
\label{sec:arrays}
\epigraph{\begin{limerick}
Жил один старичок из Пенджаба,\\
Ему на ногу прыгнула жаба,\\
Впавши в~ярость и~гнев,\\
Он позвал сорок дев, "---\\
Чтобы выгнать всех жаб из Пенджаба.
\end{limerick}
}
{\Lear}


% \section{Одномерные массивы}
\index{Массивы!одномерные}%

Массив "---  структура данных в~виде набора однородных компонент (элементов массива), расположенных в памяти непосредственно друг за другом (независимо от настроек выравнивания). 
Элемент с~наименьшим индексом располагается по младшему адресу.
% 
Доступ к~отдельным элементам массива осуществляется с помощью индексации, то есть через ссылку на массив с~указанием номера (индекса) нужного элемента. 


В~языке C++ наименьший индекс массива всегда равен $0$, а~имя массива %фактически 
является константным указателем на его начало.
Таким образом, адрес $i$-го элемента массива $M$ равен $M + i\cdot size$, где~$size$ "--- размер одного элемента и,~в~случае, когда длина массива не равна нулю, может быть определён как \lstinline!sizeof(M[0])!.
% Если массив содержит элементы простых типов 
Для большинства простых типов
(\lstinline!char, bool, short, int, long, long long, float, double, size_t, ptrdiff_t, void*!)
этот размер как на 32-, так и~на 64-битной платформе равен~$1, 2, 4$ или~$8$.

Соответственно, в~ассемблере для получения элемента массива (если элементы массива имеют размер~$1, 2, 4$ или~$8$) будут использованы три из~четырёх компонент эффективного адреса \lstinline!displacement(base, index, multiplier)! "---  база (адрес начала массива~$M$), индекс и~масштаб (размер~элемента).
\index{Адресация!косвенная}%

В~частности, адрес $i$-го элемента массива  $M$ из~чисел типа \lstinline!int! на 32-разрядных и~многих 64-разрядных платформах равен $M + i\cdot 4$, и~элемент будет записан как~\lstinline!(M, i, 4)!. При этом база~$M$ и~индекс~$i$ должны быть 32-разрядны (на соответствующей платформе) и~располагаться в~регистрах.
\begin{lstlisting}[caption={Инициализация четырёхбайтового элемента массива~\texttt{M[i]}}, label=lst:asm:alg:mi4]
const int N = 8;
int M[N], i = 0;
asm
(
"movl $0, (%[M], %[I], 4)\n"
:[I]"+r"(i)
:[M]"r"(M)
:"memory"
);
\end{lstlisting}
Так как мы модифицируем во вставке элементы массива (а~не сами параметры \lstinline![I]! и~\lstinline![M]!), необходимо указать в~списке перезаписываемых элементов специальное значение \lstinline!"memory"!.

Для инициализации массива в~целом необходим цикл.
\index{Команды!xor}%
\index{Команды!cmp}%
\index{Команды!inc}%
\index{Команды!jmp}%
\index{Команды!jCC}%
В~листинге~\ref{lst:asm:alg:m4} показана инициализация нулями массива  из элементов типа~$int$ (на большинстве платформ он четырёхбайтовый) циклом с~предусловием, аналогичным циклу~\lstinline!for! языка C++.
\begin{lstlisting}[caption={Инициализация массива~\texttt{M} из четырёхбайтовых элементов}, label=lst:asm:alg:m4]
const int N = 8;
int M[N], i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"cmpl %[M_len], %[I]\n"
"jge end_loop\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"jmp begin_iteration\n"
"end_loop:\n"
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}
Действительно, при выводе массива~\texttt{M} мы увидим нули:
\begin{lstlisting}[numbers=none]
0 0 0 0 0 0 0 0 
\end{lstlisting}

Если в~массиве гарантированно есть хотя бы один элемент, можно сократить код, использовав постусловие (листинг~\ref{lst:asm:alg:m4-1}).
\begin{lstlisting}[caption={Инициализация непустого массива~\texttt{M}}, label=lst:asm:alg:m4-1]
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"cmpl %[M_len], %[I]\n"
"jnge begin_iteration\n"
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);
\end{lstlisting}

В~приведённом выше коде на тип~\lstinline!int! у~элементов~массива указывают как суффикс~\lstinline!l! у~команды~\lstinline!mov!, так и~масштаб~\lstinline!4! при вычислении адреса.
Обе характеристики важны: попытка опустить суффикс команды приведёт к~ошибке, так как ни один из операндов~команды~\lstinline!mov! здесь не является регистром и,~следовательно, не имеет определённого размера. %, по которому можно было бы понять разрядность команды

Также %обе характеристики 
суффикс и~вычисление адреса
должны соответствовать друг другу: хотя  команды~\lstinline!movw $0, (%[M], %[I], 4)! и~\lstinline!movl $0, (%[M], %[I], 2)! синтаксически корректны и~не вызовут ошибок компиляции%
% \footnote{Ошибка возможна при использовании здесь суффикса~\lstinline!s! вместо~\lstinline!w!, хотя в~целом они оба для команд CPU равноправны и~обозначают 16-битное целое, так как существует отдельная команда~\lstinline!movs! с~поведением, отличным от~\lstinline!mov!}
,  обе они при обработке массива из элементов типа~\lstinline!int! некорректны по смыслу.
Команда~\lstinline!movw $0, (%[M], %[I], 4)! запишет по адресу~$M[i]$ 16-битный ноль, который инициализирует только младшие два байта из четырёх%, зарезервированных за~$M[i]$
; таким образом, значение элемента~$M[i]$ останется неопределённым. % и,~фактически, элемент  
Команда~\lstinline!movl $0, (%[M], %[I], 2)! перезапишет не~$M[i]$, а~либо элемент~$M[i/2]$ (для чётного~$i$), либо два старших байта 
% половину 
одного элемента и~два младших следующего  (для нечётного~$i$).

Избавиться от явного указания суффикса и~масштаба можно, используя модификаторы параметров:
\begin{lstlisting}[caption={Инициализация элемента массива~\texttt{M[i]} размера \texttt{el\_size}}, label=lst:asm:alg:misize]
const int N = 8;
short M[N];
int i = 3;
asm
(
"mov%z[el_type] $0, (%[M], %[I], %c[el_size])\n"
:[I]"+r"(i)
:[M]"r"(M), [el_size]"i"(sizeof(M[0])), [el_type]"m"(M[0])
: "memory"
);
\end{lstlisting}
Такой код будет компилироваться и~выполняться корректно для любого типа элементов массива~$M$, причём для типа~\lstinline!short! выбирается тот из синонимичных суффиксов, который не вызовет неоднозначности с~командой~\lstinline!movs!.
К~сожалению, это потребовало введения двух новых входных параметров: константа~\lstinline![el_size]! для масштаба~\lstinline!sizeof(M[0])! и~\lstinline![el_type]!, равный~\lstinline!M[0]!, для определения суффикса размера (так как ни один из ранее использованных параметров
"--- ни указатель~$M$, ни индекс~$i$ "---
в~общем случаем не совпадает~по размеру с~элементом массива%: $M$ "--- указатель, индекс~$i$ "--- \lstinline!size_t!, то есть их размер определяется платформой и~компилятором, а~не типом элемента
).

В~листинге~\ref{lst:asm:alg:mf} показана инициализация нулями массива  из элементов целого типа.
\begin{lstlisting}[caption={Инициализация  массива~\texttt{M} из элементов 2-8 байт}, label=lst:asm:alg:mf]
const int N = 8;
short M[N];
int i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"mov%z[el_type] $0, (%[M],%[I],%c[el_size])\n"
"incl %[I]\n"
"cmpl %[M_len], %[I]\n"
"jnge begin_iteration\n"
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M), 
[el_size]"i"(sizeof(M[0])), 
[el_type]"m"(M[0])
: "cc","memory"
);
for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}
Тип~$short$ в~листинге~\ref{lst:asm:alg:mf} может быть заменён на~$long$ или~$long~long$.
Не вызовет ошибки компиляции и~замена на~однобайтовое целое~$char$, но вывод будет выглядеть пустым.
При выводе на экран числа типа $char$ стандартными средствами C++ отображается символ ASCII\index{ASCII}, код которого равен числу.
% Отображение чисел, не равных кодам печатных символов ASCII, не определено и~может быть разным для различных реализаций,
Нулевой символ отображается как конец строки, то есть никак.
Если заменить в~команде \lstinline!mov! константу \lstinline!$0! на номер печатного символа~ASCII, в~частности, на~\lstinline!$'y'!, вывод на экран покажет~$N$ заданных символов.

Масштаб, равный~$1$, может быть опущен.
Таким образом, если размер элемента равен~одному байту, то адрес $i$-го элемента массива  $M$ равен $M + i$ и~сам элемент может быть записан и~как~\lstinline!(M, i, 1)!, и~как~\lstinline!(M, i)!.

% Пусть выделена память под массив однобайтовых целых чисел. В~C++ соответствующий тип обозначается как $char$.
% При выводе на экран числа типа $char$ стандартными средствами отображается символ ASCII, код которого равен числу.
% Отображение чисел, не равных кодам ASCII,  не определено и~может быть разным для различных реализаций,
% так что рассмотрим инициализацию массива кодами строчных латинских букв, начиная с~\lstinline!'a'! (листинг~\ref{lst:asm:alg:m-byte}).
Рассмотрим инициализацию массива кодами строчных латинских букв, начиная с~\lstinline!'a'! (листинг~\ref{lst:asm:alg:m-byte}).

\begin{lstlisting}[caption={Инициализация массива строчными латинскими буквами}, label=lst:asm:alg:m-byte]
const int N = 8;
int i, x;
char M[N];
asm
(
  "movb $'a', %b[X]\n"
  "xorl %[I], %[I]\n"
"begin_iteration:\n"
  "cmpl %[M_len], %[I]\n"
  "jge end_loop\n"
  "movb %b[X], (%[M],%[I])\n"
  "incb %b[X]\n"
  "incl %[I]\n"
  "jmp begin_iteration\n"
"end_loop:\n"
:[I]"=&r"(i), [X]"=&q"(x)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);
\end{lstlisting}

Вывод инициализированного таким образом массива
% \begin{lstlisting}[numbers=none]
% for(i = 0; i < N; ++i)
% {
%     cout << M[i] << " ";
% }
% cout << endl;
% \end{lstlisting}
приведёт к~следующему результату:
\begin{lstlisting}[numbers=none]
a b c d e f g h 
\end{lstlisting}

Если размер~$size$ элемента отличен от~$1, 2, 4$ или~$8$, он не может быть масштабом при вычислении адреса; таким образом, смещение $i$-го элемента относительно начала массива%, равное $i\cdot size$, 
$$
\mathit{offset} = i\cdot size % без \mathit{} между ff дырка
$$
необходимо вычислить отдельно и~затем получить элемент как~\lstinline!(M, offset)!.
% Смещение 
Так как элементы массива, как правило, обрабатываются в~цикле, это можно сделать последовательным сложением % начального адреса
с~$size$ на каждой итерации.

Один из возможных вариантов инициализации массива из элементов типа~$long~double$ (в~GCC число~$long~double$ имеет размер 10 байт, а~выделяемая под него память может занимать как 12, так и~16 байт) показан в~листинге~\ref{lst:asm:alg:m-ten}.

\begin{lstlisting}[caption={Инициализация массива~80-битных вещественных чисел}, label=lst:asm:alg:m-ten]
const int N = 8;
int i;
long double M[N], *p;
asm
(
"movl %[M_len], %[rev_idx]\n"
"movl %[M],     %[el_addr]\n"
"begin_iteration:\n"
"fldpi\n"
"fstpt (%[el_addr])\n"
"addl %[el_size], %[el_addr]\n"
"decl %[rev_idx]\n"
"jnz begin_iteration\n"
:[rev_idx]"=&r"(i), [el_addr]"=&r"(p)
:[M_len]"i"(N), [M]"r"(M), [el_size]"i"(sizeof(M[0]))
: "cc","memory"
);
\end{lstlisting}

Каждый элемент 
получает значение $\pi$.
% \begin{lstlisting}[numbers=none]
% 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 
% \end{lstlisting}

Для инициализации массива нулями можно воспользоваться тем, что нулевое вещественное значение состоит из одних нулей (листинг~\ref{lst:asm:alg:m-ten0}).

\begin{lstlisting}[caption={Инициализация массива вещественных чисел нулями}, label=lst:asm:alg:m-ten0]
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"cmpl %[M_len], %[I]\n"
"jnge begin_iteration\n"
:[I]"=&r"(i)
:[M_len]"i"(N*sizeof(M[0])/4), [M]"r"(M)
: "cc","memory"
);
\end{lstlisting}

Память, отведённая под массив~$M$ ($N*sizeof(M[0])$ байтов) целиком заполняется четырёхбайтовыми нулевыми блоками.
В~результате каждый элемент~$M[i], ~ i \in [0, N-1]$ получает нулевое значение, что можно увидеть, выведя $M$ на экран поэлементно.

% http://www.sql.ru/forum/1121399/nu-ochen-bystryy-move-dlya-x86-x64
% Так вот несколько месяцев назад я с ужасом обнаружил, что используемые ранее (REP) MOVS команды - тормозные. Что обычный цикл записи работает быстрее. Кроме того реализация Move() в Delphi x64 оставляет желать лучшего мягко говоря (впрочем как и многое в RTL x64).

% Также можно воспользоваться функциями stdlib для заливки памяти одним символом.

\subsubsection{Многомерные массивы}
\index{Массивы!многомерные}%

Если массивы с~одним индексом естественно отображаются на~одномерное адресное пространство памяти, 
то о~расположении элементов двумерного массива необходимо условиться дополнительно.

В~большинстве ЯВУ элементы статических многомерных массивов располагаются в~памяти так, что при движении от начала массива по возрастанию адресов быстрее всего меняется последний индекс. После того, как последний индекс достигнет максимального значения, увеличивается предпоследний и~так далее.

В~частности, статические двумерные массивы (матрицы) развёрнуты в~одномерный по строкам "--- сначала идёт вся нулевая строка, затем вся первая и~так далее, то есть в~массиве
\index{Массивы!матрицы}%
\begin{lstlisting}
const int I = 8, J = 8;
int M[I][J];
\end{lstlisting}
адрес элемента~$M[i][j]$ равен~$M+(i\cdot J +j)\cdot size$, где $size = $\lstinline$sizeof(M[0][0])$.

При обработке всех элементов матрицы можно рассматривать её как одномерный массив длины~$I\cdot J$, так как все её элементы однородны и~расположены в~памяти непосредственно друг за другом. 
В~этом случае %эффективный 
индекс элемента~$M[i][j]$ в~этом массиве $index = i\cdot J +j$.


Обратное преобразование (расщепление при необходимости эффективного индекса на номера строки и~столбца) выглядит следующим образом: 
$$
\left\{
\begin{array}{l}
i = index / J\\
j = index \Mod J
\end{array}
\right.
$$
и~может быть выполнено одной командой беззнакового деления.


Если требуется выполнить одно и~то же действие, в~частности, инициализацию, над всеми элементами матрицы, достаточно выполнить один проход, как по массиву $M[I\cdot J]$.
% Если при обработке нужно 

\subsubsection{Динамические массивы}

Динамические массивы,
\index{Массивы!динамические}%
память под которые выделяется из кучи с~помощью оператора $new[\,]$ или функций $*alloc()$ и~освобождается $delete[\,]/free()$, могут быть только одномерными.
При необходимости размещения в~куче многомерного массива программист вручную либо разворачивает его в~длинный одномерный, либо размещает в~древоподобной структуре данных из нескольких небольших одномерных массивов.
Способ обращения к~элементу в~таком случае зависит от способа организации данных.

Обращение к~одномерному динамическому массиву, после того, как адрес его начала помещён в~регистр, ничем не отличается от обращения к~одномерному статическому.




\subsection{Структуры и~объекты}
\epigraph{\begin{limerick}
Говорил бородатый старик:\\
«Я~совсем от покоя отвык "---\\
Шебуршат, как в~гнезде,\\
У~меня в~бороде\\
Две совы, утка, дрозд и~кулик!»
\end{limerick}
}
{\Lear}



% \section{Доступ к~элементам массивов в~памяти}
% \section{Временн\'{ы}е характеристики памяти}
\subsubsection{Выравнивание данных}


Хотя оперативная память "--- устройство с~произвольным доступом, то есть возможно читать значения по любым адресам в~любом порядке, время доступа различается в~зависимости от расположения данных.
% 
Конкретные особенности временн\'{ы}х характеристик обращения к~оперативной памяти зависят от особенностей процессора и~чипсета.


Тем не менее, есть несколько общих правил, позволяющих не потерять в~производительности слишком сильно.

\begin{enumerate}

\item Выравнивание.
Фактически процессор не работает с~данными, взятыми напрямую из оперативной памяти.
При чтении данные поступают в~сверхоперативную память (кеш); изменения вначале фиксируются в~кеше, затем попадают в~оперативную память.
Обмен между памятью и~кешем производится пакетами, длина которых %различна для разного аппаратного обеспечения, но 
составляет от~$32$ до~$128$ байт.
% и~всегда составляет круглое (равное~$2^r$) количество байт. 
Начало пакета кратно его длине.

Таким образом, если элемент попадает на границу таких блоков-пакетов, для его загрузки потребуется два запроса к~памяти~\cite{nezumi-memory}.

% читаются и~записываются в~оперативную память

Чтобы избежать таких ситуаций, достаточно (хотя и~не всегда необходимо), чтобы граница между элементами в~памяти была кратна определённому числу (таблица~\ref{tab:alg:struct-align-size}) "--- выравнена.

\begin{table}[!ht]
\caption{Размер выравнивания для данных различных типов}
\label{tab:alg:struct-align-size}

% \cite{nezumi-memory} Техника оптимизации программ. Эффективное использование памяти
\noindent\begin{tabularx}{\linewidth}{|l@{~}L|L@{~}l|}
\hline
\multicolumn{2}{|c|}{\thead{Размер данных}} & \multicolumn{2}{c|}{\thead{Граница}} \\\hline
1 байт &(8 бит) & Произвольная  &\\\hline
2 байта &(16 бит) & Кратная 2 байтам  &\\\hline
4 байта &(32 бита) & Кратная 4 байтам  &\phantom{4 байта} \\\hline
8 байт &(64 бита) & Кратная 8 байтам  &\\\hline
10 байт &(80 бит) & Кратная 16 байтам  &\\\hline
16 байт &(128 бит) & Кратная 16 байтам  &\\\hline
\end{tabularx}
\end{table}
% \bigskip

По умолчанию в~C++ как размер простых типов, так и~величина, которой кратен адрес начала такой переменной "--- величина выравнивания (кроме $long~double$) соответствуют этим значениям.
% а~адрес начала переменной соответствующего типа кратен его размеру.

Десятибайтовый тип $long~double$ может иметь размер ($sizeof$) как 16, так и~12 байт; в~последнем случае он выравнивается на 4~байта (а~компиляторы из коллекции Microsoft Visual~Studio полагают $long~double = double$, таким образом и~размер, и~величина выравнивания там равны~8).


\item Обход %большого количества 
последовательно расположенных элементов в~порядке возрастания адресов выполняется быстрее, чем в~обратном.

\end{enumerate}



\subsubsection{Поля структур}

Структуры и~объекты в~C++ сочетают в~себе несколько в~общем случае разнородных компонент (полей), расположенных в~определённом порядке.
Доступ к~отдельным полям структуры на ЯВУ осуществляется по имени.
При обработке на языке ассемблера придётся использовать смещение поля относительно начала структуры, которое будет зависеть не только от состава структуры, но и~от компилятора и~его настроек. 

Обычно поля следуют в~порядке объявления и~начало поля %типа $T$ 
кратно некоторой величине, значение которой для конкретного поля/типа, а~также текущей версии и~настроек в~GCC можно получить с~помощью оператора \lstinline!__alignof__! (синтаксис аналогичен \lstinline$sizeof$).
При этом между началом одного поля и~концом предыдущего может образоваться промежуток, также промежуток может образоваться после последнего элемента структуры.
Соответственно, размер структуры может быть больше суммы размеров её полей; также размер структуры может меняться от перестановки полей между собой.
% При описании структур и~

% неверно
% По умолчанию на x86 максимальное значение кратности выравнивания (часто называемое просто выравниванием) равно~4. 
% В~этом случае данные размера 4~байта и~более выравниваются на~4~байта, то есть адрес начала такой переменной или поля будет кратен~4.
% Двухбайтовые данные выравниваются на~2, однобайтовые "--- на~1~байт.

{
% Уменьшить
Изменить
максимальную кратность выравнивания (часто называемую просто выравниванием) в~GCC можно с~помощью флага компиляции~\lstinline$-fpack-struct[=n]$.
Также GCC для совместимости с~компиляторами Microsoft поддерживает набор директив препроцессора \lstinline$#pragma pack$, позволяющих задать различную кратность выравнивания для различных определений типов:
\sloppy

}

% https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Structure-Packing-Pragmas.html
\begin{itemize}
\item \lstinline$#pragma pack(n)$ %simply sets the new alignment.
просто устанавливает новое значение выравнивания;

\item \lstinline$#pragma pack()$ %sets the alignment to the one that was in effect when compilation started (see also command-line option -fpack-struct[=n] see Code Gen Options).
возвращает выравнивание по умолчанию (возможно, заданное~\lstinline$-fpack-struct[=n]$);

\item \lstinline$#pragma pack(push[,n])$ %pushes the current alignment setting on an internal stack and then optionally sets the new alignment.
сохраняет текущее выравнивание во внутреннем стеке и,~при заданном~$n$, устанавливает новое значение

\item \lstinline$#pragma pack(pop)$ %restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and finalized by a single #pragma pack(pop). 
восстанавливает выравнивание из вершины внутреннего стека (и~удаляет эту запись оттуда).
\end{itemize}


Рассмотрим расположение полей и~размер структур при различных настройках выравнивания (листинг~\ref{lst:asm:alg:pack}).

\begin{lstlisting}[style=lstsmall, caption={Структуры при различных значениях выравнивания}, label=lst:asm:alg:pack]
const int N = 10;
struct TSomeStruct
{
    char Tag;    
    int  Val;
} 
s1, a1[N];

#pragma pack (push, 1)
struct TSqueezedStruct
{
    char Tag;    
    int  Val;
} 
s2, a2[N];

#pragma pack (pop)
struct TAnotherStruct
{
    char Tag;    
    int  Val;
}
s3, a3[N];

TSqueezedStruct s20, a20[N];

#define PRINT(I) cout << reinterpret_cast<char *>(&s##I.Tag) \
    - reinterpret_cast<char *>(&s##I) << " " \
 << reinterpret_cast<char *>(&s##I.Val) \
    - reinterpret_cast<char *>(&s##I) \
 << " "<< sizeof(s##I) << " " << sizeof(a##I) << endl;

PRINT(1)	// 0 4 8 80
PRINT(2)	// 0 1 5 50
PRINT(3)	// 0 4 8 80
PRINT(20)	// 0 1 5 50
\end{lstlisting}

Первое поле~$Tag$ всегда имеет нулевое смещение.
Второе поле~$Val$ для структур~$s1$ и~$s3$ (выравнивание по умолчанию) смещено на четыре байта, так как адрес переменной типа~$int$ для наилучшей производительности должен быть кратен~4.
В~структурах~$s2$ и~$s20$ "--- при максимальной кратности выравнивания~1 "--- поле~$Val$ следует непосредственно за~$Tag$.
Следует отметить, что настройки выравнивания задаются при определении типа~$TSqueezedStruct$, а~не конкретных переменных~$s2$ и~$s20$.

Следует также отметить, что в~массиве элементы всегда следуют друг за другом без промежутков. 

На практике
не рекомендуется 
% уменьшать кратность выравнивания, 
изменять настройки выравнивания (особенно директивой \lstinline$#pragma pack$, %позволяющей получить несовместимый результат без изменения описания
приводящей к~несовместимости одинаково описанных структур), 
так как это может замедлить работу программы или даже нарушить её работоспособность.

При необходимости записи структуры в~файл для избавления от дыр неопределённого размера лучше воспользоваться покомпонентной записью.

Для придания размеру дыр определённости необходимо по возможности описывать поля структуры в~таком порядке (и,~возможно, добавить ещё несколько неиспользуемых полей), чтобы границы между полями независимо от настроек выравнивания совпадали с~рекомендуемыми значениями таблицы~\ref{tab:alg:struct-align-size}.


\subsubsection{Обращение к~полю структуры}

% Для обращения к~полю структуры необходимо знать адрес структуры и~смещение нужного поля.
Адрес поля структуры равен сумме  адреса структуры~$base$ и~смещения нужного поля~$displacement$.
Для обращения к~полю структуры необходимо разыменовать его адрес~$*\big(base + displacement\big)$.

Это соответствует косвенной адресации
с~двумя компонентами "--- базой~$base$  и~смещением $displacement$, что в~GAS обозначается~\lstinline!displacement(base)!.

% \subsection{Обращение к~элементу структуры}

% struct TSomeStruct
% {
%     char Tag;
%     int  Val;
% } s;

В~листинге~\ref{lst:asm:alg:struct-4} показана инициализация полей~$Tag$ и~$Val$  структуры $TSomeStruct$, описанной в~листинге~\ref{lst:asm:alg:pack}.

\begin{lstlisting}[caption={Инициализация структуры с~выравниванием на 4~байта}, label=lst:asm:alg:struct-4]
TSomeStruct s;
asm
(
"movb $'a', (%[S])\n"
"movl $13, 4(%[S])\n"
:
:[S]"r"(&s)
: "memory"
);
cout << s.Tag << " " << s.Val << endl;
\end{lstlisting}

Вывод программы показывает корректность инициализации
\begin{lstlisting}[numbers=none]
a 13
\end{lstlisting}


% \subsubsection{Обращение к~элементу структуры (переносимый код)}


Так как расположение полей зависит от настроек компиляции, более надёжно передавать смещения полей как параметры вставки (листинг~\ref{lst:asm:alg:struct-f}).

\begin{lstlisting}[caption={Инициализация  структуры с~неизвестным выравниванием}, label=lst:asm:alg:struct-f]
asm
(
"movb $'a', %c[tag_disp](%[S])\n"
"movl $13,  %c[val_disp](%[S])\n"
:
:[S]"r"(&s),
 [tag_disp]"i"(reinterpret_cast<char *>(&s.Tag) 
    - reinterpret_cast<char *>(&s)),
 [val_disp]"i"(reinterpret_cast<char *>(&s.Val) 
    - reinterpret_cast<char *>(&s))
: "memory"
);
\end{lstlisting}


Полученный код не зависит от настроек выравнивания, но очень тяжело читается.

Если код оформляется не как ассемблерная вставка, а~как функция, принимающая структуру, описанную на C++,
необходимо 
либо передавать смещения полей как параметры функции и~рассчитывать адреса вручную (что сильно замедлит выполнение),
либо задаться конкретными значениями (возможно, при помощи макросов препроцессора),
либо, что лучше всего, описывать структуру таким образом, чтобы при любых настройках выравнивания дыры между полями отсутствовали и~смещения полей не менялись.
\begin{lstlisting}[caption={Структура, выравненная вручную}, label=lst:asm:alg:robust]
struct TRobustStruct
{
    char Tag;    
    char dummy[3]; // неиспользуемые поля
    int  Val;
};
\end{lstlisting}
Листинг \ref{lst:asm:alg:robust} показывает подобное описание.

% \nsection{Контрольные вопросы}
% \epigraph{\begin{stanza}И~со свечкой искали они, и~с~умом,\\
% С~упованьем и~крепкой дубиной,\\
% Понижением акций грозили притом\\
% И~пленяли улыбкой невинной.\\
% \end{stanza}
% }
% {\Snark}


