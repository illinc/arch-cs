% восстанавливаем стиль block
\input{\COMMONPATH/4espdblocks.tex}



% \section{Простые вычисления}
% \epigraph{
% Конструктор Трурль построил однажды мыслящую машину "--- девятиэтажную; окончив самую важную работу, он покрыл машину белым лаком, 
% наугольники покрасил в~лиловый цвет, пригляделся потом издали и~добавил еще небольшой узорчик на фасаде, а~там, где можно было вообразить лоб машины, провёл тонкую оранжевую чёрточку и, очень довольный собой, небрежно посвистывая, задал порядка ради сакраментальный вопрос: сколько будет дважды два?
% }{С.\,Лем}



% \section{Ветвления и~циклы}






\section{Программирование нелинейных алгоритмов и~взаимодействие со структурами данных}

\epigraph{\begin{stanza}
В~действительности всё не так, как на самом деле.
\end{stanza}}
{%Станислав Ежи Лец (а~может быть, и~Антуан де Сент-Экзюпери)
% уже фольклор
Приписывается Станиславу~Ежи~Лецу и~Антуану~де~Сент-Экзюпери.
Фольклор, в~общем
}

В~языках высокого уровня существуют
% такие алгоритмические конструкции, как ветвления и~циклы,
операторы цикла и~условные операторы,
используемые для реализации нелинейных алгоритмов.
% Они, как и~
% Язык ассемблера не
Система машинных команд предлагает 
только команды условного и~безусловного перехода (хотя в~наборе команд x86 есть команда \lstinline!loop!, она является командой условного перехода и~не рекомендуется к~использованию).

Тем не менее, с~помощью команд перехода можно реализовать все нелинейные алгоритмические конструкции,
а~режим косвенной адресации позволяет обращаться к~элементам составных структур данных.
% 
Для визуализации нелинейных алгоритмов воспользуемся схемами программы~\cite{espd-alg}.

\subsection{Условие с~операторами в~одной ветви}
\epigraph{\begin{stanza}[0mm]
Мне нужно было всё, а иначе "--- нет.\\
Образцовый нищий, у Галери Лафайет;\\
Но я смотрел на эту ветку сорок пять лет,\\
\hspace{\stanzaoddindent}В конце концов, она взяла и взлетела. \\
\end{stanza}}
{\Aquarium}

Пусть необходимо заменить значение целой знаковой переменной $x$ нулём, если   оно отрицательно.
$$x = \left\{\begin{array}{ll}
x,& x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$$

Построим схему алгоритма (рис.~\ref{ris:if}, а) для решения этой задачи.

В~отличие от операторов  \lstinline!if! большинства языков высокого уровня,
ветвь, где должны выполняться операторы, лучше сделать ветвью «нет» (обход части программы).

Построим по данной схеме программу. Каждому  блоку процесса здесь будет соответствовать линейный фрагмент кода; блок решения завершится условным переходом по метке; точка соединения двух потоков соответствует метке  (рис.~\ref{ris:if}, б).


\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\coordinate[right=  of is_positive] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);

\node[block,on chain=alg_start, join={node[right]{нет}}] (is_positive_no_op) {$x = 0$};
\coordinate[below = of is_positive_no_op] (to_end);

\path[blockarrow] (is_positive_yes) |- (to_end);
\node[terminator, on chain=alg_start, below = of to_end, join/.style=blockarrow] (end) {Конец}; % Удаляет линию вообще
\path[blockarrow] (is_positive_no_op) -- (end);


\coordinate[right=  of is_positive_yes] (asm_coord);

% \node[asm] at (start-|asm_coord) {
%   \begin{lstlisting}
%   int x;
%   asm
%   (
%       "movl $12, %[X]\n"
%       :[X]"=rm"(x)
%   );
%   \end{lstlisting}
%   };

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = -6;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge end_check\n"
\end{lstlisting}
};
\node[asm] at (is_positive_no_op-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[X]\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  : [X]"+rm"(x)
  : : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};

\end{tikzpicture}
}

\caption{Алгоритм и~реализация ветвления}
\label{ris:if}
\end{illustration}

% Данную задачу можно также решить с~помощью команд условной пересылки:
Для более быстрой реализации подобных ветвлений (присваивания по условию) начиная с~Pentium Pro добавлены команды  условной пересылки:
\begin{lstlisting}[style=lstsmall]
int x = -6;
asm
(
  "cmpl $0, %[X]\n"
  "cmovngel %[Zero], %[X]\n"
  : [X]"+r"(x)
  : [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Так как источником для команды cmovXXX не может быть константа, вводится входной параметр \lstinline![Zero]!, расположенный в~памяти или регистре и~равный нулю.

\subsection{Условие с~операторами в~двух ветвях}
\epigraph{\begin{stanza}[0mm]
Человеческая жизнь имеет более одного аспекта;\\
В городе Таганроге есть два Звёздных проспекта...\\
\end{stanza}}
{\Aquarium}
Пусть в~зависимости от условия необходимо выполнить один из двух операторов:
$$y(x) = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$$

% Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи, выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, в).
% 
% Потоки, выходящие за пределы основной линии "--- условные и~безусловные  переходы, точки входа таких потоков-переходов в~основной вертикальный поток "--- метки.


Построим схему алгоритма (рис.~\ref{ris:if-else}, а) для решения этой задачи и~затем выстроим блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, б).


\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
% \lstset{basicstyle=\ttfamily\footnotesize\singlespacing}
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[decision,on chain=alg_start] (is_positive) {$x\geqslant0$};

\tikzset{every join/.style=blockarrow}

\coordinate[right= of is_positive, on chain=if_yes] (is_positive_yes);
\path[blockline] (is_positive) -- node[auto] {да} (is_positive_yes);
\node[block,on chain=if_yes] (yes_op) {$y = 1$};

\coordinate[left=  of is_positive, on chain=if_no] (is_positive_no);
\path[blockline] (is_positive) -- node[auto] {нет} (is_positive_no);
\node[block,on chain=if_no] (no_op) {$y = 0$};

\coordinate[below = of yes_op] (to_end_y);

\coordinate[on chain=alg_end, join/.style={}] (to_end) at (to_end_y-|start);
\path[blockline] (yes_op) |- (to_end);
\path[blockline] (no_op) |- (to_end);

\node[terminator, on chain=alg_end, below = of to_end] (end) {Конец};
% \path[blockarrow] (to_end) -- (end);



\tikzset{every join/.style=blockline}


\coordinate[right= 6em of yes_op] (squeeze_coord);

\node[terminator,on chain=squeeze_start] (start2) at (start-|squeeze_coord) {Начало};

\node[decision,on chain=squeeze_start] (is_positive2) {$x\geqslant0$};

\node[block,   on chain=squeeze_start, join={node[right]{нет}}] (no_op2) {$y = 0$};
\coordinate[on chain=squeeze_start] (to_end_no2);


\coordinate[right= of is_positive2] (is_positive_yes2);
\path[blockline] (is_positive2) -- node[auto] {да} (is_positive_yes2);
\tikzset{every join/.style=nodraw}
\coordinate[on chain=squeeze_start] (non-used);

\coordinate[on chain=squeeze_start, join/.style={}] (to_yes2);
\node[block,   on chain=squeeze_start, join/.style={}] (yes_op2) {$y = 1$};
\tikzset{every join/.style=blockline}

\coordinate[on chain=squeeze_start] (to_end_yes2);
% \coordinate[on chain=squeeze_start] (non-used2);

\node[terminator, on chain=squeeze_start, join/.style={}] (end2) {Конец};

\path[blockarrow] (is_positive_yes2) |- (to_yes2) -- (yes_op2);

\coordinate[left=of yes_op2] (from_no_to_end2);
\path[blockline] (to_end_no2) -| (from_no_to_end2);
\path[blockarrow] (from_no_to_end2) |- (to_end_yes2);
\path[blockarrow] (to_end_yes2) -- (end2);



\coordinate[right=  of is_positive_yes2] (asm_coord);

\node[asm] at (start2-|asm_coord) {
\begin{lstlisting}
int x = -6, y;
asm
(
\end{lstlisting}
};

\node[asm] at (is_positive2-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "jge setting_1\n"
\end{lstlisting}
};

\node[asm] at (to_yes2-|asm_coord) {
\begin{lstlisting}
"setting_1:\n"
\end{lstlisting}
};

\node[asm] at (yes_op2-|asm_coord) {
\begin{lstlisting}
  "movl $1, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (no_op2-|asm_coord) {
\begin{lstlisting}
  "movl $0, %[Y]\n"
\end{lstlisting}
};

\node[asm] at (to_end_no2-|asm_coord) {
\begin{lstlisting}
  "jmp end_check\n"
\end{lstlisting}
};

\node[asm] at (to_end_yes2-|asm_coord) {
\begin{lstlisting}
"end_check:\n"
\end{lstlisting}
};

\node[asm] at (end2.south-|asm_coord) (asm-end) {
\begin{lstlisting}
  :[Y]"=rm"(y)
  :[X]"rm" (x)  
  : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (end2|-lettersline) {б)};
\node at (asm-end|-lettersline) {в)};


\end{tikzpicture}
}

\caption{Алгоритм и~реализация ветвления}
\label{ris:if-else}
\end{illustration}

Сопоставим каждому блоку одну или несколько команд ассемблера.
В~этом случае излом потока (отход от базовой вертикали без ветвления) будет соответствовать безусловному переходу, блок решения включает условный переход, а~точки входа боковых потоков-переходов в~основной вертикальный поток соответствуют меткам (рис.~\ref{ris:if-else}, в).
\pagebreak[3]


Данную задачу также можно  решить с~помощью команд условной пересылки.
Для подобного задания такая реализация будет компактнее и~быстрее. 

\begin{lstlisting}
int x = 10, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $1, %[Y]\n"
  "cmovll %[Zero], %[Y]\n"
  : [Y]"+r"(y)
  : [X]"rm"(x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Здесь параметр \lstinline![Y]! объявлен как выходной с~начальным значением, хотя, казалось бы, его исходное значение нам не требуется.
Это сделано, чтобы компилятор не совместил его с~входным параметром  \lstinline![Zero]! (совмещение с~входным параметром \lstinline![X]! не повредит выполнению, так как значение \lstinline![X]! используется только для сравнения с~литералом \lstinline!$0!, до первого присваивания \lstinline![Y]!).
Если %не указать \lstinline![Y]! в~списке входных и~он 
\lstinline![Y]! будет совмещён с~\lstinline![Zero]!, мы всегда получим на выходе $y=1$.

\pagebreak[3]

Для данных значений ($y$ равен либо нулю, либо единице) задачу можно  решить и~с~помощью команды условной установки байта.
\begin{lstlisting}
int x = -7, y;
asm
(
  "cmpl $0, %[X]\n"
  "movl $0, %[Y]\n"
  "setgeb %[Y]\n"
  :[Y]"=m"(y)
  :[X]"rm"(x)
  : "cc"
);
\end{lstlisting}
Здесь мы записываем ноль в~четырёхбайтовую переменную  \lstinline![Y]!, находящуюся в~памяти, а~затем устанавливаем по условию её младший байт (так как платформа x86 использует  порядок байтов Intel, адрес младшего байта \lstinline![Y]! совпадает с~адресом \lstinline![Y]!).
Оба возможных значения $y$ неотрицательны, поэтому дополнение нулями является корректным расширением и~для знаковой, и~для беззнаковой их~интерпретации.

Также можно было установить по условию регистр  \Reg{AL} и~специальными командами расширить его вначале до \Reg{AX}, а~затем до~\Reg{EAX}.

При использовании для $y$ однобайтового типа \lstinline!char! вместо четырёхбайтового \lstinline!int! расширение не будет нужным.

\pagebreak[3]

% \subsection{Цикл с~предусловием}
\subsection{Цикл}
\epigraph{\begin{stanza}
Достаточно бросить здесь спичку, и огня будет уже не унять\\
В джунглях. 
\end{stanza}
}{\Aquarium}
Пусть необходимо найти сумму двоичных цифр беззнакового числа $x$.


% Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:if-else}, а), реализован цикл с~предусловием) и~сопоставим каждому блоку одну или несколько команд ассемблера (рис.~\ref{ris:if-else}, б).

Построим схему алгоритма для решения этой задачи, не используя парный блок цикла и~выстроив блоки линейно вдоль одной вертикали (рис.~\ref{ris:while}, а), реализован цикл с~предусловием). 
При соединении блоков немного отступим от требований ЕСПД 
(стандарт предписывает минимизировать количество изломов и~не удлинять линии потоков без необходимости)
и~отделим точку, где боковой поток случая $CF\neq 0$ входит в~основную вертикаль, от~точки, где поток отходит от вертикали, чтобы перейти назад к~началу итерации.
Расположение этих точек выберем так, чтобы поток основной вертикали на каждом её участке шёл в~естественном направлении "--- сверху вниз (это не только позволяет не~рисовать стрелку для обозначения направления, но и~соответствует выполнению %программы 
кода, не включающего команд передачи управления).



\begin{illustration}
% \resizebox{\linewidth}{!}
{
\footnotesize
\def\normalsize{\footnotesize}
\lstset{xleftmargin=0em}

\tikzstyle{asm}	= [text width=16em,text badly ragged, anchor=west]

\begin{tikzpicture}[
start chain=alg_start going below,
start chain=if_yes going below,
start chain=if_no going below,
start chain=alg_end going below,
start chain=squeeze_start going below,
start chain=squeeze_yes going below,
start chain=squeeze_end going below,
every on chain/.style=join,every join/.style=blockline,
node distance=3ex and 2em
]


\node[terminator,on chain=alg_start] (start) {Начало};
\node[block,on chain=alg_start] (init) {$count = 0$};

\coordinate[on chain=alg_start] (to_shift);
\tikzset{every join/.style=blockarrow}
\node[decision,on chain=alg_start] (is_zero) {$x=0$};
\tikzset{every join/.style=blockline}
\node[block,on chain=alg_start, join={node[right]{нет}}] (shift) {
$CF = x \& 1$

$x = (x>>1)$
};

\node[decision,on chain=alg_start] (is_last_bit) {$CF=1$};
\node[block,on chain=alg_start, join={node[right]{да}}] (inc) {$count = count+1$};
\coordinate[on chain=alg_start] (from_no_to_next_iter);
\coordinate[on chain=alg_start] (to_next_iter);
\tikzset{every join/.style=blockarrow}
\coordinate[left = of current bounding box] (to_next_iter_middle);
\path[blockarrow] (to_next_iter) -| (to_next_iter_middle) |- (to_shift);

\tikzset{every join/.style=nodraw}
% \coordinate[on chain=alg_start] (non-used);
\coordinate[on chain=alg_start] (to_end);
\node[terminator, on chain=alg_start] (end) {Конец};


\coordinate[right= of is_last_bit] (is_no_last_bit);
\path[blockarrow] (is_last_bit) -- node[auto] {нет} (is_no_last_bit) |- (from_no_to_next_iter);



\coordinate[right= of is_zero-|is_no_last_bit] (is_zero_yes);
\path[blockarrow] (is_zero) -- node[auto] {да} (is_zero_yes) |- (to_end) -- (end);



\coordinate[right=  of current bounding box] (asm_coord);

\node[asm] at (start-|asm_coord) {
\begin{lstlisting}
int x = 7, count;
asm
(
\end{lstlisting}
};

\node[asm] at (to_shift-|asm_coord) {
\begin{lstlisting}
"begin_iteration:\n"
\end{lstlisting}
};
\node[asm] at (init-|asm_coord) {
\begin{lstlisting}
  "xorl %[Count], %[Count]\n"
\end{lstlisting}
};
\node[asm] at (shift-|asm_coord) {
\begin{lstlisting}
  "shrl $1, %[X]\n"
\end{lstlisting}
};
\node[asm] at (is_zero-|asm_coord) {
\begin{lstlisting}
  "cmpl $0, %[X]\n"
  "je end_loop\n"
\end{lstlisting}
};
\node[asm] at (is_last_bit-|asm_coord) {
\begin{lstlisting}
  "jnc end_iteration\n"
\end{lstlisting}
};
\node[asm] at (inc-|asm_coord) {
\begin{lstlisting}
  "incl %[Count]\n"
\end{lstlisting}
};

\node[asm] at (from_no_to_next_iter-|asm_coord) {
\begin{lstlisting}
"end_iteration:\n"
  "jmp begin_iteration\n"
\end{lstlisting}
};

\node[asm] at (to_end-|asm_coord) {
\begin{lstlisting}
"end_loop:\n"
\end{lstlisting}
};

\node[asm] at (end-|asm_coord) (asm-end) {
\begin{lstlisting}
:[Count]"=rm"(count),[X]"+rm"(x)
: : "cc"
);
\end{lstlisting}
};

\coordinate[below = of current bounding box] (lettersline);
\node at (end|-lettersline) {а)};
\node at (asm-end|-lettersline) {б)};


\end{tikzpicture}
}

\caption{Алгоритм и~реализация цикла}
\label{ris:while}
\end{illustration}

Теперь сопоставим каждому блоку одну или несколько команд ассемблера.
Отход потока от базовой вертикали будет соответствовать команде перехода, точки входа боковых потоков в~основной вертикальный  "--- меткам 
(рис.~\ref{ris:while}, б).

Цикл с~постусловием будет отличаться только на этапе построения схемы алгоритма.

Цикл с~параметром, как и~в~C/C++, можно реализовать как цикл с~предусловием.





















\subsection{Массивы}
\label{sec:arrays}
\epigraph{\begin{limerick}
Жил один старичок из Пенджаба,\\
Ему на ногу прыгнула жаба,\\
Впавши в~ярость и~гнев,\\
Он позвал сорок дев, "---\\
Чтобы выгнать всех жаб из Пенджаба.
\end{limerick}
}
{\Lear}

\addquestion{Как располагаются в~памяти элементы массива?}
\addquestion{Как найти размер массива, зная размер элемента и~их количество?}



% \section{Одномерные массивы}
\index{Массивы!одномерные}

Массив "---  структура данных в~виде набора однородных компонент (элементов массива), расположенных в памяти непосредственно друг за другом (независимо от настроек выравнивания). 
Элемент с~наименьшим индексом располагается по младшему адресу.
% 
Доступ к~отдельным элементам массива осуществляется с помощью индексации, то есть через ссылку на массив с~указанием номера (индекса) нужного элемента. 


В~языке C++ наименьший индекс массива всегда равен $0$, а~имя массива %фактически 
является константным указателем на его начало.
Таким образом, адрес $i$-го элемента массива $M$ равен $M + i\cdot size$, где~$size$ "--- размер одного элемента и,~в~случае, когда длина массива не равна нулю, может быть определён как \lstinline!sizeof(M[0])!.
% Если массив содержит элементы простых типов 
Для большинства простых типов
(\lstinline!char, bool, short, int, long, long long, float, double, size_t, ptrdiff_t, void*!)
этот размер как на 32-, так и~на 64-битной платформе равен~$1, 2, 4$ или~$8$.

Соответственно, в~ассемблере для получения элемента массива (если элементы массива имеют размер~$1, 2, 4$ или~$8$) будут использованы три из~четырёх компонент эффективного адреса \lstinline!displacement(base, index, multiplier)! "---  база (адрес начала массива~$M$), индекс и~масштаб (размер~элемента).
\index{Адресация!косвенная}

В~частности, адрес $i$-го элемента массива  $M$ из~чисел типа \lstinline!int! на 32-разрядных и~многих 64-разрядных платформах равен $M + i\cdot 4$, и~элемент будет записан как~\lstinline!(M, i, 4)!. При этом база~$M$ и~индекс~$i$ должны быть 32-разрядны (на соответствующей платформе) и~располагаться в~регистрах:
\begin{lstlisting}
const int N = 8;
int M[N], i = 0;
asm
(
"movl $0, (%[M], %[I], 4)\n"
:[I]"+r"(i)
:[M]"r"(M)
:"memory"
);
\end{lstlisting}
Так как мы модифицируем во вставке элементы массива (а~не сами параметры \lstinline![I]! и~\lstinline![M]!), необходимо указать в~списке перезаписываемых элементов специальное значение \lstinline!"memory"!.

В~приведённом выше коде на тип~\lstinline!int! у~элементов~массива указывают как суффикс~\lstinline!l! у~команды, так и~масштаб~\lstinline!4! при вычислении адреса.
Обе характеристики важны: попытка опустить суффикс команды приведёт к~ошибке, так как ни один из операндов~команды~\lstinline!mov! здесь не является регистром и,~следовательно, не имеет определённого размера. %, по которому можно было бы понять разрядность команды

Также %обе характеристики 
суффикс и~вычисление адреса
должны соответствовать друг другу: хотя  команды~\lstinline!movw $0, (%[M], %[I], 4)! и~\lstinline!movl $0, (%[M], %[I], 2)! синтаксически корректны и~не вызовут ошибок компиляции\footnote{Ошибка возможна при использовании здесь суффикса~\lstinline!s! вместо~\lstinline!w!, хотя в~целом они оба для команд CPU равноправны и~обозначают 16-битное целое, так как существует отдельная команда~\lstinline!movs! с~поведением, отличным от~\lstinline!mov!},  обе они при обработке массива из элементов типа~\lstinline!int! некорректны по смыслу.
Команда~\lstinline!movw $0, (%[M], %[I], 4)! запишет по адресу~$M[i]$ 16-битный ноль, который инициализирует только младшие два байта из четырёх%, зарезервированных за~$M[i]$
; таким образом, значение элемента~$M[i]$ останется неопределённым. % и,~фактически, элемент  
Команда~\lstinline!movl $0, (%[M], %[I], 2)! перезапишет не~$M[i]$, а~либо элемент~$M[i/2]$ (для чётного~$i$), либо два старших байта 
% половину 
одного элемента и~два младших следующего  (для нечётного~$i$).

Избавиться от явного указания суффикса и~масштаба можно, используя модификаторы параметров:
\begin{lstlisting}
const int N = 8;
short M[N];
int i = 3;
asm
(
"mov%z[el_type] $0, (%[M], %[I], %c[el_size])\n"
:[I]"+r"(i)
:[M]"r"(M), [el_size]"i"(sizeof(M[0])), [el_type]"m"(M[0])
: "memory"
);
\end{lstlisting}
Такой код будет компилироваться и~выполняться корректно для любого типа элементов массива~$M$, причём для типа~\lstinline!short! выбирается тот из синонимичных суффиксов, который не вызовет неоднозначности с~командой~\lstinline!movs!.
К~сожалению, это потребовало введения двух новых входных параметров: константа~\lstinline![el_size]! для масштаба~\lstinline!sizeof(M[0])! и~\lstinline![el_type]!, равный~\lstinline!M[0]!, для определения суффикса размера (так как ни один из ранее использованных параметров
"--- ни указатель~$M$, ни индекс~$i$ "---
в~общем случаем не совпадает~по размеру с~элементом массива%: $M$ "--- указатель, индекс~$i$ "--- \lstinline!size_t!, то есть их размер определяется платформой и~компилятором, а~не типом элемента
).

Масштаб, равный~$1$, может быть опущен.
Таким образом, если размер элемента равен~$1$, то адрес $i$-го элемента массива  $M$ равен $M + i$ и~сам элемент может быть записан и~как~\lstinline!(M, i, 1)!, и~как~\lstinline!(M, i)!.

Если размер~$size$ элемента отличен от~$1, 2, 4$ или~$8$, он не может быть масштабом при вычислении адреса; таким образом, смещение $i$-го элемента относительно начала массива%, равное $i\cdot size$, 
$$
\mathit{offset} = i\cdot size % без \mathit{} между ff дырка
$$
необходимо вычислить отдельно и~затем получить элемент как~\lstinline!(M, offset)!.
% Смещение 
Так как элементы массива, как правило, обрабатываются в~цикле, это можно сделать последовательным сложением % начального адреса
с~$size$ на каждой итерации.

\subsubsection{Многомерные массивы}
\index{Массивы!многомерные}

Если массивы с~одним индексом естественно отображаются на~одномерное адресное пространство памяти, 
то о~расположении элементов двумерного массива необходимо условиться дополнительно.

В~большинстве ЯВУ элементы статических многомерных массивов располагаются в~памяти так, что при движении от начала массива по возрастанию адресов быстрее всего меняется последний индекс. После того, как последний индекс достигнет максимального значения, увеличивается предпоследний и~так далее.

В~частности, статические двумерные массивы (матрицы) развёрнуты в~одномерный по строкам "--- сначала идёт вся нулевая строка, затем вся первая и~так далее, то есть в~массиве
\index{Массивы!матрицы}
\begin{lstlisting}
const int I = 8, J = 8;
int M[I][J];
\end{lstlisting}
адрес элемента~$M[i][j]$ равен~$M+(i\cdot J +j)\cdot size$, где $size = $\lstinline$sizeof(M[0][0])$.

При обработке всех элементов матрицы можно рассматривать её как одномерный длины~$I\cdot J$, так как все её элементы однородны и~расположены в~памяти непосредственно друг за другом. 
В~этом случае %эффективный 
индекс элемента~$M[i][j]$ в~этом массиве $index = i\cdot J +j$.
Обратное преобразование (расщепление при необходимости эффективного индекса на номера строки и~столбца) выглядит следующим образом: 
$$
\left\{
\begin{array}{l}
i = index / J\\
j = index \Mod J
\end{array}
\right.
$$
и~может быть выполнено одной командой беззнакового деления.

Динамические массивы, \index{Массивы!динамические}
память под которые выделяется из кучи с~помощью оператора new[] или функций *alloc() и~освобождается delete[]/free(), могут быть только одномерными.
При необходимости размещения в~куче многомерного массива программист вручную либо разворачивает его в~длинный одномерный, либо размещает в~древоподобной структуре данных из нескольких небольших одномерных массивов.
Способ обращения к~элементу в~таком случае зависит от способа организации данных.






\subsection{Структуры и~объекты}
\epigraph{\begin{limerick}
Говорил бородатый старик:\\
«Я~совсем от покоя отвык "---\\
Шебуршат, как в~гнезде,\\
У~меня в~бороде\\
Две совы, утка, дрозд и~кулик!»
\end{limerick}
}
{\Lear}

\addquestion{Что такое выравнивание полей структуры?}
\addquestion{Зачем нужно выравнивание данных?}



% \section{Доступ к~элементам массивов в~памяти}
% \section{Временн\'{ы}е характеристики памяти}
\subsubsection{Выравнивание данных}


Хотя оперативная память "--- устройство с~произвольным доступом, то есть возможно читать значения по любым адресам в~любом порядке, время доступа различается в~зависимости от расположения данных.
% 
Конкретные особенности временн\'{ы}х характеристик обращения к~оперативной памяти зависят от особенностей процессора и~чипсета.


Тем не менее, есть несколько общих правил, позволяющих не потерять в~производительности слишком сильно.

\begin{enumerate}

\item Выравнивание.
Фактически процессор не работает с~данными, взятыми напрямую из оперативной памяти.
При чтении данные поступают в~сверхоперативную память (кэш); изменения вначале фиксируются в~кэше, затем попадают в~оперативную память.
Обмен между памятью и~кэшем производится пакетами, длина которых %различна для разного аппаратного обеспечения, но 
составляет от~$32$ до~$128$ байт.
% и~всегда составляет круглое (равное~$2^r$) количество байт. 
Начало пакета кратно его длине.
% 
Таким образом, если элемент попадает на границу таких блоков-пакетов, для его загрузки потребуется два запроса к~памяти.

% читаются и~записываются в~оперативную память

Чтобы избежать таких ситуаций, достаточно (хотя и~не всегда необходимо), чтобы граница между элементами в~памяти была кратна определённому числу.

% \cite{nezumi-memory} Техника оптимизации программ. Эффективное использование памяти
\noindent\begin{tabularx}{\linewidth}{|l@{~}L|L@{~}l|}
\hline
\multicolumn{2}{|c|}{\thead{Размер данных}} & \multicolumn{2}{c|}{\thead{Граница}} \\\hline
1 байт &(8 бит) & Произвольная  &\\\hline
2 байта &(16 бит) & Кратная 2 байтам  &\\\hline
4 байта &(32 бита) & Кратная 4 байтам  &\phantom{4 байта} \\\hline
8 байт &(64 бита) & Кратная 8 байтам  &\\\hline
10 байт &(80 бит) & Кратная 16 байтам  &\\\hline
16 байт &(128 бит) & Кратная 16 байтам  &\\\hline
\end{tabularx}
% \bigskip

По умолчанию в~C++ размер простых типов (кроме $long~double$) соответствует этим значениям.
Десятибайтовый тип $long~double$ может иметь размер ($sizeof$) как 16, так и~12 байт; в~последнем случае он выравнивается на 4~байта (а~компилятор MS~VC полагает $long~double = double$, таким образом и~размер, и~величина выравнивания там равны~8).


\item Обход %большого количества 
последовательно расположенных элементов в~порядке возрастания адресов выполняется быстрее, чем в~обратном.

\end{enumerate}



\subsubsection{Поля структур}

Структуры и~объекты в~C++ сочетают в~себе несколько в~общем случае разнородных компонент (полей), расположенных в~определённом порядке.
Доступ к~отдельным полям структуры на ЯВУ осуществляется по имени.
При обработке на языке ассемблера придётся использовать смещение поля относительно начала структуры, которое будет зависеть не только от состава структуры, но и~от компилятора и~его настроек. 

Обычно поля следуют в~порядке объявления и~начало поля %типа $T$ 
кратно некоторой величине, значение которой для конкретного поля/типа, а~также текущей версии и~настроек в~GCC можно получить с~помощью оператора \lstinline!__alignof__! (синтаксис аналогичен \lstinline$sizeof$).
При этом между началом одного поля и~концом предыдущего может образоваться промежуток, также промежуток может образоваться после последнего элемента структуры.
Соответственно, размер структуры может быть больше суммы размеров её полей; также размер структуры может меняться от перестановки полей между собой.
% При описании структур и~

% неверно
% По умолчанию на x86 максимальное значение кратности выравнивания (часто называемое просто выравниванием) равно~4. 
% В~этом случае данные размера 4~байта и~более выравниваются на~4~байта, то есть адрес начала такой переменной или поля будет кратен~4.
% Двухбайтовые данные выравниваются на~2, однобайтовые "--- на~1~байт.

{
% Уменьшить
Изменить
максимальную кратность выравнивания (часто называемую просто выравниванием) в~GCC можно с~помощью флага компиляции~\lstinline$-fpack-struct[=n]$.
Также GCC для совместимости с~компиляторами MS Windows поддерживает набор директив препроцессора \lstinline$#pragma pack$, позволяющих задать различную кратность выравнивания для различных определений типов:
\sloppy

}

% https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Structure-Packing-Pragmas.html
\begin{itemize}
\item \lstinline$#pragma pack(n)$ %simply sets the new alignment.
просто устанавливает новое значение выравнивания;

\item \lstinline$#pragma pack()$ %sets the alignment to the one that was in effect when compilation started (see also command-line option -fpack-struct[=n] see Code Gen Options).
возвращает выравнивание по умолчанию (возможно, заданное~\lstinline$-fpack-struct[=n]$);

\item \lstinline$#pragma pack(push[,n])$ %pushes the current alignment setting on an internal stack and then optionally sets the new alignment.
сохраняет текущее выравнивание во внутреннем стеке и,~при заданном~$n$, устанавливает новое значение

\item \lstinline$#pragma pack(pop)$ %restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and finalized by a single #pragma pack(pop). 
восстанавливает выравнивание из вершины внутреннего стека (и~удаляет эту запись оттуда).
\end{itemize}
Не рекомендуется 
уменьшать кратность выравнивания, 
%изменять настройки выравнивания%(особенно директивой \lstinline$#pragma pack$, %позволяющей получить несовместимый результат без изменения описания
% приводящей к~несовместимости одинаково описанных структур)
% , 
так как это может замедлить работу программы или даже нарушить её работоспособность.
При необходимости записи структуры в~файл для избавления от дыр неопределённого размера лучше воспользоваться покомпонентной записью.

Для придания размеру дыр определённости необходимо по возможности описывать поля структуры в~таком порядке (и,~возможно, добавить ещё несколько неиспользуемых полей), чтобы границы между полями независимо от настроек выравнивания совпадали с~рекомендуемыми значениями.





% \nsection{Контрольные вопросы}
% \epigraph{\begin{stanza}И~со свечкой искали они, и~с~умом,\\
% С~упованьем и~крепкой дубиной,\\
% Понижением акций грозили притом\\
% И~пленяли улыбкой невинной.\\
% \end{stanza}
% }
% {\Snark}


















