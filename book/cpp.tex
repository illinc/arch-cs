

\chapter{Программирование на языке высокого уровня: С++}
\label{sec:cpp}
\epigraph{
Два программиста быстро находят общий язык. \mbox{Как правило, это С++.}
}{\ProgFolk}

Для разработки программного обеспечения  часто используется язык общего назначения~C, 
а~также разработанный на его основе  объектно-ориентированный язык C++.

Программированию на C++ посвящён отдельный курс.
Вспомним некоторые особенности этого языка, полезные при исследовании содержимого оперативной памяти или сочетании программы на C++ с~ассемблерными функциями или вставками.

% \section{Стандарты C и~C++}
% % \section{Языки C и~C++} 
% \epigraph{\begin{stanza}
% Хворобей "--- провозвестник великих идей,\\
% Устремлённый в~грядущее смело;\\
% Он душою свиреп, а~одеждой нелеп,\\
% Ибо мода за ним не поспела.\\
% \end{stanza}
% }
% {\Snark}
\index{Стандарты C/C++}%

% история, назначение

Синтаксис языков C и~C++ стандартизирован.
В~настоящее время существует четыре стандарта языка C:
\begin{itemize}
\item \termin{C89 (ANSI C)} ANSI X3.159-1989;
\item \termin{C90} ISO/IEC 9899:1990;

\item \termin{C99} ISO/IEC 9899:1999, последняя правка от 2007-11-15;

\item \termin{C11} {ISO/IEC 9899:2011} от 2011-12-19.
% 
% Последний бесплатный черновик "--- \termin{n1570} %от 2011-04-12
% (последний черновик "--- \termin{n1570})

\end{itemize}
Доступ к~текстам стандартов платный.  Последний бесплатно доступный черновик C11 "--- \termin{n1570} от 2011-04-12.


% https://isocpp.org/std/the-standard
% В~настоящее время 
Также существует четыре стандарта C++.
Последний, C++17, \modifyone[опубликован в~декабре 2017~г. Начато обсуждение пятой версии "--- C++20.]{ещё готовится к публикации, но состав документа уже определён.}
\begin{itemize}
\item \termin{C++98} ISO/IEC 14882:1998;
\item \termin{C++11} ISO/IEC 14882:2011;
\item \termin{C++14} ISO/IEC 14882:2014\modifyone{ 
(последний бесплатно доступный черновик "--- \termin{n4296} от 2014-11-19)};
% \rlap{(последний черновик "--- \termin{n4296})}

\item \termin{C++17} \modifyone[ISO/IEC 14882:2017 (последний бесплатно доступный черновик "--- \termin{n4659} от 2017-03-21).]{"--- черновик \termin{n4687}.}
\end{itemize}

Не все компиляторы поддерживают последние стандарты в~полном объёме.
% 
В~данном пособии рассматриваются основные возможности языка, реализованные для всех компиляторов.



\section{Структура программы} 
% \epigraphcensoredtwo[
\epigraph{
\begin{stanza}[0mm]
Но вот Эм шагает в~область сильного слова «Могу».\\
Слушайте, слушайте моговест мощи! 
\end{stanza}
}{\Khlebnikov[Зангези]}
% ]{
% \epigraph{\begin{stanza}[0ex]
% Я родился уже помня тебя, просто не знал, как тебя звать\\
% Дох от жажды в твоих родниках "--- я не знал, как тебя знать\\
% \end{stanza}}
% {\Bg[Если бы не ты]}
% }
\index{main()}%
% http://rsdn.org/article/cpp/crt.xml#EWE
Выполнение программы на C или C++ начинается с~функции~$main()$.
Она называется головной, стартовой или главной функцией программы.

Функция $main()$ описана в~разделе \stdcppsec[basic.start.main] стандарта C++.
Она должна быть определена как $int~main()$ или как $int~main(int,$ $char**)$.
Обычно используются обозначения $int~main(int~argc,$ $char~*argv[\,])$.

Функцию $main()$ иногда называют точкой  входа в~программу, но это не совсем так.
С~точки зрения компоновщика, точка входа "--- это метка $\_start$.
Для программ на C/C++ по адресу  $\_start$ находится стартовый код библиотеки libc, который, в~частности,
инициализирует все 
используемые библиотекой ресурсы 
и~глобальные объекты, 
готовит параметры для стартовой функции~$main()$, вызывает её,
а~после возврата управления из $main()$ завершает программу.


При вызове исполняемого файла программы ему часто передаются так называемые параметры командной строки.\index{Параметры командной строки}
Обычно это имя обрабатываемого файла (например, \lstinline!pdflatex paper.tex!) или настройки для работы (\lstinline!ls -la!)
В~частности, щелчок мыши в~графической оболочке по  файлу с~данными эквивалентен запуску какой-либо программы с~именем щёлкнутого файла в~качестве параметра.

Параметры командной строки разделяются пробелами; например, здесь 
\begin{lstlisting}[language=Bash, numbers=none]
grep str */*.tex *.tex
\end{lstlisting}
программа \texttt{grep} (поиск в~текстовых файлах) вызывается с~тремя параметрами "--- \texttt{str} (искомая строка), \texttt{*/*.tex} и~\texttt{*.tex} (имена файлов для поиска).
Нулевым параметром командной строки считается само имя исполняемого файла.

Общее количество параметров, включая имя исполняемого файла "--- это $argc$, первый аргумент функции~$main()$.
Массив строк $argv$ содержит сами эти параметры.\index{Параметры командной строки}

Возвращаемое значение функции $main()$ "--- код завершения программы.
Он равен нулю в~случае успешного завершения и~ненулевому коду ошибки в~противном случае.

Корректный код завершения позволяет оболочке учитывать итоги выполнения программы.
В~частности, следующий однострочный скрипт оболочки\index{Bash}
\begin{lstlisting}[language=Bash, numbers=none]
pdflatex paper && bibtex paper
\end{lstlisting}
запускает программу \texttt{bibtex} (сборка библиографии) только в~том случае, если программа \texttt{pdflatex} (сборка текста) корректно завершилась.





\section{Типы данных} 
\label{sec:cpp-types}
% \epigraphcensoredtwo[
\epigraph{
\begin{stanza}[0mm]
На данные свои взирая объективно,\\
Задумал типы я и идеал создал...
\end{stanza}
}{К.\,П.\,Прутков. Безвыходное~положение}
% ]{
% \epigraph{\begin{stanza}
% Для чего, в самом деле, полюса, параллели, \\
% Зоны, тропики и зодиаки?\\
% И команда в ответ: «В жизни этого нет, \\
% Это "--- чисто условные знаки».\\
% \end{stanza}
% }
% {\Snark}
% }
% стандарт и~реализация в~x86




Базовые типы C++ описаны в~разделе Fundamental types (\stdcppsec[basic.fundamental]) стандарта C++~\cite{isocpp}.
Раздел Types (\stdcppsec[basic.types]) описывает общие характеристики хранения данных в~памяти.

% В~данном разделе также дана ссылка на раздел 5.2.4.2.1 стандарта C, где описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов.

% \subsection{Целые типы и~указатели}
\bottompagebreak[7\baselineskip]
\subsection{Целые типы}
\epigraph{
\begin{stanza}[0mm]
Чтобы мы не увидели войну людей, шашек Азбуки,\\ а~услышали стук длинных копий Азбуки.
\end{stanza}
}{\Khlebnikov[Зангези]}
% \epigraphcensoredtwo[
% \epigraph{\begin{stanza}[0ex]
% В обличьи есть хорошая черта,\\
% Она лишает розу цвета.\\
% Она подобна пистолету\\
% У подзаветного листа.
% \end{stanza}}
% {\Aquarium}
% ]{\epigraph{\begin{limerick}
% Жил один старичок из Марокко,\\
% Погрязший в пучине порока.\\
% Он отплясывал джигу\\
% И~показывал фигу,\\
% Возмущая сограждан в~Марокко.\\
% \end{limerick}
% }
% {\Lear}}
% }
\index{Целые типы C++}%

% \subsection{Требования стандарта к~целым типам}

Существует пять стандартных \termin{знаковых целых типов}:  
\begin{itemize}
\item \lstinline!signed char!, 
\item \lstinline!signed short int! (синонимы: \lstinline!short, signed short!),  
\item \lstinline!signed int! (синонимы: \lstinline!int, signed!),
\item \lstinline!signed long int! (синонимы: \lstinline!long, signed long!),  
\item \lstinline!signed long long int! (синонимы: \lstinline!long long, signed long long!)
\end{itemize}
% компилятор может поддерживать и~д
и~пять соответствующих \termin{беззнаковых целых типов} (каждый из них имеет тот же размер и~те же требования к~выравниванию, что и~соответствующий знаковый):
\begin{itemize}
\item \lstinline!unsigned char!, 
\item \lstinline!unsigned short int! (синонимы: \lstinline!unsigned short!),  
\item \lstinline!unsigned int! (синонимы: \lstinline!unsigned!),
\item \lstinline!unsigned long int! (синонимы: \lstinline!unsigned long!),  
\item \lstinline!unsigned long long int! (синонимы: \lstinline!unsigned long long!).
\end{itemize}
Тип \lstinline!char!, в~зависимости от реализации, может быть знаковым или беззнаковым.
Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! имеют один размер и~одинаковые требования к~выравниванию.


Стандарт C++ не содержит явных значений разрядности типов.

Согласно стандарту,
% размер типа \lstinline!char! "--- минимально возможный размер какого-то объекта в~памяти, кроме того, размер любого объекта кратен размеру~\lstinline!char!;
% также в~разделе Sizeof указано, что 
\lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! занимают 1~байт.
При этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! \emph{однобайтовый,} но \emph{не однооктетный,}
то есть занимает не~8~бит.
% 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта

% Оператор \lstinline!sizeof! возвращает, сколько раз \lstinline!char! укладывается в~аргументе. 
Таким образом, всякий объект любого типа (обозначим его \lstinline!T!) может быть скопирован в~массив \lstinline!char [sizeof(T)]!.

В~ряду целых типов каждый следующий тип имеет размер (и~диапазон значений)  не меньше предыдущего:
$$
\begin{array}{c}
\mathlst{sizeof(char)} \leqslant \mathlst{sizeof(short)} \leqslant \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
\leqslant \mathlst{sizeof(long long)}
\end{array}
$$
Размеры стандартных целых типов C++ также должны соответствовать ограничениям раздела 5.2.4.2.1 стандарта C~\cite{isoc}.
В~этом разделе описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов (при этом указанные значения не обязательно должны быть граничными).
% $$
% \begin{array}{lcl}
% \mathlst{sizeof(char)} \geqslant 
% \mathlst{sizeof(short)} \leqslant 
% \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
% \leqslant \mathlst{sizeof(long long)}
% \end{array}
% $$
Анализ этих значений приводит к~следующим выводам о~минимально допустимой разрядности стандартных типов (таблица~\ref{tab:cpp:intminsize}).

\begin{table}[!ht]
\caption{Минимальная разрядность стандартных целых типов}
\label{tab:cpp:intminsize}
\begin{tabular}{|l|l|}
\hline
Тип & Разрядность, бит (не менее) \\\hline
 \lstinline!char! & 8 \\
 \lstinline!short! & 16 \\
 \lstinline!int! & 16 \\
 \lstinline!long! & 32 \\
 \lstinline!long long! & 64 \\\hline
\end{tabular}
\centering
\end{table}



Тип \lstinline!int! должен соответствовать «естественной» разрядности архитектуры
(расплывчатость этой формулировки 
и~то, что по умолчанию разрядность данных в~шестидесятичетырёхбитном режиме равна 32,
приводит к тому, что практически на 64-битной платформе тип \lstinline!int! чаще всего 32-разряден).

% \subsubsection{интерпретация}
%  и~называются ещё \termin{узкими (narrow)}

% Размер типа \lstinline!char! 

Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! называются ещё \termin{узкими (narrow) символьными типами}, так как 
% хранящееся в~переменных так
они могут быть интерпретированы не только как числа, но и~как символы; соответственно
их размер должен быть таким, чтобы хранить представление любого символа из \termin{базового набора.}

Единственное отличие %типа \lstinline!char! 
узких символьных типов
от других целых (кроме размера) "--- то, что операторы ввода/вывода в~поток для них перегружены так, что отображают не значение переменной, а~символ, код которого равен этому значению.
Отображение чисел, не равных кодам символов ASCII\index{ASCII}, не определено и~может быть разным для различных реализаций,

Все арифметические операции для \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! выполняются точно так же, как и для любого другого целого типа.


Для  типа \lstinline!unsigned char!
каждой возможной  комбинации разрядов должно соответствовать отдельное число. 
Для других типов это не обязательно.

Для представления \termin{расширенного набора  символов} введён специальный тип \lstinline!wchar_t!, имеющий такой же размер, знаковость и~требования к~выравниванию, что и~один из~целых типов.


Тип \lstinline!bool! может хранить только два значения "--- \lstinline!true! и~\lstinline!false!.

\subsubsection{Практическая реализация}

\warning{Всё, что явно не прописано в~стандарте C++, может быть реализовано по-разному на различных платформах.

% Соответственно, в
Всё, написанное  в~этом разделе и~в~аналогичных разделах ниже, описывает в~основном платформу x86 и~наиболее популярные компиляторы.
На других программно/аппаратных платформах (в~частности, при использовании экзотического компилятора) эти закономерности могут быть нарушены.
}

Для представления беззнаковых чисел используется натуральный двоичный код (см. раздел~\ref{sec:digits-binnatural} настоящего пособия);
знаковые представляются дополнительным кодом
(см. разделы~\ref{sec:digits-binnatural}--\ref{sec:digits-negcodes}).
% (таблица~\ref{tab:naturalbincode}).
Таким образом, для всех целых типов, в~частности, для \lstinline!unsigned char!, каждой возможной  комбинации разрядов  соответствует отдельное число.
\index{Представление натуральных чисел}%
\index{Представление знаковых целых чисел}%

% \begingroup
% %  \scriptsize
% % \renewcommand{\arraystretch}{1.05}
% \newcolumntype{Y}{>{$}R<{$}}
% \renewcommand\theadlong[1]{\multicolumn{1}{@{}R@{}}{{\bfseries\small #1\par
% \vspace*{-1\baselineskip}
% \strut
% }}}
% 
% \begin{table}
% 
% \caption{Натуральный двоичный и~дополнительный коды}
% \label{tab:naturalbincode}
% 
% % \noindent
% \begin{tabularx}{1\linewidth}{YYYY@{\hspace{4em}}}
% \theadlong{Тетрада}& \theadlong{16-ричный код} & \theadlong{Беззнаковое представление}
% & \theadlong{Дополнительный код (доп. до 2)} 
% 	\\\hline
% 
% 0000 & 0	& 0 &	0  			\\%\hline
% 0001 & 1	& 1 &	+1 			\\%\hline
% 0010 & 2	& 2 &	+2 			\\%\hline
% 0011 & 3	& 3 &	+3 			\\\hline
% 0100 & 4	& 4 &	+4 			\\%\hline
% 0101 & 5	& 5 &	+5 			\\%\hline
% 0110 & 6	& 6 &	+6 			\\%\hline
% 0111 & 7	& 7 &	+7 			\\\hline
% 1000 & 8	& 8 &	-8 		\\%\hline
% 1001 & 9	& 9 &	-7 			\\%\hline
% 1010 & A	& 10 &	-6 			\\%\hline
% 1011 & B	& 11 &	-5 			\\\hline
% 1100 & C	& 12 &	-4 			\\%\hline
% 1101 & D	& 13 &	-3 			\\%\hline
% 1110 & E	& 14 &	-2 			\\%\hline
% 1111 & F	& 15 &	-1 			\\\hline
% 
% 
% \end{tabularx}
% \end{table}
% \endgroup
% 
% Как видно из таблицы~\ref{tab:naturalbincode}, минимальное беззнаковое четырёхбитное число "--- ноль ($0b0000$),
% максимальное "--- $2^4 - 1 = 15$ ($0b1111$).
% Минимальное знаковое четырёхбитное число "---  $-2^3 = -8$  ($0b1000$),
% максимальное "--- $2^3 - 1 = +7$ ($0b0111$).

Для знаковых и~беззнаковых типов по-разному реализованы некоторые арифметические и~битовые операции, в~частности, умножение (оператор \lstinline!*!), деление (оператор получения частного \lstinline!/! и~оператор получения остатка от деления \lstinline!%!), битовые сдвиги (операторы \lstinline!<<,>>!), расширение при присваивании (если приёмник больше источника).

% Циклические

Беззнаковые целые типы должны подчиняться циклической арифметике по модулю~$2^N$.

\paragraph{char, wchar\_t}

% \footnote{Использованы материалы forum.ishodniki.ru}%
% не открывается

% % Соответственно,
% Для большинства программно/аппаратных платформ 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта, занимает один байт
% (при этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! однобайтовый, но не однооктетный).
% % , как минимально  размер любого типа кратен \lstinline!char!.
% % , хотя есть и~исключения (как правило, платформы, где байт не восьмибитен).

Тип \lstinline!char! "--- восьмибитный и~знаковый.
При этом  \lstinline!char! и~\lstinline!signed char! не являются синонимами, хотя вычисления с~их использованием компилируются в~одинаковые конструкции.
% 
Именно, при перегрузке  \lstinline!f(char)! и~\lstinline!f(signed char)! считаются разными функциями и~их имена декорируются по-разному (для сравнения, \lstinline!f(int)! и~\lstinline!f(signed int)! не различаются и~декорируются одинаково).


Базовым набором символов является ASCII\index{ASCII}.
% Изначально стоит текущая для всего локаль "C" в которой мало что известно, по сути это просто US ASCII как правило. не Linux
% 
При интерпретации переменной типа \lstinline!char! как символа
значение этой переменной трактуется как ASCII-код.
% , если оно лежит в~пре
% от 0 до 127 интерпретируется
Таким образом, 64, 0x40 и '@' "--- это разные формы записи одного и того же числа (ASCII-код символа «собака» равен шестидесяти четырём).

Символы не из ASCII, в~частности, русские буквы, в~зависимости от реализации, могут быть представлены 
одной переменной типа  \lstinline!char! (кодировки koi8, cp1251, cp866; в~этом случае с учётом знаковости \lstinline!char! коды русских букв "--- 128--255 "--- трактуются как отрицательные, то есть \lstinline!'ы' < 0 < 's'!)
или цепочкой из нескольких 
% переменными типа  
\lstinline!char!'ов (кодировка UTF-8; в~этом случае можно описать строку из русских букв как \lstinline!char []!, но невозможно описать одну такую букву как \lstinline!char!).
% Представление одного символа несколькими  переменными не очень удобно

% http://forum.ishodniki.ru/index.php/topic,19509.msg80866.html?PHPSESSID=0231dfe0510c43d48470048b3716466b#msg80866

Понятие расширенного набора  символов и~тип  \lstinline!wchar_t! возникли с~появлением Unicode.
Широкий символьный тип \lstinline!wchar_t! может содержать любое количество байтов.
% С появлением юникода появился и тип "широких" символов wchar_t. Вот уж сколько в нем байтов или char-ов совершенно неизвестно. Но про него известны 2 хорошие вещи которые как правило создатели компиляторов и API закладывают в него :
% - Он используется как правило для преставления какой либо Unicode кодировки.
% - У него фиксированная длина символов. Это достаточно важно. Как известно символы в юникоде представленны абстрактным кодовым пространством (UCS).  А в реальных устройствах эти абстрактные ккоды кодируются различными "юникодными" кодировками (UTF). Причем на разные символы у этих юникодных кодировок может быть переменное число байт. Так вот прелесть wchar_t в том, что в нем обычно используются такие юникодные кодировки или их части в которых каждый логический символ занимает ровно один wchar_t.
Как правило,  при хранении символьной информации в~\lstinline!wchar_t! используются такие юникодные кодировки или их части, в~которых каждый логический символ занимает %ровно один
не менее одного \lstinline!wchar_t! (UTF-32, или, если поддерживается только часть набора символов Unicode "--- UTF-16).
Расширенный набор символов, соответственно "--- та часть набора символов Unicode, которая поддерживается и~может быть записана одним \lstinline!wchar_t!.

Литералы, соответствующие широким строкам и~символам, предваряются префиксом \lstinline!L!.
Для ввода/вывода широких символов и~строк используются те же операторы, что и~для узких, но другие потоки (\lstinline!wcin/wcout!). Поток \lstinline!cout! при выводе  \lstinline!wchar_t! отображает число, при выводе \lstinline!wchar_t*! "--- адрес в~шестнадцатеричном виде. 


% http://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c
% char is always a byte , but it's not always an
% octet. A byte is the smallest addressable unit of
% memory (in most definitions), an octet is 8-bit
% unit of mem

\paragraph{int, short, long, long long}

% Знаковые типы \lstinline!int, short, long, long long! 

% Нечёткость требований к~размеру стандартных типов формулировки приводит к тому, что практически 
Тип \lstinline!int! на 16-разрядных платформах занимал 16 бит, на 32-разрядных "--- 32 бита.
На 64-битной платформе \lstinline!int! чаще всего 32-разряден.

Тип \lstinline!short! 16-разряден на 16-, 32- и~64-разрядных платформах.

Тип \lstinline!long! на 16- и~32-разрядных платформах занимал 32 бита.
На 64-битной платформе "--- 64.

Тип \lstinline!long long!, если поддерживается, 64-разряден.

Таким образом в~C++ не существует гарантированно 32-разрядного фундаментального целого типа.
% Чаще всего 32-разряден тип \lstinline$int$, но 
% Начиная с~C++11, 

Кроме фундаментальных типов, описанных в~стандарте~C++, поддерживаются также типы, описанные в~стандарте~C~\cite{isoc}.
Современный стандарт языка~C включает типы фиксированной разрядности, в~частности, тридцатидвухразрядный \lstinline!int32_t!.

\bottompagebreak[4\baselineskip]
\subsection{Вещественные типы}
\epigraph{\begin{stanza}[0mm]
Страшен очерк их лиц: смуглого дико и~нежно пространства.\end{stanza}
}{\Khlebnikov[Зангези]}
% \epigraphcensoredtwo[
% \epigraph{\begin{stanza}[0ex]
% Париж. Квадрат в форме листа,\\
% Самолёт в виде кривой.\\
% Любимый мой, пойдём со мной\\
% В тот край, где Париж растёт зимой...\\
% \end{stanza}}
% {\Aquarium}
% ]{\epigraph{\begin{limerick}
% Жил один старичок на болоте,\\
% Убежавший от дяди и тёти.\\
% Он сидел на бревне\\
% И, довольный вполне,\\
% Пел частушки лягушкам в болоте.\\
% \end{limerick}
% }
% {\Lear}
% }
\index{Вещественные типы C++}%

Существует три стандартных \termin{вещественных типа}:  
\begin{itemize}
\item \lstinline!float!, 
\item \lstinline!double!,  
\item \lstinline!long double!.
\end{itemize}
тип \lstinline!double! обеспечивает не меньшую точность, чем \lstinline!float!,
\lstinline!long double! "---  не меньшую точность, чем \lstinline!double!.

Множество значений типа \lstinline!float! является подмножеством множества  значений типа  \lstinline!double!;
множество значений типа \lstinline!double! является подмножеством множества  значений типа  \lstinline!long double!:
$$
\mathlst{float} \subseteq \mathlst{double} \subseteq \mathlst{long double}
$$

Все они хранят данные с~плавающей запятой.

\subsubsection{Практическая реализация}
\index{Представление вещественных чисел!с~плавающей запятой}%
\index{Представление вещественных чисел!расширенной точности}%
\index{Представление вещественных чисел!двойной точности}%
\index{Представление вещественных чисел!одинарной точности}%

% \footnote{Использованы материалы: 
% В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
% с~плавающей точкой;
% текст стандарта IEEE Std 754™-2008
% }%
Вещественные числа представляются в~форматах с~плавающей запятой различной точности, в~соответствии со стандартом двоичной арифметики с~плавающей точкой IEEE 754~\cite{ieeeFloat1985rus, ieeeFloat2008}.

Процессоры семейства x86 имеют два набора команд для работы с~вещественными числами с~плавающей запятой.
Это команды математического сопроцессора FPU и~команды расширений XMM и~YMM.

Модуль операций с~плавающей запятой процессоров семейства x86 (floating point unit, FPU) %— часть процессора для выполнения широкого спектра математических операций над вещественными числами.
поддерживает три типа вещественных чисел 
\begin{itemize}
\item  одинарной точности (32 бита), 
\item  двойной точности (64 бита), 
\item  с~двойной расширенной точностью (80 бит, внутренний нестандартный формат FPU "--- 15 разрядов отводится под порядок,  64 под мантиссу).
\end{itemize}
Расширения XMM и~YMM поддерживает два типа  вещественных чисел "--- одинарной и~двойной точности. 

Типу \lstinline!float! соответствует число одинарной точности, 
типу \lstinline!double! "--- двойной.

{
Типу \lstinline!long double! чаще всего соответствует 10-байтовое число расширенной точности. % при этом они могут требовать выравнивания
Размер выделяемой под переменную \lstinline!long double! памяти при этом %может превышать реальный размер числа и, 
в~зависимости от флагов компиляции (\verb!-m96bit-long-double! и~\verb!-m128bit-long-double! в~GCC), может быть равен 12 или 16 байт. 
Используются только первые 80 бит (10 байт), остальное "--- неиспользуемая память (заполнение). 
% -m96bit-long-double
% -m128bit-long-double
% These switches control the size of long double type. The i386 application binary interface specifies the size to be 96 bits, so -m96bit-long-double is the default in 32 bit mode.
% Modern architectures (Pentium and newer) would prefer long double to be aligned to an 8 or 16 byte boundary.
\sloppy

}

В~Microsoft Visual Studio типу \lstinline!long double!  соответствуют числа двойной точности (64 бита), хотя \lstinline!long double! не считается синонимом \lstinline!double!.


\subsection{Специальные типы}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0ex]
Я как дитя играю пустотой,\\
Взметнувшейся к пределам осознанья,\\
Моя душа жемчужною волной\\
Скользит над океаном мирозданья.
\end{stanza}}
{\Rosarium[9]}
% ]{\epigraph{\begin{limerick}
%     Жила-была в городе Бледе \\
%     Одна очень тихая леди.\\
%     На вопрос: «Вы заснули?»\\
%     Шевелилась на стуле\\
%     И вздыхала загадочно леди.\\
% \end{limerick}
% }
% {\Lear} 
% }
\index{void, специальный тип C++}%

Множество значений типа  \lstinline!void! пусто.
Он, в~частности, используется для описания функций, которые не возвращают значения,
так как в~C++ нет отдельного понятия процедуры или подпрограммы, не возвращающей значения.

Любое выражение может быть приведено к~типу 
\lstinline!void!.

Указатель \lstinline!void*! считается нетипизированным.
К~типу \lstinline!void*! может быть преобразован любой указатель.


\bottompagebreak[8\baselineskip]
\subsection{Указатели}
\epigraph{\begin{stanza}[0mm]
Пространство звучит через Азбуку. 
\end{stanza}
}{\Khlebnikov[Зангези]}

% \section{Адресация и~указатели}

% \epigraphcensoredtwo[
% \epigraph{\begin{stanza}[0ex]
% И в этот миг, до корневых глубин\\
% Я постигаю сущность соответствий,\\
% Зависимость причины от последствий\\
% И торжество последствий вне причин.\\
% \end{stanza}}
% {\Orgia}
% ]{
% \epigraph{\begin{limerick}
% Старовер-маловер из Шанхая\\
% Жил, сомнениям всё подвергая.\\
% Он был просто сражён\\
% Тем, что он "--- это он,\\
% А «Шанхай» "--- лишь названье Шанхая.
% \end{limerick}
% }
% {\Lear}
% }


Каждому, простому или сложному, типу данных \lstinline!T! в~C++ соответствует свой тип указателя \lstinline!T*! "--- 
адрес участка памяти, где лежит переменная типа \lstinline!T! или массив таких переменных.

Все указатели "--- целые беззнаковые величины одного размера.
По разрядности указателей в~настоящее время определяется разрядность системы, так что
на 32-битной платформе указатели занимают 32 бита, на 64-битной "--- 64.
% Указатели:
% % 
% void*, char*, ...

Любой указатель может быть разыменован как массив, причём с~использованием произвольного целого индекса.
% индекс — знаковый!!
Таким образом, программист должен сам следить за количеством элементов по адресу, хранящемуся в~переменной-указателе.

В~C++ указатели на различные типы сами считаются различными типами.
Соответственно, механизм типизации не позволяет неявно преобразовать указатели на различные типы друг в~друга (в~частности, \lstinline!int*! в~\lstinline!char*!).
Возможно только приведение к~нетипизированному указателю \lstinline!void*!.
Это логично для строго типизированного языка высокого уровня, но не всегда удобно для низкоуровневого исследования данных.

Тем не менее, физически все указатели имеют одно строение "--- ячейка, где хранится адрес в~памяти.
Таким образом, указатели на разные типы могут быть преобразованы друг в~друга с~помощью  оператора преобразования \lstinline!reinterpret_cast!
либо в~два этапа через \lstinline!void*!.
Вначале исходный тип приводится с~помощью \lstinline!static_cast! к~нетипизированному указателю, затем также с~помощью \lstinline!static_cast! нетипизированный указатель приводится к~требуемому типу.


Также с~указателями связано два целых типа той же разрядности.
% 
Это знаковая разность указателей "---  
\lstinline!ptrdiff_t!
и~беззнаковая длина массива "--- \lstinline!size_t!.

% \subsection{Строки}
% 
% \epigraph{\begin{limerick}
%     Жила-была юная леди, \\
%     За которой погнались медведи.\\
%     Пробежав десять миль,\\
%     Она плюхнулась в пыль,\\
%     И схарчили бедняжку медведи.\\
% \end{limerick}
% }
% {\Lear}

В~C/C++ нет фундаментального строкового типа, хотя есть строковые литералы.
Функции стандартной библиотеки C обрабатывают как строки указатели на массивы чисел типа~\lstinline!char!.


\bottompagebreak
\section{Преобразование типов}
\label{sec:cpp-cast}
\epigraphA{\begin{stanza}[0mm]
При встрече с~медвежьим капканом\\
Пойди объясни, что ты не медведь.
\end{stanza}}
{\Bg[Я~хотел петь]}
{\begin{stanza}[0mm]
И~может быть, ещё ничего не~сдвинулось: \\ только ты~сдвинулся.
\end{stanza}}
{\Kandinsky[Видеть]}
%  12.  Правда не вышла бы из колодезя, если бы сырость не испортила её зеркала. 

% \footnote{Использована статья 
% Е.\,Сагалаевой «Приведение типов в C++»
% % «Приведение типов»% (\url{http://habrahabr.ru/post/106294/})
% }

В~С++ есть четыре оператора явного преобразования (приведения) типов: \lstinline!const_cast!, \lstinline!static_cast!, \lstinline!dynamic_cast! и~\lstinline!reinterpret_cast!. 
Кроме того, для совместимости поддерживается приведение в~стиле C~\cite{alenacpp_cast,habrahabr_cast}.

\begin{description}

\item[const\_cast] убирает (или добавляет, но это редко используется) так называемые cv-спецификаторы (cv qualifiers), то есть \texttt{const} и \texttt{volatile}. Спецификатор \texttt{volatile} встречается редко, так что  \lstinline!const_cast! обычно применяется для снятия \texttt{const.} Если приведение типов не удалось, выдаётся ошибка на этапе компиляции.
При использовании остальных приведений типов cv-спецификаторы останутся неизменными.
\begin{lstlisting}[style=lstsmall, caption={Снятие спецификатора \texttt{const}}]
int i;
const int * pi = &i;
// *pi имеет тип const int,
// но pi указывает на int, который константным не является
int* j = const_cast<int *> (pi);
\end{lstlisting}

% http://rsdn.ru/article/cpp/static_cast.xml
\item[static\_cast]
% Синтаксис:
% TYPE static_cast<TYPE> (object);
преобразует выражения одного статического типа в объекты и значения другого статического типа. 
% Самый популярный вид преобразования.
Может быть использован везде, где допустимо неявное преобразование типов (в~частности, преобразования чисел вроде \lstinline!int i = 1.3;! или указателя произвольного типа в~нетипизированный \lstinline!void *up = &i;!), а~также для преобразования:
\begin{itemize}
\item    любого типа к типу \texttt{void} (допустимое, но обычно ненужное на практике преобразование);
\item указателя \lstinline!void*! в~указатель произвольного типа;
\item    базового класса к ссылке на производный класс (допустимо, но опасно, если объект на самом деле не того производного класса; в~этих случаях часто лучше использовать  \lstinline!dynamic_cast!);
\item указателя на базовый класс  в~указатель на производный класс (аналогично, надёжнее использовать \lstinline!dynamic_cast!, если это возможно);
% \item    инверсия некоторых стандартных преобразований, в~частности:
% \begin{itemize}
\item    интегральных типов в перечисляемые%;
% \item    (возможно cv-квалифицированный) Base * в (с не меньшей cv-квалификацией) Derived *
% \item    (возможно cv-квалифицированный) T Base:: * в (с не меньшей cv-квалификацией) T Derived:: *
% \item    (возможно cv-квалифицированный) void* в любой T *
% \end{itemize}
.
\end{itemize}
Если приведение типов не удалось, выдается ошибка на этапе компиляции.

\item[dynamic\_cast]
"--- безопасное приведение по иерархии наследования, в том числе виртуального.
Используется для преобразования
\begin{itemize}
\item указателя на базовый класс  в~указатель на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class *>(base_class_ptr_expr)
\end{lstlisting}
если приведение невозможно, будет возвращён NULL;

\item    базового класса к ссылке на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class &>(base_class_ref_expr)
\end{lstlisting}
если приведение невозможно, 
% Работа со ссылками происходит аналогично, но в случае ошибки во время выполнения 
будет выброшено исключение \lstinline!bad_cast!.
\end{itemize}
% Используется RTTI (Runtime Type Information), чтобы привести один указатель на объект класса к другому указателю на объект класса. 
Для корректного преобразования классы должны быть полиморфными, то есть в базовом классе должна быть хотя бы одна виртуальная функция. Если это условие не соблюдено, ошибка возникнет на этапе компиляции.
 Если приведение невозможно, это станет ясно только на этапе выполнения программы.

\item[reinterpret\_cast]
"--- приведение без проверок. Не может быть приведено одно значение к другому значению. Обычно используется, чтобы привести указатель к указателю, указатель к целому, целое к указателю. Умеет также работать со ссылками.

Возможные варианты использования
\begin{lstlisting}[style=lstsmall, caption={Варианты использования \texttt{reinterpret\_cast}}]
reinterpret_cast<whatever *>(some *)
reinterpret_cast<integer_expression>(some *)
reinterpret_cast<whatever *>(integer_expression)
\end{lstlisting}
Например, допустимо:
\begin{lstlisting}[style=lstsmall, caption={Корректное использование \texttt{reinterpret\_cast}}]
double x = 1;
int i = -1;
char *pc = reinterpret_cast<char *>(&x);

// refu -- ссылка на то же место в памяти, где расположена переменная i,
// но интерпретируется этот фрагмент памяти уже как unsigned
unsigned &refu = reinterpret_cast<unsigned &>(i);

// pu указывает на то же место в памяти, где расположена переменная i (аналогично)
unsigned *pu = reinterpret_cast<unsigned *>(&i);

// u -- новая переменная, инициализированная текущим значением i в беззнаковой интерпретации (0xFFFFFFFF)
unsigned u = reinterpret_cast<unsigned &>(i);

// lox ссылается на первые (в x86 -- младшие) 4 байта x и интерпретирует их как беззнаковое целое
unsigned &lox = reinterpret_cast<unsigned &>(x);
unsigned &hix = *(&lox + 4);
\end{lstlisting}
% используя пару разнотипных переменных 
% 
Но нельзя выполнить
\begin{lstlisting}[style=lstsmall]
int i;
unsigned u = reinterpret_cast<unsigned>(i);
\end{lstlisting}

\item[Приведение в~стиле C](C-style cast) "--- самое медленное преобразование, так как  последовательно перебираются следующие вызовы:
\begin{enumerate}
\item    \lstinline!const_cast!
\item    \lstinline!static_cast!
\item    \lstinline!static_cast + const_cast!
\item    \lstinline!reinterpret_cast!
\item    \lstinline!reinterpret_cast + const_cast!
\end{enumerate}
Допустимо во всех случаях, но не рекомендуется из-за внешнего вида.

Примеры:
\begin{lstlisting}[style=lstsmall, caption={Приведение в~стиле C}]
double x = 1;
int i = -1;
char *pc = (char *)(&x);
unsigned &refu = (unsigned &)i;
unsigned *pu = (unsigned *)&i;
unsigned u = (unsigned)i;
\end{lstlisting}


\end{description}



\section{Литералы C++}
\label{sec:cpp-literals}
\index{Литералы}%
% \epigraphcensored[
\epigraphA{\begin{stanza}[0mm]
Так что в лучших книгах всегда нет имён\\
и в лучших картинах "--- лиц.
\end{stanza}
}{\Bg[Сельские леди и~джентльмены]}
{\begin{stanza}[0mm]
И оставлю кругом следы. 
\end{stanza}}
{\Khlebnikov[Око]}
% ]{\epigraph{\begin{stanza}
% Тридцать восемь тюков он на пристань привез,\\
% И~на каждом "--- свой номер и~вес;\\
% Но потом как-то выпустил этот вопрос\\
% И~уплыл в~путешествие без.\\
% \end{stanza}
% }
% {\Snark}
% }

Литералы (символические константы) "--- фиксированное значение в~коде программы (\lstinline$3, 0xFF, 7.8$).
Литералы могут использоваться как для инициализации именованных констант и~переменных (в~этом случае тип литерала приводится к~типу соответствующей константы или переменной), так и~непосредственно в~теле программы (магические числа).

\bottompagebreak[5\baselineskip]
\subsection{Целые}
\epigraph{\begin{stanza}[0mm]
Выполнял начертание круга,\\
Как плясунья пера готовальни.
\end{stanza}}{\Khlebnikov[Царапина по~небу]}
% \epigraphcensored[
% \epigraph{\begin{stanza}
% Держали камни в ладонях:\\
% Яшму и оникс; хрусталь, чтобы лучше видеть.
% \end{stanza}}
% {\Aquarium}
% ]{\epigraph{\begin{stanza}
% В какие только мы ворота не влезаем!
% \end{stanza}}
% {О.\,Арефьева}
% }
\index{Литералы!целочисленные}%

Целочисленные литералы начинаются с~цифры или знака ($+$ или $-$) и~не содержат десятичной запятой и~показателя степени. 

Для тех чисел, которые соответствуют кодам ASCII\index{ASCII} для печатных и~некоторых управляющих символов, 
%  которые можно каким-то образом задать , 
есть альтернативная форма записи "--- соответствующий символ в~одинарных кавычках, например
\lstinline!'\0'! равен 0, \lstinline!'\t'! "--- 9, \lstinline!'2'! "--- 50, \lstinline!'R'! "--- 82, \lstinline!'r'! "--- 114. 
Для чисел, соответствующих номерам Unicode, добавляется префикс~\texttt{L}, так, \lstinline!L'ы'! равен 1099, или \hex{0x044B}.

\subsubsection{Префиксы системы счисления}
Целочисленные литералы могут предваряться префиксом, обозначающим систему счисления:
\begin{description}
\item[0x, 0X] "--- шестнадцатеричная;
\item[0] (ведущий ноль) "--- восьмеричная;
\item[0b, 0B] "--- двоичная;
\end{description}
по умолчанию (без префикса) используется десятичная система.
% 
Так, одно и~то же число может быть записано как \lstinline!13, 015, 0xD! и~\lstinline!0b1101!. 

Знак может быть поставлен только перед префиксом системы счисления, но не после него.


\subsubsection{Суффиксы знаковости и~размера}

Целый литерал без суффикса имеет тип \lstinline!int! (если значение выходит за пределы \lstinline!int!, то используется минимальный знаковый тип, в~который литерал помещается;
ACSII-коды имеют тип \lstinline!char!, Unicode-номера "--- \lstinline!wchar_t!).

Для указания беззнакового типа литерала (без суффикса размера это тип \lstinline!unsigned!) используется суффикс \lstinline!u! или \lstinline!U!. 

Для указания размера используются следующие суффиксы:
\begin{description}
\item[l, L] "---  \lstinline!long!;
\item[ll, LL] "---  \lstinline!long long!.
\end{description}
Так, \lstinline!2ul! "--- беззнаковое число типа \lstinline!unsigned long! (возможна также запись \lstinline!2lu!).

Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.

К~альтернативной символьной записи 
целых чисел 
суффиксы неприменимы.
% ACSII-коды имеют тип \lstinline!char!, Unicode-коды "--- \lstinline!wchar_t!.

\bottompagebreak[4\baselineskip]
\subsection{Вещественные}
\epigraph{\begin{stanza}[0mm]
\emph{Пи} далее и~далее в~ночную темноту.
\end{stanza}}{\Khlebnikov[Царапина по~небу]}
% \epigraphcensored[
% \epigraph{\begin{stanza}[0mm]
% Таинственный бокал похож на крюк,\\
% Вокруг него рассыпаны алмазы...
% \end{stanza}
% }{\Aquarium}
% ]{\epigraph{\begin{stanza}
%  Есть трудные места в таблице умноженья...
% \end{stanza}}
% {О.\,Арефьева}}
\index{Литералы!вещественные}%

Литералы с плавающей запятой задают значения, которые должны иметь дробную часть (возможно, нулевую). Эти значения содержат разделитель целой и~дробной частей (в~соответствии с~западной традицией "--- точку, \texttt{.}) и/или показатели степени: \texttt{34.56 $(34+\frac{56}{100})$, 0.12 $(\frac{12}{100})$, 1.} (вещественное число $1$), \lstinline!1e4! ($10^4$), \lstinline!5e-4! ($5\cdot10^{-4}$), \lstinline!2.12e+2! ($2,12\cdot10^2 = 212$),
\texttt{0x1p10} ($1\cdot2^{10}=1024$), \texttt{0xF.Fp4} ($\digitF,\digitF_{16}\cdot2^{4}=\digitF\digitF_{16}=255$),
\texttt{0x.8p0} ($0,8_{16}=\frac{1}{2}$),
\texttt{0x.8p-1} ($0,8_{16}\cdot2^{-1}=\frac{1}{4}$).

\subsubsection{Системы счисления}

Вещественные литералы могут быть заданы в~двух системах счисления "--- 
десятичной и~шестнадцатерично-двоичной.

Литерал в~десятичной системе %включает значащие цифры в~виде десятичного числа (возможно, с~дробной частью)  и~
может иметь вид
\begin{equation}
M[\mathtt{e}S] = M[\cdot10^{S}]
\end{equation}
где
$M$ "--- значащие цифры, записанные  в~виде десятичного числа (возможно, со знаком и/или с~дробной частью),
$S$ "--- десятичный порядок, записанный в~виде целого десятичного числа.
Порядок может быть опущен вместе с~символом~$\mathtt{e}$.
Регистр символа~\hex{e} может быть любым ($\mathtt{e/E}$).


Литерал в~шестнадцатерично-двоичной системе предваряется шестнадцатеричным префиксом~\hex{0x} или~\hex{0X} и~обязательно включает двоичный порядок
\begin{equation}
\hex{0x}M\mathtt{p}S = M\cdot2^{S}
\end{equation}
$M$ "--- значащие цифры, записанные  в~виде беззнакового шестнадцатеричного числа (возможно, с~дробной частью),
$S$ "--- двоичный порядок, записанный в~виде целого десятичного числа.
Так как символ~$\mathtt{e/E}$ является корректной шестнадцатеричной цифрой, порядок отделяется  символом~$\mathtt{p/P}$  (регистр может быть любым).
В~шестнадцатерично-двоичном вещественном литерале должны присутствовать обе компоненты~$M$ и~$S$, даже если $M=1$ или~$S=0$.
% (в~последнем случае, если)

Знак может быть поставлен перед префиксом~\hex{0x}.
% Полученное вещественное выражение будет иметь 

\subsubsection{Суффиксы размера}

Вещественный литерал без суффикса имеет тип \lstinline!double! (если значение выходит за пределы \lstinline!double!, то "--- \lstinline!long double!).
Для указания размера используются следующие суффиксы:
\begin{description}
\item[f, F] "---  \lstinline!float!;
\item[l, L] "---  \lstinline!long double!.
\end{description}
Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Строки}
\epigraph{\begin{stanza}[0mm]
Чётками чуткими\\
Пали зари.
\end{stanza}
}{\Khlebnikov[Зангези]}
% \epigraphcensored[\epigraph{\begin{stanza}[0mm]
% Равновеликие холодному молчанью\\
% Струились реки посреди равнин.\\
% Я плыл по рекам, но не дал названья\\
% Ни берегу, ни камню средь стремнин.
% \end{stanza}}{\Orgia}
% ]{
% \epigraph{\begin{stanza}
%  Он жадный. И лежит он в двух могилах.
% \end{stanza}}
% {О.\,Арефьева}}
\index{Литералы!строковые}%

Строковые литералы заключаются в~двойные кавычки.
Перед «широкими» строками ставится префикс \lstinline!L!.

Русские строковые литералы могут быть как узкими, так и~широкими.
При этом представление полученной константы в~памяти зависит от реализации.
Если используются «узкие» строки, то
количество символов в~полученной строке, как правило, превышает количество букв в~литерале за счёт того, что используется восьмибитный байт и~кодировка~UTF-8, так что одна русская буква представляется двумя элементами типа \lstinline!char!.

% В~выражениях %на место строкового литерала
Строковый литерал имеет тип \lstinline!const char*! или \lstinline!const wchar_t*! и~является адресом соответствующего массива символов, завершающегося нулём "---  строки, расположенной в~памяти.

Таким образом, %следующие переменные \texttt{s1} и~\texttt{s2}
% \begin{lstlisting}
% char s1[] = { 't', 'e', 's', 't', '\0' };
% char *s2 = "test";
% \end{lstlisting}
узкая строка \lstinline!"test"! %состоит не из четырёх 
занимает в~памяти не четыре байта, а~пять.
Объявления
\begin{lstlisting}[numbers=none]
char s[] = { 't', 'e', 's', 't', '\0' };
\end{lstlisting}
и
\begin{lstlisting}[numbers=none]
char s[] = "test";
\end{lstlisting}
эквивалентны.
% определяет одну и~ту же строку.
% При этом переменная~\texttt{s} во втором случае занимает четыре байта, так как содержит адрес строки.



\section{Средства автоматизации C++} 

\epigraph{
"--* А почему ты решила, что я стою только у этих ворот? "--- хмыкнула МакКанарейкл. "---
Кстати, спасибо, что напомнила. 
Все-сью-сюда!
}{\ZhvalevskijMytko[Личное~дело Мергионы \mbox{или Четыре~чёртовы дюжины}]}

Языки C и~C++ строго типизированы. 
Это позволяет избежать множества ошибок, но иногда требуется выполнить какое-нибудь одно действие над данными различных типов.

Для этого в~языке C++ доступны два средства "--- шаблоны C++  и~унаследованные от языка C макросы препроцессора.

Шаблоны раскрываются на этапе компиляции;
при формировании нужной реализации учитываются фактические типы и~значения параметров шаблона.
Макросы "--- текстовая замена, производящаяся на этапе препроцессинга без учёта семантики текста.

\bottompagebreak[7\baselineskip]
\subsection{Шаблоны C++}
% \epigraphcensored[
\epigraph{\begin{stanza}[0mm]
% Свет ночной, ночные тени,\\
% Тени без конца,\\
Ряд волшебных изменений\\
Милого лица.
\end{stanza}}{A.\,А\,Фет. Шёпот, робкое дыханье...}
% ]{
% \epigraph{\begin{limerick}
% Пожилой джентльмен из Норфолка\\
% Ходит в гости, запрятав иголку\\
% В отвороте кашне:\\
% "--- Вдруг пристанут ко мне\\
% Иль обидят "--- отвечу я колко!\\
% \end{limerick}
% }
% {А. Белкин}
% }
\index{Шаблоны C++}%

В~языке C++ для выполнения единообразных действий над данными различных типов используются шаблоны.
Существует два основных вида шаблонов "--- шаблонные функции и~шаблонные классы.

Перед заголовком соответствующей функции или класса
указывается дополнительный заголовок шаблона, который начинается с~ключевого слова \texttt{template},
после которого в~угловых скобках через запятую перечисляются параметры шаблона.
Для каждого параметра указываются его тип и~имя.
Тип параметра шаблона может быть перечислимым (в~частности, \texttt{int}, \texttt{char}, любое описанное пользователем перечисление) или описан ключевым словом \texttt{typename} или \texttt{class} (раздел \stdcppsec[temp.param]
стандарта утверждает, что семантика этих ключевых слов не различается), тогда параметр представляет собой имя типа C++.

\begin{lstlisting}[caption=Шаблонная функция, label=lst:cpp:templates-foo]
template<typename T>
int foo(T x)
{
  T y = x;
...
}
\end{lstlisting}

% Ключевое слово \texttt{typename} или \texttt{class}

Внутри шаблонной функции или шаблонного класса имя параметра может быть использовано как целочисленная именованная константа или как имя типа C++,
в~соответствии с~типом параметра.

% Параметром шаблона может быть тип (\texttt{typename} или \texttt{class}), а~также значения перечислимых типов.

\begin{lstlisting}[caption=Шаблонный класс, label=lst:cpp:templates-tmatrix]
template <typename T, int Rows, int Cols>
class TMatrix
{
    T data[Rows][Cols];
    ...
};
\end{lstlisting}

% \begin{lstlisting}
% template<typename T>
% T bar(T x)
% {
%   T y = x + 12;
%   ....
% }
% \end{lstlisting}
% 
% \begin{lstlisting}
% int i = 0, j, k, n;
% double x = 1, y;
% 
% j = foo(i);
% k = foo(x);
% 
% n = bar(i);
% y = bar(x);
% \end{lstlisting}
При вызове шаблонной функции достаточно просто передать ей набор параметров "--- \lstinline!j = foo(1)!.
Компилятор сформирует по шаблону нужную реализацию и~подставит её вызов.
При необходимости можно явно указать вызываемую реализацию, подставив после имени функции список фактических параметров шаблона "--- \lstinline!foo<int>(1.7)!. 
% В~этом случае

Можно явно описать реализацию шаблона для какого-либо конкретного типа (специализацию).

\begin{lstlisting}[caption=Частная реализация шаблона для типа \texttt{long}, label=lst:cpp:templates-expl]
template <typename T> T f(T x)
{
    return x;
}
template <> long f(long x)
{
    return 2*x;
}
\end{lstlisting}
% int main()
% {
%     std::cout << f(1) << f(1.0) << f(1l);
% 
%     return 0;
% }
В~этом случае при вызове шаблонной функции~$f()$ с~аргументом любого типа, кроме~\texttt{long}, в~том числе с~аргументом типа~\texttt{int},
она вернёт значение переданного аргумента~$x$, а~если вызвать $f()$ с~аргументом типа~\texttt{long} "--- его удвоенное значение~$2x$.
% \begin{lstlisting}[numbers=none]
% std::cout << f(1) << f(1.0) << f(1l);
% \end{lstlisting}

% \section{Препроцессор C/C++}
\bottompagebreak[9\baselineskip]
\subsection{Макросы препроцессора C/C++}
\index{Препроцессор!макросы}%

% \epigraphcensored[
\epigraph{
\begin{stanza}[0mm]
Разворачивайтесь в марше!\\
Словесной не место кляузе.\\
Тише, ораторы!\\
Ваше\\
слово,\\
товарищ маузер.\\
\end{stanza}
}{\Vvm[Левый марш]}
% ]
% {
% \epigraph{\begin{limerick}
% А другой  джентльмен из Норфолка\\
% Часто носит с собою двустволку:\\
% "--- Если вдруг мне в Норфолке\\
% Попадутся иголки "---\\
% От двустволки поболее толку.\\
% \end{limerick}
% }
% {А. Белкин}
% }

Для выполнения единообразных действий над величинами разных типов также могут использоваться макросы препроцессора, описанные в~разделе~\ref{sec:cpp-macro}.
% Так как параметрами макросов 

Так как макрос является по сути текстовой заменой, описанные в~нём действия могут быть применены к~данным любого типа.
Невозможно описать отдельную реализацию для параметров определённого типа, имени, длины или вида.

При этом % макросы, обрабатывающиеся 
в~макросе, в~отличие от шаблонной функции, возможно обработать не только значение или тип переменной, но и~её имя.
В~частности, макрос~\lstinline!PRINT!, описанный в~листинге~\ref{lst:cpp:define-PRINT}, выводит на стандартный вывод имя переменной и~её значение.

\begin{lstlisting}[caption={Определение макроса отладочной печати переменной}, label=lst:cpp:define-PRINT]
#define PRINT(val) cout << #val << " = " << val << "  ";
\end{lstlisting}

Таким образом, строка \lstinline!PRINT(x)PRINT(y)! будет преобразована препроцессором в: %~\lstinline!
\begin{lstlisting}
cout << "x" << " = " << x << "  ";cout << "y" << " = " << y << "  ";
\end{lstlisting}
и, если переменные~$x$ и~$y$ существуют, выведет их значение.
В~частности, при $x=5,7$ и~$y=0$  будет \modifyone[напечатано]{выведено}% что-то наподобие
~\lstinline!x = 5.7  y = 0!.



% \begin{lstlisting}
% #include <iostream>
% #include "myheader.h"
% 
% #define N 13
% #define MAX(x, y) ((x) > (y) ? (x) : (y))
% #define INTEGER short
% 
% // так делать плохо
% #define true 0
% 
% #define FLAG
% #ifdef FLAG
% ...
% #else
% ...
% #endif
% 
% \end{lstlisting}




\bottompagebreak[5\baselineskip]
\section{Ввод-вывод} 
% \epigraphcensoredtwo[
\epigraph{
Человек ведёт переписку со всем земным шаром, а~через печать сносится даже с отдалённым потомством. 
}{\PrutkovMA}
% ]{
% \epigraph{\begin{stanza}
% Ему вспомнилась милого детства пора,\\
% Невозвратные светлые дали "---\\
% Так похож был тот крик на скрипенье пера,\\
% Выводящего двойку в журнале. \\
% \end{stanza}
% }
% {\Snark}
% }

В~языке C++ доступно два варианта платформонезависимого ввода-вывода "--- полиморфные операторы ввода-вывода в~поток и~функции стандартной библиотеки C.

\bottompagebreak[6\baselineskip]
\subsection{Ввод-вывод в~поток}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
Тонут гении, курицы, лошади, скрипки.\\
Тонут слоны.\\
Мелочи тонут.
\end{stanza}
}{\Vvm[Человек]}
% ]{
% \epigraph{\begin{limerick}
%     Бедный дедушка в Иокогаме \\
%     С детства был обделён пирогами.\\
%     «Ах, зачем я рождён!» "---\\
%     Приговаривал он\\
%     И обиженно дрыгал ногами.\\
% \end{limerick}
% }
% {\Lear}
% }

В~библиотеке C++ описаны шаблонные классы потоков "--- объектов,
% для которых 
% предназначенных для ввода и~вывода.
% инкапсулирующие
куда может быть направлен ввод или откуда взят вывод.
В~качестве операторов ввода и~вывода используются перегруженные операторы битового сдвига \lstinline!<<! и~\lstinline!>>!.
Если левым операндом является поток, то оператор \lstinline!<<! выводит туда поток левый операнд и~возвращает ссылку на этот поток.
% Последнее даёт возможность
% cout << y<< endl << x << endl << s1 <<sizeof(s2) << s2  << endl;
Аналогично %работает оператор ввода
перегружен оператор~\lstinline!>>!.
% <iomanip>

% Система счисления (префикс не добавляется):
% \begin{itemize}
% \item манипуляторы \lstinline!hex, oct, dec!
% \item манипулятор \lstinline!setbase(int base)! (фактически "--- 8, 10 и~16).
% \end{itemize}
% 
% Регистр цифр \lstinline!A..F! и~символа \lstinline!E! в~экспоненциальной форме "--- манипуляторы \lstinline!uppercase! и~\lstinline!lowercase!.
% 
% Ширина "---  \lstinline!setw(int w)! (только для следующего выводимого значения).
% 
% Символ заполнения "--- \lstinline!setfill(int ch)!.


Используемые для вывода в~поток перегруженные операторы \lstinline!<<! и~\lstinline!>>! реализованы для разных типов по-разному.
% 
Типы \lstinline!char, signed char! и~\lstinline!unsigned char! отображаются в~потоке как символы, код которых равен значениям переменных.
Вывести значение такой переменной как число можно, преобразовав её в~другой целый тип, в~частности, \lstinline!int! или \lstinline!unsigned!, для чего можно использовать \lstinline!static_cast!:
\begin{lstlisting}[caption={Вывод первого байта $x$ в~поток как числа со знаком}]
char *p = reinterpret_cast<char *>(&x);
cout << static_cast<int>(*p);
\end{lstlisting}
или
\begin{lstlisting}[caption={Вывод первого байта $x$ в~поток как числа без знака}]
unsigned char *p = reinterpret_cast<unsigned char *>(&x);
cout << static_cast<unsigned>(*p);
\end{lstlisting}
оба эти листинга выводят в~поток \lstinline!cout! первый байт объекта~\lstinline!x!,
первый "--- как знаковое число, второй "--- как беззнаковое.

Прочие целые типы %по умолчанию
отображаются как значение в~десятичной, восьмеричной или шестнадцатеричной системе счисления.
Используемую систему счисления можно  изменить, используя манипуляторы \lstinline!hex, oct, dec! или \lstinline!setbase()!.
Манипуляторы \lstinline!hex, oct! и~\lstinline!dec! меняют вывод целых чисел (но не \lstinline!char!) на  шестнадцатеричный, восьмеричный и~десятичный соответственно.
Манипулятор \lstinline!setbase (int base)! позволяет задать основание; фактически можно выбрать только 8, 10 и~16.
Теми же манипуляторами можно задать систему счисления для ввода чисел.

Знак отображается только в~десятичной форме вывода; восьмеричная и~шестнадцатеричная формы при выводе знаковых чисел представляют собой двоичное представление числа, приведённое к~соответствующей системе счисления.
Так, число $-1$ (так как в~литерале не указан суффикс типа, число имеет тип \lstinline!int!) в~восьмеричной и~шестнадцатеричной формах соответственно выглядит как
\lstinline!37777777777! и~\lstinline!ffffffff!.

Регистр шестнадцатеричных цифр \lstinline!A..F! (а~также символа \lstinline!E! в~экспоненциальной форме вывода вещественных чисел) задаётся манипуляторами \lstinline!uppercase! и~\lstinline!lowercase!.

Манипулятор \lstinline!setfill(int ch)! 	устанавливает символ заполнения равным \lstinline!ch!.
В~частности, \lstinline!setfill('0')! указывает, что числа нужно дополнять до ширины, указанной манипулятором \lstinline!setw()!, не пробелами, а~ведущими нулями.

Действие манипуляторов \lstinline!hex, oct, dec, setbase()!, \lstinline!uppercase!, \lstinline!lowercase! и~\lstinline!setfill()! не прекращается после вывода/ввода одного числа и~длится до
% задания нового основания или символа заполнения 
изменения
другим аналогичным манипулятором.

Ширина вывода устанавливается манипулятором \lstinline!setw(int w)! только для следующего выводимого значения.
Если выводимое значение не помещается в~\lstinline!w! знакомест, оно выводится целиком.

Таким образом, строка
\begin{lstlisting}[style=lstsmall, caption=Вывод нескольких чисел в~поток]
cout << hex << setfill('0')
    << setw(4) << 10 << " " << 20 << " "
    << setw(3) << " " << setw(8) << 30 << " "
    << setw(2) << 257 << endl;
\end{lstlisting}
поместит в~поток \lstinline!cout!
\begin{lstlisting}[style=lstsmall]
000a 14 00 0000001e 101
\end{lstlisting}
манипулятор \lstinline!hex! действует на все целые числа;
\lstinline!setfill('0')! "--- на все выводимые данные, для которых ширина поля вывода превышает ширину данных (включая пробел, для которого установлена ширина поля вывода в~3 знакоместа);
манипулятор \lstinline!setw(4)! действует только на число 10 (\lstinline!0xA!), \lstinline!setw(3)! "--- только на выводимый после него пробел, \lstinline!setw(8)! "--- только на число 30 (\lstinline!0x1E!); \lstinline!setw(2)! не влияет на вывод числа 257 (\lstinline!0x101!), так как для его вывода нужно три знакоместа.

Порядок использования манипуляторов не важен.


\bottompagebreak[4\baselineskip]
% \subsection{Ввод-вывод с~помощью \modifytwo[libc]{стандартной библиотеки C}}
\subsection{Ввод-вывод с~помощью libc}
% \epigraphcensoredtwo[
\epigraph{
\begin{stanza}[0mm]
И при железных дорогах лучше сохранять двуколку. 
\end{stanza}
}{\PrutkovMA}
% ]{
% \epigraph{\begin{limerick}
%     Пожилой господин из Хунрепа \\
%     В гневе выглядел очень свирепо:\\
%     Он швырял сапоги,\\
%     Отвергал пироги\\
%     И питался морковкой и репой.\\
% \end{limerick}
% }
% {\Lear}
% }

Стандартная библиотека языка C \modifytwo[(libc)]{} включает множество функций ввода-вывода.
Как и~для любых функций стандартной библиотеки, подробную информацию о~них можно найти в~третьем разделе man-страниц GNU/Linux.
В~частности, команда
\lstinline[language=Bash]!$ man 3 printf!
выводит в~консоль данные о~функции \lstinline!printf()!, а~также об используемых ею форматных полях.

\subsubsection{Вывод}

% \subsubsection{Ввод-вывод строк}
% В~частности, п
Простой вывод строки~$s$ на стандартный вывод можно выполнить с~помощью функции
       \lstinline!int puts(const char *s)!.

% puts
% gets не рекомендуется man

% \subsubsection{Форматированный ввод-вывод}
% printf
% scanf
% #include <cstdio>

Форматированный вывод данных различных простых типов осуществляется с~помощью функции
\lstinline!int printf(const char *format, ...)!.
Первый аргумент этой функции "--- форматная строка, содержащая некоторый набор форматных полей,
а~следующие "--- выводимые данные простых типов.
Каждому полю обычно соответствует один параметр, выводимый функцией~$printf()$ на экран, для некоторых видов полей также требуется один или два дополнительных целых параметра, уточняющих формат вывода.

Несмотря на то, что второй и~последующие аргументы могут иметь различные типы, функция~$printf()$, как и~$scanf()$, не является ни шаблонной, ни перегруженной.
Соответственно, её имя не декорируется и~изменяется по правилам C-функций.

Форматное поле начинается с~символа~\lstinline!%! и~заканчивается буквой, обозначающей обобщённый вид формата, в~соответствии с~которым выводится значение (таблица~\ref{tab:cpp:printf-conversion}).%
\begin{table}[!ht]
\caption{Основные форматы вывода $printf()$}
\label{tab:cpp:printf-conversion}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Обозначение} & \thead{Преобразование} 
\\\hline
\multicolumn{2}{|c|}{\textbf{Форматы вывода целых чисел}}\\\hline
d, i 	&	Целое число выводится как знаковое десятичное значение
\\\hline
o, u, x, X  &	Целое число выводится как беззнаковое восьмеричное (\texttt{o}), десятичное~(\texttt{u}) или шестнадцатеричное (\texttt{x, X}) значение без префикса
\\\hline
c	&	Целое число преобразуется к~типу \lstinline!unsigned char!, после чего выводится символ с~соответствующим кодом
\\\hline
\multicolumn{2}{|c|}{\textbf{Форматы вывода вещественных чисел}}\\\hline
e, E	&	Вещественное число выводится в~десятичном экспоненциальном формате
\\\hline
f, F	&	Вещественное число выводится в~формате с~десятичной запятой
\\\hline
g, G	&	Вещественное число выводится в~десятичном экспоненциальном формате или формате с~десятичной запятой, так, чтобы результат был наиболее компактным
\\\hline
a, A	&	Вещественное число выводится в~шестнадцатеричном экспоненциальном формате с~двоичным порядком с~префиксом
\\\hline
\multicolumn{2}{|c|}{\textbf{Форматы вывода указателей}}\\\hline
s	&	Байты по указанному адресу выводятся как строка, завершающаяся нулём
\\\hline
p	&	Указатель выводится как шестнадцатеричное значение
\\\hline
\end{tabularx}
\end{table}
Символ процента можно вывести с~помощью поля~\lstinline!%%!, которому не должно соответствовать никакого параметра функции~$printf()$.

Между символом процента и~форматом вывода могут присутствовать (но не обязательно) символы, уточняющие формат.
% Для прочих форматов допускается только о
Они располагаются в~следующем порядке:
\begin{itemize}
\item флаги (таблица~\ref{tab:cpp:printf-flags}; флагов может быть несколько, один или ни одного);

\begin{table}[!ht]
\caption{Основные флаги вывода $printf()$}
\label{tab:cpp:printf-flags}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Обозначение} & \thead{Действие} 
\\\hline
% \multicolumn{2}{|c|}{\textbf{Форматы вывода целых чисел}}\\\hline
\# 	&	Значение выводится в~«альтернативной форме».

В~частности, для форматов \texttt{o} и~\texttt{x/X} добавляется префикс системы счисления (\texttt{0} и~\texttt{0x/0X} соответственно)
\\\hline
0 	&	Если длина значения в~заданном формате меньше заданной минимальной ширины поля вывода, значение дополняется ведущими нулями до заданной ширины.

При одновременном задании \texttt{0} и~\texttt{-} флаг \texttt{0} игнорируется
\\\hline
-	& Если длина значения в~заданном формате меньше заданной минимальной ширины поля вывода, значение выравнивается по левому краю поля
\\\hline
« » \textrm{(пробел)}	& Перед беззнаковыми числами (в~позиции, соответствующей знаку) вставляется пробел.

При одновременном задании \texttt{« »} и~\texttt{+} флаг \texttt{« »} игнорируется
\\\hline
+	& Перед положительными числами указывается знак $+$
\\\hline
\end{tabularx}
\end{table}


\item минимальная ширина поля вывода "--- число, звёздочка \texttt{*} (значение задаётся параметром) или другое описанное в~документации значение;
\item точность вывода (для целых форматов "--- общее количество выводимых цифр, для вещественных "--- после запятой);
точность 
% отделяется от минимальной ширины поля точкой и~
описывается аналогично минимальной ширине поля  "--- число, звёздочка \texttt{*} или другое описанное в~документации значение
и~отделяется от минимальной ширины точкой;
\item модификатор размера.
\end{itemize}
Любой из уточняющих символов может быть опущен.

\modifythree[Кроме форматных полей, в~форматной строке $printf()$ могут присутствовать произвольные символы
и~управляющие последовательности (\lstinline!\\n!, \lstinline!\\t!, \lstinline!\\\\! и~т.\,п.).
Символы выводятся на экран <<как есть>>, вместо управляющих последовательностей выводятся соответствующие символы
(в~частности, \lstinline!\\n! "--- перевод строки, \lstinline!\\t! "--- табуляция, \lstinline!\\\\! "---  одиночная обратная косая черта% \textbackslash
).
]{}
% 
Таким образом, строка
%   printf("Переменные: %d %d\n", 19, foo);
% \begin{lstlisting}[style=lstsmall, caption=Вывод чисел при помощи функции printf()]
\begin{lstlisting}[style=lstsmall]
printf("%+4d %03x\n", 19, 13);
\end{lstlisting}
% выведет на экран
поместит на стандартный вывод
\begin{lstlisting}[style=lstsmall,showspaces=true]
 +19 00d
\end{lstlisting}
% printf("%04x %x %08x %02x", )
% cout << hex << setfill('0')
%     << setw(4) << 10 << " " << 20 << " "
%     << setw(3) << " " << setw(8) << 30 << " "
%     << setw(2) << 257 << endl;
% \end{lstlisting}


Регистр шестнадцатеричных цифр \hex{A{-}F} соответствует регистру   буквенного обозначения формата.

Если целому аргументу функции~$printf()$ поставить в~соответствии вещественный формат вывода или наоборот, 
к~нужному типу приводится не сам аргумент, а~его адрес.
То есть число, выведенное на экран, не будет соответствовать  значению аргумента.





\begin{modifythreelong}
\subsubsection{Ввод}


Ввод данных в~соответствии с~заданным форматом осуществляется функцией %$scanf()$.
\lstinline!int scanf(const char *format, ...)!.
Форматная строка функции $scanf()$ и~подобных ей функций ввода состоит из последовательного описания ожидаемого формата вводимых данных и~способа их обработки.
Следующие за форматной строкой аргументы "--- %указатели,
адреса, куда записываются прочитанные и~обработанные данные (количество этих адресов, как правило, соответствует количеству %форматных 
полей форматной строки).

Форматная строка функции $scanf()$ может содержать:
\begin{itemize}
\item пробельные символы, при этом любая комбинация любых пробельных символов (собственно пробела, табуляции, перевода строки и~т.\,п.)
в~форматной строке
соответствует любой, в~том числе другой, вводимой комбинации любых пробельных символов 
либо их полному отсутствию в~указанном месте;

\item форматные поля, 
% начинающееся, как и~для $printf()$, знаком процента \lstinline!%!,
каждое из которых соответствует последовательности символов, которая может быть преобразована в~некоторое значение (в~частности, слово, символ, число),
а~значение "--- записано по одному из аргументов-адресов; %, в~порядке перечисления;

\item иные символы, которые должны присутствовать во вводимых данных <<как есть>>, в~противном случае чтение прервётся и~$scanf()$ завершит  работу.
\end{itemize}

Форматное поле $scanf()$ начинается, как и~для $printf()$, знаком процента \lstinline!%!
и~заканчивается обозначением формата (таблица~\ref{tab:cpp:scanf-conversion}).
\begin{table}[!ht]
\caption{Основные форматы ввода $scanf()$}
\label{tab:cpp:scanf-conversion}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Обозначение} & \thead{Преобразование} 
\\\hline
\multicolumn{2}{|c|}{\textbf{Форматы ввода целых чисел}}\\\hline
d 	&	Знаковое десятичное значение сохраняется как $int$
\\\hline
i 	&	Знаковое значение с~префиксом системы счисления (восьмеричное, десятичное или шестнадцатеричное) сохраняется как $int$
\\\hline
o 	&	Беззнаковое восьмеричное значение сохраняется как $unsigned~int$
\\\hline
u 	&	Беззнаковое десятичное значение сохраняется как $unsigned~int$
\\\hline
x, X 	&	Беззнаковое шестнадцатеричное значение без префикса сохраняется как $unsigned~int$
\\\hline
\multicolumn{2}{|c|}{\textbf{Форматы ввода вещественных чисел}}\\\hline
% \begin{tabular}{@{}l@{}}
e, E, f, g, a
% \\
% \end{tabular}	
&	Вещественное значение сохраняется как $float$
\\\hline
\multicolumn{2}{|c|}{\textbf{Форматы ввода символьных последовательностей}}\\\hline
s	&	Слово (последовательность непробельных символов) сохраняется как строка, завершающаяся нулём
\\\hline
[\textrm{множество}]	&	Последовательность символов из заданного множества сохраняется как строка, завершающаяся нулём
\\\hline
c	&	Последовательность произвольных символов (включая пробельные; количество ограничено максимальной шириной поля ввода, по умолчанию "--- один символ) сохраняется как строка без завершающего нуля
\\\hline
\end{tabularx}
\end{table}


Между ними могут присутствовать символы, уточняющие формат:
\begin{itemize}
\item символ \lstinline!*!, обозначающий, что значение этого форматного поля % вычисляется, но 
не сохраняется 
(такие поля %, помеченные звёздочкой, 
не учитываются при подсчёте возвращаемого значения $scanf()$);

\item максимальная ширина поля ввода (в~символах "--- широких \lstinline!wchar_t! или узких \lstinline!char!, в~зависимости от типа сохраняемой строки) "--- десятичное число;

\item модификатор размера (таблица~\ref{tab:cpp:scanf-size}), изменяющий тип сохраняемого значения.
\begin{table}[!ht]
\caption{Основные модификаторы размера}
\label{tab:cpp:scanf-size}
\small\def\normalsize{\small}
\begin{tabularx}{\linewidth}{|>{\ttfamily}l|L|} 
\hline
\normalfont\thead{Модификатор} & \thead{Тип приёмника} 
\\\hline
% \multicolumn{2}{|c|}{\textbf{Для целых значений}}\\\hline
hh 	& $signed~char$ для знаковых целых значений, 	$unsigned~char$ для беззнаковых	\\\hline
h 	& $short$ для знаковых целых значений, 	$unsigned~short$ для беззнаковых	\\\hline
l 	& $long$ для знаковых целых значений, 	$unsigned~long$ для беззнаковых, $double$~для вещественных;
для символьных последовательностей "--- использование широких символов 	\\\hline
ll, L	& $long~long$ для целых значений, 	 $long~double$ для вещественных	\\\hline
\end{tabularx}
\end{table}


\end{itemize}
Любой из уточняющих символов может быть опущен.

Для $scanf()$ форматы \texttt{x} и~\texttt{X} полностью эквивалентны, то есть любой из них соответствует чтению шестнадцатеричного числа с~произвольным регистром цифр. Эквивалентны также \texttt{e, E, f, g, a} "--- любой из них позволяет прочесть вещественное число в~любой форме.

Допустимое множество символов для формата \lstinline!%[...]! задаётся так же, как для регулярных выражений в~стиле Perl "--- перечисляется в~квадратных скобках без разделителей. 
Так, \lstinline!%[ab]! соответствует любому количеству символов \texttt{a} и~\texttt{b} в~любом порядке.
С~помощью дефисоминуса можно задать диапазон: \lstinline!%[0-9]! соответствует любому набору цифр;
с~помощью символа циркумфлекса (крышки), следующего сразу после открывающей квадратной скобки, получается дополнение множества:
\lstinline!%[^\r\n]! соответствует символам, не равным возврату каретки и~переводу строки, то есть всем символам до конца строки.
Если необходимо
% включить в~множество или
указать среди символов закрывающую квадратную скобку, то этот символ должен перечисляться первым после открывающей квадратной скобки или циркумфлекса;
циркумфлекс "--- 
% вторым или позже;
на любом месте, кроме первого после открывающей скобки;
дефисоминус "--- последним перед закрывающей скобкой.
% Циркумфлекс теряет своё спе
Так, \lstinline!%[^]0-9-]! "--- любые символы, кроме закрывающей квадратной скобки, цифр и~дефисоминуса.

Пробельные символы перед значениями любого  формата, кроме \lstinline!%c! и~\lstinline!%[...]! (но включая \lstinline!%%!, соответствующий одиночному знаку процента), игнорируются.
% Пробельные символы перед \lstinline!%c! или непосредственно указанными в~форматной строке символами учитываются.
% % В~частности, таким пробельным символом является перевод строки \lstinline!\n!, так что
% % файл, содержащий 
% % колонку чисел
% Соответственно, несколько чисел
% можно считать циклическим чтением \lstinline!"%g"!, но 
% % файл, содержащий колонку 
% % непробельных символов
% % букв, читать
% для букв необходимо явно указывать в~форматной строке наличие  разделителей: \lstinline!" %c "! или \lstinline!"%c\n"!.
% Все пробельные разделители при вводе эквивалентны друг другу
% (в~частности, перевод строки \lstinline!\n! при вводе множества значений может быть заменён на пробел или наоборот).
% Ввести строку, включающую пробельный символ, можно только при использовании форматов \lstinline!%c! и~\lstinline!%[...]!.
% 
Все элементы форматной строки "--- жадные.
% , то есть сопоставляются максимально возможному с~учётом ввода количеству символов.
% , таким образом, \lstinline!12! никогда не будет прочитано как .

Если для форматов  \lstinline!%s! и~\lstinline!%[...]! не задана максимальная ширина поля ввода, то
длина сохраняемой строки
зависит только от того, что вводит пользователь и~%
потенциально не ограничена.
Это легко может привести к~переполнению буфера, адрес которого передан соответствующим аргументом.
% Таким образом, если ёмкость буфера составляет $n$ символов (узк)
% Более того, если размер буфера равен~$n$ байт, то при 
При этом необходимо учесть, что максимальная ширина поля ввода 
не включает завершающий ноль,
а~также
задаётся в~символах \lstinline!char/wchar_t!, а~не в~буквах,
так что, если при вводе русских строк в~кодировке UTF-8
указать недостаточную максимальную ширину,
% Если же  максимальная ширина слишком мала, 
строка может быть оборвана % вероятность обрыва 
на полубукве.
% Соответственно, оптимальное значение максимальной ширины поля ввода для буфера размером $n$ символов равно $n-1$.

Функция  $scanf()$ возвращает количество успешно прочитанных и~присвоенных значений.
При корректных вводимых данных $scanf()$ вернёт число, равное количеству аргументов-адресов;
в~случае сбоя возвращаемое значение может быть меньше, в~том числе равным нулю или константе $EOF$ (она определяется как $-1$).
Если на каком-то этапе реальные вводимые данные не соответствуют форматной строке, дальнейший ввод не читается и~$scanf()$ завершает свою работу (при этом введённые, но не прочитанные данные остаются в~буфере, так что следующий вызов $scanf()$ или другой функции ввода начнёт чтение с~них).


Кроме $printf()/scanf()$, использующих стандартный вывод и~стандартный ввод,
библиотека libc
включает 
% множество аналогичных функций, отличающихся 
аналогичные пары функций, отличающиеся
использованием иного приёмника или источника данных
"--- это
% , в~частности, 
$sprintf()/sscanf()$ для формирования и~анализа строк
и~$fprintf()/fscanf()$ для записи и~чтения текстовых файлов.
% приёмником вывода/источником ввода.
Адрес источника/приёмника передаётся в~них первым параметром, перед форматной строкой.

\end{modifythreelong}


% \section{Исследование памяти в~C++} 
% \label{sec:cpp-memorydump}
% \epigraph{\begin{limerick}
% Злополучную даму в~Байраме\\
% Много раз прищемляло дверями.\\
% «А~может быть, впредь\\
% В~дверях не сидеть?» "---\\
% Подумала дама в~Байраме.\\
% \end{limerick}
% }
% {\Lear}
% 
% макросы и~шаблоны, применение для исследования памяти



\bottompagebreak[5\baselineskip]
\section{Отладочная печать}
\label{sec:cpp-memorydump}
\epigraph{
\begin{stanza}[0mm]
Читай запись дел твоих!\\ Ныне ты сам в~состоянии требовать от себя отчёт. 
\end{stanza}
}
{\Quran{17.15}}
\index{Память!просмотр содержимого}%

В~некоторых случаях использование окон отладчика по какой-то причине неудобно, в~частности, иногда необходимо сформировать файл протокола, содержащий шестнадцатеричные представления множества объектов.

\subsection{Средства исследования переменных} 
% \epigraphcensoredtwo[
\epigraph{
Спрашивается: можно ли сделать инструмент оптический, помощью которого можно б~было видеть вещи в море или в реках глубже, нежели как простыми глазами усмотреть можно.
}
{\Lomonosov[Задача, которую следует предложить на~соискание премии]}
% ]{
% \epigraph{\begin{limerick}
% Один старикашка с~косою\\
% Расправлялся косой с~колбасою "---\\
% И, косясь на зевак, \\
% Приговаривал так:\\
% «Что на свете сравнится с~косою!»
% \end{limerick}
% }
% {\Lear}
% }

Язык C++ предоставляет множество средств для исследования структуры объектов во~время выполнения программы.

%  the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or

\subsubsection{Идентификация типа}
% \footnote{Использован черновик стандарта C++14, раздел expr.typeid}

Для получения информации о~типе объекта во время исполнения программы (run-time type identification "--- RTTI, раздел \stdcppsec[expr.typeid] стандарта) в~C++ используется оператор \lstinline!typeid!.
Оператор \lstinline!typeid! принимает в~качестве параметра имя типа или переменной и~возвращает \lstinline!const std::type_info!.

{\sloppy
Класс \lstinline!std::type_info! включает метод \lstinline!name()!, возвращающий строку, характеризующую тип (не имя типа и~не формат вывода).
В~частности, \lstinline!typeid(int).name()! вернёт  \lstinline!"i"!, \lstinline!typeid(double).name()! "---  \lstinline!"d"!, а~\lstinline!typeid(long double).name()! "---  \lstinline!"e"!.
Составные типы характеризуются длинными многокомпонентными строками.

}

\subsubsection{Размер объекта}
% \footnote{Использован черновик стандарта C++14, раздел expr.sizeof}
Размер выделяемой под объект памяти можно узнать, используя оператор \lstinline!sizeof!.
% 
Согласно стандарту C++ (раздел \stdcppsec[expr.sizeof]),  оператор \lstinline!sizeof! возвращает количество байтов, используемое для представления операнда.

Размеры узких символьных типов \lstinline!sizeof(char), sizeof(signed char)! и~\lstinline!sizeof(unsigned char)! равны~$1$, для остальных стандартных типов определяется реализацией.

% \subsubsection{Адреса и~указатели}
\subsubsection{Дамп памяти}

% Указатель "--- объект (переменная), хранящая адрес другого объекта. 

С~точки зрения языка высокого уровня, указатели, хранящие адреса объектов различных типов, сами имеют разные типы.
Это сделано для защиты от ошибок, чтобы не попытаться рассмотреть в~памяти то, чего там нет (и~не получить очень странное значение, например, нечаянно прочитав часть вещественного числа как целое) или не испортить соседние переменные, записывая объект большого размера в~область, зарезервированную под меньший.

С точки зрения более низкого уровня, адреса объектов различных типов ничем не различаются, и~программист сам должен помнить размер, структуру и~назначение каждого объекта в~памяти.
Все адреса имеет один размер, соответствующий разрядности платформы, и,~теоретически, любой адрес может быть преобразован к~любому типу указателя.

На практике не любое преобразование указатель-указатель имеет смысл.
Так как размер любого типа кратен размеру  \lstinline!char!, адрес любого объекта~\lstinline!x! может быть преобразован в~указатель типа \lstinline!char *!.
Таким образом мы получим доступ к~байтам, составляющим объект, как к~массиву \lstinline!char!'ов; размер этого массива "--- количество байтов~в~\lstinline!x! "--- равен \lstinline!sizeof(x)!.


Язык C++ позволяет преобразовать указатели на разные типы только с~помощью самого наглого и~не портируемого оператора преобразования "--- \lstinline!reinterpret_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
\end{lstlisting}
{\sloppy
В~программировании на высоком уровне не рекомендуется использование \lstinline!reinterpret_cast! вообще и~преобразование типов указателей в~частности, так как это небезопасно.

}

Низкоуровневое программирование небезопасно само по себе.

Тем не менее, преобразование адреса объекта в~адрес цепочки байт,
которая затем выводится в~отладочный протокол "--- весьма эффективное средство исследования структуры этого объекта.

\subsubsection{Вывод в~поток}

Для формирования файла-протокола можно воспользоваться потоками вывода.
Ассоциировав в~программе какой-либо файл с~потоком типа \lstinline!fstream!, мы получим возможность записи протокола непосредственно в~этот файл.
Выводя протокол в~стандартный поток вывода (\lstinline!cout!), мы сможем наблюдать протокол в~консоли или сохранить его в~файл, используя перенаправление стандартного потока вывода в~командном интерпретаторе (в~частности, \lstinline!bash!\index{Bash}):
\begin{lstlisting}[language=Bash]
$ program > /tmp/log.txt
\end{lstlisting}
(данная команда запускает программу \lstinline!program! и~направляет её стандартный вывод не в~консоль, а~в~файл \lstinline!/tmp/log.txt!).
Второй способ более универсален, поэтому во всех примерах будем рассматривать стандартный поток вывода.

Таким образом, вывести в~поток \lstinline!cout! первый байт по адресу \lstinline!p! в~том, виде, который использован в~окне Memory dump (две шестнадцатеричные цифры с~ведущим нулём), можно следующим образом: 
\begin{lstlisting}[caption={Вывод первого байта по адресу $p$ в~шестнадцатеричном виде}]
unsigned char *p;
cout << hex << setfill('0') << setw(2) << static_cast<unsigned>(*p);
\end{lstlisting}
используется тип~\lstinline!unsigned char!, чтобы расширение до \lstinline!unsigned! гарантированно было беззнаковым, и~выводимое значение поместилось в~два знакоместа.

Адрес следующего элемента (с~учётом того, что \lstinline!p! "--- указатель на однобайтовый тип "--- следующего байта) равен \lstinline!p+1! и~так далее.
Соответственно, зная адрес начала переменной, можно вывести в~поток все составляющие её байты, сымитировав функциональность  окна Memory dump.

Зная размер переменной (\lstinline!sizeof(x)!), можно вывести на экран её побайтовое представление.
Оно может не совпадать с~шестнадцатеричным представлением из-за порядка байтов в~словах.
В~шестнадцатеричном представлении цифры выводятся по-арабски, от старшей к~младшей;
побайтовый вывод показывает реальный порядок байтов в~памяти (на платформе x86 "--- от младшего к~старшему), при этом  цифры каждого байта выводятся  от старшей к~младшей.

% \subsubsection{Шаблоны C++}
\subsection{Автоматизация отладочной печати}

% \epigraphcensoredtwo[
\epigraph{\begin{stanza}
Всё, что они делают, вносится в книги.\end{stanza}
}
{\Quran{54.52}}
% ]{
% \epigraph{\begin{limerick}
% Один старичок из Оттавы\\
% Обличал современные нравы.\\
% На совет: «Отдохни!»\\
% Возражал он: «Ни-ни!\\
% Я не все обличил ещё нравы!»\\
% \end{limerick}
% }
% {\Lear}
% }

% Для автоматизации отладочной печати можно воспользоваться  шаблонами. 
% Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.

Для автоматизации отладочной печати лучше реализовать её в~виде отдельной функции, чтобы упростить внесение изменений.
Назовём эту функцию  \lstinline!MemoryDump()!.
Пусть  \lstinline!MemoryDump()! получает в~качестве аргумента исследуемый объект \lstinline!x!, печатает данные о~нём в~стандартном потоке вывода и~возвращает ничего (\lstinline!void!).

Чтобы избежать приведения типа аргумента и,~соответственно, искажения данных о~нём,
необходима отдельная реализация \lstinline!MemoryDump()! для каждого возможного типа аргумента; 
при этом текст реализаций \lstinline!MemoryDump()! для различных типов аргументов будет полностью совпадать.
Для этого идеально подходит механизм \termin{шаблонов (templates).}
\index{Шаблоны C++}%
Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.
Так как нам нужно варьировать только тип аргумента, у~шаблона будет один параметр "--- имя типа аргумента функции:
\begin{lstlisting}[style=lstsmall, caption={Параметр шаблона "--- тип печатаемого значения}]
template<typename T>
void MemoryDump(T ...x)
{
...
}
\end{lstlisting}

Для доступа к~памяти, где реально находится объект, необходимо передать этой функций указатель или ссылку на него.
С~точки зрения низкого уровня указатель и~ссылка "--- одно и~то же; на уровне C++ передача по ссылке позволит использовать те же синтаксические конструкции, что и~для исследования локальной переменной.
\begin{lstlisting}[style=lstsmall, caption={Заголовок шаблона для печати дампа памяти}]
template<typename T>
void MemoryDump(T &x)
...
\end{lstlisting}
Так как планируется не изменение, а~только печать аргумента, правила хорошего тона требуют для него спецификатора \lstinline!const! (соответственно, используемый в~тексте \lstinline!MemoryDump()! указатель \lstinline!p! тоже должен быть константным).
Получим окончательный вариант шаблонной функции отладочной печати дампа памяти в~виде листинга \ref{lst:cpp:MemoryDump}.
\begin{lstlisting}[style=lstsmall, caption={Шаблон для печати дампа $x$}, label=lst:cpp:MemoryDump]
template<typename T>
void MemoryDump(const T &x)
{
    const unsigned char *p 
        = reinterpret_cast<const unsigned char *>(&x);

    cout << "Type: " << typeid(x).name() << " Value: " << x << endl
	 << "Size: " << sizeof(x) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
	 
    for(size_t i = 0; i < sizeof(x); ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Эта функция позволяет вывести в~стандартный поток вывода байты любой переменной в~том порядке, в~котором они лежат в~памяти.
В~частности, результатом следующего кода:
\begin{lstlisting}[style=lstsmall, caption={Печать сведений о~трёх переменных}]
int i = 1;
double d = 1;
long double ld = 1;

MemoryDump(i);
MemoryDump(d);
MemoryDump(ld);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall, caption={Значения, размеры и~дамп переменных}]
Type: i Value: 1
Size: 4
Dump: 01 00 00 00 

Type: d Value: 1
Size: 8
Dump: 00 00 00 00 00 00 F0 3F 

Type: e Value: 1
Size: 12
Dump: 00 00 00 00 00 00 00 80 FF 3F 00 00 
\end{lstlisting}
Для каждого такого вызова компилятор формирует отдельную функцию "---  реализацию шаблона \lstinline!MemoryDump()! для конкретного типа аргумента.  
Такие реализации перегружают друг друга и~имеют одно имя для C++; с~точки зрения компоновщика разные реализации имеют разные имена, так как по-разному декорируются.

При вызове шаблонной функции  \lstinline!MemoryDump()! конкретная вызываемая реализация определяется типом передаваемого фактического параметра.
Указывать реализацию явно (например, \lstinline!MemoryDump<int>(i)!) здесь не только не нужно, но и~вредно "--- если указанный тип реализации не совпадёт с~настоящим типом передаваемого параметра, результат будет некорректен.

Для указателя данная функция выведет размер и~представление в~памяти самой переменной-указателя, а~не тот фрагмент памяти, куда он указывает.

Если необходимо напечатать именно память, на которую указывает аргумент, необходимо модифицировать шаблонную функцию \lstinline!MemoryDump()!.
Получим листинг \ref{lst:cpp:PointerMemoryDump} (\lstinline!CellCount! "--- количество ячеек типа \lstinline!T! по адресу \lstinline!px!).
\bottompagebreak
\begin{lstlisting}[style=lstsmall, caption={Шаблон для печати дампа памяти по адресу $px$}, label=lst:cpp:PointerMemoryDump]
template<typename T>
void PointerMemoryDump(T *px, int CellCount)
{
    const unsigned char *p
        = reinterpret_cast<const unsigned char *>(px);

    size_t BytesCount = sizeof(*px)*CellCount;

    cout << "Type: " << typeid(px).name() << " Value: " << px << endl
	 << "Size: " << sizeof(px) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
	 
    for(size_t i = 0; i < BytesCount; ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Тогда результатом выполнения листинга \ref{lst:cpp:dump-str}, печатающего сведения  об указателе~$s$ и~восьмибайтовом значении по этому указателю,
\begin{lstlisting}[style=lstsmall, caption={Печать сведений об указателе и~о~значении}, label=lst:cpp:dump-str]
char *s = "abcdef";

MemoryDump(s);
PointerMemoryDump(s,8);
\end{lstlisting}
будет следующий вывод:
\begin{lstlisting}[style=lstsmall, caption={Дамп памяти собственно указателя и~значения по указателю}]
Type: Pc Value: abcdef
Size: 4
Dump: 08 96 04 08 

Type: Pc Value: abcdef
Size: 4
Dump: 61 62 63 64 65 66 00 54
\end{lstlisting}
{\sloppy
Таким образом, шаблонная функция \lstinline!MemoryDump(s)! выводит данные об указателе~\lstinline!s!,
а~\lstinline!PointerMemoryDump(s,8)! "--- о~строке~\lstinline!s!, включающей семь узких символов (шесть латинских букв и~завершающий строку нулевой символ).
Видно, что, кроме семи байт строки, листинг \ref{lst:cpp:dump-str} выводит ещё один, лишний, байт.

В~отладочной печати, как и~при изучении содержимого памяти при помощи инструментов интерактивной отладки, необходимо различать те переменные, которые содержат интересующее программиста значение и~переменные-указатели, которые содержат адрес интересующего значения.
}


\addquestion{Как называется головная функция программы на C++?}
\addquestion{Какие целые типы языка C++ вы знаете?}


\addquestion{Какие вещественные типы языка C++ вы знаете?}

\addquestion{Какие операторы преобразования типов C++ вы знаете?}

\addquestion{Как записываются целые, вещественные, строковые литералы?}

\addquestion{Как автоматизировать отладочную печать в~C++?}

% \addquestion{Для чего служит  модификатор volatile в~C++?    }
% \addquestion{Для чего служит спецификатор register в~C++?}
% \addquestion{Чем различается работа с~целыми числами разной разрядности?}
% \addquestion{Чем различается работа с~целыми и~вещественными числами?}

\printquestions




