



\chapter{Программирование на языке высокого уровня: С++}
\epigraph{
Два программиста быстро находят общий язык. \mbox{Как правило, это С++.}
}{\ProgFolk}

\section{Языки C и~C++} 
\epigraph{\begin{stanza}
Хворобей "--- провозвестник великих идей,\\
Устремлённый в~грядущее смело;\\
Он душою свиреп, а~одеждой нелеп,\\
Ибо мода за ним не поспела.\\
\end{stanza}
}
{\Snark}

% история, назначение

Синтаксис языков C и~C++ стандартизирован.
% \subsection{Стандарты C и~C++}


\newcommand{\Old}[1]{{%
  \renewcommand{\terminblue}{\color{blue!20!gray!60}}
  \color{blue!20!gray!70}
  #1%
}}
\newcommand{\UnderConstruction}[1]{\Old{%
  #1%
}}

\begin{itemize}
\item C
\begin{itemize}
\Old{
\item \termin{C89 (ANSI C)} ANSI X3.159-1989
\item \termin{C90} ISO/IEC 9899:1990

\item \termin{C99} ISO/IEC 9899:1999 %от 2007-11-15
}
\item \termin{C11} {ISO/IEC 9899:2011} %от 2011-12-19 
% 
% Последний бесплатный черновик "--- \termin{n1570} %от 2011-04-12
(последний черновик "--- \termin{n1570})

\end{itemize}

% https://isocpp.org/std/the-standard
\item C++
\begin{itemize}
\Old{
\item \termin{C++98} ISO/IEC 14882:1998 
\item \termin{C++11} ISO/IEC 14882:2011
}
\item \termin{C++14} ISO/IEC 14882:2014
% 
% Последний бесплатный черновик "--- \termin{n4296} %от 2014-11-19
\rlap{(последний черновик "--- \termin{n4296})}

\UnderConstruction{
\item \termin{C++17} Черновик \termin{n4595}
}
\end{itemize}
\end{itemize}






\section{Структура программы} 
\epigraph{\begin{stanza}
Я родился уже помня тебя, просто не знал, как тебя звать\\
Дох от жажды в твоих родниках "--- я не знал, как тебя знать\\
\end{stanza}}
{\Aquarium}
\index{main()}
\addquestion{Как называется головная функция программы на C++?}
% http://rsdn.org/article/cpp/crt.xml#EWE
Выполнение программы на C или C++ начинается с~функции~$main()$.
Она называется головной, стартовой или главной функцией программы.
Согласно стандарту C++, она должна быть определена как $int~main()$ или как $int~main(int,$ $char*[])$.
Обычно используются обозначения $int~main(int~argc,$ $char~*argv[])$.

Функцию $main()$ иногда называют точкой  входа в~программу, но это не совсем так.
С~точки зрения компоновщика, точка входа "--- это метка $\_start$.
Для программ на C/C++ по адресу  $\_start$ находится стартовый код библиотеки stdlib, который, в~частности,
инициализирует все 
используемые библиотекой ресурсы 
и~глобальные объекты, 
готовит параметры для стартовой функции~$main()$, вызывает её,
а~после возврата управления из $main()$ завершает программу.



Вызов программы с~параметрами, конвейер.
Щелчок мыши по файлу эквивалентен запуску программы с~параметром.

параметры

возвращаемое значение








\section{Типы данных} 
\label{sec:cpp-types}

\epigraph{\begin{stanza}
Для чего, в самом деле, полюса, параллели, \\
Зоны, тропики и зодиаки?\\
И команда в ответ: «В жизни этого нет, \\
Это "--- чисто условные знаки».\\
\end{stanza}
}
{\Snark}
% стандарт и~реализация в~x86




Базовые типы C++ описаны в~разделе Fundamental types (basic.fundamental) стандарта C++~\cite{isocpp}.
Раздел Types (basic.types) описывает общие характеристики хранения данных в~памяти.

% В~данном разделе также дана ссылка на раздел 5.2.4.2.1 стандарта C, где описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов.

% \subsection{Целые типы и~указатели}
\subsection{Целые типы}
% \subsection{Требования стандарта к~целым типам}
\addquestion{Какие целые типы языка C++ вы знаете?}

Существует пять стандартных \termin{знаковых целых типов}:  
\begin{itemize}
\item \lstinline!signed char!, 
\item \lstinline!signed short int! (синонимы: \lstinline!short, signed short!),  
\item \lstinline!signed int! (синонимы: \lstinline!int, signed!),
\item \lstinline!signed long int! (синонимы: \lstinline!long, signed long!),  
\item \lstinline!signed long long int! (синонимы: \lstinline!long long, signed long long!)
\end{itemize}
% компилятор может поддерживать и~д
и~пять соответствующих \termin{беззнаковых целых типов} (каждый из них имеет тот же размер и~те же требования к~выравниванию, что и~соответствующий знаковый):
\begin{itemize}
\item \lstinline!unsigned char!, 
\item \lstinline!unsigned short int! (синонимы: \lstinline!unsigned short!),  
\item \lstinline!unsigned int! (синонимы: \lstinline!unsigned!),
\item \lstinline!unsigned long int! (синонимы: \lstinline!unsigned long!),  
\item \lstinline!unsigned long long int! (синонимы: \lstinline!unsigned long long!).
\end{itemize}
Тип \lstinline!char!, в~зависимости от реализации, может быть знаковым или беззнаковым.
Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! имеют один размер и~одинаковые требования к~выравниванию.


Стандарт C++ не содержит явных значений разрядности типов.

Согласно стандарту,
% размер типа \lstinline!char! "--- минимально возможный размер какого-то объекта в~памяти, кроме того, размер любого объекта кратен размеру~\lstinline!char!;
% также в~разделе Sizeof указано, что 
\lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! занимают 1~байт.
При этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! \emph{однобайтовый,} но \emph{не однооктетный,}
то есть занимает не~8~бит.
% 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта

% Оператор \lstinline!sizeof! возвращает, сколько раз \lstinline!char! укладывается в~аргументе. 
Таким образом, всякий объект любого типа (обозначим его \lstinline!T!) может быть скопирован в~массив \lstinline!char [sizeof(T)]!.

В~ряду целых типов каждый следующий тип имеет размер (и~диапазон значений)  не меньше предыдущего:
$$
\begin{array}{c}
\mathlst{sizeof(char)} \leqslant \mathlst{sizeof(short)} \leqslant \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
\leqslant \mathlst{sizeof(long long)}
\end{array}
$$
Размеры стандартных целых типов C++ также должны соответствовать ограничениям раздела 5.2.4.2.1 стандарта C.
В~этом разделе описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов (при этом указанные значения не обязательно должны быть граничными).
% $$
% \begin{array}{lcl}
% \mathlst{sizeof(char)} \geqslant 
% \mathlst{sizeof(short)} \leqslant 
% \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
% \leqslant \mathlst{sizeof(long long)}
% \end{array}
% $$
Анализ этих значений приводит к~следующим выводам о~минимально допустимой разрядности стандартных типов:\\
\strut\hfill
\begin{tabular}{l|l}
Тип & Разрядность, бит (не менее) \\\hline
 \lstinline!char! & 8 \\
 \lstinline!short! & 16 \\
 \lstinline!int! & 16 \\
 \lstinline!long! & 32 \\
 \lstinline!long long! & 64 \\
\end{tabular}
\hfill\strut\bigskip




Тип \lstinline!int! должен соответствовать «естественной» разрядности архитектуры
(расплывчатость этой формулировки приводит к тому, что практически на 64-битной платформе тип \lstinline!int! чаще всего 32-разряден).

% \subsubsection{интерпретация}
%  и~называются ещё \termin{узкими (narrow)}

% Размер типа \lstinline!char! 

Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! называются ещё \termin{узкими (narrow) символьными типами}, так как 
% хранящееся в~переменных так
они могут быть интерпретированы не только как числа, но и~как символы; соответственно
их размер должен быть таким, чтобы хранить представление любого символа из \termin{базового набора.}

Единственное отличие %типа \lstinline!char! 
узких символьных типов
от других целых (кроме размера) "--- то, что операторы ввода/вывода в~поток для них перегружены так, что отображают не значение переменной, а~символ, код которого равен этому значению.
Все арифметические операции для \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! выполняются точно так же, как и для любого другого целого типа.


Для  типа \lstinline!unsigned char!
каждой возможной  комбинации разрядов должно соответствовать отдельное число. 
Для других типов это не обязательно.

Для представления \termin{расширенного набора  символов} введён специальный тип \lstinline!wchar_t!, имеющий такой же размер, знаковость и~требования к~выравниванию, что и~один из~целых типов.


Тип \lstinline!bool! может хранить только два значения "--- \lstinline!true! и~\lstinline!false!.

\subsubsection{Практическая реализация}

\warning{Всё, что явно не прописано в~стандарте C++, может быть реализовано по-разному на различных платформах.

% Соответственно, в
Всё, написанное  в~этом разделе и~в~аналогичных разделах ниже, описывает в~основном платформу x86 и~наиболее популярные компиляторы.
На других программно/аппаратных платформах (в~частности, при использовании экзотического компилятора) эти закономерности могут быть нарушены.
}

Для представления беззнаковых чисел используется натуральный двоичный код;
знаковые представляются дополнительным кодом (таблица~\ref{tab:naturalbincode}).
Таким образом, для всех целых типов, в~частности, для \lstinline!unsigned char!, каждой возможной  комбинации разрядов  соответствует отдельное число.
\index{Представление данных!целых!натуральный код}

\begingroup
%  \scriptsize
% \renewcommand{\arraystretch}{1.05}
\newcolumntype{Y}{>{$}R<{$}}
\renewcommand\theadlong[1]{\multicolumn{1}{@{}R@{}}{{\bfseries\small #1\par
\vspace*{-1\baselineskip}
\strut
}}}

\begin{table}

\caption{Натуральный двоичный и~дополнительный коды}
\label{tab:naturalbincode}

% \noindent
\begin{tabularx}{1\linewidth}{YYYY@{\hspace{4em}}}
\theadlong{Тетрада}& \theadlong{16-ричный код} & \theadlong{Беззнаковое представление}
& \theadlong{Дополнительный код (доп. до 2)} 
	\\\hline

0000 & 0	& 0 &	0  			\\%\hline
0001 & 1	& 1 &	+1 			\\%\hline
0010 & 2	& 2 &	+2 			\\%\hline
0011 & 3	& 3 &	+3 			\\\hline
0100 & 4	& 4 &	+4 			\\%\hline
0101 & 5	& 5 &	+5 			\\%\hline
0110 & 6	& 6 &	+6 			\\%\hline
0111 & 7	& 7 &	+7 			\\\hline
1000 & 8	& 8 &	-8 		\\%\hline
1001 & 9	& 9 &	-7 			\\%\hline
1010 & A	& 10 &	-6 			\\%\hline
1011 & B	& 11 &	-5 			\\\hline
1100 & C	& 12 &	-4 			\\%\hline
1101 & D	& 13 &	-3 			\\%\hline
1110 & E	& 14 &	-2 			\\%\hline
1111 & F	& 15 &	-1 			\\\hline


\end{tabularx}
\end{table}
\endgroup

Как видно из таблицы~\ref{tab:naturalbincode}, минимальное беззнаковое четырёхбитное число "--- ноль ($0b0000$),
максимальное "--- $2^4 - 1 = 15$ ($0b1111$).
Минимальное знаковое четырёхбитное число "---  $-2^3 = -8$  ($0b1000$),
максимальное "--- $2^3 - 1 = +7$ ($0b0111$).

Для знаковых и~беззнаковых типов по-разному реализованы некоторые арифметические и~битовые операции, в~частности, умножение (\lstinline!*!), деление (\lstinline!/, %!), битовые сдвиги (\lstinline!<<,>>!), расширение при присваивании (если приёмник больше источника).

\paragraph{char, wchar\_t%
\footnote{Использованы материалы forum.ishodniki.ru}%
}

% % Соответственно,
% Для большинства программно/аппаратных платформ 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта, занимает один байт
% (при этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! однобайтовый, но не однооктетный).
% % , как минимально  размер любого типа кратен \lstinline!char!.
% % , хотя есть и~исключения (как правило, платформы, где байт не восьмибитен).

Тип \lstinline!char! "--- восьмибитный и~знаковый.
При этом  \lstinline!char! и~\lstinline!signed char! не являются синонимами, хотя вычисления с~их использованием компилируются в~одинаковые конструкции.
% 
Именно, при перегрузке  \lstinline!f(char)! и~\lstinline!f(signed char)! считаются разными функциями и~их имена декорируются по-разному (для сравнения, \lstinline!f(int)! и~\lstinline!f(signed int)! не различаются и~декорируются одинаково).


Базовым набором символов является ASCII.
% Изначально стоит текущая для всего локаль "C" в котрой мало что известно, по сути это просто US ASCII как правило. не Linux
% 
При интерпретации переменной типа \lstinline!char! как символа
значение этой переменной трактуется как ASCII-код.
% , если оно лежит в~пре
% от 0 до 127 интерпретируется
Таким образом, 64, 0x40 и '@' "--- это разные формы записи одного и того же числа (ASCII-код символа «собака» равен шестидесяти четырём).

Символы не из ASCII, в~частности, русские буквы, в~зависимости от реализации, могут быть представлены 
одной переменной типа  \lstinline!char! (кодировки koi8, cp1251, cp866; в~этом случае с учётом знаковости \lstinline!char! коды русских букв "--- 128--255 "--- трактуются как отрицательные, то есть \lstinline!'ы' < 0 < 's'!)
или цепочкой из нескольких 
% переменными типа  
\lstinline!char!'ов (кодировка UTF-8; в~этом случае можно описать строку из русских букв как \lstinline!char []!, но невозможно описать одну такую букву как \lstinline!char!).
% Представление одного символа несколькими  переменными не очень удобно

% http://forum.ishodniki.ru/index.php/topic,19509.msg80866.html?PHPSESSID=0231dfe0510c43d48470048b3716466b#msg80866

Понятие расширенного набора  символов и~тип  \lstinline!wchar_t! возникли с~появлением Unicode.
Широкий символьный тип \lstinline!wchar_t! может содержать любое количество байтов.
% С появлением юникода появился и тип "широких" символов wchar_t. Вот уж сколько в нем байтов или char-ов совершенно неизвестно. Но про него известны 2 хорошие вещи которые как правило создатели компиляторов и API закладывают в него :
% - Он используется как правило для преставления какой либо Unicode кодировки.
% - У него фиксированная длина символов. Это достаточно важно. Как известно символы в юникоде представленны абстрактным кодовым пространством (UCS).  А в реальных устройствах эти абстрактные ккоды кодируются различными "юникодными" кодировками (UTF). Причем на разные символы у этих юникодных кодировок может быть переменное число байт. Так вот прелесть wchar_t в том, что в нем обычно используются такие юникодные кодировки или их части в которых каждый логический символ занимает ровно один wchar_t.
Как правило,  при хранении символьной информации в~\lstinline!wchar_t! используются такие юникодные кодировки или их части, в~которых каждый логический символ занимает ровно один \lstinline!wchar_t! (UTF-32, или, если поддерживается только часть набора символов Unicode "--- UTF-16).
Расширенный набор символов, соответственно "--- та часть набора символов Unicode, которая поддерживается и~может быть записана одним \lstinline!wchar_t!.

Литералы, соответствующие широким строкам и~символам, предваряются префиксом \lstinline!L!.
Для ввода/вывода широких символов и~строк используются те же операторы, что и~для узких, но другие потоки (\lstinline!wcin/wcout!). Поток \lstinline!cout! при выводе  \lstinline!wchar_t! отображает число, при выводе \lstinline!wchar_t*! "--- адрес в~шестнадцатеричном виде. 


% http://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c
% char is always a byte , but it's not always an
% octet. A byte is the smallest addressable unit of
% memory (in most definitions), an octet is 8-bit
% unit of mem

\paragraph{int, short, long, long long}


% Нечёткость требований к~размеру стандартных типов формулировки приводит к тому, что практически 
Тип \lstinline!int! на 16-разрядных платформах занимал 16 бит, на 32-разрядных "--- 32 бита.
На 64-битной платформе \lstinline!int! чаще всего 32-разряден.

Тип \lstinline!short! 16-разряден на 16-, 32- и~64-разрядных платформах.

Тип \lstinline!long! на 16- и~32-разрядных платформах занимал 32 бита.
На 64-битной платформе "--- 64.

Тип \lstinline!long long!, если поддерживается, 64-разряден.

\subsection{Вещественные типы}
\addquestion{Какие вещественные типы языка C++ вы знаете?}

Существует три стандартных \termin{вещественных типа}:  
\begin{itemize}
\item \lstinline!float!, 
\item \lstinline!double!,  
\item \lstinline!long double!.
\end{itemize}
тип \lstinline!double! обеспечивает не меньшую точность, чем \lstinline!float!,
\lstinline!long double! "---  не меньшую точность, чем \lstinline!double!.

Множество значений типа \lstinline!float! является подмножеством множества  значений типа  \lstinline!double!;
множество значений типа \lstinline!double! является подмножеством множества  значений типа  \lstinline!long double!:
$$
\mathlst{float} \subseteq \mathlst{double} \subseteq \mathlst{long double}
$$

\subsubsection{Практическая реализация}
\index{Представление данных!вещественных!расширенной точности}
\index{Представление данных!вещественных!двойной точности}
\index{Представление данных!вещественных!одинарной точности}

% \footnote{Использованы материалы: 
% В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
% с~плавающей точкой;
% текст стандарта IEEE Std 754™-2008
% }%
Вещественные числа представляются в~форматах с~плавающей запятой различной точности, в~соответствии со стандартом двоичной арифметики с~плавающей точкой IEEE 754~\cite{ieeeFloat1985rus, ieeeFloat2008}.

Модуль операций с~плавающей запятой процессоров семейства x86 (floating point unit, FPU) %— часть процессора для выполнения широкого спектра математических операций над вещественными числами.
поддерживает три типа вещественных чисел 
\begin{itemize}
\item  одинарной точности (32 бита), 
\item  двойной точности (64 бита), 
\item  с~двойной расширенной точностью (80 бит, внутренний формат FPU "--- 15 разрядов отводится под порядок,  64 под мантиссу), отводится под экпоненту).
\end{itemize}
Типу \lstinline!float! соответствует число одинарной точности, 
типу \lstinline!double! "--- двойной.

{
Типу \lstinline!long double! чаще всего соответствует 10-байтовое число расширенной точности. % при этом они могут требовать выравнивания
Размер выделяемой под переменную \lstinline!long double! памяти при этом %может превышать реальный размер числа и, 
в~зависимости от флагов компиляции (\verb!-m96bit-long-double! и~\verb!-m128bit-long-double! в~GCC), может быть равен 12 или 16 байт. 
Используются только первые 80 бит (10 байт), остальное "--- неиспользуемая память (заполнение). 
% -m96bit-long-double
% -m128bit-long-double
% These switches control the size of long double type. The i386 application binary interface specifies the size to be 96 bits, so -m96bit-long-double is the default in 32 bit mode.
% Modern architectures (Pentium and newer) would prefer long double to be aligned to an 8 or 16 byte boundary.
% \sloppy

}

В~Microsoft Visual Studio типу \lstinline!long double!  соответствуют числа двойной точности (64 бита), хотя \lstinline!long double! не считается синонимом \lstinline!double!.


\subsection{Специальные типы}

Множество значений типа  \lstinline!void! пусто.
Он используется для описания функций, которые не возвращают значения.

% Любое выражение может быть приведено к~типу 
% \lstinline!void!.


\subsection{Указатели}

Указатели:
% 
void*, char*, ...

Разность указателей:
% 
ptrdiff\_t

Длина: size\_t



\section{Преобразование типов\footnote{Использована статья 
Е.\,Сагалаевой «Приведение типов в C++»
% «Приведение типов»% (\url{http://habrahabr.ru/post/106294/})
}}
\label{sec:cpp-cast}
\epigraph{\begin{stanza}
При встрече с~медвежьим капканом\\
Пойди объясни, что ты не медведь.
\end{stanza}}
{\Aquarium}


В~С++ есть четыре оператора явного преобразования (приведения) типов: \lstinline!const_cast!, \lstinline!static_cast!, \lstinline!dynamic_cast! и~\lstinline!reinterpret_cast!. 
Кроме того, для совместимости поддерживается приведение в~стиле C.

\begin{description}

\item[const\_cast] убирает (или добавляет, но это редко используется) так называемые cv-спецификаторы (cv qualifiers), то есть const и volatile. volatile встречается не очень часто, так что  \lstinline!const_cast! более известен как приведение типов, предназначенное для убирания const. Если приведение типов не удалось, выдается ошибка на этапе компиляции.
При использовании остальных приведений типов cv-спецификаторы останутся как были.
\begin{lstlisting}[style=lstsmall]
int i;
const int * pi = &i;
// *pi имеет тип const int,
// но pi указывает на int, который константным не является
int* j = const_cast<int *> (pi);
\end{lstlisting}

% http://rsdn.ru/article/cpp/static_cast.xml
\item[static\_cast]
% Синтаксис:
% TYPE static_cast<TYPE> (object);
преобразует выражения одного статического типа в объекты и значения другого статического типа. 
% Самый популярный вид преобразования.
Может быть использован везде, где допустимо неявное преобразование типов (в~частности, преобразования чисел вроде \lstinline!int i = 1.3;! или указателя произвольного типа в~нетипизированный \lstinline!void *up = &i;!), а~также для преобразования:
\begin{itemize}
\item    любого типа к типу void (допустимое, но обычно ненужное на практике преобразование);
\item указателя \lstinline!void *! в~указатель произвольного типа;
\item    базового класса к ссылке на производный класс (допустимо, но опасно, если объект на самом деле не того производного класса; в~этих случаях часто лучше использовать  \lstinline!dynamic_cast!);
\item указателя на базовый класс  в~указатель на производный класс (аналогично, надёжнее использовать \lstinline!dynamic_cast!, если это возможно);
% \item    инверсия некоторых стандартных преобразований, в~частности:
% \begin{itemize}
\item    интегральных типов в перечисляемые%;
% \item    (возможно cv-квалифицированный) Base * в (с не меньшей cv-квалификацией) Derived *
% \item    (возможно cv-квалифицированный) T Base:: * в (с не меньшей cv-квалификацией) T Derived:: *
% \item    (возможно cv-квалифицированный) void * в любой T *
% \end{itemize}
.
\end{itemize}
Если приведение типов не удалось, выдается ошибка на этапе компиляции.

\item[dynamic\_cast]
"--- безопасное приведение по иерархии наследования, в том числе виртуального.
Используется для преобразования
\begin{itemize}
\item указателя на базовый класс  в~указатель на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class *>(base_class_ptr_expr)
\end{lstlisting}
если приведение невозможно, будет возвращён NULL;

\item    базового класса к ссылке на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class &>(base_class_ref_expr)
\end{lstlisting}
если приведение невозможно, 
% Работа со ссылками происходит аналогично, но в случае ошибки во время выполнения 
будет выброшено исключение \lstinline!bad_cast!.
\end{itemize}
% Используется RTTI (Runtime Type Information), чтобы привести один указатель на объект класса к другому указателю на объект класса. 
Для корректного преобразования классы должны быть полиморфными, то есть в базовом классе должна быть хотя бы одна виртуальная функция. Если это условие не соблюдено, ошибка возникнет на этапе компиляции.
 Если приведение невозможно, это станет ясно только на этапе выполнения программы.

\item[reinterpret\_cast]
"--- приведение без проверок. Не может быть приведено одно значение к другому значению. Обычно используется, чтобы привести указатель к указателю, указатель к целому, целое к указателю. Умеет также работать со ссылками.

Возможные варианты использования
\begin{lstlisting}[style=lstsmall]
reinterpret_cast<whatever *>(some *)
reinterpret_cast<integer_expression>(some *)
reinterpret_cast<whatever *>(integer_expression)
\end{lstlisting}
Например, допустимо:
\begin{lstlisting}[style=lstsmall]
double x = 1;
int i = -1;
char *pc = reinterpret_cast<char *>(&x);

// refu -- ссылка на то же место в памяти, где расположена переменная i,
// но интерпретируется этот фрагмент памяти уже как unsigned
unsigned &refu = reinterpret_cast<unsigned &>(i);

// pu указывает на то же место в памяти, где расположена переменная i (аналогично)
unsigned *pu = reinterpret_cast<unsigned *>(&i);

// u -- новая переменная, инициализированная текущим значением i в беззнаковой интерпретации (0xFFFFFFFF)
unsigned u = reinterpret_cast<unsigned &>(i);

// lox ссылается на первые (в x86 -- младшие) 4 байта x и интерпретирует их как беззнаковое целое
unsigned &lox = reinterpret_cast<unsigned &>(x);
unsigned &hix = *(&lox + 4);
\end{lstlisting}
% используя пару разнотипных переменных 
% 
Но нельзя выполнить
\begin{lstlisting}[style=lstsmall]
int i;
unsigned u = reinterpret_cast<unsigned>(i);
\end{lstlisting}

\item[Приведение в~стиле C](C-style cast) "--- самое медленное преобразование, так как  последовательно перебираются следующие вызовы:
\begin{enumerate}
\item    \lstinline!const_cast!
\item    \lstinline!static_cast!
\item    \lstinline!static_cast + const_cast!
\item    \lstinline!reinterpret_cast!
\item    \lstinline!reinterpret_cast + const_cast!
\end{enumerate}
Допустимо во всех случаях, но не рекомендуется из-за внешнего вида.

Примеры:
\begin{lstlisting}[style=lstsmall]
double x = 1;
int i = -1;
char *pc = (char *)(&x);
unsigned &refu = (unsigned &)i;
unsigned *pu = (unsigned *)&i;
unsigned u = (unsigned)i;
\end{lstlisting}


\end{description}



\section{Литералы C++}
\epigraph{\begin{stanza}
Тридцать восемь тюков он на пристань привез,\\
И~на каждом "--- свой номер и~вес;\\
Но потом как-то выпустил этот вопрос\\
И~уплыл в~путешествие без.\\
\end{stanza}
}
{\Snark}

\subsection{Целые}

Целочисленные литералы начинаются с~цифры или знака ($+$ или $-$) и~не содержат десятичной запятой и~показателя степени. 

Для тех чисел, которые соответствуют кодам ASCII для печатных и~некоторых управляющих символов, 
%  которые можно каким-то образом задать , 
есть альтернативная форма записи "--- соответствующий символ в~одинарных кавычках, например
\lstinline!'\0'! равен 0, \lstinline!'\t'! "--- 9, \lstinline!'2'! "--- 50, \lstinline!'R'! "--- 82, \lstinline!'r'! "--- 114. 

\subsubsection{Префиксы системы счисления}
Целочисленные литералы могут предваряться префиксом, обозначающим систему счисления:
\begin{description}
\item[0x, 0X] "--- шестнадцатеричная;
\item[0] (ведущий ноль) "--- восьмеричная;
\item[0b, 0B] "--- двоичная;
\end{description}
по умолчанию (без префикса) используется десятичная система.
% 
Так, одно и~то же число может быть записано как \lstinline!13, 015, 0xD! и~\lstinline!0b1101!. 

\subsubsection{Суффиксы знаковости и~размера}

Целый литерал без суффикса имеет тип \lstinline!int! (если значение выходит за пределы \lstinline!int!, то "--- минимальный знаковый тип, в~который литерал помещается).

Для указания беззнакового типа литерала (без суффикса размера это тип \lstinline!unsigned!) используется суффикс \lstinline!u! или \lstinline!U!. 

Для указания размера используются следующие суффиксы:
\begin{description}
\item[l, L] "---  \lstinline!long!;
\item[ll, LL] "---  \lstinline!long long!.
\end{description}
Так, \lstinline!2ul! "--- беззнаковое число типа \lstinline!unsigned long! (возможна также запись \lstinline!2lu!).

Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Вещественные}
Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные точки (.) и/или показатели степени: \lstinline!34.56, 0.12, 1.! (вещественное число 1), \lstinline!1e4! ($10^4$), \lstinline!5e-4! ($5\cdot10^{-4}$), \lstinline!2.12e+2! ($2,12\cdot10^2 = 212$).

Вещественный литерал без суффикса имеет тип \lstinline!double! (если значение выходит за пределы \lstinline!double!, то "--- \lstinline!long double!).
Для указания размера используются следующие суффиксы:
\begin{description}
\item[f, F] "---  \lstinline!float!;
\item[l, L] "---  \lstinline!long double!.
\end{description}
Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Строки}

Строковые литералы заключаются в~двойные кавычки.
Перед «широкими» строками ставится префикс \lstinline!L!.


\section{Ввод-вывод} 
\epigraph{\begin{stanza}

На обыденных картах "--- слова, острова,\\
   Все сплелось, перепуталось "--- жуть!\\
А на нашей, как в море, одна синева,\\
  Вот так карта "--- приятно взглянуть!\\
\end{stanza}
}
{\Snark}

\subsection{Ввод-вывод в~поток}

<iomanip>

Система счисления (префикс не добавляется):
\begin{itemize}
\item манипуляторы \lstinline!hex, oct, dec!
\item манипулятор \lstinline!setbase(int base)! (фактически "--- 8, 10 и~16).
\end{itemize}

Регистр цифр \lstinline!A..F! и~символа \lstinline!E! в~экспоненциальной форме "--- манипуляторы \lstinline!uppercase! и~\lstinline!lowercase!.

Ширина "---  \lstinline!setw(int w)! (только для следующего выводимого значения).

Символ заполнения "--- \lstinline!setfill(int ch)!.

\subsection{Ввод-вывод с~помощью стандартной библиотеки C}

printf

scanf



\section{Адресация и~указатели}


\epigraph{\begin{limerick}
Старовер-маловер из Шанхая\\
Жил, сомнениям всё подвергая.\\
Он был просто сражён\\
Тем, что он "--- это он,\\
А «Шанхай» "--- лишь названье Шанхая.
\end{limerick}
}
{\Lear}

\section{Исследование памяти в~C++} 
\label{sec:cpp-memorydump}
\epigraph{\begin{limerick}
Злополучную даму в~Байраме\\
Много раз прищемляло дверями.\\
«А~может быть, впредь\\
В~дверях не сидеть?» "---\\
Подумала дама в~Байраме.\\
\end{limerick}
}
{\Lear}

макросы и~шаблоны, применение для исследования памяти




\subsection{Отладочная печать}
\epigraph{\begin{stanza}
Всё, что они делают, вносится в книги.\end{stanza}
}
{54.52}
\index{Память!просмотр содержимого}

В~некоторых случаях использование окон отладчика по какой-то причине неудобно, в~частности, иногда необходимо сформировать файл протокола, содержащий шестнадцатеричные представления множества объектов.

Язык C++ предоставляет множество средств для исследования структуры объектов во~время выполнения программы.


%  the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or

\subsubsection{Идентификация типа\footnote{Использован черновик стандарта C++14, раздел expr.typeid}}

Для получения информации о~типе объекта во время исполнения программы (run-time type identification "--- RTTI) в~C++ используется оператор \lstinline!typeid!.
Оператор \lstinline!typeid! принимает в~качестве параметра имя типа или переменной и~возвращает \lstinline!const std::type_info!.

Класс \lstinline!std::type_info! включает метод \lstinline!name()!, возвращающий строку, характеризующую тип (не имя типа и~не формат вывода).
В~частности, \lstinline!typeid(int).name()! вернёт  \lstinline!"i"!, \lstinline!typeid(double).name()! "---  \lstinline!"d"!, а~\lstinline!typeid(long double).name()! "---  \lstinline!"e"!.
Составные типы характеризуются длинными многокомпонентными строками.

\subsubsection{Размер объекта\footnote{Использован черновик стандарта C++14, раздел expr.sizeof}}

Размер выделяемой под объект памяти можно узнать, используя оператор \lstinline!sizeof!.
% 
Согласно стандарту C++,  оператор \lstinline!sizeof! возвращает количество байтов, используемое для представления операнда.

\lstinline!sizeof(char), sizeof(signed char)! и~\lstinline!sizeof(unsigned char)! равны~1, для остальных стандартных типов определяется реализацией.

\subsubsection{Адреса и~указатели}

% Указатель "--- объект (переменная), хранящая адрес другого объекта. 

С~точки зрения языка высокого уровня, указатели, хранящие адреса объектов различных типов, сами имеют разные типы.
Это сделано для защиты от ошибок, чтобы не попытаться рассмотреть в~памяти то, чего там нет (и~не получить очень странное значение, например, нечаянно прочитав часть вещественного числа как целое) или не испортить соседние переменные, записывая объект большого размера в~область, зарезервированную под меньший.

С точки зрения более низкого уровня, адреса объектов различных типов ничем не различаются, и~программист сам должен помнить размер, структуру и~назначение каждого объекта в~памяти.
Все адреса имеет один размер, соответствующий разрядности платформы, и,~теоретически, любой адрес может быть преобразован к~любому типу указателя.

% На практике не любое преобразование указатель-указатель имеет смысл.
Так как размер любого типа кратен размеру  \lstinline!char!, адрес любого объекта~\lstinline!x! может быть преобразован в~указатель типа \lstinline!char *!.
Таким образом мы получим доступ к~байтам, составляющим объект, как к~массиву \lstinline!char!'ов; размер этого массива "--- количество байтов~в~\lstinline!x! "--- равен \lstinline!sizeof(x)!.


Язык C++ позволяет преобразовать указатели на разные типы только с~помощью самого наглого и~не портируемого оператора преобразования "--- \lstinline!reinterpret_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
\end{lstlisting}
В~программировании на высоком уровне не рекомендуется использование \lstinline!reinterpret_cast! вообще и~преобразование типов указателей в~частности, так как это небезопасно.
% Низкоуровневое программирование небезопасно само по себе.

\subsubsection{Вывод в~поток}

Для формирования файла-протокола можно воспользоваться потоками вывода.
Ассоциировав в~программе какой-либо файл с~потоком типа \lstinline!fstream!, мы получим возможность записи протокола непосредственно в~этот файл.
Выводя протокол в~стандартный поток вывода (\lstinline!cout!), мы сможем наблюдать протокол в~консоли или сохранить его в~файл, используя перенаправление стандартного потока вывода в~командном интерпретаторе (в~частности, \lstinline!bash!):
\begin{lstlisting}[language=Bash]
$ program > /tmp/log.txt
\end{lstlisting}
(данная команда запускает программу \lstinline!program! и~направляет её стандартный вывод не в~консоль, а~в~файл \lstinline!/tmp/log.txt!).
Второй способ более универсален, поэтому во всех примерах будем рассматривать стандартный поток вывода.

Используемые для вывода в~поток перегруженные операторы \lstinline!<<! и~\lstinline!>>! реализованы для разных типов по-разному.
% 
Типы \lstinline!char, signed char! и~\lstinline!unsigned char! отображаются в~потоке как символы, код которых равен значениям переменных.
Вывести значение такой переменной как число можно, преобразовав её в~другой целый тип, в~частности, \lstinline!int! или \lstinline!unsigned!, для чего можно использовать \lstinline!static_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
cout << static_cast<int>(*p);
\end{lstlisting}
или
\begin{lstlisting}
unsigned char *p = reinterpret_cast<unsigned char *>(&x);
cout << static_cast<unsigned>(*p);
\end{lstlisting}
оба эти листинга выводят в~поток \lstinline!cout! первый байт объекта~\lstinline!x!,
первый "--- как знаковое число, второй "--- как беззнаковое.

Прочие целые типы %по умолчанию
отображаются как значение в~десятичной, восьмеричной или шестнадцатеричной системе счисления.
Используемую систему счисления можно  изменить, используя манипуляторы \lstinline!hex, oct, dec! или \lstinline!setbase()!.
Манипуляторы \lstinline!hex, oct! и~\lstinline!dec! меняют вывод целых чисел (но не \lstinline!char!) на  шестнадцатеричный, восьмеричный и~десятичный соответственно.
Манипулятор \lstinline!setbase (int base)! позволяет задать основание; фактически можно выбрать только 8, 10 и~16.
Теми же манипуляторами можно задать систему счисления для ввода чисел.

Знак отображается только в~десятичной форме вывода; восьмеричная и~шестнадцатеричная формы при выводе знаковых чисел представляют собой двоичное представление числа, приведённое к~соответствующей системе счисления.
Так, число $-1$ (так как в~литерале не указан суффикс типа, число имеет тип \lstinline!int!) в~восьмеричной и~шестнадцатеричной формах соответственно выглядит как
\lstinline!37777777777! и~\lstinline!ffffffff!.

Регистр шестнадцатеричных цифр \lstinline!A..F! (а~также символа \lstinline!E! в~экспоненциальной форме вывода вещественных чисел) задаётся манипуляторами \lstinline!uppercase! и~\lstinline!lowercase!.

Манипулятор \lstinline!setfill(int ch)! 	устанавливает символ заполнения равным \lstinline!ch!.
В~частности, \lstinline!setfill('0')! указывает, что числа нужно дополнять до ширины, указанной манипулятором \lstinline!setw()!, не пробелами, а~ведущими нулями.

Действие манипуляторов \lstinline!hex, oct, dec, setbase()!, \lstinline!uppercase!, \lstinline!lowercase! и~\lstinline!setfill()! не прекращается после вывода/ввода одного числа и~длится до
% задания нового основания или символа заполнения 
изменения
другим аналогичным манипулятором.

Ширина вывода устанавливается манипулятором \lstinline!setw(int w)! только для следующего выводимого значения.
Если выводимое значение не помещается в~\lstinline!w! знакомест, оно выводится целиком.

Таким образом, строка
\begin{lstlisting}[style=lstsmall]
cout << hex << setfill('0')
    << setw(4) << 10 << " " << 20 << " "
    << setw(3) << " " << setw(8) << 30 << " "
    << setw(2) << 257 << endl;
\end{lstlisting}
поместит в~поток \lstinline!cout!
\begin{lstlisting}[style=lstsmall]
000a 14 00 0000001e 101
\end{lstlisting}
манипулятор \lstinline!hex! действует на все целые числа;
\lstinline!setfill('0')! "--- на все выводимые данные, для которых ширина поля вывода превышает ширину данных (включая пробел, для которого установлена ширина поля вывода в~3 знакоместа);
манипулятор \lstinline!setw(4)! действует только на число 10 (\lstinline!0xA!), \lstinline!setw(3)! "--- только на выводимый после него пробел, \lstinline!setw(8)! "--- только на число 30 (\lstinline!0x1E!); \lstinline!setw(2)! не влияет на вывод числа 257 (\lstinline!0x101!), так как для его вывода нужно три знакоместа.

Порядок использования манипуляторов не важен.

Таким образом, вывести в~поток \lstinline!cout! первый байт по адресу \lstinline!p! в~том, виде, который использован в~окне Memory dump (две шестнадцатеричные цифры с~ведущим нулём), можно следующим образом: 
\begin{lstlisting}
unsigned char *p;
cout << hex << setfill('0') << setw(2) << static_cast<unsigned>(*p);
\end{lstlisting}
используется тип~\lstinline!unsigned char!, чтобы расширение до \lstinline!unsigned! гарантированно было беззнаковым, и~выводимое значение поместилось в~два знакоместа.

Адрес следующего элемента (с~учётом того, что \lstinline!p! "--- указатель на однобайтовый тип "--- следующего байта) равен \lstinline!p+1! и~так далее.
Соответственно, зная адрес начала переменной, можно вывести в~поток все составляющие её байты, сымитировав функциональность  окна Memory dump.

Зная размер переменной (\lstinline!sizeof(x)!), можно вывести на экран её побайтовое представление.
Оно может не совпадать с~шестнадцатеричным представлением из-за порядка байтов в~словах.
В~шестнадцатеричном представлении цифры выводятся по-арабски, от старшей к~младшей;
побайтовый вывод показывает реальный порядок байтов в~памяти (на платформе x86 "--- от младшего к~старшему), при этом  цифры каждого байта выводятся  от старшей к~младшей.

\subsubsection{Шаблоны C++}
% Для автоматизации отладочной печати можно воспользоваться  шаблонами. 
% Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.

Для автоматизации отладочной печати лучше реализовать её в~виде отдельной функции, чтобы упростить внесение изменений.
Назовём эту функцию  \lstinline!MemoryDump()!.
Пусть  \lstinline!MemoryDump()! получает в~качестве аргумента исследуемый объект \lstinline!x!, печатает данные о~нём в~стандартном потоке вывода и~возвращает ничего (\lstinline!void!).

Чтобы избежать приведения типа аргумента и,~соответственно, искажения данных о~нём,
необходима отдельная реализация \lstinline!MemoryDump()! для каждого возможного типа аргумента; 
при этом текст реализаций \lstinline!MemoryDump()! для различных типов аргументов будет полностью совпадать.
Для этого идеально подходит механизм \termin{шаблонов (templates).}
Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.
Так как нам нужно варьировать только тип аргумента, у~шаблона будет один параметр "--- имя типа аргумента функции:
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T ...x)
{
...
}
\end{lstlisting}

Для доступа к~памяти, где реально находится объект, необходимо передать этой функций указатель или ссылку на него.
С~точки зрения низкого уровня указатель и~ссылка "--- одно и~то же; на уровне C++ передача по ссылке позволит использовать те же синтаксические конструкции, что и~для исследования локальной переменной.
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T &x)
...
\end{lstlisting}
Так как планируется не изменение, а~только печать аргумента, правила хорошего тона требуют для него спецификатора \lstinline!const! (соответственно, используемый в~тексте \lstinline!MemoryDump()! указатель \lstinline!p! тоже должен быть константным):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(const T &x)
{
    const unsigned char *p 
        = reinterpret_cast<const unsigned char *>(&x);

    cout << "Type: " << typeid(x).name() << " Value: " << x << endl
	 << "Size: " << sizeof(x) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < sizeof(x); ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Эта функция позволяет вывести в~стандартный поток вывода байты любой переменной в~том порядке, в~котором они лежат в~памяти.
В~частности, результатом следующего кода:
\begin{lstlisting}[style=lstsmall]
int i = 1;
double d = 1;
long double ld = 1;

MemoryDump(i);
MemoryDump(d);
MemoryDump(ld);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: i Value: 1
Size: 4
Dump: 01 00 00 00 

Type: d Value: 1
Size: 8
Dump: 00 00 00 00 00 00 F0 3F 

Type: e Value: 1
Size: 12
Dump: 00 00 00 00 00 00 00 80 FF 3F 00 00 
\end{lstlisting}
Для каждого такого вызова компилятор формирует отдельную функцию "---  реализацию шаблона \lstinline!MemoryDump()! для конкретного типа аргумента.  
Такие реализации перегружают друг друга и~имеют одно имя для C++; с~точки зрения линкера разные реализации имеют разные имена, так как по-разному декорируются.

При вызове шаблонной функции  \lstinline!MemoryDump()! конкретная вызываемая реализация определяется типом передаваемого фактического параметра.
Указывать реализацию явно (например, \lstinline!MemoryDump<int>(i)!) здесь не только не нужно, но и~вредно "--- если указанный тип реализации не совпадёт с~настоящим типом передаваемого параметра, результат будет некорректен.

Для указателя данная функция выведет размер и~представление в~памяти самой переменной-указателя, а~не тот фрагмент памяти, куда он указывает.
Если необходимо напечатать именно память, на которую указывает аргумент, необходимо модифицировать функцию (\lstinline!CellCount! "--- количество ячеек типа \lstinline!T! по адресу \lstinline!px!):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void PointerMemoryDump(T *px, int CellCount)
{
    const unsigned char *p
        = reinterpret_cast<const unsigned char *>(px);

    size_t BytesCount = sizeof(*px)*CellCount;

    cout << "Type: " << typeid(px).name() << " Value: " << px << endl
	 << "Size: " << sizeof(px) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < BytesCount; ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Тогда результатом кода:
\begin{lstlisting}[style=lstsmall]
char *s = "abcdef";

MemoryDump(s);
PointerMemoryDump(s,8);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: Pc Value: abcdef
Size: 4
Dump: 08 96 04 08 

Type: Pc Value: abcdef
Size: 4
Dump: 61 62 63 64 65 66 00 54
\end{lstlisting}
% \section{Порядок выполнения лабораторной работы}
% Выполните задания, оформите отчёт и~покажите работу преподавателю.

% \section{Требования}
% \begin{enumerate}
% \item При подготовке к~работе (дома) студент должен подготовить конспект, содержащий: название
% работы, выполненные теоретически задания \ref{task:intcode}--\ref{task:char} и~тексты программы (или набора программ) для заданий \ref{task:prog:start}--\ref{task:prog:end}.
% 
% \item При выполнении работы оформите отчёт. %, дополнив конспект ответами на вопросы, которые
% указаны в~тексте соответствующих заданий (синим цветом). 
% Также проверьте, соответствуют ли
% ваши теоретические результаты практическим результатам для заданий \ref{task:intcode}--\ref{task:char}.
% % Объясните   расхождения
% 
% Объясните совпадения и~различия результатов на разных платформах.
% \end{enumerate}

\section{Средства автоматизации C++} 

\epigraph{
"--* А почему ты решила, что я стою только у этих ворот? "--- хмыкнула МакКанарейкл. "---
Кстати, спасибо, что напомнила. 
Все-сью-сюда!
}{Жвалевский/Мытько}

\input{book/fragments/cpp-templates}
\input{book/fragments/c-macro}

\nsection{Контрольные вопросы}


\begin{enumerate}
\item Для чего служит  модификатор volatile в~C++?
\item Для чего служит спецификатор register в~C++?
\item Чем различается размещение в~памяти локальных, глобальных и~статических переменных?

\item Чем различается работа с~целыми числами разной разрядности?
\item Чем различается работа с~целыми и~вещественными числами?

\end{enumerate}

\printquestions




