

\subsection{Обозреватель памяти (Memory~dump)}

Исследовать структуру объекта и~его представление в~памяти во время отладки можно с~помощью  обозревателя памяти.

% Окно отладчика «Memory~dump» доступно во время отладки и~отображает содержимое памяти.
В~среде Code::Blocks окно просмотра содержимого фрагмента памяти  «Memory~dump»  (рис.~\ref{ris:cb-memory}) доступно во время отладки.
Его можно скрыть или вернуть, используя меню $Debug \to Debugging~windows \to Memory~dump$.

\begin{illustration}
\includegraphics[width=\linewidth]{cb-memory}

\caption{Отладочное окно Memory~dump в~Code::Blocks}
\label{ris:cb-memory}
\end{illustration}

Начало фрагмента может быть литералом (конкретным адресом в~памяти), адресом переменной (\lstinline!&x!), регистром, в~котором содержится адрес или~выражением C++ (результатом выражения должен быть указатель).
% Например, \lstinline!(char*)(&x)-4! "--- адрес на 4~байта меньше, чем начало переменной~\lstinline!x!.

Содержимое памяти отображается как последовательность байтов. 
Каждый байт представлен как беззнаковое целое (в~виде двух шестнадцатеричных цифр) и~как ASCII-символ (справа).
Байты разбиты на строки по 16; слева перед строкой показан адрес первого байта в~строке в~шестнадцатеричном виде.

% Просмотр памяти по адресу переменной с~помощью отладчика позволяет получит ту же информацию, что и~отладочная печать байтов "--- 


\subsection{Отладочная печать}

В~некоторых случаях использование окон отладчика по какой-то причине неудобно, в~частности, иногда необходимо сформировать файл протокола, содержащий шестнадцатеричные представления множества объектов.

Язык C++ предоставляет множество средств для исследования структуры объектов во~время выполнения программы.


%  the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or

\subsubsection{Идентификация типа\footnote{Использован черновик стандарта C++14, раздел expr.typeid}}

Для получения информации о~типе объекта во время исполнения программы (run-time type identification "--- RTTI) в~C++ используется оператор \lstinline!typeid!.
Оператор \lstinline!typeid! принимает в~качестве параметра имя типа или переменной и~возвращает \lstinline!const std::type_info!.

Класс \lstinline!std::type_info! включает метод \lstinline!name()!, возвращающий строку, характеризующую тип (не имя типа и~не формат вывода).
В~частности, \lstinline!typeid(int).name()! вернёт  \lstinline!"i"!, \lstinline!typeid(double).name()! "---  \lstinline!"d"!, а~\lstinline!typeid(long double).name()! "---  \lstinline!"e"!.
Составные типы характеризуются длинными многокомпонентными строками.

\subsubsection{Размер объекта\footnote{Использован черновик стандарта C++14, раздел expr.sizeof}}

Размер выделяемой под объект памяти можно узнать, используя оператор \lstinline!sizeof!.
% 
Согласно стандарту C++,  оператор \lstinline!sizeof! возвращает количество байтов, используемое для представления операнда.

\lstinline!sizeof(char), sizeof(signed char)! и~\lstinline!sizeof(unsigned char)! равны~1, для остальных стандартных типов определяется реализацией.

\subsubsection{Адреса и~указатели}

% Указатель "--- объект (переменная), хранящая адрес другого объекта. 

С~точки зрения языка высокого уровня, указатели, хранящие адреса объектов различных типов, сами имеют разные типы.
Это сделано для защиты от ошибок, чтобы не попытаться рассмотреть в~памяти то, чего там нет (и~не получить очень странное значение, например, нечаянно прочитав часть вещественного числа как целое) или не испортить соседние переменные, записывая объект большого размера в~область, зарезервированную под меньший.

С точки зрения более низкого уровня, адреса объектов различных типов ничем не различаются, и~программист сам должен помнить размер, структуру и~назначение каждого объекта в~памяти.
Все адреса имеет один размер, соответствующий разрядности платформы, и,~теоретически, любой адрес может быть преобразован к~любому типу указателя.

% На практике не любое преобразование указатель-указатель имеет смысл.
Так как размер любого типа кратен размеру  \lstinline!char!, адрес любого объекта~\lstinline!x! может быть преобразован в~указатель типа \lstinline!char *!.
Таким образом мы получим доступ к~байтам, составляющим объект, как к~массиву \lstinline!char!'ов; размер этого массива "--- количество байтов~в~\lstinline!x! "--- равен \lstinline!sizeof(x)!.


Язык C++ позволяет преобразовать указатели на разные типы только с~помощью самого наглого и~не портируемого оператора преобразования "--- \lstinline!reinterpret_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
\end{lstlisting}
В~программировании на высоком уровне не рекомендуется использование \lstinline!reinterpret_cast! вообще и~преобразование типов указателей в~частности, так как это небезопасно.
% Низкоуровневое программирование небезопасно само по себе.

\subsubsection{Вывод в~поток}

Для формирования файла-протокола можно воспользоваться потоками вывода.
Ассоциировав в~программе какой-либо файл с~потоком типа \lstinline!fstream!, мы получим возможность записи протокола непосредственно в~этот файл.
Выводя протокол в~стандартный поток вывода (\lstinline!cout!), мы сможем наблюдать протокол в~консоли или сохранить его в~файл, используя перенаправление стандартного потока вывода в~командном интерпретаторе (в~частности, \lstinline!bash!):
\begin{lstlisting}[language=Bash]
$ program > /tmp/log.txt
\end{lstlisting}
(данная команда запускает программу \lstinline!program! и~направляет её стандартный вывод не в~консоль, а~в~файл \lstinline!/tmp/log.txt!).
Второй способ более универсален, поэтому во всех примерах будем рассматривать стандартный поток вывода.

Используемые для вывода в~поток перегруженные операторы \lstinline!<<! и~\lstinline!>>! реализованы для разных типов по-разному.
% 
Типы \lstinline!char, signed char! и~\lstinline!unsigned char! отображаются в~потоке как символы, код которых равен значениям переменных.
Вывести значение такой переменной как число можно, преобразовав её в~другой целый тип, в~частности, \lstinline!int! или \lstinline!unsigned!, для чего можно использовать \lstinline!static_cast!:
\begin{lstlisting}
char *p = reinterpret_cast<char *>(&x);
cout << static_cast<int>(*p);
\end{lstlisting}
или
\begin{lstlisting}
unsigned char *p = reinterpret_cast<unsigned char *>(&x);
cout << static_cast<unsigned>(*p);
\end{lstlisting}
оба эти листинга выводят в~поток \lstinline!cout! первый байт объекта~\lstinline!x!,
первый "--- как знаковое число, второй "--- как беззнаковое.

Прочие целые типы %по умолчанию
отображаются как значение в~десятичной, восьмеричной или шестнадцатеричной системе счисления.
Используемую систему счисления можно  изменить, используя манипуляторы \lstinline!hex, oct, dec! или \lstinline!setbase()!.
Манипуляторы \lstinline!hex, oct! и~\lstinline!dec! меняют вывод целых чисел (но не \lstinline!char!) на  шестнадцатеричный, восьмеричный и~десятичный соответственно.
Манипулятор \lstinline!setbase (int base)! позволяет задать основание; фактически можно выбрать только 8, 10 и~16.
Теми же манипуляторами можно задать систему счисления для ввода чисел.

Знак отображается только в~десятичной форме вывода; восьмеричная и~шестнадцатеричная формы при выводе знаковых чисел представляют собой двоичное представление числа, приведённое к~соответствующей системе счисления.
Так, число $-1$ (так как в~литерале не указан суффикс типа, число имеет тип \lstinline!int!) в~восьмеричной и~шестнадцатеричной формах соответственно выглядит как
\lstinline!37777777777! и~\lstinline!ffffffff!.

Регистр шестнадцатеричных цифр \lstinline!A..F! (а~также символа \lstinline!E! в~экспоненциальной форме вывода вещественных чисел) задаётся манипуляторами \lstinline!uppercase! и~\lstinline!lowercase!.

Манипулятор \lstinline!setfill(int ch)! 	устанавливает символ заполнения равным \lstinline!ch!.
В~частности, \lstinline!setfill('0')! указывает, что числа нужно дополнять до ширины, указанной манипулятором \lstinline!setw()!, не пробелами, а~ведущими нулями.

Действие манипуляторов \lstinline!hex, oct, dec, setbase()!, \lstinline!uppercase!, \lstinline!lowercase! и~\lstinline!setfill()! не прекращается после вывода/ввода одного числа и~длится до
% задания нового основания или символа заполнения 
изменения
другим аналогичным манипулятором.

Ширина вывода устанавливается манипулятором \lstinline!setw(int w)! только для следующего выводимого значения.
Если выводимое значение не помещается в~\lstinline!w! знакомест, оно выводится целиком.

Таким образом, строка
\begin{lstlisting}[style=lstsmall]
cout << hex << setfill('0')
    << setw(4) << 10 << " " << 20 << " "
    << setw(3) << " " << setw(8) << 30 << " "
    << setw(2) << 257 << endl;
\end{lstlisting}
поместит в~поток \lstinline!cout!
\begin{lstlisting}[style=lstsmall]
000a 14 00 0000001e 101
\end{lstlisting}
манипулятор \lstinline!hex! действует на все целые числа;
\lstinline!setfill('0')! "--- на все выводимые данные, для которых ширина поля вывода превышает ширину данных (включая пробел, для которого установлена ширина поля вывода в~3 знакоместа);
манипулятор \lstinline!setw(4)! действует только на число 10 (\lstinline!0xA!), \lstinline!setw(3)! "--- только на выводимый после него пробел, \lstinline!setw(8)! "--- только на число 30 (\lstinline!0x1E!); \lstinline!setw(2)! не влияет на вывод числа 257 (\lstinline!0x101!), так как для его вывода нужно три знакоместа.

Порядок использования манипуляторов не важен.

Таким образом, вывести в~поток \lstinline!cout! первый байт по адресу \lstinline!p! в~том, виде, который использован в~окне Memory dump (две шестнадцатеричные цифры с~ведущим нулём), можно следующим образом: 
\begin{lstlisting}
unsigned char *p;
cout << hex << setfill('0') << setw(2) << static_cast<unsigned>(*p);
\end{lstlisting}
используется тип~\lstinline!unsigned char!, чтобы расширение до \lstinline!unsigned! гарантированно было беззнаковым, и~выводимое значение поместилось в~два знакоместа.

Адрес следующего элемента (с~учётом того, что \lstinline!p! "--- указатель на однобайтовый тип "--- следующего байта) равен \lstinline!p+1! и~так далее.
Соответственно, зная адрес начала переменной, можно вывести в~поток все составляющие её байты, сымитировав функциональность  окна Memory dump.

Зная размер переменной (\lstinline!sizeof(x)!), можно вывести на экран её побайтовое представление.
Оно может не совпадать с~шестнадцатеричным представлением из-за порядка байтов в~словах.
В~шестнадцатеричном представлении цифры выводятся по-арабски, от старшей к~младшей;
побайтовый вывод показывает реальный порядок байтов в~памяти (на платформе x86 "--- от младшего к~старшему), при этом  цифры каждого байта выводятся  от старшей к~младшей.

\subsubsection{Шаблоны C++}
% Для автоматизации отладочной печати можно воспользоваться  шаблонами. 
% Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.

Для автоматизации отладочной печати лучше реализовать её в~виде отдельной функции, чтобы упростить внесение изменений.
Назовём эту функцию  \lstinline!MemoryDump()!.
Пусть  \lstinline!MemoryDump()! получает в~качестве аргумента исследуемый объект \lstinline!x!, печатает данные о~нём в~стандартном потоке вывода и~возвращает ничего (\lstinline!void!).

Чтобы избежать приведения типа аргумента и,~соответственно, искажения данных о~нём,
необходима отдельная реализация \lstinline!MemoryDump()! для каждого возможного типа аргумента; 
при этом текст реализаций \lstinline!MemoryDump()! для различных типов аргументов будет полностью совпадать.
Для этого идеально подходит механизм \termin{шаблонов (templates).}
Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.
Так как нам нужно варьировать только тип аргумента, у~шаблона будет один параметр "--- имя типа аргумента функции:
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T ...x)
{
...
}
\end{lstlisting}

Для доступа к~памяти, где реально находится объект, необходимо передать этой функций указатель или ссылку на него.
С~точки зрения низкого уровня указатель и~ссылка "--- одно и~то же; на уровне C++ передача по ссылке позволит использовать те же синтаксические конструкции, что и~для исследования локальной переменной.
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T &x)
...
\end{lstlisting}
Так как планируется не изменение, а~только печать аргумента, правила хорошего тона требуют для него спецификатора \lstinline!const! (соответственно, используемый в~тексте \lstinline!MemoryDump()! указатель \lstinline!p! тоже должен быть константным):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(const T &x)
{
    const unsigned char *p 
        = reinterpret_cast<const unsigned char *>(&x);

    cout << "Type: " << typeid(x).name() << " Value: " << x << endl
	 << "Size: " << sizeof(x) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < sizeof(x); ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Эта функция позволяет вывести в~стандартный поток вывода байты любой переменной в~том порядке, в~котором они лежат в~памяти.
В~частности, результатом следующего кода:
\begin{lstlisting}[style=lstsmall]
int i = 1;
double d = 1;
long double ld = 1;

MemoryDump(i);
MemoryDump(d);
MemoryDump(ld);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: i Value: 1
Size: 4
Dump: 01 00 00 00 

Type: d Value: 1
Size: 8
Dump: 00 00 00 00 00 00 F0 3F 

Type: e Value: 1
Size: 12
Dump: 00 00 00 00 00 00 00 80 FF 3F 00 00 
\end{lstlisting}
Для каждого такого вызова компилятор формирует отдельную функцию "---  реализацию шаблона \lstinline!MemoryDump()! для конкретного типа аргумента.  
Такие реализации перегружают друг друга и~имеют одно имя для C++; с~точки зрения линкера разные реализации имеют разные имена, так как по-разному декорируются.

При вызове шаблонной функции  \lstinline!MemoryDump()! конкретная вызываемая реализация определяется типом передаваемого фактического параметра.
Указывать реализацию явно (например, \lstinline!MemoryDump<int>(i)!) здесь не только не нужно, но и~вредно "--- если указанный тип реализации не совпадёт с~настоящим типом передаваемого параметра, результат будет некорректен.

Для указателя данная функция выведет размер и~представление в~памяти самой переменной-указателя, а~не тот фрагмент памяти, куда он указывает.
Если необходимо напечатать именно память, на которую указывает аргумент, необходимо модифицировать функцию (\lstinline!CellCount! "--- количество ячеек типа \lstinline!T! по адресу \lstinline!px!):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void PointerMemoryDump(T *px, int CellCount)
{
    const unsigned char *p
        = reinterpret_cast<const unsigned char *>(px);

    size_t BytesCount = sizeof(*px)*CellCount;

    cout << "Type: " << typeid(px).name() << " Value: " << px << endl
	 << "Size: " << sizeof(px) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < BytesCount; ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Тогда результатом кода:
\begin{lstlisting}[style=lstsmall]
char *s = "abcdef";

MemoryDump(s);
PointerMemoryDump(s,8);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: Pc Value: abcdef
Size: 4
Dump: 08 96 04 08 

Type: Pc Value: abcdef
Size: 4
Dump: 61 62 63 64 65 66 00 54
\end{lstlisting}
% \section{Порядок выполнения лабораторной работы}
% Выполните задания, оформите отчёт и~покажите работу преподавателю.

% \section{Требования}
% \begin{enumerate}
% \item При подготовке к~работе (дома) студент должен подготовить конспект, содержащий: название
% работы, выполненные теоретически задания \ref{task:intcode}--\ref{task:char} и~тексты программы (или набора программ) для заданий \ref{task:prog:start}--\ref{task:prog:end}.
% 
% \item При выполнении работы оформите отчёт. %, дополнив конспект ответами на вопросы, которые
% указаны в~тексте соответствующих заданий (синим цветом). 
% Также проверьте, соответствуют ли
% ваши теоретические результаты практическим результатам для заданий \ref{task:intcode}--\ref{task:char}.
% % Объясните   расхождения
% 
% Объясните совпадения и~различия результатов на разных платформах.
% \end{enumerate}
