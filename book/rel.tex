\chapter{Связь уровней абстракции}
\label{sec:rel}

\epigraph{\begin{stanza}
Мы выходим по приборам на великую глушь\\
Назад в~Архангельск.\\
\end{stanza}}
{\Aquarium}


% \chapter{Разработка и~отладка программного обеспечения}
% \chapter{Инструменты разработки}

Современная вычислительная система включает шесть уровней абстракции, но только нижние четыре из них интерпретируются вычислительной машиной или операционной системой.
Для трансляции программы с~языка высокого уровня, в~частности, C++, или даже с~языка ассемблера
% в~машинный код
в~исполняемый файл, пригодный для запуска операционной системой,
% на уровень ассемблера 
необходимы специализированные программные средства.

Более того, подобные средства должны обеспечивать не только прямую вертикальную связь соседних уровней,
то есть компиляцию с~языка на язык,
но и~«диагональные» связи "--- %объединение фрагментов, написанных на различных языках, в~один
сборку исполняемого файла из множества фрагментов (модулей, функций), возможно, написанных на различных языках.

Универсальный способ  объединения   функций, написанных на различных языках "--- использование промежуточного (так называемого объектного) представления 
с~последующей компоновкой  модулей, содержащих эти функции, в~единое целое.
Так, в~частности, из программы, написанной на языке Паскаль\index{Паскаль}, можно вызвать функцию, описанную на C++,
если они будут следовать одному соглашению о~вызове.

% Соединить таким образом язык C++ и~язык ассемблера можно двумя основными способами:
% \begin{itemize}
% \item скомпоновать в~один исполняемый файл функции
% \end{itemize}

Для соединения языка высокого уровня и~языка ассемблера также используется механизм ассемблерных вставок в~код.
С~помощью специальной конструкции ЯВУ можно вставить в~код несколько команд ассемблера, не используя вызова и~возврата из функции.

\section{Компиляция}
\label{sec:rel-compile}
\epigraph{\begin{stanza}
Вскипятите его, остудите во льду\\
И~немножко припудрите мелом,\\
Но одно безусловно имейте в~виду:\\
Не нарушить симметрию в~целом!\\
\end{stanza}
}
{\Snark}

В~простейшем случае вертикальная связь уровней абстракции осуществляется через компиляцию "--- перевод программы с~языка более высокого уровня на язык следующего уровня абстракции.

\subsection{Инструменты разработки}

\epigraph{
Включив Компыотерище, не стал он дожидаться, пока разогреется его кристаллическое нутро, а, пошёл на~прогулку. Когда же вернулся, машина занималась делом невообразимо сложным, а~именно "--- из попавших под руку материалов строила другую машину, несравненно огромнейшую. Та, своим чередом, в~течение ночи и~следующего дня вырвала из фундамента стены дома и~снесла крышу, возводя громаду третьей по счету машины.
}{С.\,Лем}


В~настоящее время 
разработка  программного обеспечения невозможна без вспомогательных программ "--- инструментов разработчика.
% 
Для перевода программы с~языка высокого уровня, в~частности, C++, или даже с~языка ассемблера,
в~машинный код,
необходима программа-компилятор, для получения исполняемого файла "--- компоновщик и~т.\,д.

\subsubsection{Компиляторы C++}
\index{Компилятор}

Для платформы x86 разработано множество компиляторов\index{Компилятор} C++.
Большинство из них входит в~состав той или иной коллекции. % компиляторов.
В~подобные коллекции входят компиляторы с~языков C и~C++, часто ассемблер, а~также компилятор\index{Компилятор} с~Фортрана\index{Фортран} и~других ЯВУ.
Некоторые коллекции включают, кроме компиляторов, и~другие средства разработки, %~частности,  IDE
иногда даже специализированные отладчик и~IDE.

Перечислим наиболее известные коллекции.
\begin{itemize}
\item %Компилятор C++ из 
\termin{GNU Compiler Collection (GCC)} реализована более чем для 45 платформ, поддерживает большинство ОС (порт под Microsoft Windows исторически носит название \termin{MinGW}), семь языков (в~том числе C и~C++, со строгим соблюдение стандартов), 
% лицензия GNU GPL 3+ 
и~распространяется под лицензией GNU GPL~3+, позволяющей как образовательную, так и~коммерческую разработку (в~том числе разработку приложений с~закрытым исходным кодом). 

\item \termin{TenDRA/Ten15} "--- первоначально британская оборонная разработка, сейчас поддерживает архитектуры x86, x86-64, IA-64 (Itanium), DEC Alpha; POSIX-совместимые ОС
% лицензия BSD;
и~распространяется под лицензией BSD, позволяющей любые виды разработки. 

\item \termin{Portable C Compiler (PCC)} "--- ранний компилятор C, какое-то время поддерживавшийся в~OpenBSD, в~настоящее время  x86, x86-64, Unix-подобные ОС, в~том числе GNU/Linux, 
Microsoft Windows; лицензия BSD.

\item \termin{Intel C++ compiler} "--- x86, x86-64,  IA-64, GNU/Linux, MacOS~X, Microsoft Windows, коммерческая собственническая лицензия.

{
\item \termin{Oracle Solaris Studio} "--- x86, x86-64, SPARC; Solaris, OpenSolaris, GNU/Linux; собственническая лицензия.
В~настоящее время распространяется бесплатно.
\sloppy

}

\item \termin{Open Watcom} "--- DOS, OS/2 и~Microsoft Windows; лицензия  	
Sybase Open Watcom Public License version 1.0, 
%не полностью поддерживает стандарт С++
неполная поддержка стандарта.

\item \termin{Microsoft Visual Studio} "--- x86, x86-64, IA-64 и~.NET, только Microsoft Windows, коммерческая собственническая лицензия, грубые 
нарушения стандарта.

% \item \termin{Norcroft C Сompiler} "--- Intel Pentium для GNU/Linux, коммерческая собственническая лицензия
% 
% 
% \hrulefill
% \item \termin{Clang} "--- виртуальная RISC-машина LLVM

\end{itemize}

Коллекция GCC портирована на наибольшее количество платформ.
В~её состав входят, в~частности, \termin{gcc} "---  компилятор\index{Компилятор}~C
и~\termin{g++} "---  компилятор\index{Компилятор}~C++,
а~также ассемблер %ы для всех поддерживаемых платформ.
\termin{gas.}


\subsubsection{Ассемблеры x86}
\index{Синтаксис!AT\&T}%
\index{Синтаксис!Intel}%

Если синтаксис языка высокого уровня описан соответствующим стандартом, то синтаксис ассемблера не стандартизирован. %, так как зав
Хотя набор мнемонических обозначения ассемблера определяется набором команд процессора,
% сами об
их символьное представление может существенно различаться.
Кроме того, практически у~каждого ассемблера уникальный набор директив и~других синтаксических элементов, которые не транслируются непосредственно в~машинные команды, но необходимы для корректной сборки программы.

% Соответственно, детали синтаксиса 
Таким образом, фактически каждый %компилятор с~языка ассемблера ()
ассемблер, предназначенный для архитектуры x86, обладает уникальным синтаксисом, несовместимым с~остальными.
При этом их можно разбить на две большие группы:
синтаксис AT\&T, традиционно используемый в~Unix, но реализованный и~для других операционных систем, и~множество диалектов синтаксиса Intel.
\begin{itemize}
\item \termin{GNU Assembler (GAS)} из коллекции GCC (лицензия GNU GPL~3+) используется на одном из этапов компиляции, поэтому реализован для всех поддерживаемых платформ.
GAS использует для всех процессоров единообразный синтаксис %, основанный на  
(так называемый синтаксис AT\&T).
\end{itemize}
Другие трансляторы поддерживают только архитектуру x86 и~её шестидесятичетырёхбитный вариант x86-64.
\begin{itemize}
\item \termin{Flat Assembler (FASM)} реализован для  Unix-подобных операционных систем (GNU/Linux, OpenBSD и~др.), FreeDOS и~Microsoft Windows, 
распространяется по лицензии BSD.
Несколько операционных систем написаны полностью на FASM "--- MenuetOS и~KolibriOS. %DexOS,
\item \termin{NASM/Yasm} также реализован для Unix-подобных систем, FreeDOS и~Microsoft Windows под лицензией BSD.
% \item HLASM "--- z/Architecture IBM
\item \termin{Turbo Assembler (TASM)/Lazy Assembler} "--- поддерживает  FreeDOS и~Microsoft Windows.
Оригинальный Turbo Assembler имел два режима "--- режим совместимости с~MASM и~более удобный режим Ideal.
Lazy Assembler использует синтаксис режима Ideal и~при этом поддерживает современные наборы команд.

\item \termin{MASM} от Microsoft также поддерживает только FreeDOS и~Microsoft Windows.

\end{itemize}
% Их синтаксисы являются вариантами 
Они используют различные варианты (диалекты)
синтаксиса Intel, предложенного разработчиком x86 и~не используемого на неинтеловских процессорах.

% https://stackoverflow.com/questions/35904895/masm-mov-from-to-immediate-memory-address/35906112
% https://stackoverflow.com/questions/25129743/confusing-brackets-in-masm32/25130189#25130189
Хотя все эти диалекты  обычно объединяются термином «синтаксис Intel», они несовместимы между собой как из-за различных директив, так и~из-за неоднозначности трактовки операндов.
В~частности, 
команда пересылки (её мнемоническое обозначение \lstinline!mov! происходит от move "--- перемещать) \lstinline!mov ecx, dword ptr [0xCCCCCCCC]! записана в~соответствии с~синтаксисом Intel (очевидный приёмник "--- регистр общего назначения $ecx$ "--- указан первым, размер операнда-константы задан с~помощью конструкции \lstinline!dword ptr!, то есть равен 32 битам), но по-разному трактуется различными ассемблерами.
\index{Команды!mov}%


Так, MASM преобразует её в~код \hex{B9\,CC\,CC\,CC\,CC}, который запишет в~регистр $ecx$ значение указателя, то есть константу \lstinline!0xCCCCCCCC! (что в~синтаксисе Intel также может быть записано как \lstinline!mov ecx, 0xCCCCCCCC!).
% 
Для синтаксиса AT\&T 
% помещение константы в~регистр~$C$ 
это действие
записывается как \lstinline!movl $0xCCCCCCCC, %ecx!, где суффикс \lstinline!l! после имени команды означает разрядность операндов 32 бита ($long$), префикс \lstinline!$! "--- непосредственное значение, а~префикс \lstinline!%! "--- имя регистра.

Другой популярный ассемблер с~синтаксисом Intel, NASM, преобразует \lstinline!mov ecx, dword ptr [0xCCCCCCCC]! в~код 
\hex{8B\,0D\,CC\,CC\,CC\,CC}, который записывает в~$ecx$ значение из памяти по заданному указателю (для синтаксиса  AT\&T это соответствует команде \lstinline!movl 0xCCCCCCCC, %ecx! "--- отсутствие префикса перед константой означает разыменование её как указателя).

GAS также поддерживает синтаксис Intel для архитектуры x86,
но в~данном пособии будет рассматриваться синтаксис AT\&T как более наглядный и~универсальный.


\subsubsection{Интегрированные среды разработки}
% \epigraph{\begin{stanza}
% Браконьер мог бы так продолжать до утра,\\
%     Но "--- увы! "--- было  с~временем туго;\\
%  И~он тихо заплакал, взглянув на Бобра,\\
%     Как на самого близкого друга.\\
% \end{stanza}
% }
% {\Snark}
% 
% % \section{Компиляция и~отладка в~IDE} 
% \label{sec:cpp-ide}
% watch'и, memory, дизассемблер

Интегрированные среды разработки (integrated development environment, IDE) включают редактор кода
и~множество %интерактивных 
инструментов, облегчающих разработку, в~том числе
интерфейс для запуска компилятора\index{Компилятор}. %, отладчика и~т.\,д. %других средств разработки.

Набор файлов исходного кода, настроек и~сценариев сборки объединяется в~\termin{проект.}
Формат проекта различается для разных IDE.
% 
Один и~тот же проект может быть собран с~различными комплектами настроек.
Такой комплект может называться целью или конфигурацией.
Для каждого проекта IDE по умолчанию создаёт как минимум две цели сборки: отладочную (Debug) и~лишённую отладочной информации (Release).
Интерактивная отладка на уровне инструкций языка высокого уровня (в~частности, точка останова на конкретном операторе ЯВУ) возможна только для отладочной сборки.
% Проект, 

Большинство интегрированных сред может работать с~различными компиляторами и~отладчиками.
Если на компьютере разработчика установлено несколько коллекций компиляторов, в~настройках потребуется выбрать необходимый вариант.
Многие среды могут поставляться как отдельно, так и~комплекте с~какой-либо коллекцией компиляторов и~отладчиком.
% К~сожалению, существуе
Некоторые среды, в~частности, IDE Visual Studio от Microsoft, поставляющаяся только с~соответствующей коллекцией компиляторов,
ограничены в~функциональности и~полностью поддерживают только одну коллекцию (хотя в~последних версиях появилась частичная поддержка GCC).
% не позволяют всех возможностей при работе с~GCC.
% Они ограничены в~функциональности и~полностью поддерживают только одну коллекцию.
% % 
Соответственно, IDE Visual Studio непригодна для разработки на ассемблере с~синтаксисом AT\&T.
Наиболее распространена IDE Qt Creator.
Также для разработки с~помощью GCC можно использовать IDE Code::Blocks или TheIDE.

\subsubsection{Дизассемблер}

Так как  языка ассемблера близок к~машинному коду, возможно преобразовать машинные команды в~инструкции ассемблера.
Такое преобразование не всегда однозначно.
% 
Соответствующие инструменты "--- дизассемблеры "--- широко применяются в~Microsoft Windows для исследования программного обеспечения с~закрытым исходным кодом.

В~GNU/Linux дизассемблер используется в~основном %при отладке
как компонент интерактивного отладчика,
позволяющий %отлаживать
работать с~программой, собранной без отладочной информации.

\subsection{Этапы компиляции}
\label{sec:cpp-compile}
\index{Компиляция!этапы}%

\epigraph{
"--*  Как убить синего слона?

"--*  Из винтовки для синих слонов.

"--*  А~как убить красного слона?

"--*  Его надо душить, до тех пор пока он не посинеет, затем застрелить из винтовки для синих слонов.

"--*  А~как убить зелёного слона?

"--*  Нужно рассказывать ему похабные анекдоты, пока он не покраснеет, затем душить, пока не посинеет, затем застрелить из винтовки для синих слонов.
}
{П.\,Канюкова}


% \footnote{%http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html
% Использованы материалы CSCI 241
% Intermediate Programming in C++
% Spring 2015
% (The C++ compilation process)
% % http://knzsoft.ru/cpp-bgr-ls1/
% и~А.\,А.\,Князев. Руководство по C++ для начинающих}
% % }

\begingroup

\newlength{\slideheigth}
\setlength{\slideheigth}{0.5\textheight}

Компиляция программы на языке C++ в~исполняемый файл включает четыре этапа (рис.~\ref{ris:c++compile}):
препроцессинг, собственно компиляция (с~С++ в~ассемблерный код), ассемблирование и~компоновка~\cite{CS241/Notes/compile}.

% \begin{illustration}[p]
% \includegraphics[width=\linewidth]{compile}
% 
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}
% % \hfill
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}
% 
% \caption{Этапы компиляции программы на C++}
% \label{ris:c++compile}
% \end{illustration}
\begin{illustration}
\resizebox{\linewidth}{!}{
\input{book/drawings/compile-cpp}
}
\caption{Этапы компиляции программы на C++}
\label{ris:c++compile}
\end{illustration}


\begin{enumerate}[wide=\parindent]
{
\item Препроцессор копирует содержимое включённых  директивой \lstinline!#include! заголовочных файлов в~исходный код модуля, раскрывает макросы и,~в~том числе, выполняет текстовые замены «констант», определённых с~помощью директивы \lstinline!#define!, на их значения, а~также отрабатывает директивы условной компиляции, выбрасывая из кода те или иные фрагменты.\fussy

}
\index{Препроцессор}%

\lstset{language=Bash}

При использовании компилятора из коллекции GCC
увидеть результат препроцессинга\index{Препроцессинг} можно, воспользовавшись опцией \lstinline!-E!% компилятора g++
. Результат будет выведен в~стандартный поток вывода (в~представленном %ниже 
примере %стандартный поток вывода 
перенаправлен в~файл main.E).

\begin{lstlisting}
$ g++ -E main.cpp > main.E
\end{lstlisting}
Здесь и~далее, знак доллара (\lstinline!$!) обозначает стандартное приглашение к~вводу команды
% консоли Unix-подобных систем.
в~консоли (приглашение, оканчивающееся знаком~\lstinline!$!, традиционно используется в~командных интерпретаторах Unix-подобных систем).
Писать знак доллара не требуется.
Регистр важен.


\item Код, обработанный препроцессором, транслируется компилятором\index{Компилятор} в~ассемблерный код для соответствующей платформы.

% \begin{centeredfloat}[!ht]
% \begin{tabularx}{1\linewidth}{LLL}
% main.cpp
% 
% \begin{lstlisting}
% int x = 13;
% int main()
% {
%     int y = 2*x + 123;
% ...
% }
% \end{lstlisting}
% 
% &
% g++ -S main.cpp $\to$
% &
% main.s
% 
% \begin{lstlisting}
% ...
% .globl	x
% 	.data
% 	.align 4
% 	.type	x, @object
% 	.size	x, 4
% x:
% 	.long	13
% ...
% 	movl	x, %eax
% 	addl	%eax, %eax
% 	addl	$123, %eax
% 	movl	%eax, -12(%ebp)
% \end{lstlisting}
% 
% \\
% \end{tabularx}
% \end{centeredfloat}

Для остановки компиляции после этого этапа для компилятора g++ следует воспользоваться ключом \lstinline!-S!:
\begin{lstlisting}
$ g++ -S main.cpp
\end{lstlisting}





На этапе компиляции выполняется \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.\index{Компилятор}\index{Декорирование}%
% Имена 
% C++ искорёжены почти до неузнаваемости, C — у~меня сохранены, а~у~вас, если статья Фога не ошибатеся, к~ним приписывается префикс _: _Sqr вместо Sqr (и~было бы __Sqr вместо _Sqr, но такой функции в~C++-программе нет).
В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
(в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).

Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
В~статье Агнера Фога 
«Calling conventions for different C++ compilers and operating systems»~\cite{agner_fog_calling_conventions}
приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).


\item Ассемблерный код, созданный компилятором, транслируется в~объектный код для соответствующей платформы.
Останов компиляции файла после этапа ассемблирования\index{Ассемблирование}  обеспечивается ключом \lstinline!-c!:

\begin{lstlisting}
$ g++ -c main.cpp
\end{lstlisting}
При ассемблировании  имена функций сохраняются.

Некоторые компиляторы скрывают этап ассемблирования, преобразуя исходный код на языке высокого уровня, обработанный препроцессором, напрямую в~объектный файл.
Компиляторы\index{Компилятор} коллекции GCC можно остановить после любого этапа.



\item Объектные файлы% различных модулей и~библиотек
, созданные ассемблером, объединяются компоновщиком (линкером, редактором связей) в~исполняемый файл.\index{Компоновка}

На данном этапе компоновщик ищет реализации для всех внешних (\lstinline!extern!) функций по именам.
Соответственно, имена, которые в~разных модулях носит одна и~та же функция, на этапе компоновки должны совпадать.


\end{enumerate}
\FloatBarrier
Интегрированные среды разработки (IDE) выполняют все этапы автоматически.

\subsection{Расширения файлов исходного кода}

\epigraph{\begin{limerick}
    Старичок, проживающий в~Туле, \\
    Смастерил из оглоблей ходули.\\
    Он обвил их кругом\\
    Васильком и~вьюнком,\\
    Чтобы видели: сделано в~Туле.\\
\end{limerick}
}
{\Lear}

% Чтобы начать сборку не с~начала, достаточно задать для файла расширение, отличное от~\lstinline!.cpp! или ~\lstinline!.c!.
Чтобы начать сборку с~определённого этапа, достаточно задать для файла расширение, 
соответствующее этому этапу.
% 
Вообще, компилятор\index{Компилятор} "--- одна из немногих программ, которые учитывают расширение файла при его обработке~\cite{labor-liber.org/en/gnu-linux/development/extensions}.

Расширение  \programname{.s} соответствует ассемблерному файлу. 
Таким образом, команды
\mbox{\lstinline!$ g++ main.s!} и~\mbox{\lstinline!$ gcc main.s!}
эквивалентны и~выполняют ассемблирование и~компоновку ассемблерного файла~\lstinline!main.s!%.
, минуя этапы препроцессинга и~компиляции с~ЯВУ.

{

Расширение \programname{.o} соответствует объектному файлу, и~команды
\mbox{\lstinline!$ g++ main.o!} и~\mbox{\lstinline!$ gcc main.o!}
выполняют только компоновку файла~\lstinline!main.o!.
\fussy

}

В~случае, когда необходимо выполнить препроцессинг, ассемблирование и~компоновку, выбросив только этап компиляции с~ЯВУ (именно такая последовательность оптимальна при сборке модулей, вручную написанных на ассемблере), используется
расширение \programname{.S}.
\begin{lstlisting}
$ g++ main.S
\end{lstlisting}
Большинство современных файловых систем чувствительны к~регистру имён, а~современные ОС, такие как GNU/Linux и~BSD, различают регистр при обработке,
так что имена~\lstinline!main.s! и~\lstinline!main.S! будут различаться.

Операционная система Microsoft Windows не различает регистра имён файлов (хотя наиболее часто используемая ею файловая система  NTFS теоретически чувствительна к~регистру),
так что для файлов, требующих препроцессинга, используется расширение \programname{.sx}.
Компиляторы GCC трактуют расширение \programname{.sx} аналогично \programname{.S}.

Многие интегрированные среды разработки «не знают» расширений~\programname{.s} и~\programname{.sx}, так что их необходимо не только вручную добавить в~проект, но и~указать, что они должны компилироваться и~компоноваться как в~режиме отладочной сборки, так и~в~оптимизированном.
 
\subsection{Изменение имени выходного файла}

\epigraph{
"--* Значит,  будешь   Рыжик. И~не спорь! Так  будет  правильно! Или как  тебя  назвать?

    Рыжик  покачал белоснежной головой, но своего варианта не предложил.
}{Жвалевский/Мытько}


Исполняемый файл, полученный после  компиляции и~ассемблирования GCC, независимо от количества и~имён файлов с~исходным кодом
по умолчанию будет называться \lstinline!a.out! (assembler output).

% Имя исполняемого файла по умолчанию (\lstinline!a.out!) 
Это имя
можно изменить, используя ключ~\lstinline!-o!,
после которого указывается желаемое имя выходного файла:
\begin{lstlisting}
$ g++ main.cpp -o prog
\end{lstlisting}
Таким образом исполняемый файл, полученный после сборки main.cpp (отсутствие ключей остановки сборки соответствует выполнению всех этапов), получит имя~\lstinline!prog!.

Исполняемый файл в~большинстве операционных систем не имеет расширения и~отличается от неисполняемого правами доступа.
% При желании можно задать для него любое имя.

\subsection{Компиляция проекта, состоящего из нескольких модулей}
\index{Компиляция!модули}%

\epigraph{\begin{limerick}
    Жил один долгожитель в~Дамаске, \\
    Не знававший заботы и~ласки.\\
    Он в~двуколку свою\\
    Брал трёх сов и~свинью "---\\
    И~катил по Дамаску без тряски.\\
     \end{limerick}
}
{\Lear}

\lstset{language=Bash}

При компиляции проекта, включающего несколько модулей, шаги препроцессинга, компиляции и~ассемблирования повторяются для каждого файла исходного кода.
Затем из полученных объектных файлов компоновщик собирает единый исполняемый файл (рис.~\ref{ris:compile-cpp-cpp}).
Это можно выполнить одним запуском %любого 
компилятора\index{Компилятор} из коллекции GCC:
\begin{lstlisting}
g++ -o prog prog1.cpp prog3.cpp 
\end{lstlisting}


\begin{illustration}
\resizebox{\linewidth}{!}{
\schemafont
\input{book/drawings/compile-cpp-cpp}
}
\caption{Совместная компиляция нескольких модулей}
\label{ris:compile-cpp-cpp}
\end{illustration}

Если попытаться собрать каждый из модулей отдельно, мы получим ошибки компоновки (так как во всех модулях, кроме главного, отсутствует точка входа "--- функция \lstinline!main!, а~в~главном "--- нет функций, описанных в~остальных).


Можно остановить сборку после этапа компиляции модулей:
\begin{lstlisting}
g++ -c prog1.cpp prog3.cpp 
g++ -c prog3.cpp 
\end{lstlisting}

Затем из полученных объектных файлов одним запуском компоновщика можно получить исполняемый файл:\index{Компоновка}
\begin{lstlisting}
g++ -o prog prog1.o prog3.o 
\end{lstlisting}
Ручная сборка небольших проектов обычно выполняется одной командой, в~интегрированных средах разработки этапы, как правило, разделяются.



\subsection{Импорт и~экспорт функций}
\label{sec:compilation-functions}
\epigraph{\begin{limerick}
Дама, оставив Равенну,\\
поехала поездом в~Вену,\\
Но, доехав до Вены,\\
решила мгновенно,\\
Что вернётся в~родную Равенну.
\end{limerick}
}
{\Lear}

Наиболее универсальным способом использования  в~одной программе несколько языков программирования
является %импорт и~экспорт функций.
статическая совместная компоновка модулей, написанных на разных языках.

При статической компоновке каждый модуль %компилируется и~ассемблируется.
необходимо скомпилировать из~соответствующего языка и~ассемблировать, остановив %после этого процесс.
сборку на стадии объектных файлов (напомним, что в~GCC для этого используется ключ  \lstinline!-c!).
Полученные объектные файлы собираются компоновщиком в~единый исполняемый файл (рис.~\ref{ris:compile-cpp-asm}).\index{Компоновка}


\begin{illustration}
\resizebox{\linewidth}{!}{
\input{book/drawings/compile-cpp-asm}
}
\caption{Совместная компиляция  модулей на разных языках}
\label{ris:compile-cpp-asm}
\end{illustration}

% Так как
Сочетание модулей на языке высокого уровня и~на ассемблере используется так часто, что компиляторы коллекции GCC
корректно собирают подобный набор модулей одной командой сборки многомодульного проекта,
как показано на рис.~\ref{ris:compile-cpp-asm}:
\begin{lstlisting}
g++ prog1.cpp prog2.S 
\end{lstlisting}
Останов сборки и~компоновка отдельной командой в~этом случае не нужны.

Интегрированные разработки, поддерживающие компиляторы коллекции GCC, также автоматически выполняют сборку проекта на языке высокого уровня, содержащего ассемблерные модули.



\endgroup




\section{Препроцессор}
\label{sec:cpp-macro}
% \epigraph{
% C позволяет легко выстрелить себе в~ногу %; C++ делает это сложнее, но, когда вы это делаете, отстреливает всю вашу ногу.
% % При помощи C вы легко можете выстрелить себе в~ногу. П
% (при помощи C++ это сделать сложнее, но если это произойдёт, вам оторвёт всю ногу целиком).
% }{Б. Страуструп}
\epigraph{
Препроцессор, возможно, и~неудачен, но трудно найти ему лучше структурированную и~более эффективную замену.
}{Б. Страуструп}


Первая стадия компиляции программы на C/C++ "--- обработка исходного кода препроцессором.
% На этом этапе выполняется обработка текста программы в~соответствии с~определёнными в~этом же тексте правилами "--- макросами препроцессора.
% Макросы представляют собой текстовую замену %выполняющиеся на этапе препроцессинга.
% и~никак не связаны с~особенностями используемого языка "--- C/C++ или ассемблера.
Препроцессор «не понимает» языков C, C++ или ассемблера и~обрабатывает собственный язык "--- директивы препроцессора.
Директива начинается с~символа~\lstinline!#! и~заканчивается переводом строки,
в~частности, \lstinline!#define!, \lstinline!#undef!, \lstinline!#include!, \lstinline!#if!, \lstinline!#ifdef!, \lstinline!#ifndef!, \lstinline!#else!, \lstinline!#elif!, \lstinline!#endif!.
% #error и~#warning

После завершения препроцессинга в~тексте программы не остаётся ни директив препроцессора, ни имён определяемых ими макросов.

В~настоящее время в~программировании на языке C++ препроцессор используется в~основном для двух задач 
"--- условной компиляции и~%включения файла,  
копирования файла, содержащего заголовки функций, классов и~т.\,п. в~несколько файлов исходного кода.
% Современные стандарты языка C++ описывают высокоуровневые возможности, позволяющие отказаться от директив препроцессора, но пока эти возможности не распространены.
Также препроцессор поддерживает \termin{макросы,} которые могут применяться как %вспомогательное средство
для обеспечения корректного решения описанных выше задач, так и~самостоятельно.


Макросы представляют собой текстовую подстановку, выполняющуюся на этапе препроцессинга,
и~никак не связаны с~особенностями используемого языка "--- C/C++ или ассемблера.
Для того, чтобы отличать их от конструкций языка, принято давать макросам имена, состоящие только из заглавных букв.
Их возможности не ограничиваются использованием в~условной компиляции.

Тем не менее использование макросов небезопасно и~не должно (за исключением условной компиляции) применяться при программировании на высоком уровне.


\subsection{Включение файла}
\index{Препроцессор!включение файла}%
\epigraph{\begin{stanza}[0ex]
Я~умею найти в~искривлённых пространствах путь,\\
Я~умею быть сейчас, здесь и~всегда,\\
Я~летаю как птица над ветром, я~ведаю суть,\\
И~я~говорю: кто любит меня "--- сюда! \\
\end{stanza}}
{О.\,Арефьева}

Включение файлов с~заголовками выполняется директивой \lstinline!#include!:
запись \lstinline!#include имя_файла! целиком копирует указанный файл на место, где была эта директива. % \lstinline!#include!.
Имя включаемого файла может содержать путь к~нему и~заключается в~угловые скобки или кавычки.
Если имя файла заключено в~угловые скобки (\lstinline!#include <iostream>!), %путь отсчитывается от %директории
файл должен располагаться в~одной из папок со стандартными заголовочными файлами,
если имя файла в~кавычках (\lstinline!#include "myheader.h"!) "--- он должен находиться в~папке проекта.

В~имени включаемого файла не должно быть комментариев (сочетание \lstinline!/*! трактуется как маска имени файла, в~частности, \lstinline!"dir/*"! "--- все файлы в~папке $dir$).
Зато имя может включать макросы, что позволяет реализовать различные наборы включаемых файлов для различных версий или платформ.

Заголовочные файлы могут включаться как в~файлы, содержащие определения функций, так и~в~другие заголовочные файлы.
В~первом случае возможна ситуация, когда в~файл с~определениями в~итоге включается несколько копий одного и~того же заголовочного файла.
% 
Для предотвращения многократного включения внутри заголовочного файла необходимо применять директивы условной компиляции,
как показано в~листинге~\ref{lst:cpp:ifndef-include-protect}.


\begin{lstlisting}[caption={Защита  от повторного включения}, label=lst:cpp:ifndef-include-protect]
#ifndef THIS_UNIT_ALREADY_INCLUDED
#define THIS_UNIT_ALREADY_INCLUDED
... // весь текст заголовочного файла
#endif
\end{lstlisting}

В~разрабатываемый стандарт C++ планировалось включить поддержку модулей, аналогичных модулям языка Паскаль\index{Паскаль}.
Это позволило бы отказаться как от использования директивы \lstinline!#include!, так и~от ручной защиты от многократного включения, но в~окончательную редакцию C++17 модули не вошли.

\subsection{Условная компиляция}
\index{Препроцессор!условия}%
\epigraph{\begin{limerick}
Принц Непальский покинул Непал\\
И~в~пути с~парохода упал.\\
На запрос из Непала:\\
«Что упало, пропало!» "---\\
Отвечало посольство в~Непал.\\
\end{limerick}
}
{\Lear}

Условная компиляция обеспечивается директивами \lstinline!#if!, \lstinline!#ifdef!, \lstinline!#ifndef!, \lstinline!#else!, \lstinline!#elif!, \lstinline!#endif!,
обеспечивающими удаление части текста до начала этапа компиляции.

Директивы семейства \lstinline!#if*! и~\lstinline!#elif! используют условие, которое не должно зависеть от кода C/C++ или ассемблера.
% Директива  \lstinline!#define! в~настоящее время совместно с~\lstinline!#if!, \lstinline!#ifdef!, \lstinline!#ifndef!, \lstinline!#else!, \lstinline!#elif!, \lstinline!#endif!
% используется для обеспечения условной компиляции.
Для этого используются \termin{макросы препроцессора,} определяемые директивой \lstinline!#define!.


Условие директивы  \lstinline!#if! может включать целочисленные литералы, арифметические операторы, макросы и~специальный оператор препроцессора \lstinline!defined!. %, применяющийся к~макросу и~опр
Истинным считается ненулевое значение условия.
Унарный оператор \lstinline!defined(NAME)! может использоваться только в~условиях препроцессора. С~его помощью можно узнать, определён ли макрос с~именем~\lstinline!NAME!.
Для часто употребляемой конструкции \lstinline!#if defined(NAME)! 
существует синоним~\lstinline!#ifdef NAME!, для \lstinline?#if !defined(NAME)?
"--- синоним~\lstinline!#ifndef NAME!.

В~простейшем случае текст, расположенный от директивы  \lstinline!#if*! до \lstinline!#endif!
остаётся в~коде после препроцессинга в~том случае, когда условие  истинно
и~исключается, если условие ложно.
% Использование условной компиляции для защиты от повторного включения
Подобная конструкция, в~частности, используется для описания отладочных фрагментов которые не должны войти в~окончательную сборку программы (листинг~\ref{lst:cpp:ifdef-gebug}), а~также в~заголовочных файлах для защиты от повторного включения в~один и~тот же файл (листинг~\ref{lst:cpp:ifndef-include-protect}).

\begin{lstlisting}[caption={Отладочный фрагмент}, label=lst:cpp:ifdef-gebug]
#ifdef DEBUG
...
#endif
\end{lstlisting}



Если между директивой семейства \lstinline!#if*! и~\lstinline!#endif! находится директива~\lstinline!#else! (листинг~\ref{lst:cpp:ifdef-else}),
то в~том случае, когда условие  истинно, остаётся фрагмент между \lstinline!#if*! и~\lstinline!#else!, а~фрагмент от~\lstinline!#else! до~\lstinline!#endif! удаляется,
в~случае, если условие ложно "--- наоборот.

\begin{lstlisting}[caption={Выбор одного из фрагментов}, label=lst:cpp:ifdef-else]
#ifdef FLAG
...
#else
...
#endif
\end{lstlisting}

Используя директиву \lstinline!#elif!,  можно организовать выбор из нескольких фрагментов.
В~окончательный вариант текста, который будет компилироваться, войдёт только один из фрагментов, расположенных между  директивами \lstinline!#if*! и~соответствующей \lstinline!#endif!
и~разделённых директивами \lstinline!#elif! и~\lstinline!#else!.


\subsection{Макросы}
\index{Препроцессор!макросы}%
% \epigraph{\begin{limerick}
% Брадобрей-бракодел из Бразилии\\
% Путал все имена и~фамилии\\
% И~за это был бит,\\
% Он теперь инвалид,\\
% Этот бедный старик из Бразилии.
% \end{limerick}
% }
% {Мила Предущенко}
\epigraph{
% \begin{otherlanguage}{german}
\begin{stanza}[0ex]
Reise, Reise \\
Seemann Reise\\
Jeder tut's auf seine Weise\\
Der eine st\"{o}{\fontfamily{cmr}\selectfont\ss}t den Speer zum Mann\\
Der andere zum Fische dann.\\
\end{stanza}
% \end{otherlanguage}
}
{Rammstein}

% Определение макроса начинается с~д
Макрос определяется с~помощью директивы \lstinline!#define!.
В~простейшем случае за директивой следует имя определяемого макроса, а~за ним до конца строки "---  текст, на который производится замена (значение или определение макроса).
Имя макроса отделяется от директивы \lstinline!#define! и~значения пробельными символами.

\begin{lstlisting}[caption={Определение макроса без параметров}, label=lst:cpp:define-THE_NUMBER]
#define THE_NUMBER 13
\end{lstlisting}

После определения макроса \lstinline!THE_NUMBER! согласно листингу~\ref{lst:cpp:define-THE_NUMBER}, приведённого в~файле с~исходным кодом (непосредственно в~его тексте или в~тексте включённого заголовочного файла) строка \lstinline!THE_NUMBER! будет до конца файла с~исходным кодом (либо до удаления определения с~помощью директивы~\lstinline!#undef!) заменяться на строку~\lstinline!13!.
Вхождения строки  \lstinline!THE_NUMBER!, находящиеся до определения этого макроса, останутся без изменений.

При использовании макроса без параметров в~тексте его имя заменяется на значение без каких-либо изменений, то есть \lstinline!int i = THE_NUMBER+1! будет заменяться на \lstinline!int i = 13+1!.
Имя макроса заменяется только в~том случае, когда оно является целым словом (то есть отделено от других строк пробельными символами или знаками препинания),  в~частности, строка \lstinline!THE_NUMBER_2! не будет заменена на \lstinline!13_2!.

При этом заменяется любое вхождение макроса как целого слова, то есть, в~частности, описание функции \lstinline!int f(int THE_NUMBER)! будет заменено на \lstinline!int f(int 13)!, что вызовет ошибку компиляции.
% 
В~менее благоприятном случае сообщения об ошибке может и~не быть.
В~частности, определение \lstinline!#define true 0! не приведёт к~сбою, но работа программы будет некорректной.
% 
Для предупреждения подобных ситуаций необходимо отделять имена макросов препроцессора от имён, используемых в~программе.
Обычно имена макросов записываются заглавными буквами и~не должны быть слишком короткими (в~частности, имя \lstinline!N! с~большей вероятностью будет использовано в~программе, чем~\lstinline!THE_NUMBER!, поэтому определение \lstinline!#define N 13! не очень удачно).

Если после имени макроса в~строке определения нет ничего, кроме, может быть, пробельных символов,
такой макрос имеет пустое значение.

\begin{lstlisting}[caption={Определение макроса с~пустым значением}]
#define FLAG
\end{lstlisting}

Макросы с~пустым значением обычно используются только в~директивах условной компиляции  \lstinline!#ifdef! или~\lstinline!#ifndef!,
которые проверяют не значение, а~факт наличия макроса.
Если такой макрос встречается в~тексте, он заменяется на пустую строку.

% Макросами  
% \begin{lstlisting}
% #define INTEGER short
% \end{lstlisting}

Удалить определение макроса можно с~помощью директивы \lstinline!#undef!.

\begin{lstlisting}[caption={Удаление макроса}, label=lst:cpp:undef]
#undef THE_NUMBER
\end{lstlisting}

В~тексте, лежащем после директивы, приведённой в~листинге~\ref{lst:cpp:undef}, строка~\lstinline!THE_NUMBER! останется без изменения.


\paragraph{Параметры макросов}

С~помощью директивы \lstinline!#define! можно также определить \termin{макросы с~параметрами} "---
лексемы, которые принимают параметры подобно функциям, но фактически являющиеся \termin{текстовой заменой} (более гибким аналогом меню Replace текстового редактора) и~раскрываются не во время выполнения (как функции) и~не во время компиляции (как шаблоны C++), а~до анализа и~компиляции программы, никак не сообразуясь с~типами переменных, текстом программы и~так далее.


При описании макроса
после директивы \lstinline!#define! указывается имя макроса, за которым в~скобках (без пробелов) следуют имена параметров, отделённые запятыми и~определение макроса, отделённое пробелом. 

% Макрос без параметров
% \begin{lstlisting}[caption={Макрос без параметров}]
% #define THE_NUMBER 13
% \end{lstlisting}
% Макрос с~двумя параметрами
\begin{lstlisting}[caption={Определение макроса с~двумя параметрами}, label=lst:cpp:define-max]
#define MAX(num1, num2) ((num1) > (num2) ? (num1) : (num2))
\end{lstlisting}

При использовании макроса в~тексте 
после его имени также ставятся круглые скобки, где перечисляются фактические значения параметров макроса.
\begin{lstlisting}
int j = MAX(9, i);
\end{lstlisting}
При подстановке макрос заменяется своим значением, причём на место имён параметров вписывается соответствующий текст.

Параметры макроса при подстановке никак не проверяются.
Если в~результате такой текстовой подстановки возникнет ошибка, это выяснится только на этапе компиляции, причём не всегда сообщение об ошибке будет вменяемым.

В~листинге~\ref{lst:cpp:define-max} параметры макроса в~его определении берутся в~скобки, чтобы избежать неприятных ситуаций в~том случае, если параметрами будут не имена переменных и~литералы, а~строки, представляющие собой более сложные выражения C++.
Если макрос представляет собой вычисление выражения, то и~его тоже лучше взять в~скобки, что также сделано в~листинге~\ref{lst:cpp:define-max}.

Например, определим макрос~\lstinline!SQUARE(x)! для вычисления квадрата параметра \lstinline!x!.
Макрос, определённый как в~листинге~\ref{lst:cpp:define-SQUARE-bad}, вычисляет неверное значение в~случае, если его параметр является выражением.

\begin{lstlisting}[caption={Неудачное определение макроса с~параметрами}, label=lst:cpp:define-SQUARE-bad]
#define SQUARE(x) x*x
\end{lstlisting}
В~частности, текст
% \begin{lstlisting}
\lstinline!i = SQUARE(2+2)!
% \end{lstlisting}
раскроется в~\lstinline!i = 2+2*2+2!, что даст \lstinline!i!, равное~$2+4+2=8$, а~не $(2+2)^2=16$.
% Вообще, для
% 
Определение %макроса %корректно обработает параметр, 
из листинга~\ref{lst:cpp:define-SQUARE-good}
заменит \lstinline!SQUARE(2+2)! на \lstinline!((2+2)*(2+2))! так что значение квадрата параметра в~данном случае будет рассчитано корректно.

\begin{lstlisting}[caption={Более корректное определение макроса с~параметрами}, label=lst:cpp:define-SQUARE-good]
#define SQUARE(x) ((x)*(x))
\end{lstlisting}

Значение квадрата выражения, модифицирующего свои переменные, будет всё равно вычисляться некорректно.
В~частности, \lstinline!SQUARE(i++)! будет раскрыто как \lstinline!((i++)*(i++))!, так что переменная~$i$ будет увеличена два раза.
Единственный выход "--- не использовать такие выражения как параметры подобных макросов.

\paragraph{Объёмные макросы}

Определение макроса должно занимать одну строку.
Если строка-подстановка не помещается в~строку файла, то в~качестве знака переноса строки используется  обратная косая черта. 

\begin{lstlisting}[caption={Определение объёмного макроса}, label=lst:cpp:define-DISPLAY_ARRAY]
#define DISPLAY_ARRAY(arr, size) {\
	int i;\
	for (i = 0; i < size; i++) {\
		printf("%d ", arr[i]);\
	}\
	printf("\n");\
}
\end{lstlisting}

«Склейка» нескольких  строк в~одну с~помощью косой черты допустима не только в~макросах, но и~в~любом месте программы,
но в~большинстве прочих случаев не имеет смысла, так так перевод строки в~C/C++ является корректным пробельным символом.

% Макрос с~параметрами "--- это просто текстовая замена, поэтому 

% \paragraph{Действия с~параметрами}
\paragraph{Закавычивание строк}


Параметры макроса можно взять в~кавычки, используя оператор \lstinline!#!.
\begin{lstlisting}[caption={Макрос, заключающий аргумент в~кавычки}, label=lst:cpp:define-QUOTES]
#define QUOTES(x) #x
\end{lstlisting}
Тогда следующий код
\begin{lstlisting}
cout <<  QUOTES(1+2) << " " << QUOTES(x) << " " << QUOTES(мяу) << " " << QUOTES("мяу") << endl;
\end{lstlisting}
выведет
\begin{lstlisting}
1+2 x мяу "мяу"
\end{lstlisting}
% Выражения,. заключённые 
Чаще всего этот оператор используется в~отладочной печати, так как позволяет вывести на стандартный вывод или сохранить в~файл имя переменной.


\paragraph{Конкатенация строк}

% Строки (не в~смысле C/C++, а~произвольные кусочки исходного )  
% Элементы  
Параметры можно «склеивать» друг с~другом и~с~произвольными строками
% можно объединить
с~помощью оператора \lstinline!##!. 
Пример такого макроса приведён в~листинге~\ref{lst:cpp:define-DEF_X_Y}.
\begin{lstlisting}[caption={Макрос, объявляющий две переменные}, label=lst:cpp:define-DEF_X_Y]
#define DEF_X_Y(typename) typename x##typename = 1, y##typename = 0; \
    cout << typeid(x##typename).name() << " " << x##typename << endl;
\end{lstlisting}
Получив имя типа как параметр (например, \lstinline!int!),  макрос \lstinline!DEF_X_Y! формирует текст, который объявляет и~инициализирует две переменные \lstinline!x<имя типа>! и~\lstinline!y<имя типа>!, а~также выводит на стандартный вывод характеристику типа и~значение переменной~\lstinline!x<имя типа>!.
Следующий код не вызовет ошибок компиляции.
\begin{lstlisting}
    DEF_X_Y(int)
    yint = xint+1;
\end{lstlisting}
% Здесь, в~отличие от шаблонов


Конкатенация строк может быть использована для 
% искажения имён функций ассемблерного модуля вручную
% при совместной сборке модулей на C++ и~на ассемблере.
изменения имён функций или переменных  «на лету» в~зависимости от версии программы или используемой платформы, что иногда необходимо.





% \chapter{Соединение уровней ЯВУ и~ассемблера}


\section{Ассемблерные вставки в~код C++}
\label{sec:asm-inline}
\epigraph{\begin{limerick}
Одна дама, живущая в~гавани,\\
возмечтала отправиться в~плаванье,\\
Но когда на дубу\\
поглядела в~трубу,\\
То решила "--- спокойнее в~гавани.\\
\end{limerick}
}
{\Lear}



Для вставки одной или нескольких инструкций ассемблера в~код на C++ используется ключевое слово \lstinline!asm!~\cite{isocpp,gcc-inline-asm, agner_fog_optimizing_assembly}.
% 
% В~разделе 
%  [dcl.asm]
%  стандарта C++ сказано
% «An asm declaration has the form
% asm-definition:
% \lstinline!asm ( string-literal ) ;!
% The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
% is used to pass information through the implementation to an assembler. — end note ]»

Стандарт C++ описывает %синтаксис ассемблерной вставки как
использование  \lstinline!asm! следующим образом:
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}
% содержимое круглых скобок 
конкретный вид \lstinline!string-literal! 
при этом не регламентируется.
% \lstinline!asm("assembly code");!
% 
Обычно такие вставки используются для передачи кода непосредственно ассемблеру.


% Так как ассемблерный код  не стандартизирован, синтаксис 
% Синтаксис 
Содержимое
таких вставок зависит как от архитектуры целевого аппаратного обеспечения (набор команд, регистров и~т.\,д.), так и~от компилятора (мнемоники команд, порядок операндов, синтаксис и~т.\,д.).

Используемая операционная система определяет {только} обращения \emph{непосредственно к~интерфейсам операционной системы} (системные вызовы Linux и~BSD, функции API Windows~т.\,п.).
% Если не использовать напрямую интерфейсы операционной системы, 
% а~вызывать, например, функции стандартной библиотеки С/С++, методы Qt или функции, описанные в~C/C++ части проекта, ассемблерная вставка будет работать под любой операционной системой, где есть нужный компилятор (и~Qt).
% http://www.linux.org.ru/forum/development/11701125
% вставка будет собираться и~работать под любой  операционной системой. 
Вычисления, а~в~тридцатидвухбитных системах также и~обращение к~стандартной библиотеке С~или к~кроссплатформенным библиотекам типа Qt, описываются одинаково под любой операционной системой.

Таким образом, механизм ассемблерных вставок в~код на языке C++ позволяет получить переносимую между различными операционными системами программу, включающую фрагменты на ассемблере. 




\subsection{Синтаксис ассемблерных вставок в~GCC}
\epigraph{\begin{limerick}
Жил известный профессор в~Найроби\\
Изучавший науки в~чащобе.\\
Там под шелест синиц\\
Он читал пять страниц\\
И~опять возвращался в~Найроби. \\
\end{limerick}
}
{\Lear}


Ассемблерная вставка в~программу, собираемую компилятором GCC, может быть описана с~использованием двух ключевых слов: \lstinline!asm!  либо \lstinline!__asm__!~\cite{sysbin.com/files/lowlevel/gcc_inline_assembly.htm,ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html}. 
% ru.wikibooks.org/wiki
Эти формы равнозначны и~используют одинаковый синтаксис. Форма \lstinline!__asm__! применяется, когда стандартное ключевое слово \lstinline!asm! конфликтует с~чем-либо в~программе.

\subsubsection{Базовая форма}
Базовая форма ассемблерной вставки выглядит следующим образом.

\begin{lstlisting}[style=lstsmall, caption=Базовая форма вставки]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    );
\end{lstlisting}

Ключевое слово \lstinline!volatile! для базовой формы не оказывает никакого эффекта, так как такая вставка не оптимизируется компилятором никогда.

Например:
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX = ECX
\end{lstlisting}
или
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX = BH (байт)
\end{lstlisting}
Если код во вставке содержит более одной строки, то каждая строка помещается в~кавычки. 
Тем не менее, этого недостаточно для разделения инструкций.

\subsubsection{Разделение инструкций}

% Несколько 
При компиляции соседние строки ассемблерной вставки склеиваются, как склеиваются части любой строковой константы "--- точно так же, как в~объявлении вида
\begin{lstlisting}
    char *s = "abcd"
        "ABCD";
\end{lstlisting}
которое задаёт строку \lstinline!"abcdABCD"!, не разделённую посередине никаким символом.
То есть вставка
\begin{lstlisting}
asm ("movl %eax, %ebx"
     "movl $56, %esi");
\end{lstlisting}
На самом деле выглядит как
\begin{lstlisting}
asm ("movl %eax, %ebxmovl $56, %esi");
\end{lstlisting}
и~вызывает логичное сообщение о~некорректном имени регистра «ebxmovl».

Таким образом, если во вставке необходимо использовать более одной инструкции, то  
в~конце каждой строки необходимо поместить суффикс \lstinline!\n! для разделения инструкций (если желательно иметь красивый выходной файл, можно использовать суффикс  \lstinline!\n\t!, если форматирование выходного файла безразлично "--- можно использовать вместо  \lstinline!\n! разделитель \lstinline";").
% \lstinline!\n\t!, чтобы сформированный компилятором ассемблерный файл был корректно отформатирован.
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movb %ah, (%ebx)");
\end{lstlisting}

\subsubsection{Доступные в~базовой форме вставки имена}

Внутри ассемблерной вставки можно обращаться по именам к~регистрам, а~также к~глобальным %и~статическим (то есть имеющим фиксированный адрес) <- не получается 
переменным программы (листинг~\ref{lst:rel:inline-basic-global}).

\begin{lstlisting}[caption=Увеличение глобальной переменной $n$, label=lst:rel:inline-basic-global]
int n = 12;

int main(){
    asm ("incl n");
    cout << n <<endl;
    return 0;
}
\end{lstlisting}
% Параметры функций 
Локальные переменные функций размещаются компилятором в~стеке\index{Стек} (причём не всегда в~порядке объявления), поэтому к~ним необходимо обращаться, используя \emph{расширенный ассемблер GCC,} а~именно \termin{параметры вставок.}

Необходимо также учитывать, что в~регистрах, используемых во вставке, ранее компилятором могла быть размещена какая-либо регистровая переменная.
В~этом случае компилятор не определяет автоматически, что регистр изменён, что может привести к~краху программы.

\warning{
На практике описанную выше базовую форму ассемблерных вставок \mbox{(без параметров)} не стоит использовать \emph{никогда}.

Только расширенная форма даёт возможность корректного взаимодействия с~программой на ЯВУ.
}
% Вставка "--- не функция.

% \subsection{Передача параметров в~ассемблерную вставку}
\subsection{Расширенная форма} %http://www.gamedev.ru/code/articles/gcc_inline_asm?page=3
\epigraph{\begin{limerick}
Старичок из далёкого Таллинна\\
О~египетских грезил разваллинах.\\
Он до пальмы добрался,\\
Он на пальму забрался,\\
И~ему хорошо и~без Таллинна.\\
\end{limerick}
}
{\Lear}


% http://www.ibm.com/developerworks/ru/library/l-linux_kernel_15/index.html
Синтаксис  вставки (расширенный) в~GCC может иметь две формы.

Первая выглядит следующим образом (листинг~\ref{lst:rel:inline-ext-params}).

\begin{lstlisting}[style=lstsmall, caption=Расширенная форма с~выходными параметрами, label=lst:rel:inline-ext-params]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}

% Ключевое слово const используется в~случае, когда выходные параметры зависят только от входных, что позволяет, в~частности, вынести блок за тело цикла при оптимизации.
% Один из случаев, когда const нельзя использовать "--- когда один из входных параметров интерпретируется как указатель. Значение по данному адресу может измениться, даже если сам адрес неизменен.

Ключевое слово \lstinline!volatile!
используется для того, чтобы указать компилятору, что вставляемый ассемблерный код может обладать побочными эффектами, поэтому попытки оптимизации могут привести к~логическим ошибкам.
% В~частности, если необходимо не менять вставку местами с~дрк
% запрещает компилятору оптимизировать блок и~указывает вставить его как есть.

Вторая форма расширенной ассемблерной вставки имеет вид, приведённый в~листинге~\ref{lst:rel:inline-ext-goto}.

\begin{lstlisting}[style=lstsmall, caption=Расширенная форма с~метками выхода, label=lst:rel:inline-ext-goto]
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  

Ключевое слово goto указывает, что ассемблерный код может делать переходы на метки, перечисленные в~соответствующем разделе.

Обращение к~параметру-метке предваряется префиксом \lstinline!%l! (от \emph{label}), за которым идёт порядковый номер метки в~списке всех параметров; псевдоним для метки указать нельзя.
В~частности, данный код переходит к~метке \lstinline!carry:! (и~функция возвращает~1), если в~числе~$p1$ взведён бит с~номером~$p2$ (младший бит имеет нулевой номер).

\index{Команды!bt}%
\begin{lstlisting}[style=lstsmall, caption=Переход к~метке \texttt{carry} по значению бита]
asm goto (
    "btl %[BitIdx], %[Val]\n\t"
    "jc %l2"
    :: [Val]"r" (p1), [BitIdx]"r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда \texttt{bt}  копирует бит, номер которого передается вторым параметром, в~флаг $CF$.
Затем происходит условный переход на метку~\texttt{label:} в~том случае, если  флаг~$CF$ взведён.

% http://sysbin.com/files/lowlevel/gcc_inline_assembly.htm

Параметры указываются как \lstinline!%0!, \lstinline!%1! и~т.\,д. или как \lstinline!%[Value]!, где Value "--- определённый в~разделе %выходных 
параметров псевдоним (если параметр соответствует какой-либо переменной ЯВУ, то псевдоним может как совпадать, так и~не совпадать с~именем этой переменной).
% Примечание:е
% Если в~коде указаны параметры, которые, как и~регистры, начинаются с~префикса \lstinline'%', то 
Чтобы избежать конфликтов с~именами регистров,
регистры во вставке с~расширенным синтаксисом указываются с~префиксом \lstinline'%%', например, \lstinline!%%eax!.

Общее количество параметров ограничено: $input + output + goto \leqslant 30$.


\subsubsection{Выходные параметры}

Раздел выходных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

% https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands
Описание выходного параметра
в~общем случае имеет вид~\cite{gcc.gnu.org/onlinedocs/gcc}:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cvariablename)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда.
Область определения такого псевдонима "--- вся ассемблерная вставка.
Псевдоним может быть любым допустимым идентификатором C++.
Два разных операнда не могут использовать один псевдоним.

Псевдоним выходного параметра может быть указан как ограничение расположения входного.
В~этом случае параметр с~данным псевдонимом является входным и~выходным одновременно (как правило, это изменяемая во вставке переменная).

Если псевдоним не определён, используются номер операнда, начиная с~нуля: \lstinline!%0! для первого, \lstinline!%1! для второго и~т.\,д.
% \begin{lstlisting}[style=lstsmall]
% int x;
% asm
% (
%     "movl $12, %[x]\n"
%     :[x]"=rm"(x)
% );
% \end{lstlisting}

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для выходного параметра начинается с~символа \lstinline!=! (если значение параметра перезаписывается) %, после которого 
или \lstinline!+! (если значение параметра используется как для чтения, так и~для записи).

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

При выборе регистра для размещения выходного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++ (lvalue), куда будет записано значение выходного параметра (обычно имя переменной).

Если для выходного параметра указано размещение в~регистре и~имя соответствующей переменной, это не значит, что переменная обязательно будет размещена в~регистре.
Возможно, в~регистре будет сформировано выходное значение, которое затем будет скопировано в~локальную стековую переменную.

\end{description}
Например, данный фрагмент записывает константу 12 в~переменную~$x$.
\index{Команды!mov}%
\begin{lstlisting}[style=lstsmall, caption=Перезапись выходного параметра]
int x;
asm
(
    "movl $12, %[x]\n"
    :[x]"=rm"(x)
);
\end{lstlisting}
начальное значение параметра \lstinline![x]! не определено.

Следующий фрагмент кода удваивает~$x$:
\index{Команды!add}%
\begin{lstlisting}[style=lstsmall, caption=Модификация выходного параметра]
asm
(
    "addl %[x], %[x]\n"
    :[x]"+r"(x)
);
\end{lstlisting}
Символ  \lstinline!+! в~строке расположения указывает на то, что данный параметр является не чисто выходным, а~модифицируемым.
Начальное значение параметра \lstinline![x]! берётся из~выражения-приёмника, в~данном случае "--- переменной~$x$.
% Если бы ограничение расположения начиналось бы с~\lstinline!=!, начальное значение параметра было бы не определено.

\subsubsection{Входные параметры}

Раздел входных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

Описание входного параметра в~общем случае:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cexpression)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда, аналогично псевдонимам выходных параметров.

Если псевдоним не определён, используются номер операнда, начиная со следующего за последним выходным параметром.
Если есть два выходных параметра, то первый входной будет обозначен \lstinline!%2! и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для входного параметра не может начинаться ни с~\lstinline!=!, ни с~\lstinline!+!.

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (входной параметр размещается в~регистре) и~\lstinline!m! (входной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

Если входной параметр должен располагаться там же, где один из выходных,
расположение также может быть указано цифрой или псевдонимом данного выходного параметра.

При выборе регистра для размещения входного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++, откуда берётся значение входного параметра (также может быть именем переменной).

\end{description}

Например, конструкция:
\index{Команды!mov}%
\begin{lstlisting}[style=lstsmall]
asm ("movl %0, %%eax"::"i"(1) : "%eax");
\end{lstlisting}
превратится после компиляции %в~ассемблерном коде 
в:
\begin{lstlisting}[style=lstsmall]
movl $1, %eax
\end{lstlisting}

Данный фрагмент эквивалентен \lstinline!foo += bar!:
\index{Команды!add}%
\begin{lstlisting}[style=lstsmall]
int foo = 6, bar = 12;
asm ("addl %[bar], %[foo]"
    : [foo]"+r"(foo)
    : [bar]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
причём, если переменная foo не располагается в~регистре изначально, её значение будет скопировано в~регистр, а~после добавления bar результат будет скопирован обратно в~foo.


\subsubsection{Перезаписываемые элементы}

% %
% \footnote{Использованы материалы:
% {https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\#Clobbers}%,
% % {https://ru.wikipedia.org/wiki/GCC\_Inline_Assembly#.C2.ABmemory.C2.BB\_.D0.B2\_clobber\_list}
% }
Код в~ассемблерной вставке может прямо или косвенно изменять значения не только выходных параметров, но и~прочих регистров.
Эти регистры перечисляются в~списке перезаписываемых (clobber) регистров~\cite{gcc.gnu.org/onlinedocs/gcc}.

В~частности, команда умножения в~своей классической форме (\lstinline!%eax = %eax*src!) записывает старшую часть произведения в~\lstinline"%edx".
\index{Команды!imul}%
\begin{lstlisting}[style=lstsmall, caption=Неявно перезаписываемый регистр]
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}

Если во вставке явно модифицируется какой-либо регистр (что не рекомендуется; в~случае, если нужен регистр для хранения временного значения, лучше объявить фиктивный входной параметр, как описано в~следующем подразделе), его также необходимо указать в~списке перезаписываемых элементов.
% \hyperref[sss:inline:tmpreg]{qq}
% \pagebreak[3]
% 
\index{Команды!mov}%
\begin{lstlisting}[caption=Явно перезаписываемый регистр]
asm ("movl %[One], %%eax"    
  ::[One]"i"(1)  
  : "%eax");	// movl $1, %eax
\end{lstlisting}
\pagebreak[3]

Неуказание таких регистров в~списке перезаписываемых, скорее всего, приведёт к~тому, что компилятор поместит один из параметров вставки или переменных ЯВУ в~этот же регистр и,~соответственно, к~непредсказуемому значению в~нём. 

Специальные аргументы для списка перезаписываемых регистров:
\begin{description}
\item["cc"]
показывает, что код изменяет регистр флагов.

Флаги изменяют все арифметические инструкции.


\index{Команды!add}%
\begin{lstlisting}[style=lstsmall, caption=Перезапись флагов]
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}



\item["memory"]
показывает, что код меняет значение в~памяти (не считая явно указанных выходных параметров) "--- например, интерпретирует какой-либо из параметров как указатель.

\begin{lstlisting}[style=lstsmall, caption=Перезапись памяти по указателю]
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}


% Помимо простого указания компилятору, что ассемблерная вставка изменяет содержимое памяти, она ещё служит директивой Memory Barrier для компилятора. Это означает, что те операции обращений в~память, которые стоят выше по коду, в~результирующем машинном коде будут выполняться до тех, которые стоят ниже ассемблерной вставки. В~случае многопоточной среды, когда от этого напрямую зависит риск возникновения race condition, это обстоятельство является существенным.

% Кроме указания компилятору на изменение памяти,
% барьер компилятора

При указании \lstinline!"memory"! в~списке перезаписываемых элементов все операции работы с~памятью, которые были в~программе до ассемблерной вставки, выполнятся до неё, а~те, что стоят в~программе после "--- будут после.
В~противном случае компилятор может поменять местами как операторы C++, так и~ассемблерные вставки.
\end{description}


\subsection{Практическое использование параметров}
\epigraph{\begin{limerick}
    Жил-был старичок у~причала,\\
    Которого жизнь удручала.\\
    Ему дали салату\\
    И~сыграли сонату,\\
    И~немного ему полегчало.\\
\end{limerick}
}
{\Lear}


\subsubsection{Временные регистры}

% \footnote{Использованы материалы:
% {http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}
% }
% \labellocal{sss::tmpreg}
% \label{sss:inline:tmpreg}

Использовать под временные данные фиксированные регистры и~указывать их в~списке  перезаписываемых не вполне корректно~\cite{osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}.

Более правильным будет ввести фиктивный выходной параметр, размещаемый в~регистре (\lstinline!=r! или \lstinline!=&r!, либо более конкретное ограничение "--- подробнее указано в~разделе \ref{sec:Constraints}), так как это даст компилятору больше свободы при оптимизации.

В~тексте вставки можно использовать данный параметр для хранения произвольных временных данных.

% Так, в~программе 
% \begin{lstlisting}[style=lstsmall]
% int main()
% {
%     int a=77, b;
%     asm("movl %0, %%eax"::"d"(a));
%     asm("movl %%eax, %0":"=d"(b));
%     cout << b;
%     return 0;
% }
% \end{lstlisting}
% первая вставка записывает значение локальной переменной \lstinline!a! через регистр \EDX{} (\lstinline!"d"!) в~регистр \EAX;
% вторая "--- содержимое регистра \EAX{} записывает через регистр \EDX{} в~переменную \lstinline!b! (\lstinline!"=d"(b)!).
% То есть если вставки сохранят порядок после компиляции (что не гарантируется), программа копирует содержимое локальной переменной \lstinline!a! (77) в~локальную переменную \lstinline!b!, и~последующий оператор вывода выведет 77. 

Пересылка через временный регистр:
\begin{lstlisting}[style=lstsmall, caption=Фиктивный выходной параметр как временный регистр]
int src = 1, dst, tmp;
asm
(
    "movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);
\end{lstlisting}


\subsubsection{Модификация входных параметров}

Модифицировать входные параметры, не являющиеся одновременно и~выходными, \termin{нельзя}.

Если возникает необходимость изменить значение, переданное как входной параметр, оно должно быть описано ещё и~как выходной.


Рассмотрим код, который увеличивает переменную $foo$ на значение переменной $bar$.
В~данном случае $bar$ может быть только входным параметром, а~$foo$ "--- модифицируемым, то есть  одновременно и~входным, и~выходным.

В~следующем фрагменте неименованный параметр \lstinline!%0! является входным и~выходным одновременно (точнее, входной параметр \lstinline!%1! располагается там же, где и~выходной \lstinline!%0!).
Это определяется ограничением размещения входного параметра \lstinline!%1! "--- %вместо  ограничений 
там указан номер параметра \lstinline!%0!.
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
); // foo += bar
\end{lstlisting}
Аналогичные вычисления с~использованием именованных параметров (\lstinline![S]! здесь "--- %и~входной и~выходной параметр
выходной параметр в~регистре, и~в~том же регистре расположен неименованный входной параметр) выглядят следующим образом.
% \begin{lstlisting}[style=lstsmall]
% asm("addl %[A], %[X]\n"
%     : [X]"=r"(foo)
%     :"[X]"(foo), [A]"g" (bar)
%     :"cc"
% ); // foo += bar
% \end{lstlisting}
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
% Используя \lstinline![S]! как приёмник сложения, мы фактически модифицируем неименованный выходной параметр \lstinline!%1!
Мы используем  неименованный выходной параметр \lstinline!%1!, чтобы задать начальное значение входному~\lstinline![S]!.
В~данном случае (входной параметр инициализируется исходным значением $foo$ "--- приёмника совмещённого с~ним выходного параметра~\lstinline![S]!) можно было и~не вводить дополнительный входной параметр, а~заменить описание% %ограничение расположения
~\lstinline![S]! на~\lstinline![S]"+r" (foo)!.


Описание параметра как выходного и~входного одновременно (точнее, однорасположенной пары параметров <<выходной-входной>>), в~частности, делает параметр сохраняющим предсказуемое значение на всём протяжении вставки.
Если такой параметр размещается в~регистре, никакой другой параметр данной вставки не будет помещён в~этот регистр.

Отличие такого описания параметра от выходного с~начальным значением (расположение которого начинается с~\lstinline!+!) "--- то, что источник начального значения  может отличаться от исходного значения назначения.
Так, следующий фрагмент кода устанавливает начальное значение параметра-регистра \lstinline![S]! нулём, а~значение этого регистра после завершения вставки записывается в~переменную~$foo$:
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}
% Если для инициализации выходного параметра не требуется значение, отличное от~исходного значения его приёмника,

Также для входного параметра, расположенного на месте выходного, можно задать отдельный псевдоним. %, так как %, в~отличие от 
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : [S_initial_value]"[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}


\subsubsection{Конфликт выходных и~входных долгоживущих параметров}

При размещении параметров в~регистрах компилятор считает, что входные параметры используются в~начале вставки, а~выходные "--- в~конце, \emph{после} использования всех входных.
Соответственно, <<только входные>> параметры часто располагаются в~тех же регистрах, что и~<<только выходные>>, чтобы освободить максимальное количество регистров для других переменных.

Это может привести к~конфликту, если какой-либо входной параметр используется в~конце вставки, после присваивания хотя бы одного из выходных параметров.
При размещении этих двух параметров в~одном регистре присваивание уничтожит оригинальное значение входного параметра.

В~частности, данный фрагмент (вычисляющий $y = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$) в~случае размещения входного параметра \lstinline![Zero]! и~выходного \lstinline![y]! в~одном регистре работает некорректно ($y$ всегда равен $1$, так как инициализация выходного параметра  \lstinline![y]! единицей выполняется до чтения  входного параметра \lstinline![Zero]!, и~в~момент условного присваивания \lstinline!cmovll %[Zero], %[y]! регистр, где расположены оба этих параметра, равен $1$).
\begin{lstlisting}[style=lstsmall, caption=Параметр $y$ конфликтует с~$Zero$]
int x = 10, y;
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
); // y = 1 независимо от x
\end{lstlisting}
Это можно исправить, объявив \lstinline![y]! выходным параметром с~начальным значением (\lstinline!+! вместо \lstinline!=! в~расположении), хотя нам и~не требуется исходное значение переменной~$y$.
Такое ограничение не позволит компилятору совместить  какой-либо входной параметр с~\lstinline![y]!.
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"+r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
% 
Другой способ "--- явно указать, какой входной параметр следует расположить на месте выходного~\lstinline![y]!.
Здесь мы можем совместить с~\lstinline![y]! входной \lstinline![x]!, так как последнее чтение~\lstinline![x]! (сравнение \lstinline![x]! с~нулём) выполняется до инициализации~\lstinline![y]!:
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"[y]" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Оба этих способа позволяют разрешить конфликт и~получить корректное значение~$y$.
% $y = \left\{\begin{array}{ll}
% 1, & x \geqslant 0 \\
% 0, & x < 0 \\
% \end{array}\right.$

\subsection{%Типы размещения параметров% 
Ограничения на расположение операнда}
\label{sec:Constraints}
\epigraph{\begin{limerick}
    Некий доктор, раскрыв свой баул, \\
    Попросил: «Принесите мне стул».\\
    В~тот же миг эскулапу\\
    Принесли его шляпу\\
    И~сказали: «Чем \emph{это} не стул?»\\
\end{limerick}
}
{\Lear}
% \footnote{Использованы материалы:
% {https://gcc.gnu.org/onlinedocs/gcc/Constraints.html\#Constraints}
% }

% https://gcc.gnu.org/ml/gcc/1999-10n/msg00488.html
% Типы параметров:
Некоторые общие ограничения (типы размещения параметров)~\cite{gcc.gnu.org/onlinedocs/gcc}:
\begin{description}
\item[r] "--- регистр; %- register
\item[m] "--- память; %- memory effective address
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); %- immediate value, 0..0xffffffff
\item[g] "--- память, регистр общего назначения или непосредственное значение (обычно этот тип эквивалентен \lstinline"rim"); %- general effective address
\item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
\end{description}

% But there are some i386-specific ones described in the processor-specific
% part of the manual and in more detail in GCC's i386.h:
Некоторые ограничения (типы), специфичные для i386 (определены в~файле i386.h GCC)
\begin{description}
% \item[q] "--- регистр, который можно адресовать по байтам младшего слова (EAX, EBX, ECX, EDX); %- byte-addressable register (eax, ebx, ecx, edx)
% \item[A] "--- пара регистров  EDX:EAX;
\item[q] "--- регистр, который можно адресовать по байтам младшего слова ($A, B, C, D$); %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров $D:A$;
\item[a, b, c, d, S, D] "--- регистры %eax, ebx, ecx, edx, esi, edi 
$A, B, C, D, si, di$ соответственно;

\item[I..P] "--- машинно-зависимые ограничения для констант:
% \end{description}
% 
% Ограничения для констант:
% \begin{description}
% \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% %     ("i" would allow an address known only at link time)
\begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% \item[K] "--- Signed 8-bit integer constant. ?  255
% \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (сдвиги, которые может выполнить \lstinline!lea!);
\index{Команды!lea}%

\item[N] "--- непосредственное значение в~диапазоне 0..255 (беззнаковое однобайтовое).
% \item[O] "--- непосредственное значение в~диапазоне 0..32
\end{description}
\end{description}


\subsection{Модификаторы параметров}
\epigraph{\begin{limerick}
Осмотрительный старец из Кёльна \\
    Отвечал на расспросы окольно.\\
    На вопрос: «Вы здоровы?»\\
    Говорил он: «А~кто вы?» "---\\
    Подозрительный старец из Кёльна.\\
\end{limerick}
}
{\Lear}

\newcommand{\moddesc}[1]{\textbf{#1}}

Иногда в~коде программы требуется подставить не  значение параметра в~неизменённом виде, а~какую-либо его характеристику.
В~этом случае необходимо использовать так называемые модификаторы параметров (таблица~\ref{tab:inline-par-modifiers}).

\begin{table}[!ht]
\caption{Модификаторы параметров ассемблерных вставок GCC}
\label{tab:inline-par-modifiers}

\begin{tabularx}{\linewidth}{|>{\bfseries}c|L|}
\hline
\thead{Модификатор} & \thead{Действие} \\\hline
z & Печать суффикса команды для размера операнда \\\hline
c & Печать константы без префикса \lstinline!$! \\\hline
b & Печать имени младшего байта регистра 
\mbox{(\lstinline!\%al! для регистра $A$)}
\\
h & Печать имени старшего байта младшего слова регистра \mbox{(\lstinline!\%ah! для регистра $A$)} \\
w & Печать имени младшего слова регистра \mbox{(\lstinline!\%ax! для регистра $A$)} \\
k & Печать имени младшего двойного слова регистра \mbox{(\lstinline!\%eax! для регистра $A$)} \\
q & Печать 64-битного варианта имени регистра \mbox{(\lstinline!\%rax! для регистра $A$)}\\\hline
\end{tabularx}
\end{table}

% Modifier 	Description 	Operand 	masm=att 	masm=intel
% z 	Print the opcode suffix for the size of the current integer operand (one of b/w/l/q). 	%z0 	l 	
% b 	Print the QImode name of the register. 	%b0 	%al 	al
% h 	Print the QImode name for a “high” register. 	%h0 	%ah 	ah
% w 	Print the HImode name of the register. 	%w0 	%ax 	ax
% k 	Print the SImode name of the register. 	%k0 	%eax 	eax
% q 	Print the DImode name of the register. 	%q0 	%rax 	rax
% l 	Print the label name with no punctuation. 	%l2 	.L2 	.L2
% c 	Require a constant operand and print the constant expression with no punctuation. 	%c1 	2 	

Модификатор указывается между префиксом \lstinline!%! и~именем параметра.

В~частности, при инициализации параметра~\lstinline![dmem]!, находящегося в~памяти, необходимо указать  размер приёмника.
В~GCC это делается при помощи суффикса размера (раздел~\ref{sec:att-suffixes}).
Явное указание суффикса сделает программу неустойчивой к~изменению типа переменной, передающейся как~\lstinline![dmem]!.
Если суффикс указан с~помощью модификатора \lstinline!z!:
\begin{lstlisting}[numbers=none]
"mov%z[dmem] $0, %[dmem]\n"
\end{lstlisting}
данная команда будет корректно инициализировать переменную как~типа~$short$, так и~$int$ или~$long~long$.

Печать константы без префикса \lstinline!$! необходима, если эта константа используется не как непосредственный операнд команды, а~как-то иначе.
В~частности, такая константа может быть частью адреса.
% Адреса полей 
% Следующий фрагмент
\begin{lstlisting}[numbers=none]
"movl $13,  %c[FieldDisp](%[Struct])\n"
\end{lstlisting}
Приведённый фрагмент ассемблерной вставки инициализирует поле структуры, расположенной по адресу~\lstinline![Struct]!.
Смещение поля задано параметром~\lstinline![FieldDisp]!.

Модификаторы печати имени части регистра доступны только для параметров в~регистрах,
причём печать младшего байта и~старшего байта младшего слова "--- только в~тех, где %младший байт
эти байты
можно адресовать.
\index{REX, префикс}%
В~тридцатидвухбитном режиме как младший байт, так и~следующий за ним можно адресовать только для~$A{-}D$.
В~шестидесятичетырёхбитном младший байт адресуется для всех шестнадцати регистров общего назначения с~помощью префикса~$REX$. Второй байт доступен только для $A{-}D$, причём не в~любой ситуации (использование префикса $REX$ запрещает доступ к~$ah{-}dh$).
% (если в~команде используется префикс $REX$).

% Модификатор печати имени старшего байта младшего слова  доступен только для тех регистров, где младший байт можно адресовать.

\addquestion{Какие стадии включает компиляция программы с~помощью GCC?}

\addquestion{Какое расширение имеет файл с~исходным кодом на языке ассемблера?}
\addquestion{Какое расширение имеет файл с~исходным кодом на языке C++?}
\addquestion{Как изменить имя выходного файла при сборке?}
\addquestion{Как собрать программу, состоящую из нескольких модулей?}

\addquestion{Каким ключевым словом открывается ассемблерная вставка?}
\addquestion{Как из ассемблерной вставки обратиться к~локальным переменным?}

\addquestion{Какие вы знаете ограничения на размещение параметров ассемблерных вставок?}



\printquestions
