\chapter{Связь уровней абстракции}
\label{sec:rel}

\epigraph{\begin{stanza}
Мы выходим по приборам на великую глушь\\
Назад в~Архангельск.\\
\end{stanza}}
{\Aquarium}


% \chapter{Разработка и~отладка программного обеспечения}
% \chapter{Инструменты разработки}

Современная вычислительная система включает шесть уровней абстракции, но только нижние четыре из них интерпретируются вычислительной машиной или операционной системой.
Для трансляции программы с~языка высокого уровня, в~частности, C++, или даже с~языка ассемблера
% в~машинный код
в~исполняемый файл, пригодный для запуска операционной системой,
% на уровень ассемблера 
необходимы специализированные программные средства.

Более того, подобные средства должны обеспечивать не только прямую вертикальную связь соседних уровней,
то есть компиляцию с~языка на язык,
но и~«диагональные» связи "--- %объединение фрагментов, написанных на различных языках, в~один
сборку исполняемого файла из множества фрагментов (модулей, функций), возможно, написанных на различных языках.

Универсальный способ  объединения   функций, написанных на различных языках "--- использование промежуточного (так называемого объектного) представления 
с~последующей компоновкой их в~единое целое.
Так, в~частности, из программы, написанной на языке Pascal, можно вызвать функцию, описанную на C++,
если они будут следовать одному соглашению о~вызове.

% Соединить таким образом язык C++ и~язык ассемблера можно двумя основными способами:
% \begin{itemize}
% \item скомпоновать в~один исполняемый файл функции
% \end{itemize}

Для соединения языка высокого уровня и~языка ассемблера также используется механизм ассемблерных вставок в~код.
С~помощью специальной конструкции ЯВУ можно вставить в~код несколько команд ассемблера, не используя вызова и~возврата из функции.

\section{Компиляция}
\label{sec:rel-compile}
\epigraph{\begin{stanza}
Вскипятите его, остудите во льду\\
И~немножко припудрите мелом,\\
Но одно безусловно имейте в~виду:\\
Не нарушить симметрию в~целом!\\
\end{stanza}
}
{\Snark}

В~простейшем случае вертикальная связь уровней абстракции осуществляется через компиляцию "--- перевод программы с~языка более высокого уровня на язык следующего уровня абстракции.

\subsection{Инструменты разработки}

\epigraph{
Включив Компыотерище, не стал он дожидаться, пока разогреется его кристаллическое нутро, а, пошёл на прогулку. Когда же вернулся, машина занималась делом невообразимо сложным, а именно "--- из попавших под руку материалов строила другую машину, несравненно огромнейшую. Та, своим чередом, в течение ночи и следующего дня вырвала из фундамента стены дома и снесла крышу, возводя громаду третьей по счету машины.
}{С.\,Лем}


% В~настоящее время 
% разработка  программного обеспечения невозможна без вспомогательных программ.
% % 
% Для перевода программы с~языка высокого уровня, в~частности, C++, или даже с~языка ассемблера,
% в~машинный код,
% необходима программа-компилятор.

\subsubsection{Компиляторы C++}


Для платформы x86 разработано множество компиляторов C++.
Большинство из них входит в~состав той или иной коллекции. % компиляторов.
В~подобные коллекции входят компиляторы с~языков C и~C++, часто ассемблер, а~также компилятор с~Фортрана и~других ЯВУ.
Некоторые коллекции включают, кроме компиляторов, и~другие средства разработки, %~частности,  IDE
иногда даже специализированные отладчик и~IDE.

Перечислим наиболее известные коллекции.
\begin{itemize}
\item %Компилятор C++ из 
\termin{GNU Compiler Collection (GCC)} реализована более чем для 45 платформ, поддерживает большинство ОС (порт под Microsoft Windows исторически носит название \termin{MinGW}), семь языков (в~том числе C и~C++, со строгим соблюдение стандартов), 
% лицензия GNU GPL 3+ 
и~распространяется под лицензией GNU GPL~3+, позволяющей как образовательную, так и~коммерческую разработку (в~том числе разработку приложения с~закрытым исходным кодом). 

\item \termin{TenDRA/Ten15} "--- первоначально британская оборонная разработка, сейчас поддерживает архитектуры x86, x86-64, IA-64 (Itanium), DEC Alpha; POSIX-совместимые ОС
% лицензия BSD;
и~распространяется под лицензией BSD, позволяющей любые виды разработки. 

\item \termin{Portable C Compiler (PCC)} "--- ранний компилятор C, какое-то время поддерживавшийся в~OpenBSD, в~настоящее время  x86, x86-64, Unix-подобные ОС, в~том числе GNU/Linux, 
Microsoft Windows; лицензия BSD.

\item \termin{Intel C++ compiler} "--- x86, x86-64,  IA-64, GNU/Linux, MacOS~X, Microsoft Windows, коммерческая собственническая лицензия.

{
\item \termin{Oracle Solaris Studio} "--- x86, x86-64, SPARC; Solaris, OpenSolaris, GNU/Linux; собственническая лицензия.
\sloppy

}

\item \termin{Open Watcom} "--- DOS, OS/2 и Microsoft Windows; лицензия  	
Sybase Open Watcom Public License version 1.0, 
%не полностью поддерживает стандарт С++
неполная поддержка стандарта.

\item \termin{Microsoft Visual Studio} "--- x86, x86-64, IA-64 и~.NET, только Microsoft Windows, коммерческая собственническая лицензия, грубые 
нарушения стандарта.

% \item \termin{Norcroft C Сompiler} "--- Intel Pentium для GNU/Linux, коммерческая собственническая лицензия
% 
% 
% \hrulefill
% \item \termin{Clang} "--- виртуальная RISC-машина LLVM

\end{itemize}

Коллекция GCC портирована на наибольшее количество платформ.
В~её состав входят, в~частности, \termin{gcc} "---  компилятор~C
и~\termin{g++} "---  компилятор~C++,
а~также ассемблер %ы для всех поддерживаемых платформ.
\termin{gas.}


\subsubsection{Ассемблеры x86}

Если синтаксис языка высокого уровня описан соответствующим стандартом, то синтаксис ассемблера не стандартизирован. %, так как зав
Хотя набор мнемонических обозначения ассемблера определяется набором команд процессора,
% сами об
их символьное представление может существенно различаться.
Кроме того, практически у~каждого ассемблера уникальный набор директив и~других синтаксических элементов, которые не транслируются непосредственно в~машинные команды, но необходимы для корректной сборки программы.

% Соответственно, детали синтаксиса 
Таким образом, фактически каждый %компилятор с~языка ассемблера ()
ассемблер, предназначенный для архитектуры x86, обладает уникальным синтаксисом, несовместимым с~остальными.
\begin{itemize}
\item \termin{GNU Assembler (GAS)} из коллекции GCC (лицензия GNU GPL~3+) используется на одном из этапов компиляции, поэтому реализован для всех поддерживаемых платформ.
GAS использует для всех процессоров единообразный синтаксис %, основанный на  
(так называемый синтаксис AT\&T).
\end{itemize}
Другие трансляторы поддерживают только архитектуру x86 и~её шестидесятичетырёхбитный вариант x86-64.
\begin{itemize}
\item \termin{Flat Assembler (FASM)} реализован для  Unix-подобных операционных систем (GNU/Linux, OpenBSD и~др.), FreeDOS и~Microsoft Windows, 
распространяется по лицензии BSD.
Несколько операционных систем написаны полностью на FASM "--- MenuetOS и~KolibriOS. %DexOS,
\item \termin{NASM/Yasm} также реализован для Unix-подобных систем, FreeDOS и~Microsoft Windows под лицензией BSD.
% \item HLASM "--- z/Architecture IBM
\item \termin{Turbo Assembler (TASM)/Lazy Assembler} "--- поддерживает  FreeDOS и~Microsoft Windows.
Имеет режим совместимости с~MASM.
\item \termin{MASM} от Microsoft также поддерживает только FreeDOS и~Microsoft Windows.

\end{itemize}
% Их синтаксисы являются вариантами 
Они используют различные варианты (диалекты)
синтаксиса Intel, предложенного разработчиком x86 и~не используемого на неинтеловских процессорах.
GAS также поддерживает синтаксис Intel для архитектуры x86,
но в~данном пособии будет рассматриваться синтаксис AT\&T как более наглядный и~универсальный.


\subsubsection{Интегрированные среды разработки}
% \epigraph{\begin{stanza}
% Браконьер мог бы так продолжать до утра,\\
%     Но "--- увы! "--- было  с временем туго;\\
%  И он тихо заплакал, взглянув на Бобра,\\
%     Как на самого близкого друга.\\
% \end{stanza}
% }
% {\Snark}
% 
% % \section{Компиляция и~отладка в~IDE} 
% \label{sec:cpp-ide}
% watch'и, memory, дизассемблер

Интегрированные среды разработки (integrated development environment, IDE) включают редактор кода
и~множество %интерактивных 
инструментов, облегчающих разработку, в~том числе
интерфейс для запуска компилятора. %, отладчика и~т.\,д. %других средств разработки.

Набор файлов исходного кода, настроек и~сценариев сборки объединяется в~\termin{проект.}
Формат проекта различается для разных IDE.
% 
Один и~тот же проект может быть собран с~различными комплектами настроек.
Такой комплект может называться целью или конфигурацией.
Для каждого проекта IDE по умолчанию создаёт как минимум две цели сборки: отладочную (Debug) и~лишённую отладочной информации (Release).
Интерактивная отладка на уровне инструкций языка высокого уровня (в~частности, точка останова на конкретном операторе ЯВУ) возможна только для отладочной сборки.
% Проект, 

Большинство интегрированных сред может работать с~различными компиляторами и~отладчиками.
Если на компьютере разработчика установлено несколько коллекций компиляторов, в~настройках потребуется выбрать необходимый вариант.
Многие среды могут поставляться как отдельно, так и~комплекте с~какой-либо коллекцией компиляторов и~отладчиком.
% К~сожалению, существуе
Некоторые среды, в~частности, IDE Visual Studio от Microsoft, поставляющаяся только с~соответствующей коллекцией компиляторов,
ограничены в~функциональности и~полностью поддерживают только одну коллекцию (хотя в~последних версиях появилась частичная поддержка GCC).
% не позволяют всех возможностей при работе с~GCC.
% Они ограничены в~функциональности и~полностью поддерживают только одну коллекцию.
% % 
Соответственно, IDE Visual Studio непригодна для разработки на ассемблере с~синтаксисом AT\&T.
Наиболее распространена IDE Qt Creator.
Также для разработки с~помощью GCC можно использовать IDE Code::Blocks или TheIDE.

\subsubsection{Дизассемблер}

Так как  языка ассемблера близок к~машинному коду, возможно преобразовать машинные команды в~инструкции ассемблера.
Такое преобразование не всегда однозначно.
% 
Соответствующие инструменты "--- дизассемблеры "--- широко применяются в~Microsoft Windows для исследования программного обеспечения с~закрытым исходным кодом.

В~GNU/Linux дизассемблер используется в~основном %при отладке
как компонент интерактивного отладчика,
позволяющий %отлаживать
работать с~программой, собранной без отладочной информации.

\subsection{Этапы компиляции}
\label{sec:cpp-compile}
\index{Компиляция!этапы}

\epigraph{
"--*  Как убить синего слона?

"--*  Из винтовки для синих слонов.

"--*  А как убить красного слона?

"--*  Его надо душить, до тех пор пока он не посинеет, затем застрелить из винтовки для синих слонов.

"--*  А как убить зелёного слона?

"--*  Нужно рассказывать ему похабные анекдоты, пока он не покраснеет, затем душить, пока не посинеет, затем застрелить из винтовки для синих слонов.
}
{П.\,Канюкова}


% \footnote{%http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html
% Использованы материалы CSCI 241
% Intermediate Programming in C++
% Spring 2015
% (The C++ compilation process)
% % http://knzsoft.ru/cpp-bgr-ls1/
% и~А.\,А.\,Князев. Руководство по C++ для начинающих}
% % }

\begingroup

\newlength{\slideheigth}
\setlength{\slideheigth}{0.5\textheight}

Компиляция программы на языке C++ в~исполняемый файл включает четыре этапа (рис.~\ref{ris:c++compile}):
препроцессинг, собственно компиляция (с~С++ в~ассемблерный код), ассемблирование и~компоновка~\cite{CS241/Notes/compile}.

% \begin{illustration}[p]
% \includegraphics[width=\linewidth]{compile}
% 
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}
% % \hfill
% % \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}
% 
% \caption{Этапы компиляции программы на C++}
% \label{ris:c++compile}
% \end{illustration}
\begin{illustration}
\resizebox{\linewidth}{!}{
\input{book/drawings/compile-cpp}
}
\caption{Этапы компиляции программы на C++}
\label{ris:c++compile}
\end{illustration}


\begin{enumerate}[wide=\parindent]
{
\item Препроцессор копирует содержимое включённых  директивой \lstinline!#include! заголовочных файлов в~исходный код модуля, раскрывает макросы и,~в~том числе, выполняет текстовые замены «констант», определённых с~помощью директивы \lstinline!#define!, на их значения, а~также отрабатывает директивы условной компиляции, выбрасывая из кода те или иные фрагменты.\fussy

}
\index{C/C++!препроцессор}

\lstset{language=Bash}

При использовании компилятора из коллекции GCC
увидеть результат препроцессинга можно, воспользовавшись опцией \lstinline!-E!% компилятора g++
. Результат будет выведен в стандартный поток вывода (в~представленном %ниже 
примере %стандартный поток вывода 
перенаправлен в~файл main.E).

\begin{lstlisting}
$ g++ -E main.cpp > main.E
\end{lstlisting}
Здесь и далее, знак доллара (\lstinline!$!) обозначает стандартное приглашение к~вводу команды
% консоли Unix-подобных систем.
в~консоли (приглашение, оканчивающееся знаком~\lstinline!$!, традиционно используется в~командных интерпретаторах Unix-подобных систем).
Писать знак доллара не требуется.
Регистр важен.


\item Код, обработанный препроцессором, транслируется компилятором в~ассемблерный код для соответствующей платформы.

% \begin{centeredfloat}[!ht]
% \begin{tabularx}{1\linewidth}{LLL}
% main.cpp
% 
% \begin{lstlisting}
% int x = 13;
% int main()
% {
%     int y = 2*x + 123;
% ...
% }
% \end{lstlisting}
% 
% &
% g++ -S main.cpp $\to$
% &
% main.s
% 
% \begin{lstlisting}
% ...
% .globl	x
% 	.data
% 	.align 4
% 	.type	x, @object
% 	.size	x, 4
% x:
% 	.long	13
% ...
% 	movl	x, %eax
% 	addl	%eax, %eax
% 	addl	$123, %eax
% 	movl	%eax, -12(%ebp)
% \end{lstlisting}
% 
% \\
% \end{tabularx}
% \end{centeredfloat}

Для остановки компиляции после этого этапа для компилятора g++ следует воспользоваться ключом \lstinline!-S!:
\begin{lstlisting}
$ g++ -S main.cpp
\end{lstlisting}





На этапе компиляции выполняется \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.\index{Декорирование}
% Имена 
% C++ искорёжены почти до неузнаваемости, C — у меня сохранены, а у вас, если статья Фога не ошибатеся, к ним приписывается префикс _: _Sqr вместо Sqr (и было бы __Sqr вместо _Sqr, но такой функции в C++-программе нет).
В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
(в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).

Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
В~статье Агнера Фога 
«Calling conventions for different C++ compilers and operating systems»~\cite{agner_fog_calling_conventions}
приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).


\item Ассемблерный код, созданный компилятором, транслируется в~объектный код для соответствующей платформы.
Останов компиляции файла после этапа ассемблирования  обеспечивается ключом \lstinline!-c!:

\begin{lstlisting}
$ g++ -c main.cpp
\end{lstlisting}
При ассемблировании  имена функций сохраняются.

Некоторые компиляторы скрывают этап ассемблирования, преобразуя исходный код на языке высокого уровня, обработанный препроцессором, напрямую в~объектный файл.
Компиляторы коллекции GCC можно остановить после любого этапа.



\item Объектные файлы% различных модулей и~библиотек
, созданные ассемблером, объединяются компоновщиком (линкером, редактором связей) в~исполняемый файл.

На данном этапе компоновщик ищет реализации для всех внешних (\lstinline!extern!) функций по именам.
Соответственно, имена, которые в~разных модулях носит одна и~та же функция, на этапе компоновки должны совпадать.


\end{enumerate}
\FloatBarrier
Интегрированные среды разработки (IDE) выполняют все этапы автоматически.

\subsection{Препроцессор}
\label{sec:cpp-macro}
% \epigraph{
% C позволяет легко выстрелить себе в ногу %; C++ делает это сложнее, но, когда вы это делаете, отстреливает всю вашу ногу.
% % При помощи C вы легко можете выстрелить себе в ногу. П
% (при помощи C++ это сделать сложнее, но если это произойдёт, вам оторвёт всю ногу целиком).
% }{Б. Страуструп}
\epigraph{
Препроцессор, возможно, и~неудачен, но трудно найти ему лучше структурированную и более эффективную замену.
}{Б. Страуструп}


Первая стадия компиляции программы на C/C++ "--- обработка исходного кода препроцессором.
% На этом этапе выполняется обработка текста программы в~соответствии с~определёнными в~этом же тексте правилами "--- макросами препроцессора.
% Макросы представляют собой текстовую замену %выполняющиеся на этапе препроцессинга.
% и~никак не связаны с~особенностями используемого языка "--- C/C++ или ассемблера.
Препроцессор «не понимает» языков C, C++ или ассемблера и~обрабатывает собственный язык "--- директивы препроцессора.
Директива начинается с~символа~\lstinline!#! и~заканчивается переводом строки,
в~частности, \lstinline!#define!, \lstinline!#undef!, \lstinline!#include!, \lstinline!#if!, \lstinline!#ifdef!, \lstinline!#ifndef!, \lstinline!#else!, \lstinline!#elif!, \lstinline!#endif!.
% #error и #warning

После завершения препроцессинга в~тексте программы не остаётся ни директив препроцессора, ни имён определяемых ими макросов.

В~настоящее время в~программировании на языке C++ препроцессор используется в~основном для двух задач 
"--- условной компиляции и~%включения файла,  
копирования файла, содержащего заголовки функций, классов и~т.\,п. в~несколько файлов исходного кода.
% Современные стандарты языка C++ описывают высокоуровневые возможности, позволяющие отказаться от директив препроцессора, но пока эти возможности не распространены.
Также препроцессор поддерживает \termin{макросы,} которые могут применяться как %вспомогательное средство
для обеспечения корректного решения описанных выше задач, так и~самостоятельно.


Макросы представляют собой текстовую подстановку, выполняющуюся на этапе препроцессинга,
и~никак не связаны с~особенностями используемого языка "--- C/C++ или ассемблера.
Для того, чтобы отличать их от конструкций языка, принято давать макросам имена, состоящие только из заглавных букв.
Их возможности не ограничиваются использованием в~условной компиляции.

Тем не менее использование макросов небезопасно и~не должно (за исключением условной компиляции) применяться при программировании на высоком уровне.


\subsubsection{Включение файла}
\index{Препроцессор!включение файла}

Включение файлов с~заголовками выполняется директивой \lstinline!#include!:
запись \lstinline!#include имя_файла! целиком копирует указанный файл на место, где была эта директива. % \lstinline!#include!.
Имя включаемого файла может содержать путь к~нему и~заключается в~угловые скобки или кавычки.
Если имя файла заключено в~угловые скобки (\lstinline!#include <iostream>!), %путь отсчитывается от %директории
файл должен располагаться в~одной из папок со стандартными заголовочными файлами,
если имя файла в~кавычках (\lstinline!#include "myheader.h"!) "--- он должен находиться в~папке проекта.

В~имени включаемого файла не должно быть комментариев (сочетание \lstinline!/*! трактуется как маска имени файла, в~частности, \lstinline!"dir/*"! "--- все файлы в~папке $dir$).
Зато имя может включать макросы, что позволяет реализовать различные наборы включаемых файлов для различных версий или платформ.

Заголовочные файлы могут включаться как в~файлы, содержащие определения функций, так и~в~другие заголовочные файлы.
В~первом случае возможна ситуация, когда в~файл с~определениями в~итоге включается несколько копий одного и~того же заголовочного файла.
% 
Для предотвращения многократного включения внутри заголовочного файла необходимо применять директивы условной компиляции,
как показано в~листинге~\ref{lst:cpp:ifndef-include-protect}.


\begin{lstlisting}[caption={Защита  от повторного включения}, label=lst:cpp:ifndef-include-protect]
#ifndef THIS_UNIT_ALREADY_INCLUDED
#define THIS_UNIT_ALREADY_INCLUDED
... // весь текст заголовочного файла
#endif
\end{lstlisting}

В~разрабатываемый стандарт C++ планировалось включить поддержку модулей, аналогичных модулям языка Паскаль.
Это позволило бы отказаться как от использования директивы \lstinline!#include!, так и~от ручной защиты от многократного включения, но в~окончательную редакцию C++17 модули не вошли.

\subsubsection{Условная компиляция}
\index{Препроцессор!условия}

Условная компиляция обеспечивается директивами \lstinline!#if!, \lstinline!#ifdef!, \lstinline!#ifndef!, \lstinline!#else!, \lstinline!#elif!, \lstinline!#endif!,
обеспечивающими удаление части текста до начала этапа компиляции.

Директивы семейства \lstinline!#if*! и~\lstinline!#elif! используют условие, которое не должно зависеть от кода C/C++ или ассемблера.
% Директива  \lstinline!#define! в~настоящее время совместно с~\lstinline!#if!, \lstinline!#ifdef!, \lstinline!#ifndef!, \lstinline!#else!, \lstinline!#elif!, \lstinline!#endif!
% используется для обеспечения условной компиляции.
Для этого используются \termin{макросы препроцессора,} определяемые директивой \lstinline!#define!.


Условие директивы  \lstinline!#if! может включать целочисленные литералы, арифметические операторы, макросы и~специальный оператор препроцессора \lstinline!defined!. %, применяющийся к~макросу и~опр
Истинным считается ненулевое значение условия.
Унарный оператор \lstinline!defined(NAME)! может использоваться только в~условиях препроцессора. С~его помощью можно узнать, определён ли макрос с~именем~\lstinline!NAME!.
Для часто употребляемой конструкции \lstinline!#if defined(NAME)! 
существует синоним~\lstinline!#ifdef NAME!, для \lstinline?#if !defined(NAME)?
"--- синоним~\lstinline!#ifndef NAME!.

В~простейшем случае текст, расположенный от директивы  \lstinline!#if*! до \lstinline!#endif!
остаётся в~коде после препроцессинга в~том случае, когда условие  истинно
и~исключается, если условие ложно.
% Использование условной компиляции для защиты от повторного включения
Подобная конструкция, в~частности, используется для описания отладочных фрагментов которые не должны войти в~окончательную сборку программы (листинг~\ref{lst:cpp:ifdef-gebug}), а~также в~заголовочных файлах для защиты от повторного включения в~один и~тот же файл (листинг~\ref{lst:cpp:ifndef-include-protect}).

\begin{lstlisting}[caption={Отладочный фрагмент}, label=lst:cpp:ifdef-gebug]
#ifdef DEBUG
...
#endif
\end{lstlisting}



Если между директивой семейства \lstinline!#if*! и~\lstinline!#endif! находится директива~\lstinline!#else! (листинг~\ref{lst:cpp:ifdef-else}),
то в~том случае, когда условие  истинно, остаётся фрагмент между \lstinline!#if*! и~\lstinline!#else!, а~фрагмент от~\lstinline!#else! до~\lstinline!#endif! удаляется,
в~случае, если условие ложно "--- наоборот.

\begin{lstlisting}[caption={Выбор одного из фрагментов}, label=lst:cpp:ifdef-else]
#ifdef FLAG
...
#else
...
#endif
\end{lstlisting}

Используя директиву \lstinline!#elif!,  можно организовать выбор из нескольких фрагментов.
В~окончательный вариант текста, который будет компилироваться, войдёт только один из фрагментов, расположенных между  директивами \lstinline!#if*! и~соответствующей \lstinline!#endif!
и~разделённых директивами \lstinline!#elif! и~\lstinline!#else!.


\subsubsection{Макросы}
\index{Препроцессор!макросы}

% Определение макроса начинается с~д
Макрос определяется с~помощью директивы \lstinline!#define!.
В~простейшем случае за директивой следует имя определяемого макроса, а~за ним до конца строки "---  текст, на который производится замена (значение или определение макроса).
Имя макроса отделяется от директивы \lstinline!#define! и~значения пробельными символами.

\begin{lstlisting}[caption={Определение макроса без параметров}, label=lst:cpp:define-THE_NUMBER]
#define THE_NUMBER 13
\end{lstlisting}

После определения макроса \lstinline!THE_NUMBER! согласно листингу~\ref{lst:cpp:define-THE_NUMBER}, приведённого в~файле с~исходным кодом (непосредственно в~его тексте или в~тексте включённого заголовочного файла) строка \lstinline!THE_NUMBER! будет до конца файла с~исходным кодом (либо до удаления определения с~помощью директивы~\lstinline!#undef!) заменяться на строку~\lstinline!13!.
Вхождения строки  \lstinline!THE_NUMBER!, находящиеся до определения этого макроса, останутся без изменений.

При использовании макроса без параметров в~тексте его имя заменяется на значение без каких-либо изменений, то есть \lstinline!int i = THE_NUMBER+1! будет заменяться на \lstinline!int i = 13+1!.
Имя макроса заменяется только в~том случае, когда оно является целым словом (то есть отделено от других строк пробельными символами или знаками препинания),  в~частности, строка \lstinline!THE_NUMBER_2! не будет заменена на \lstinline!13_2!.

При этом заменяется любое вхождение макроса как целого слова, то есть, в~частности, описание функции \lstinline!int f(int THE_NUMBER)! будет заменено на \lstinline!int f(int 13)!, что вызовет ошибку компиляции.
% 
В~менее благоприятном случае сообщения об ошибке может и~не быть.
В~частности, определение \lstinline!#define true 0! не приведёт к~сбою, но работа программы будет некорректной.
% 
Для предупреждения подобных ситуаций необходимо отделять имена макросов препроцессора от имён, используемых в~программе.
Обычно имена макросов записываются заглавными буквами и~не должны быть слишком короткими (в~частности, имя \lstinline!N! с~большей вероятностью будет использовано в~программе, чем~\lstinline!THE_NUMBER!, поэтому определение \lstinline!#define N 13! не очень удачно).

Если после имени макроса в~строке определения нет ничего, кроме, может быть, пробельных символов,
такой макрос имеет пустое значение.

\begin{lstlisting}[caption={Определение макроса с~пустым значением}]
#define FLAG
\end{lstlisting}

Макросы с~пустым значением обычно используются только в~директивах условной компиляции  \lstinline!#ifdef! или~\lstinline!#ifndef!,
которые проверяют не значение, а~факт наличия макроса.
Если такой макрос встречается в~тексте, он заменяется на пустую строку.

% Макросами  
% \begin{lstlisting}
% #define INTEGER short
% \end{lstlisting}

Удалить определение макроса можно с~помощью директивы \lstinline!#undef!.

\begin{lstlisting}[caption={Удаление макроса}, label=lst:cpp:undef]
#undef THE_NUMBER
\end{lstlisting}

В~тексте, лежащем после директивы, приведённой в~листинге~\ref{lst:cpp:undef}, строка~\lstinline!THE_NUMBER! останется без изменения.


\paragraph{Параметры макросов}

С помощью директивы \lstinline!#define! можно также определить \termin{макросы с~параметрами} "---
лексемы, которые принимают параметры подобно функциям, но фактически являющиеся \termin{текстовой заменой} (более гибким аналогом меню Replace текстового редактора) и~раскрываются не во время выполнения (как функции) и~не во время компиляции (как шаблоны C++), а~до анализа и~компиляции программы, никак не сообразуясь с~типами переменных, текстом программы и~так далее.


При описании макроса
после директивы \lstinline!#define! указывается имя макроса, за которым в скобках (без пробелов) следуют имена параметров, отделённые запятыми и определение макроса, отделённое пробелом. 

% Макрос без параметров
% \begin{lstlisting}[caption={Макрос без параметров}]
% #define THE_NUMBER 13
% \end{lstlisting}
% Макрос с~двумя параметрами
\begin{lstlisting}[caption={Определение макроса с~двумя параметрами}, label=lst:cpp:define-max]
#define MAX(num1, num2) ((num1) > (num2) ? (num1) : (num2))
\end{lstlisting}

При использовании макроса в~тексте 
после его имени также ставятся круглые скобки, где перечисляются фактические значения параметров макроса.
\begin{lstlisting}
int j = MAX(9, i);
\end{lstlisting}
При подстановке макрос заменяется своим значением, причём на место имён параметров вписывается соответствующий текст.

Параметры макроса при подстановке никак не проверяются.
Если в~результате такой текстовой подстановки возникнет ошибка, это выяснится только на этапе компиляции, причём не всегда сообщение об ошибке будет вменяемым.

В~листинге~\ref{lst:cpp:define-max} параметры макроса в~его определении берутся в~скобки, чтобы избежать неприятных ситуаций в~том случае, если параметрами будут не имена переменных и~литералы, а~строки, представляющие собой более сложные выражения C++.
Если макрос представляет собой вычисление выражения, то и~его тоже лучше взять в~скобки, что также сделано в~листинге~\ref{lst:cpp:define-max}.

Например, определим макрос~\lstinline!SQUARE(x)! для вычисления квадрата параметра \lstinline!x!.
Макрос, определённый как в~листинге~\ref{lst:cpp:define-SQUARE-bad}, вычисляет неверное значение в~случае, если его параметр является выражением.

\begin{lstlisting}[caption={Неудачное определение макроса с~параметрами}, label=lst:cpp:define-SQUARE-bad]
#define SQUARE(x) x*x
\end{lstlisting}
В~частности, текст
% \begin{lstlisting}
\lstinline!i = SQUARE(2+2)!
% \end{lstlisting}
раскроется в~\lstinline!i = 2+2*2+2!, что даст \lstinline!i!, равное~$2+4+2=8$, а~не $(2+2)^2=16$.
% Вообще, для
% 
Определение %макроса %корректно обработает параметр, 
из листинга~\ref{lst:cpp:define-SQUARE-good}
заменит \lstinline!SQUARE(2+2)! на \lstinline!((2+2)*(2+2))! так что значение квадрата параметра в~данном случае будет рассчитано корректно.

\begin{lstlisting}[caption={Более корректное определение макроса с~параметрами}, label=lst:cpp:define-SQUARE-good]
#define SQUARE(x) ((x)*(x))
\end{lstlisting}

Значение квадрата выражения, модифицирующего свои переменные, будет всё равно вычисляться некорректно.
В~частности, \lstinline!SQUARE(i++)! будет раскрыто как \lstinline!((i++)*(i++))!, так что переменная~$i$ будет увеличена два раза.
Единственный выход "--- не использовать такие выражения как параметры подобных макросов.

\paragraph{Объёмные макросы}

Определение макроса должно занимать одну строку.
Если строка-подстановка не помещается в~строку файла, то в качестве знака переноса строки используется  обратная косая черта. 

\begin{lstlisting}[caption={Определение объёмного макроса}, label=lst:cpp:define-DISPLAY_ARRAY]
#define DISPLAY_ARRAY(arr, size) {\
	int i;\
	for (i = 0; i < size; i++) {\
		printf("%d ", arr[i]);\
	}\
	printf("\n");\
}
\end{lstlisting}

«Склейка» нескольких  строк в~одну с~помощью косой черты допустима не только в~макросах, но и~в~любом месте программы,
но в~большинстве прочих случаев не имеет смысла, так так перевод строки в~C/C++ является корректным пробельным символом.

% Макрос с~параметрами "--- это просто текстовая замена, поэтому 

% \paragraph{Действия с~параметрами}
\paragraph{Закавычивание строк}


Параметры макроса можно взять в~кавычки, используя оператор \lstinline!#!:
\begin{lstlisting}
#define QUOTES(x) #x
\end{lstlisting}
Тогда следующий код
\begin{lstlisting}
cout <<  QUOTES(1+2) << " " << QUOTES(x) << " " << QUOTES(мяу) << " " << QUOTES("мяу") << endl;
\end{lstlisting}
выведет
\begin{lstlisting}
1+2 x мяу "мяу"
\end{lstlisting}
% Выражения,. заключённые 
Чаще всего этот оператор используется в~отладочной печати, так как позволяет вывести на стандартный вывод или сохранить в~файл имя переменной.


\paragraph{Конкатенация строк}

% Строки (не в~смысле C/C++, а~произвольные кусочки исходного )  
% Элементы  
Параметры можно «склеивать» друг с~другом и~с~произвольными строками
% можно объединить
с~помощью оператора \lstinline!##!. 
Пример такого макроса:
\begin{lstlisting}
#define DEF_X_Y(typename) typename x##typename = 1, y##typename = 0; \
    cout << typeid(x##typename).name() << " " << x##typename << endl;
\end{lstlisting}
получив имя типа как параметр (например, \lstinline!int!),  макрос формирует текст, который объявляет и~инициализирует две переменные \lstinline!x<имя типа>! и~\lstinline!y<имя типа>!, а~также выводит на стандартный вывод характеристику типа и~значение переменной~\lstinline!x<имя типа>!.
Следующий код не вызовет ошибок компиляции.
\begin{lstlisting}
    DEF_X_Y(int)
    yint = xint+1;
\end{lstlisting}
% Здесь, в~отличие от шаблонов


Конкатенация строк может быть использована для 
% искажения имён функций ассемблерного модуля вручную
% при совместной сборке модулей на C++ и~на ассемблере.
изменения имён функций или переменных  «на лету» в~зависимости от версии программы или используемой платформы, что иногда необходимо.


\subsection{Расширения файлов исходного кода}

\epigraph{\begin{limerick}
    Старичок, проживающий в Туле, \\
    Смастерил из оглоблей ходули.\\
    Он обвил их кругом\\
    Васильком и вьюнком,\\
    Чтобы видели: сделано в Туле.\\
\end{limerick}
}
{\Lear}

% Чтобы начать сборку не с~начала, достаточно задать для файла расширение, отличное от~\lstinline!.cpp! или ~\lstinline!.c!.
Чтобы начать сборку с~определённого этапа, достаточно задать для файла расширение, 
соответствующее этому этапу.
% 
Вообще, компилятор "--- одна из немногих программ, которые учитывают расширение файла при его обработке~\cite{labor-liber.org/en/gnu-linux/development/extensions}.

Расширение  \programname{.s} соответствует ассемблерному файлу. 
Таким образом, команды
\mbox{\lstinline!$ g++ main.s!} и~\mbox{\lstinline!$ gcc main.s!}
эквивалентны и~выполняют ассемблирование и~компоновку ассемблерного файла~\lstinline!main.s!%.
, минуя этапы препроцессинга и~компиляции с~ЯВУ.

{

Расширение \programname{.o} соответствует объектному файлу, и~команды
\mbox{\lstinline!$ g++ main.o!} и~\mbox{\lstinline!$ gcc main.o!}
выполняют только компоновку файла~\lstinline!main.o!.
\fussy

}

В~случае, когда необходимо выполнить препроцессинг, ассемблирование и~компоновку, выбросив только этап компиляции с~ЯВУ (именно такая последовательность оптимальна при сборке модулей, вручную написанных на ассемблере), используется
расширение \programname{.S}.
\begin{lstlisting}
$ g++ main.S
\end{lstlisting}
Большинство современных файловых систем чувствительны к~регистру имён, а~современные ОС, такие как GNU/Linux и~BSD, различают регистр при обработке,
так что имена~\lstinline!main.s! и~\lstinline!main.S! будут различаться.

Операционная система Microsoft Windows не различает регистра имён файлов (хотя наиболее часто используемая ею файловая система  NTFS теоретически чувствительна к~регистру),
так что для файлов, требующих препроцессинга, используется расширение \programname{.sx}.
Компиляторы GCC трактуют расширение \programname{.sx} аналогично \programname{.S}.

Многие интегрированные среды разработки «не знают» расширений~\programname{.s} и~\programname{.sx}, так что их необходимо не только вручную добавить в~проект, но и~указать, что они должны компилироваться и~компоноваться как в~режиме отладочной сборки, так и~в~оптимизированном.
 
\subsection{Изменение имени выходного файла}

\epigraph{
"--* Значит,  будешь   Рыжик. И не спорь! Так  будет  правильно! Или как  тебя  назвать?

    Рыжик  покачал белоснежной головой, но своего варианта не предложил.
}{Жвалевский/Мытько}


Исполняемый файл, полученный после  компиляции и~ассемблирования GCC, независимо от количества и~имён файлов с~исходным кодом
по умолчанию будет называться \lstinline!a.out! (assembler output).

% Имя исполняемого файла по умолчанию (\lstinline!a.out!) 
Это имя
можно изменить, используя ключ~\lstinline!-o!,
после которого указывается желаемое имя выходного файла:
\begin{lstlisting}
$ g++ main.cpp -o prog
\end{lstlisting}
Таким образом исполняемый файл, полученный после сборки main.cpp (отсутствие ключей остановки сборки соответствует выполнению всех этапов), получит имя~\lstinline!prog!.

Исполняемый файл в~большинстве операционных систем не имеет расширения и~отличается от неисполняемого правами доступа.
% При желании можно задать для него любое имя.

\subsection{Компиляция проекта, состоящего из нескольких модулей}
\index{Компиляция!модули}

\epigraph{\begin{limerick}
    Жил один долгожитель в Дамаске, \\
    Не знававший заботы и ласки.\\
    Он в двуколку свою\\
    Брал трёх сов и свинью "---\\
    И катил по Дамаску без тряски.\\
     \end{limerick}
}
{\Lear}

\lstset{language=Bash}

При компиляции проекта, включающего несколько модулей, шаги препроцессинга, компиляции и~ассемблирования повторяются для каждого файла исходного кода.
Затем из полученных объектных файлов линкер собирает единый исполняемый файл (рис.~\ref{ris:compile-cpp-cpp}).
Это можно выполнить одним запуском %любого 
компилятора из коллекции GCC:
\begin{lstlisting}
g++ -o prog prog1.cpp prog3.cpp 
\end{lstlisting}


\begin{illustration}
\resizebox{\linewidth}{!}{
\input{book/drawings/compile-cpp-cpp}
}
\caption{Совместная компиляция нескольких модулей}
\label{ris:compile-cpp-cpp}
\end{illustration}

Если попытаться собрать каждый из модулей отдельно, мы получим ошибки компоновки (так как во всех модулях, кроме главного, отсутствует точка входа "--- функция \lstinline!main!, а~в~главном "--- нет функций, описанных в~остальных).


Можно остановить сборку после этапа компиляции модулей:
\begin{lstlisting}
g++ -с prog1.cpp prog3.cpp 
g++ -с prog3.cpp 
\end{lstlisting}

Затем из полученных объектных файлов одним запуском линкера можно получить исполняемый файл:
\begin{lstlisting}
g++ -o prog prog1.o prog3.o 
\end{lstlisting}
Ручная сборка небольших проектов обычно выполняется одной командой, в~интегрированных средах разработки этапы, как правило, разделяются.

\endgroup







% \chapter{Соединение уровней ЯВУ и~ассемблера}


\section{Импорт и~экспорт функций}
\label{sec:calling-functions}
\epigraph{\begin{limerick}
Дама, оставив Равенну,\\
поехала поездом в~Вену,\\
Но, доехав до Вены,\\
решила мгновенно,\\
Что вернётся в~родную Равенну.
\end{limerick}
}
{\Lear}

Наиболее универсальным способом использования  в~одной программе несколько языков программирования
является %импорт и~экспорт функций.
статическая совместная компоновка модулей, написанных на разных языках.

При статической компоновке каждый модуль %компилируется и~ассемблируется.
необходимо скомпилировать из~соответствующего языка и~ассемблировать, остановив %после этого процесс.
сборку на стадии объектных файлов (напомним, что в~GCC для этого используется ключ  \lstinline!-c!).
Полученные объектные файлы собираются линкером в~единый исполняемый файл (рис.~\ref{ris:compile-cpp-asm}).


\begin{illustration}
\resizebox{\linewidth}{!}{
\input{book/drawings/compile-cpp-asm}
}
\caption{Совместная компиляция  модулей на разных языках}
\label{ris:compile-cpp-asm}
\end{illustration}

% Так как
Сочетание модулей на языке высокого уровня и~на ассемблере используется так часто, что компиляторы коллекции GCC
корректно собирают подобный набор модулей одной командой сборки многомодульного проекта,
как показано на рис.~\ref{ris:compile-cpp-asm}:
\begin{lstlisting}
g++ prog1.cpp prog2.S 
\end{lstlisting}
Останов сборки и~компоновка отдельной командой в~этом случае не нужны.

Интегрированные разработки, поддерживающие компиляторы коллекции GCC, также автоматически выполняют сборку проекта на языке высокого уровня, содержащего ассемблерные модули.




\subsection{Требования к~вызовам функций}
\label{sec:asm-calling-conventions}

\epigraph{\begin{stanza}[0mm]
И может быть мы сразу друг друга поймём,\\
Если у нас один и тот же разъём.
\end{stanza}}
{\Aquarium}

% Функции 
К~механизму вызова 
подпрограммы
% функции
(в~различных языках используется также термины «функция», «метод», «процедура») 
можно сформировать ряд требований.
\begin{enumerate}
\item Возможность передачи управления на произвольный адрес.
\item Возврат управления назад после завершения подпрограммы.
\item Вложенные вызовы подпрограмм.
\item Сохранение и~восстановление регистров вызывающей программы.
\item Передача заданного количества аргументов.
\item Возврат значения. % (часто подпрограмму, способную возвращать).
% \item Передача и~возврат структур.
\item Выделение и~освобождение памяти под локальные переменные подпрограмм.
\end{enumerate}
В~системе команд x86 реализованы только первые три из них.
Обеспечить выполнение остальных можно только в~том случае, если вызывающая и~вызываемая программа «договорятся», где будут находиться передаваемые  аргументы и~локальные переменные.



В~некоторых источниках считается, что функцией можно назвать только подпрограмму, написанную на языке высокого уровня.
При этом подпрограмма, написанная на ассемблере и~соответствующая используемому в~данном языке высокого уровня соглашению о~вызове,
может быть вызвана наравне с~написанными на ЯВУ.
Таким образом, логичнее считать термин «функция» либо синонимом подпрограммы,
либо обозначать им подпрограмму, соответствующую одному из общепринятых соглашений.


% \subsection{Модули и~функции на ассемблере}
% \subsection{Вызов подпрограммы}
% \subsection{Подпрограммы на ассемблере}
% \subsection{Вызов подпрограммы на ассемблере}
\subsection{Механизм вызова подпрограммы}
\index{Подпрограммы!вызов}
\label{sec:asm-func}
\epigraph{
Что такое заклинание, понятно всем.\\Это когда говоришь "--- а оно случается.
% 
% Нет, как-то ненаучно вышло. Заглянем в трактат профессора Югоруса Лужжа «Основные направления развития всеобщего магического образования на 1975-2125 годы»:
% 
% «Заклинание "--- вербализованная модуляция унитарного магического воздействия, подкрепленная спорадически сознательным, а иногда эмерджентным импульсом психофизиологического характера».
% 
% Вот.
% 
% А так было все понятно…
% 
% Сейчас попробуем объяснить. «Вербализованный» "--- это значит «словами», «модуляция» "--- это… ну… то сильнее, то слабее…
% 
% Ладно, все равно слово «эмерджентный» авторы даже руками показать не смогут. Вернемся к прежнему определению. Из него следует, что достаточно что-то произнести, и что-то случится. В такой, наиболее общей форме определение верно абсолютно: что бы вы ни произнесли, где-нибудь что-нибудь случится.
% 
% Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{Жвалевский/Мытько}
\index{Вызов функций}
\index{Стек}
\index{Команды!push}
\index{Команды!pop}
\index{Команды!call}
\index{Команды!ret}


% Вызов подпрограммы (функции или процедуры) можно разбить на последовательность следующих действий.
% \begin{enumerate}
% \item Передача параметров.
% \item Сохранение адреса возврата.
% \item Передача управления вызываемой подпрограмме.
% \item Выполнение вызываемой подпрограммы.
% \item Подготовка возвращаемого значения.
% \item Возвращение управления вызывающей программе.
% \end{enumerate}


% Соответственно, к~механизму вызова подпрограммы можно сформировать ряд требований.
% \begin{enumerate}
% \item Возможность передачи управления на произвольный адрес.
% \item Возврат управления назад после завершения подпрограммы.
% \item Вложенные вызовы подпрограмм.
% \item Сохранение и~восстановление регистров вызывающей программы.
% \item Передача заданного количества аргументов.
% \item Передача и~возврат структур.
% \item Выделение и~освобождение памяти под локальные переменные подпрограмм.
% \end{enumerate}

% В~системе команд x86 реализованы только первые три из них.

В~системе команд x86 для реализации механизма подпрограмм используются всего две команды:
\begin{itemize}
\item команда вызова подпрограммы \lstinline!call!, единственным аргументом которой является адрес начала подпрограммы;
\item команда возврата из подпрограммы \lstinline!ret!.
\end{itemize}
Пусть следующая команда, расположенная по адресу $c_i$ "--- \lstinline!call f!
(рис.~\ref{ris:call-stack}, а).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-abv}
}

\caption{Изменение указателя стека командами вызова и~возврата}
\label{ris:call-stack}
\end{illustration}%
Команда \lstinline!call! помещает в~стек адрес следующей по порядку команды $c_{i+1}$ "--- \termin{адрес возврата,}
после чего в~указатель команд~$ip$ помещается адрес~$f$, так что эта команда становится следующей для исполнения процессором
(рис.~\ref{ris:call-stack}, б).
Когда в~процессе исполнения подпрограммы~$f$ встретится команда \lstinline!ret!
(рис.~\ref{ris:call-stack}, в),
из стека извлекается верхнее машинное слово "--- там должен быть адрес возврата "--- и~помещается в~указатель команд~$ip$
(рис.~\ref{ris:call-stack}, г).
Соответственно, выполнение вызывающей программы продолжится со следующей за  \lstinline!call! команды.  

\subsubsection{Локальные переменные}

Как уже говорилось в~разделе~\ref{sec:stack-segment}, локальные переменные подпрограммы хранятся в~стеке;
также программист или оптимизирующий компилятор может поместить часть локальных переменных в~регистрах общего назначения.
Это не предписано системой команд, но является общепринятым.

Так как память под локальные переменные подпрограммы выделяется подпрограммой после %её вызова
передачи управления на её начало, 
эти переменные будут расположены в~стеке над адресом возврата (так как стек растёт вниз "--- по меньшим адресам).
Для выделения и~освобождения памяти под переменные служат 
\index{Пролог подпрограммы}%
\index{Эпилог подпрограммы}%
специальные фрагменты кода в~начале и~в~конце подпрограммы "--- пролог и~эпилог соответственно.

Современные компиляторы 
% сразу после 
помещают в~пролог команду уменьшения указателя стека $sp$ на величину, равную общему объёму локальных переменных, помещаемых в~стеке
(рис.~\ref{ris:call-stack-var-sp}, а) и~б).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-var-sp-abv}
}

\caption{Размещение локальных переменных в~стеке оптимизирующим компилятором}
\label{ris:call-stack-var-sp}
\end{illustration}%
В~эпилоге указатель $sp$ увеличивается на ту же величину (рис.~\ref{ris:call-stack-var-sp}, в) и~г),
так что к~моменту выхода из подпрограммы на вершине стека окажется адрес возврата (рис.~\ref{ris:call-stack-var-sp}, г).

% После этого локальные переменные можно 
Адреса локальных переменных можно выразить через $sp$.
В~процессе выполнения программы указатель $sp$ может меняться% (в~частности, для размещения)
, в~этом случае необходимо соответственно корректировать смещения переменных относительно $sp$.
Также,  %если в~процессе выполнения в~стеке резервировалась память под новые локальные
если код подпрограммы нарушает баланс стека,
может понадобиться скорректировать величину, добавляемую к~$sp$ в~эпилоге.

Ранние компиляторы сохраняли в~регистре~$bp$ значение $sp$ до резервирования памяти под локальные переменные.
Это позволяло адресовать переменные относительно $bp$ и~не корректировать смещение, а~в~эпилоге восстановить значение~$sp$ из~$bp$
(рис.~\ref{ris:call-stack-var-bp}, а)--д).
\begin{illustration}
\resizebox{1\linewidth}{!}{
\schemafont
\input{book/drawings/call-stack-var-bp-abv}
}

\caption{Размещение локальных переменных в~стеке (устаревший вариант)}
\label{ris:call-stack-var-bp}
\end{illustration}%
Это удлиняло пролог и~эпилог за счёт необходимости сохранять и~восстанавливать исходное значение~$bp$.
Кроме того, при этом невозможно использовать~$bp$ для других целей.

Размещение локальных переменных происходит внутри вызываемой подпрограммы и~не затрагивает данные вызывающей программы.
При ручном программировании можно использовать как современную, так и~устаревшую форму пролога и~эпилога;
если все локальные переменные размещены в~регистрах, пролог и~эпилог вообще не требуются.

Следует отметить два момента:
\begin{itemize}
\item при компиляции с~языка высокого уровня порядок локальных переменных в~стеке может не совпадать с~порядком их объявления;
\item содержимое резервируемой в~стеке памяти, как и~начальное значение регистров, не определено, поэтому локальные переменные обязательно нужно инициализировать.
\end{itemize}

\subsubsection{Параметры и~возвращаемое значение}

Параметры  также могут передаваться в~подпрограмму через стек или регистры.
Вызывающая программа должна разместить параметры в~условленных местах до того, как управление будет передано подпрограмме.
Соответственно, параметры, передаваемые через стек, окажутся под адресом возврата, то есть будут иметь б\'{о}льшие адреса.

Возвращаемое значение функции не может передаваться вызывающей подпрограмме через стек, так как %оно должно быть записано на своё место до команды \lstinline!ret!, 
% возвращающей
% а~
% к~моменту возврата 
при выполнении команды~\lstinline!ret!
в~стеке не должно остаться ничего после адреса возврата.
Соответственно, возвращаемое значение может передаваться в~вызывающую подпрограмму только через регистр.

Иногда значение, которое, согласно синтаксису языка высокого уровня, является возвращаемым, не может быть размещено в~регистре (в~частности, это может быть объект).
В~этом случае зарезервированное для него место (или его адрес) фактически передаётся как ещё один параметр.


Таким образом, «настоящее» возвращаемое значение может быть только числом.
Если это целое число или указатель, 
в~программах для x86
для возврата используется регистр~$A$.
% если  разрядность результата превышает разрядность платформы "--- пара регистров $D:A$ (старшая часть в~$D$, младшая в~$A$).
% 
Вещественное значение возвращается через вершину стека математического сопроцессора $st(0)$.

% В~языке высокого уровня функция может возвращать только одно значение.



\subsection{Соглашения о~вызовах}
\label{sec:calling-conventions}
\epigraph{
Если же вы хотите, чтобы произошло не что-то где-то, а~что надо и~здесь, придётся подбирать выражения. Точнее "--- заклинания.
}{Жвалевский/Мытько}




% \footnote{Использованы материалы:
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.
% }
\index{Подпрограммы!соглашения о~вызовах}

{Соглашение о~вызовах} определяет протокол взаимодействия вызывающей и~вызываемой программ;
в~частности, необходимо согласовать следующие правила.
% \vspace{-1\parskip}
\begin{enumerate}
\item Способ передачи параметров (через стек, через регистры, смешанный; а~также используемые регистры и~их порядок).
\item Порядок размещения параметров в~стеке 
(%прямой порядок, или 
порядок Pascal подразумевает, что первый параметр помещается в~стек первым, 
% обратный порядок, или 
порядок C "--- что первый параметр помещается последним, непосредственно перед адресом возврата).
\item Как передаётся указатель $this%/self
$ (для методов объекта).

\item Какие регистры могут изменяться подпрограммой.
% Если 

\item Кто очищает стек и~сохраняет/восстанавливает регистры.

\item Инструкции вызова и возврата из подпрограмм.
\item Возврат значения из подпрограммы (функции).
\end{enumerate}



На платформе x86 для вызова и~возврата из подпрограммы используются соответственно команды \lstinline!call! и~\lstinline!ret!;
а~значение обычно возвращается через регистр~$A$.
Параметры обычно передаются либо через стек, либо смешанным способом: первые из тех, что можно разместить в~отведённых регистрах, передаются через регистры,
оставшиеся "--- через стек.
% Если 

% Возвращаемое значение:
% % \vspace{-1\parskip}
% \begin{enumerate}
% \item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
% \item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
% \end{enumerate}

Остальные пункты по-разному реализованы в~различных языках, компиляторах,  операционных системах
и~для различной разрядности.
% Также для передачи 
Подробно эти различия рассмотрены в~исследовании Агнера Фога~\cite{agner_fog_calling_conventions}.

% \subsubsection{}
В~таблице~\ref{tab:calling-conventions-32} приведены наиболее популярные соглашения о~вызовах, используемые на 32-битных платформах.
Регистры для передачи параметров используются в~указанном порядке.
Если столбец «Параметры в~регистрах» пуст, все параметры передаются через стек.
Указатель $this$ обычно передаётся первым параметром.

\begin{table}[!ht]

\caption{Тридцатидвухбитные соглашения о~вызовах}
\label{tab:calling-conventions-32}

\renewcommand\theadfont{\bfseries\small}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}

% \scriptsize
% \footnotesize

\singlespacing
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|>{\theadfont}M{6em}|l|l|L|%L|
}
\hline
Соглашение &\tdhead{Параметры\\в~регистрах}	&\theadlong{Порядок}	&\theadlong{Очистка стека}	\\\hline
cdecl		&	&	C	&	вызывающая программа	\\\hline
pascal		&	&	Pascal	&	функция			\\\hline
winapi (stdcall)&	&	C	&	функция			\\\hline
gnu		&	&	C	&	this "--- функция, \mbox{остальные "---  вызывающая программа}	\\\hline
gnu fastcall		&	$ecx, edx$	&	C	&	функция	\\\hline
gnu regparm (3)		&	$eax, edx, ecx$	&	C	&	функция	\\\hline
Borland fastcall	&	$ecx, edx$	&	Pascal	&	функция	\\\hline
Microsoft fastcall	&	$ecx, edx$	&	C	&	функция	\\\hline
\end{tabularx}
\end{table}

Для соглашения gnu regparm можно указать количество параметров в~регистрах (от одного до трёх).

Кроме того, регистры делятся на те, которые подпрограмма может изменять по своему усмотрению 
(соответственно, если они используются в~вызывающей программе, вызывающей программе необходимо сохранить их перед обращение к подпрограмме и~восстановить после того, как подпрограмма закончит работу)
и~те, которые должны сохранить своё значение 
(если в~подпрограмме потребуется использовать один из таких регистров, то сохранить и~потом восстановить их исходное значение должна сама подпрограмма).

Согласно Фогу,  в~тридцатидвухбитных программах, как в~Microsoft Windows, так и~в~Unix-подобных операционных системах (GNU/Linux, BSD, Mac~OS~X),
подпрограмма может изменять 
регистры
$eax, ecx, edx,$ регистры сопроцессора $st(0)-st(7)$
и~регистры расширений $xmm/ymm/zmm.$
Неприкосновенными должны остаться $ebx, ebp$ и~$esi, edi.$

На~шестидесятичетырёхбитных платформах применяется всего два соглашения о~вызовах (таблица~\ref{tab:calling-conventions-64}).
К~сожалению, они несовместимы между собой.
Также для разных платформ теперь различается набор регистров, которые могут изменяться в~подпрограмме.
% В~таблице~\ref{tab:calling-conventions-64} приведены соглашения о~вызовах, используемые на 64-битных платформах.
Регистры для передачи параметров используются в~указанном порядке.
Указатель $this$ передаётся первым параметром.

\begin{table}[!ht]

\caption{Шестидесятичетырёхбитные соглашения о~вызовах}
\label{tab:calling-conventions-64}

\renewcommand\theadfont{\bfseries\footnotesize}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{@{}l@{}}#1\end{tabular}}}}

\singlespacing
\small

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|L|L|l|L|L|L|
}
\hline
\theadlong{Соглашение} &\tdhead{Параметры\\в~регистрах}	&\tikz[baseline]\node[rotate=90] {\theadlong{Порядок}};	&\theadlong{Очистка стека}	
&\tdhead{Изменяемые\\регистры}	&	%\tdhead{Неприкосновенные\\регистры}
\tdhead{Неизменяемые\\регистры}
\\\hline
{\theadfont Microsoft Windows,} компиляторы MinGW, Microsoft, Intel	&	
% $rcx/zmm0,$
% $rdx/zmm1,$
% $r8/zmm2,$
% $r9/zmm3$
\begin{tabular}{@{}>{$}c<{$}@{$/$}>{$}c<{$}@{}}
rcx&zmm0,\\
rdx&zmm1,\\
r8&zmm2,\\
r9&zmm3 \\
\end{tabular}
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$ $r8{-}r11,$ $st(0){-}st(7),$ 
$x/y/zmm,$
кроме младших частей $6{-}15$
&
$rbx, rbp,$ $rsi, rdi,$ $r12{-}r15,$ $xmm6{-}xmm15$
\\\hline
% Unix-подобные (
{\theadfont GNU/Linux, BSD, Mac~OS~X,} компиляторы GCC, Intel	&	
% $rdi, rsi,$
% $rdx, rcx,$ 
% $r8, r9,$ 
\begin{tabular}{@{}>{$}c<{$}@{$~$}>{$}c<{$}@{}}
rdi,& rsi,\\
rdx,& rcx,\\
r8, & r9,\\
\end{tabular}
$zmm0{-}zmm7$
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$  $rsi, rdi,$ $r8{-}r11,$ $st(0){-}st(7),$ $x/y/zmm$
&
$rbx, rbp,$ $r12{-}r15$ 
\\\hline
\end{tabularx}
\end{table}

Как видно из таблицы~\ref{tab:calling-conventions-64}, в~64-битном режиме под разными операционными системами в~подпрограмме необходимо сохранять и~восстанавливать разные регистры.


\subsubsection{Вызов подпрограммы в~GAS}

На тридцатидвухбитной платформе в~GCC используются 
соглашения о~вызове gnu, cdecl, gnu fastcall, gnu regparm (0--3).
Для внешних функций с~отключённым декорированием  (\lstinline!extern "C"!)
применяется только cdecl, то есть: % все параметры передаются через стек.
\begin{itemize}%[wide=\parindent]

\item размещение аргументов исключительно \emph{в~стеке,} без использования регистров, причём аргументы, меньшие 4 байт, расширяются до 4 байт;

\item размещение аргументов в~стеке %\emph{справа налево,} так 
таким образом,
что первый аргумент оказывается на вершине стека;
% (после вызова первый аргумент находится непосредственно под адресом возврата, как показано на рис.~\ref{ris:cdecl-stack});

\item очистка стека выполняется \emph{вызывающей программой,} так что
в~функции 
аргументы должны не сниматься со стека, а~копироваться оттуда.


\end{itemize}
Размещение аргументов в~стеке {справа налево} и~очистка стека вызывающей программой позволяет определить функции с~переменным количеством аргументов, такие, как  \lstinline!printf! и~\lstinline!scanf! из стандартной библиотеки \lstinline!C!, но надо помнить о~небезопасности таких функций.

% Адрес возврата принято передавать через стек
При вызове функции в~стек сначала помещаются аргументы в~соответствии с~соглашением о~вызовах, 
а~затем команда вызова кладёт сверху адрес возврата.
Соответственно, когда функция получает управление, 
% http://trubetskoy1.narod.ru/arttranslate/FuncCallPart2_1.html
то первые четыре байта по адресу, хранящемуся в~$sp$, будут содержать адрес возврата. 
Далее идут аргументы функции. При использовании соглашения о~вызовах \lstinline!cdecl!
непосредственно за адресом возврата (по адресу $sp + 4$) будет находиться первый параметр,
% следующие 4 байта (т.\,е. 4 байта по адресу $\text{\ESP} + 4$) будут содержать первый параметр, 
% в четырёх байтах по адресу $\text{\ESP} + 8$ будет второй параметр
за ним идёт второй 
и~т.\,д. (рис.~\ref{ris:cdecl-stack})

\begin{illustration}
\resizebox{\approvedImageWidth}{!}{
\schemafont
\input{book/drawings/cdecl-stack}
}

\caption{Параметры и~адрес возврата в~соглашении cdecl}
\label{ris:cdecl-stack}
\end{illustration}%

Регистры $B, bp, si, di$ не~должны изменяться подпрограммой.
% 
Возврат значения по возможности выполняется через регистры:
\begin{itemize}
\item $eax$, если результат "--- указатель или целое число до 4 байт (если результат меньше 4~байт, старшую часть $eax$ необходимо обнулить);
\item пара регистров $edx:eax$, если результат "--- целое число размером 8~байт;
\item вершина стека сопроцессора, если результат "--- вещественное число;

если результат не помещается в~регистры, возвращается указатель на него (через $eax$).
\end{itemize}

На шестидесятичетырёхбитной платформе в~GCC для любых функций,
в~том числе внешних  с~отключённым декорированием  (\lstinline!extern "C"!),
используется соглашение, соответствующее операционной системе.


\subsection{Импорт функций из модулей на ассемблере}
\label{sec:gas-extern}

\epigraph{
% Итак, в~предыдущих главах вы узнали о~сути колдовства, секрете вечного счастья и~основных правилах техники безопасности. 
Вы представляете, какой жест при взмахе волшебной палочкой выглядит наиболее эффектно, куда~её~направлять в~начальной фазе ворожбы и~куда~прятаться, если она вдруг заработает.
}{Жвалевский/Мытько}

   
% \section{Подключение модуля на ассемблере к~C++-проекту}
% \index{Подключение модуля на ассемблере}
Функции, описанные в~ассемблерном модуле, необходимо описать в~коде C++ как внешние (\lstinline!extern!).
После спецификатора \lstinline!extern!, согласно стандарту C++, могут быть указаны строки \lstinline!"C++"! (подразумевается по умолчанию) или \lstinline!"C"! (различные компиляторы могут поддерживать и~иные строки) для указания компоновщику, какой язык использовался при написании внешней функции.
Конкретные свойства таких функций не описываются в~стандарте. На практике \lstinline!"C++"! подразумевает %декорирование (mangling) имён функций
искажение имён функций до неузнаваемости (что подробнее описано в~%предыдущем 
разделе~\ref{sec:mangling})
и~передачу параметров по возможности через регистры, что реализуется в~разных компиляторах по-разному.
% 
Указание \lstinline!"C"! %на практике
уменьшает искажение имён и~для тридцатидвухбитных платформ
подразумевает соглашение о~вызовах \lstinline!cdecl!.

Рассмотрим функцию $int~sqr(int~x)$, вычисляющую квадрат целого числа на тридцатидвухбитной платформе GNU/Linux~\cite{opennet.ru/base/dev/from_c_to_asm}.
% \lstset{language=[Motorola68k]Assembler}
Текст ассемблерного модуля \programname{sqr.S} с~текстом функции
% \footnote{
% Использованы материалы статьи Hiran Ramankutty «От C к~Ассемблеру», перевод: Андрей Киселев
% } 
% находится в~файле \programname{sqr.S} % (так как здесь нет необходимости в~препроцессинге, можно было использовать также имя \programname{sqr.s})
приведён в~листинге~\ref{lst:sqr.S}.

\index{Команды!ret}
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
.globl sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
\end{lstlisting}

Директива \lstinline!.globl! делает функцию   $sqr()$ видимой для внешних модулей.
В~следующей строке находится метка, показывающая начало этой функции.
% 
Команда \lstinline!movl 4(%esp), %eax! копирует (move) четыре байта (что обозначается суффиксом~$l$) из ячейки памяти, смещённой на четыре байта относительно вершины стека $sp$ (по адресу $sp + 4$), в~регистр~$A$. Следующая команда выполняет умножение $A ~{*}{=}~ A$.
Затем следует возврат из функции.



Функция $sqr()$ принимает единственный параметр $x$ типа $int$ (что для 32-битной платформы обычно эквивалентно 32-битному целому числу со знаком),
то есть этот параметр занимает четыре байта и~должен непосредственно следовать за адресом возврата (то есть находиться по адресу $sp+4$).
% т.\,е. четыре байта (что даёт суффикс \lstinline!l! "--- \lstinline!long! для команд) по адресу $sp + 4$ или, в~соответствии с~синтаксисом ассемблера GCC, \lstinline!4(%esp)!, будут содержать первый и~единственный параметр.

% Умножая  \EAX{} на \EAX, мы получаем квадрат аргумента в~регистре \EAX, 
После умножения результат %(квадрат аргумента)
$x^2$
находится в~регистре~$A$,
через который и нужно вернуть значение.
Таким образом, сразу после команды умножения можно выйти из функции командой \lstinline!ret!.

Если в~файле несколько функций, можно указать для отладчика их границы.
\begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S:endfunc]
.globl sqr
.func sqr
        sqr:
                movl 4(%esp), %eax
                imull %eax, %eax
                ret
.endfunc
\end{lstlisting}
Парные директивы .func  $\ldots$  .endfunc не влияют ни на что, кроме добавления некоторой отладочной информации при сборке в~отладочном режиме.
В~режиме Release игнорируются.

% В~шестидесятичетырёхбитном GNU/Linux  тип $int$ часто 32-битен
% $di$
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:sqr.S]
% .globl sqr
%         sqr:
%                 movl %edi, %eax
%                 imull %eax, %eax
%                 ret
% \end{lstlisting}

Основной файл \programname{main.cpp} содержит импорт функции как \lstinline!extern "C"! и её вызов
из головной функции $main()$.
% Функция \lstinline!sqr! может использоваться так же, как и~функция, описанная на языке C++ (кроме перегрузки).
\begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:main.cpp]
#include <iostream>

using namespace std;
extern "C" int sqr(int x);

int main()
{
    int x=2, y;
    y = sqr(x);
    cout << y <<endl;
    return 0;
}
\end{lstlisting}

Для импорта функции из другого объектного файла здесь она описана как внешняя (\lstinline!extern "C"!).
% 
В~GNU/Linux имена внешних C-функций не искажаются, поэтому в~модулях \programname{main.cpp} и~\programname{sqr.S}
используется одно и~то же имя~$sqr()$.





% \subsection{Импорт внешних функций в~подпрограмму на ассемблере}
\subsection{Импорт функций из модулей на C++ в~код на ассемблере}
% \subsection{Экспорт функций из C++}

\epigraph{
Если заклинание не сработало нужным образом, обратитесь к разработчику. Возможно, вы неправильно его активировали (заклинание, а~не~разработчика).
}{Жвалевский/Мытько}


Подпрограмма на ассемблере может обращаться не только к~другим подпрограммам из того же модуля на ассемблере, 
но и~к~внешним, в~частности, к~функциям, из других объектных файлов проекта или к~стандартной библиотеке stdlib.

Для того, чтобы функция, описанная на языке C++, была доступна для экспорта в~другие модули, используется ключевое слово extern, как и~для импорта внешних функций (для отключения декорирования также используется \lstinline!extern "C"!):
% \begin{lstlisting}
% /*@\colorbox{codestronghighlight}{extern "C"{}}@*/
% __attribute__((__cdecl__)) 
% int /*@\colorbox{codehighlight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
\begin{lstlisting}[caption=Файл \programname{bar.cpp}, label=lst:demangle:bar.cpp]
extern "C" int bar(int x)
{
    return 3*x+1;
};
\end{lstlisting}
% Декорирование C++-функций делает их имена неопознаваемыми, поэтому на практике при экспорте функций лучше использовать только "C" 
% Соглашение о~вызове на всякий случай указано явно с~использованием ключевого слова \lstinline!__attribute__!, но чаще всего для использования cdecl достаточно\lstinline!extern "C"!. 

Для импорта функции в~ассемблере не требуется никаких директив, достаточно знать её имя.
% \begin{lstlisting}
% pushl $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}

\index{Команды!push}
\index{Команды!call}
\begin{lstlisting}[caption=Фрагмент файла \programname{main.S}, label=lst:main.S]
pushl $1
call bar
add $4, %esp
\end{lstlisting}
Приведённый фрагмент кода рассчитывает $bar(1)$.

Команда \lstinline!call!, в~отличие от оператора вызова функции на ЯВУ, не позволяет передать параметры и~получить возвращаемое значение.
Она только помещает в~стек адрес следующей после вызова подпрограммы команда, а~затем передаёт управление на начало подпрограммы.

Таким образом, перед вызовом функции командой \lstinline$call$ параметры необходимо вручную поместить  туда, где их ожидает увидеть подпрограмма.
Для соглашения cdecl они должны находиться в~стеке. %, куда помещаются командой push 
% в~обратном порядке.
Соответственно, единицу нужно загрузить в~стек как четырёхбайтовое целое число, что и~делает команда \lstinline!pushl $1!.

После завершения работы такой функции параметры необходимо вручную удалить из стека;
для этого к~указателю стека добавляется размер параметров "--- четыре байта.

% 
Возвращаемое значение типа $int$ можно найти, в~соответствии с~соглашением о~вызове, в~регистре~$A$.

% Необходимо всегда помнить о~том, что после вызова функции значения многих регистров меняется.

Здесь также во всех модулях используется одно и~то же имя $bar$,
так как 
в~GNU/Linux имена внешних C-функций не искажаются.

При вызове программы с~несколькими параметрами необходимо помнить, что
в~соответствии с~соглашением cdecl они должны находиться в~стеке в~обратном порядке.
\begin{lstlisting}[caption={Вывод двух чисел на экран}, label=lst:demangle:printf]
fmt: .string "Переменные: %d, %d\n"
foo: .int 13
...
pushl foo	// Значение foo в стек
pushl $19	// Значение 19 в стек
pushl $fmt	// Адрес строки fmt в стек
call printf
addl $3*4, %esp // Три четырёхбайтовых числа из стека  
\end{lstlisting}
Приведённый код выведет на экран сообщение «Переменные: 19, 13».


\subsection{Искажение имён при компиляции}
\label{sec:mangling}
\epigraph{
"--* Как вы его зовете?

"--* Штырь.

"--* Ну и~имечко!

"--* А~что такое? Уменьшительное от Алджернон.
}{П.\,Г.\,Вудхауз}


Имена функций, задаваемые программистом, в~процессе компиляции искажаются;
наиболее заметные изменения связаны с~процессом \termin{декорирования} (name mangling).\index{Декорирование}
Механизм декорирования имён отсутствовал в~языке~C.
Язык C++, в~отличие от C, поддерживает перегрузку функций, то есть программа, написанная на C++, 
может содержать множество функций, носящих одно и~то же имя.
При этом на этапе компоновки для корректной сборки программы у~каждой функции должно быть уникальное имя.
Соответственно, на этапе компиляции в~имя каждой функции включается информация о~всех её параметрах (явных и~неявных),
причём так, что в~изменённом  имени используются только допустимые символы.

Алгоритм декорирования не стандартизирован;
различные компиляторы для различных платформ используют разные схемы.

Декорирование имён можно отключить вместе с~возможностью перегрузки,
объявив функцию  внешней C-функцией \lstinline!extern "C"!.
Большинство современных операционных систем вообще не искажает имён таких функций.
% но на некоторых платформах искажение имён 
В~Microsoft Windows к~имени функции даже при отключённом декорировании
может быть приписан префикс или суффикс.
Конкретный способ искажения зависит от разрядности, компилятора и~версии Windows.

Чаще всего в~Microsoft Windows при компиляции к~именам добавляется  префикс \lstinline!_! (ведущее нижнее подчёркивание).
Имена функций стандартной библиотеки stdlib  также подвергаются искажению (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).
На некоторых (но не на всех) 64-разрядных версиях Microsoft Windows при использовании GCC имена не искажаются.

Если имя функции искажается компилятором,
описанный в~предыдущих разделах код вызовет ошибку компоновки.


% Также \lstinline!extern "C"! подразумевает
% % \item 
% \emph{отсутствие декорирования имён,} % "--- имена функций воспринимаются линкером «как есть»
% % что позволяет не задумываться о~том, как имя, используемое линкером, складывается из имени, данного разработчиком и~характеристик аргументов функции,
% % но делает невозможной перегрузку таких функций.
% что  в~GNU/Linux значит, что имена не будут изменяться компилятором вообще;
% в~Microsoft Windows искажение имён зависит от разрядности, компилятора и~версии Windows.
% Чаще всего при компиляции к~именам добавляется  префикс \lstinline!_!



Если используемый компилятор для данной платформы изменяет имена внешних C-функций, %упоминаемых в~модулях C++, 
например, добавляет префикс \lstinline!_!, как в~случае gcc (mingw) под Microsoft Windows, то ссылка на внешнюю функцию %\lstinline!sqr! 
\lstinline!extern "C" int sqr(int x)!, упоминаемую в~некотором cpp-файле %к~моменту компоновки 
в~соответствующем объектном файле
будет выглядеть как \lstinline!_sqr!.
Таким образом, для корректной компоновки под Microsoft Windows имя данной функции в~объектном файле, полученном из ассемблерного модуля,  также должно быть \lstinline!_sqr!.
Так как на этапе ассемблирования имена не искажаются ни на какой платформе,
это означает, что в~ассемблерном модуле имя также должно выглядеть как  \lstinline!_sqr!.

При этом в~других операционных системах имена не искажаются,
так что для корректной компоновки в~GNU/Linux имя этой же функции должно выглядеть как \lstinline!sqr!.

Если речь идёт об импорте в~C++ функции, описанной на ассемблере, 
то в~ассемблерном файле можно указать оба варианта имени (листинг~\ref{lst:demangle:sqr:S}).
% \begin{lstlisting}[caption=Файл \programname{sqr.S}, label=lst:demangle:sqr:S]
% /*@\colorbox{clExportLight}{.globl sqr}@*/
% /*@\colorbox{clExportLight}{.globl \_sqr}@*/
% /*@\colorbox{clFuncnameLight}{sqr:}@*/
% /*@\colorbox{clFuncnameLight}{\_sqr:}@*/
%   movl 4(%esp), %eax
%   imull %eax, %eax
%   ret
% \end{lstlisting}
\begin{lstlisting}[caption=Файл \programname{sqr.S}: экспорт вариантов без искажения и~с~ним, label=lst:demangle:sqr:S]
.globl sqr
.globl _sqr
sqr:
_sqr:
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
В~этом случае код на C++  (листинг~\ref{lst:main.cpp}) соберётся с~модулем~\ref{lst:demangle:sqr:S} как под GNU/Linux или BSD,
так и~под Microsoft Windows,
но это не лучшее решение.
% \begin{lstlisting}[caption=Файл \programname{main.cpp}, label=lst:demangle:sqr:cpp]
% #include <iostream>
% 
% using namespace std;
% /*@\colorbox{clExportLight}{extern "C"{} int sqr(int x);}@*/
% 
% int main()
% {
%   cout << /*@\colorbox{clFuncnameLight}{sqr(2)}@*/ << endl;
%   return 0;
% }
% \end{lstlisting}




% \termin{декорирование} имён функций; таким образом, если остановить ключом \lstinline!-S! сборку после этого этапа, то в~полученном ассемблерном файле имена будут изменены компилятором.
% % Имена 
% % C++ искорёжены почти до неузнаваемости, C — у меня сохранены, а у вас, если статья Фога не ошибатеся, к ним приписывается префикс _: _Sqr вместо Sqr (и было бы __Sqr вместо _Sqr, но такой функции в C++-программе нет).
% В~декорированное имя C++-функции включается информация о~всех её параметрах (явных и~неявных).
% Имена C-функций изменяются более предсказуемо, так как для них не поддерживается перегрузка %(может быть добавлен префикс, суффикс или )
% (в~большинстве случаев имена не изменяются; на некоторых платформах к~ним может добавиться фиксированный префикс или суффикс).
% 
% Конкретный алгоритм декорирования зависит от компилятора, платформы и~указанного соглашения о~вызове.
% В~статье Агнера Фога 
% «Calling conventions for different C++ compilers and operating systems»~\cite{agner_fog_calling_conventions}
% приведено, в~числе прочего, описание алгоритмов декорирования наиболее популярных компиляторов.
% В~частности, имена C-функций при компиляции gcc на платформах GNU/Linux и~BSD не изменяются вообще. 
% На 32-разрядной платформе Microsoft Windows имена C-функций при компиляции приобретают дополнительное ведущее подчёркивание (то есть \lstinline!printf! преобразуется  в~\lstinline!_printf!).






В~случае импорта в~программу на ассемблере функции из модуля на C++, в~частности, % одной из функций stdlib
% или 
функции $int~bar(int~x)$, описанной в~листинге~\ref{lst:demangle:bar.cpp},
уже невозможно описать два имени одновременно.
% \begin{lstlisting}[caption=Файл \programname{unit.cpp}, label=lst:demangle:unit:cpp]
% /*@\colorbox{clExportLight}{extern "C"{}}@*/ int /*@\colorbox{clFuncnameLight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
Вызов подобной функции из программы на ассемблере
будет выглядеть как \lstinline!call bar! под GNU/Linux или BSD и~как~\lstinline!call _bar! под тридцатидвухбитными и~некоторыми шестидесятичетырёхбитными версиями  Microsoft Windows.

Как правило, программа  вызывает 
% функции, импортированные из  модулей на C++, и~функции stdlib
% не в~одном месте, 
подобные функции из множества мест,
так что править её вручную затруднительно.

% Можно описать два варианта вызова с~помощью директив условной компиляции.
% Определим макрос-флаг \lstinline!#define ISPREFIX!, если имена искажаются 
% \begin{lstlisting}[caption=Фрагмент файла \programname{main.S}, label=lst:main.S]
% #ifdef ISPREFIX
% call _bar
% #else
% call bar
% #endif\end{lstlisting}

% 
% Фрагмент main.S (GNU/Linux, BSD)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}
% 
% Фрагмент main.S (MS Windows)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{\_bar}@*/
% addl $4, %esp
% \end{lstlisting}

Кроссплатформенности в~этом случае можно достичь использованием макросов для искажения имён в~\programname{.S}-файле вручную.
Опишем макрос~\lstinline!FUNC_NAME! с~параметром $s$ "--- именем функции, который либо добавляет к~$s$ ведущее подчёркивание
(тогда его нужно описать как~\lstinline!#define FUNC_NAME(s) _##s!),
либо ничего с~$s$ не делает (\lstinline!#define FUNC_NAME(s) s!)
и~вместо имени функции, например, $bar$, будем указывать \lstinline!FUNC_NAME(bar)!.

% В~этом случае для переноса с~GNU/Linux на Microsoft Windows в~случае 32-разрядных систем достаточно будет закомментировать 
% 
% для искажающих имена версий Microsoft Windows и~как~ для остальных операционных систем,
% будет преобразовывать имена в~необходимый вид.
% В~этом случае при переносе программы %с~GNU/Linux на 
% достаточно будет изменить описание макроса, чтобы
% вызов~\lstinline!call FUNC_NAME(bar)! или~\lstinline!call FUNC_NAME(printf)! всегда был корректным.

В~случае тридцатидвухбитных систем подчёркивание необходимо добавлять при работе под  Microsoft Windows
и~не нужно для остальных операционных систем.
Для этого можно воспользоваться предопределённым макросом препроцессора~\lstinline!_WIN32!:
\begin{lstlisting}
#ifdef _WIN32
#define FUNC_NAME(s) _##s
#else
#define FUNC_NAME(s) s
#endif 
\end{lstlisting}
Данное определение можно поместить в~начало ассемблерного файла с~расширением~\programname{.S}
или в~файл, включаемый в~него директивой \lstinline!#include!. %, так как 

После этого макрос~\lstinline!FUNC_NAME! можно применять для искажения имён во всех случаях
"--- при экспорте имени функции:
\begin{lstlisting}[caption=Файл \programname{sqr.S}: кроссплатформенный экспорт, label=lst:demangle:sqr:S:FUNC_NAME]
.globl FUNC_NAME(sqr)
FUNC_NAME(sqr):
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}
при импорте:
\begin{lstlisting}[caption=Фрагмент файла \programname{main.S}: кроссплатформенный импорт, label=lst:demangle:main.S:FUNC_NAME]
pushl $1
call FUNC_NAME(bar)
add $4, %esp
\end{lstlisting}
или при вызове библиотечных функций:
\begin{lstlisting}[caption={Вывод двух чисел на экран}, label=lst:demangle:printfS:FUNC_NAME]
pushl foo	// Значение foo в стек
pushl $19	// Значение 19 в стек
pushl $fmt	// Адрес строки fmt в стек
call FUNC_NAME(printf)
addl $3*4, %esp // Три четырёхбайтовых числа из стека  
\end{lstlisting}

Шестидесятичетырёхбитный перенос функций из GNU/Linux в~Microsoft Windows или наоборот сложнее.
Во-первых, не все шестидесятичетырёхбитные версии Microsoft Windows искажают имена, так что нужный вариант макроса \lstinline!FUNC_NAME!, возможно, придётся выбирать вручную.
Во-вторых,
если на тридцатидвухбитных платформах для внешних C-функций использовалось соглашение cdecl, 
то здесь 
% в~шестидесятичетырёхбитных платформах используются разные
соглашения для разных операционных систем разные, 
так что для достижения кроссплатформенности придётся 
описать два варианта копирования параметров из регистров,
воспользовавшись директивами условной компиляции.

% В~дальнейшем все примеры будут рассматриваться без учёта искажения имён.

\section{Ассемблерные вставки в~код C++}
\label{sec:asm-inline}
\epigraph{\begin{limerick}
Одна дама, живущая в~гавани,\\
возмечтала отправиться в~плаванье,\\
Но когда на дубу\\
поглядела в~трубу,\\
То решила "--- спокойнее в~гавани.\\
\end{limerick}
}
{\Lear}



Для вставки одной или нескольких инструкций ассемблера используется ключевое слово \lstinline!asm!~\cite{isocpp,gcc-inline-asm, agner_fog_optimizing_assembly}.
% 
% В~разделе 
%  [dcl.asm]
%  стандарта C++ сказано
% «An asm declaration has the form
% asm-definition:
% \lstinline!asm ( string-literal ) ;!
% The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
% is used to pass information through the implementation to an assembler. — end note ]»

Стандарт C++ описывает %синтаксис ассемблерной вставки как
использование  \lstinline!asm! следующим образом:
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}
% содержимое круглых скобок 
конкретный вид \lstinline!string-literal! 
при этом не регламентируется.
% \lstinline!asm("assembly code");!
% 
Обычно такие вставки используются для передачи кода непосредственно ассемблеру.


% Так как ассемблерный код  не стандартизирован, синтаксис 
% Синтаксис 
Содержимое
таких вставок зависит как от архитектуры целевого аппаратного обеспечения (набор команд, регистров и~т.\,д.), так и~от компилятора (мнемоники команд, порядок операндов, синтаксис и~т.\,д.).

Используемая операционная система определяет {только} обращения \emph{непосредственно к~интерфейсам операционной системы} (системные вызовы Linux и~BSD, функции API Windows~т.\,п.).
% Если не использовать напрямую интерфейсы операционной системы, 
% а~вызывать, например, функции стандартной библиотеки С/С++, методы Qt или функции, описанные в~C/C++ части проекта, ассемблерная вставка будет работать под любой операционной системой, где есть нужный компилятор (и~Qt).
% http://www.linux.org.ru/forum/development/11701125
% вставка будет собираться и~работать под любой  операционной системой. 
Вычисления, а~также обращение к~стандартной библиотеке С или к~кроссплатформенным библиотекам типа Qt описываются одинаково под любой операционной системой.





\subsection{Синтаксис ассемблерных вставок в~GCC}
\epigraph{\begin{limerick}
Жил известный профессор в~Найроби\\
Изучавший науки в чащобе.\\
Там под шелест синиц\\
Он читал пять страниц\\
И опять возвращался в Найроби. \\
\end{limerick}
}
{\Lear}


Ассемблерная вставка в~программу, собираемую компилятором GCC, может быть описана с~использованием двух ключевых слов: \lstinline!asm!  либо \lstinline!__asm__!~\cite{sysbin.com/files/lowlevel/gcc_inline_assembly.htm,ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html}. 
% ru.wikibooks.org/wiki
Эти формы равнозначны и~используют одинаковый синтаксис. Форма \lstinline!__asm__! применяется, когда стандартное ключевое слово \lstinline!asm! конфликтует с~чем-либо в~программе.

\subsubsection{Базовая форма}
Базовая форма ассемблерной вставки выглядит следующим образом.

\begin{lstlisting}[style=lstsmall, caption=Базовая форма вставки]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    );
\end{lstlisting}

Ключевое слово volatile для базовой формы не оказывает никакого эффекта, так как такая вставка не оптимизируется компилятором никогда.

Например:
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX = ECX
\end{lstlisting}
или
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX = BH (байт)
\end{lstlisting}
Если код во вставке содержит более одной строки, то каждая строка помещается в~кавычки. 
Тем не менее, этого недостаточно для разделения инструкций.

\subsubsection{Разделение инструкций}

% Несколько 
При компиляции соседние строки ассемблерной вставки склеиваются, как склеиваются части любой строковой константы "--- точно так же, как в~объявлении вида
\begin{lstlisting}
    char *s = "abcd"
        "ABCD";
\end{lstlisting}
которое задаёт строку \lstinline!"abcdABCD"!, не разделённую посередине никаким символом.
То есть вставка
\begin{lstlisting}
asm ("movl %eax, %ebx"
     "movl $56, %esi");
\end{lstlisting}
На самом деле выглядит как
\begin{lstlisting}
asm ("movl %eax, %ebxmovl $56, %esi");
\end{lstlisting}
и~вызывает логичное сообщение о некорректном имени регистра «ebxmovl».

Таким образом, если во вставке необходимо использовать более одной инструкции, то  
в~конце каждой строки необходимо поместить суффикс \lstinline!\n! для разделения инструкций (если желательно иметь красивый выходной файл, можно использовать суффикс  \lstinline!\n\t!, если форматирование выходного файла безразлично "--- можно использовать вместо  \lstinline!\n! разделитель \lstinline";").
% \lstinline!\n\t!, чтобы сформированный компилятором ассемблерный файл был корректно отформатирован.
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movb %ah, (%ebx)");
\end{lstlisting}

\subsubsection{Доступные в~базовой форме вставки имена}

Внутри ассемблерной вставки можно обращаться по именам к~регистрам, а~также к~глобальным %и~статическим (то есть имеющим фиксированный адрес) <- не получается 
переменным программы (листинг~\ref{lst:rel:inline-basic-global}).

\begin{lstlisting}[caption=Увеличение глобальной переменной $n$, label=lst:rel:inline-basic-global]
int n = 12;

int main(){
    asm ("incl n");
    cout << n <<endl;
    return 0;
}
\end{lstlisting}
% Параметры функций 
Локальные переменные функций размещаются компилятором в~стеке (причём не всегда в~порядке объявления), поэтому к~ним необходимо обращаться, используя \emph{расширенный ассемблер GCC,} а~именно \termin{параметры вставок.}
Необходимо также учитывать, что в~регистрах, используемых во вставке, ранее компилятором могла быть размещена какая-либо регистровая переменная.
В~этом случае компилятор не определяет автоматически, что регистр изменён, что может привести к~краху программы.

\warning{
На практике описанную выше базовую форму ассемблерных вставок \mbox{(без параметров)} не стоит использовать \emph{никогда}.

Только расширенная форма даёт возможность корректного взаимодействия с~программой на ЯВУ.
}
% Вставка "--- не функция.

% \subsection{Передача параметров в~ассемблерную вставку}
\subsection{Расширенная форма} %http://www.gamedev.ru/code/articles/gcc_inline_asm?page=3
\epigraph{\begin{limerick}
Старичок из далёкого Таллинна\\
О~египетских грезил разваллинах.\\
Он до пальмы добрался,\\
Он на пальму забрался,\\
И~ему хорошо и~без Таллинна.\\
\end{limerick}
}
{\Lear}


% http://www.ibm.com/developerworks/ru/library/l-linux_kernel_15/index.html
Синтаксис  вставки (расширенный) в~GCC может иметь две формы.

Первая выглядит следующим образом (листинг~\ref{lst:rel:inline-ext-params}).

\begin{lstlisting}[style=lstsmall, caption=Расширенная форма с~выходными параметрами, label=lst:rel:inline-ext-params]
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}

% Ключевое слово const используется в~случае, когда выходные параметры зависят только от входных, что позволяет, в~частности, вынести блок за тело цикла при оптимизации.
% Один из случаев, когда const нельзя использовать "--- когда один из входных параметров интерпретируется как указатель. Значение по данному адресу может измениться, даже если сам адрес неизменен.

Ключевое слово volatile  
используется для того, чтобы указать компилятору, что вставляемый ассемблерный код может обладать побочными эффектами, поэтому попытки оптимизации могут привести к логическим ошибкам.
% В~частности, если необходимо не менять вставку местами с~дрк
% запрещает компилятору оптимизировать блок и~указывает вставить его как есть.

Вторая форма расширенной ассемблерной вставки имеет вид, приведённый в~листинге~\ref{lst:rel:inline-ext-goto}.

\begin{lstlisting}[style=lstsmall, caption=Расширенная форма с~метками выхода, label=lst:rel:inline-ext-goto]
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  

Ключевое слово goto указывает, что ассемблерный код может делать переходы на метки, перечисленные в~соответствующем разделе.

Обращение к~параметру-метке предваряется префиксом \lstinline!%l! (от \emph{label}), за которым идёт порядковый номер метки в~списке всех параметров; псевдоним для метки указать нельзя.
В~частности, данный код переходит к~метке \lstinline!carry:! (и~функция возвращает~1), если в~числе~$p1$ взведён бит с~номером~$p2$ (младший бит имеет нулевой номер).

\begin{lstlisting}[style=lstsmall, caption=Переход к~метке carry по значению бита]
asm goto (
    "btl %[BitIdx], %[Val]\n\t"
    "jc %l2"
    :: [Val]"r" (p1), [BitIdx]"r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда \texttt{bt}  копирует бит, номер которого передается вторым параметром, в~флаг $CF$.
Затем происходит условный переход на метку~\texttt{label:} в~том случае, если  флаг~$CF$ взведён.

% http://sysbin.com/files/lowlevel/gcc_inline_assembly.htm

Параметры указываются как \lstinline!%0!, \lstinline!%1! и~т.\,д. или как \lstinline!%[Value]!, где Value "--- определённый в~разделе %выходных 
параметров псевдоним (если параметр соответствует какой-либо переменной ЯВУ, то псевдоним может как совпадать, так и~не совпадать с~именем этой переменной).
% Примечание:е
% Если в коде указаны параметры, которые, как и регистры, начинаются с префикса \lstinline'%', то 
Чтобы избежать конфликтов с~именами регистров,
регистры во вставке с~расширенным синтаксисом указываются с префиксом \lstinline'%%', например, \lstinline!%%eax!.

Общее количество параметров ограничено: $input + output + goto \leqslant 30$.


\subsubsection{Выходные параметры}

Раздел выходных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

% https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands
Описание выходного параметра
в~общем случае имеет вид~\cite{gcc.gnu.org/onlinedocs/gcc}:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cvariablename)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда.
Область определения такого псевдонима "--- вся ассемблерная вставка.
Псевдоним может быть любым допустимым идентификатором C++.
Два разных операнда не могут использовать один псевдоним.

Псевдоним выходного параметра может быть указан как ограничение расположения входного.
В этом случае параметр с~данным псевдонимом является входным и~выходным одновременно (как правило, это изменяемая во вставке переменная).

Если псевдоним не определён, используются номер операнда, начиная с~нуля: \lstinline!%0! для первого, \lstinline!%1! для второго и~т.\,д.
% \begin{lstlisting}[style=lstsmall]
% int x;
% asm
% (
%     "movl $12, %[x]\n"
%     :[x]"=rm"(x)
% );
% \end{lstlisting}

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для выходного параметра начинается с~символа \lstinline!=! (если значение параметра перезаписывается) %, после которого 
или \lstinline!+! (если значение параметра используется как для чтения, так и~для записи).

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

При выборе регистра для размещения выходного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++ (lvalue), куда будет записано значение выходного параметра (обычно имя переменной).

Если для выходного параметра указано размещение в~регистре и~имя соответствующей переменной, это не значит, что переменная обязательно будет размещена в~регистре.
Возможно, в~регистре будет сформировано выходное значение, которое затем будет скопировано в~локальную стековую переменную.

\end{description}
Например, данный фрагмент записывает константу 12 в~переменную~$x$.
\begin{lstlisting}[style=lstsmall, caption=Перезапись выходного параметра]
int x;
asm
(
    "movl $12, %[x]\n"
    :[x]"=rm"(x)
);
\end{lstlisting}
начальное значение параметра \lstinline![x]! не определено.

Следующий фрагмент кода удваивает~$x$:
\begin{lstlisting}[style=lstsmall, caption=Модификация выходного параметра]
asm
(
    "addl %[x], %[x]\n"
    :[x]"+r"(x)
);
\end{lstlisting}
Символ  \lstinline!+! в~строке расположения указывает на то, что данный параметр является не чисто выходным, а~модифицируемым.
Начальное значение параметра \lstinline![x]! берётся из~выражения-приёмника, в~данном случае "--- переменной~$x$.
% Если бы ограничение расположения начиналось бы с~\lstinline!=!, начальное значение параметра было бы не определено.

\subsubsection{Входные параметры}

Раздел входных параметров состоит из описаний отдельных параметров (операндов), разделённых запятыми.

Описание входного параметра в~общем случае:
\begin{lstlisting}[style=lstsmall]
     [ [asmSymbolicName] ] constraint (cexpression)
\end{lstlisting}
где
\begin{description}
\item[asmSymbolicName]
определяет псевдоним для операнда, аналогично псевдонимам выходных параметров.

Если псевдоним не определён, используются номер операнда, начиная со следующего за последним выходным параметром.
Если есть два выходных параметра, то первый входной будет обозначен \lstinline!%2! и~т.\,д.

\item[constraint]
строковая константа, описывающая ограничения на расположение операнда.

Для входного параметра не может начинаться ни с~\lstinline!=!, ни с~\lstinline!+!.

После префикса указывается одно или более ограничение. 
Чаще всего используются ограничения \lstinline!r! (выходной параметр размещается в~регистре) и~\lstinline!m! (выходной параметр размещается в~памяти).
Если указано несколько вариантов размещения, компилятор выбирает наиболее эффективный.

Если входной параметр должен располагаться там же, где один из выходных,
расположение также может быть указано цифрой или псевдонимом данного выходного параметра.

При выборе регистра для размещения входного параметра компилятор не рассматривает регистры из списка перезаписываемых. 

\item[cvariablename]
"--- выражение C++, откуда берётся значение входного параметра (также может быть именем переменной).

\end{description}

Например, конструкция:
\begin{lstlisting}[style=lstsmall]
asm ("movl %0, %%eax"::"i"(1) : "%eax");
\end{lstlisting}
превратится после компиляции %в~ассемблерном коде 
в:
\begin{lstlisting}[style=lstsmall]
movl $1, %eax
\end{lstlisting}

Данный фрагмент эквивалентен \lstinline!foo += bar!:
\begin{lstlisting}[style=lstsmall]
int foo = 6, bar = 12;
asm ("addl %[bar], %[foo]"
    : [foo]"+r"(foo)
    : [bar]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
причём, если переменная foo не располагается в~регистре изначально, её значение будет скопировано в~регистр, а~после добавления bar результат будет скопирован обратно в~foo.


\subsubsection{Перезаписываемые элементы}

% %
% \footnote{Использованы материалы:
% {https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\#Clobbers}%,
% % {https://ru.wikipedia.org/wiki/GCC\_Inline_Assembly#.C2.ABmemory.C2.BB\_.D0.B2\_clobber\_list}
% }
Код в~ассемблерной вставке может прямо или косвенно изменять значения не только выходных параметров, но и прочих регистров.
Эти регистры перечисляются в~списке перезаписываемых (clobber) регистров~\cite{gcc.gnu.org/onlinedocs/gcc}.

В~частности, команда умножения в~своей классической форме (\lstinline!%eax = %eax*src!) записывает старшую часть произведения в~\lstinline"%edx".
\begin{lstlisting}[style=lstsmall, caption=Неявно перезаписываемый регистр]
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}

Если во вставке явно модифицируется какой-либо регистр (что не рекомендуется; в~случае, если нужен регистр для хранения временного значения, лучше объявить фиктивный входной параметр, как описано в~следующем подразделе), его также необходимо указать в~списке перезаписываемых элементов.
% \hyperref[sss:inline:tmpreg]{qq}
% \pagebreak[3]
% 
\begin{lstlisting}[caption=Явно перезаписываемый регистр]
asm ("movl %[One], %%eax"    
  ::[One]"i"(1)  
  : "%eax");	// movl $1, %eax
\end{lstlisting}
\pagebreak[3]

Неуказание таких регистров в~списке перезаписываемых, скорее всего, приведёт к~тому, что компилятор поместит один из параметров вставки или переменных ЯВУ в~этот же регистр и,~соответственно, к~непредсказуемому значению в~нём. 

Специальные аргументы для списка перезаписываемых регистров:
\begin{description}
\item["cc"]
показывает, что код изменяет регистр флагов.

Флаги изменяют все арифметические инструкции.


\begin{lstlisting}[style=lstsmall, caption=Перезапись флагов]
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}



\item["memory"]
показывает, что код меняет значение в~памяти (не считая явно указанных выходных параметров) "--- например, интерпретирует какой-либо из параметров как указатель.

\begin{lstlisting}[style=lstsmall, caption=Перезапись памяти по указателю]
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}


% Помимо простого указания компилятору, что ассемблерная вставка изменяет содержимое памяти, она ещё служит директивой Memory Barrier для компилятора. Это означает, что те операции обращений в память, которые стоят выше по коду, в результирующем машинном коде будут выполняться до тех, которые стоят ниже ассемблерной вставки. В случае многопоточной среды, когда от этого напрямую зависит риск возникновения race condition, это обстоятельство является существенным.

% Кроме указания компилятору на изменение памяти,
% барьер компилятора

При указании \lstinline!"memory"! в~списке перезаписываемых элементов все операции работы с~памятью, которые были в~программе до ассемблерной вставки, выполнятся до неё, а~те, что стоят в~программе после "--- будут после.
В~противном случае компилятор может поменять местами как операторы C++, так и~ассемблерные вставки.
\end{description}


\subsection{Практическое использование параметров}
\epigraph{\begin{limerick}
    Жил-был старичок у причала,\\
    Которого жизнь удручала.\\
    Ему дали салату\\
    И сыграли сонату,\\
    И немного ему полегчало.\\
\end{limerick}
}
{\Lear}


\subsubsection{Временные регистры}

% \footnote{Использованы материалы:
% {http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}
% }
% \labellocal{sss::tmpreg}
% \label{sss:inline:tmpreg}

Использовать под временные данные фиксированные регистры и~указывать их в~списке  перезаписываемых не вполне корректно~\cite{osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm}.

Более правильным будет ввести фиктивный выходной параметр, размещаемый в~регистре (\lstinline!=r! или \lstinline!=&r!, либо более конкретное ограничение "--- подробнее указано в~разделе \ref{sec:Constraints}), так как это даст компилятору больше свободы при оптимизации.

В~тексте вставки можно использовать данный параметр для хранения произвольных временных данных.

% Так, в~программе 
% \begin{lstlisting}[style=lstsmall]
% int main()
% {
%     int a=77, b;
%     asm("movl %0, %%eax"::"d"(a));
%     asm("movl %%eax, %0":"=d"(b));
%     cout << b;
%     return 0;
% }
% \end{lstlisting}
% первая вставка записывает значение локальной переменной \lstinline!a! через регистр \EDX{} (\lstinline!"d"!) в~регистр \EAX;
% вторая "--- содержимое регистра \EAX{} записывает через регистр \EDX{} в~переменную \lstinline!b! (\lstinline!"=d"(b)!).
% То есть если вставки сохранят порядок после компиляции (что не гарантируется), программа копирует содержимое локальной переменной \lstinline!a! (77) в~локальную переменную \lstinline!b!, и~последующий оператор вывода выведет 77. 

Пересылка через временный регистр:
\begin{lstlisting}[style=lstsmall, caption=Фиктивный выходной параметр как временный регистр]
int src = 1, dst, tmp;
asm
(
    "movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);
\end{lstlisting}


\subsubsection{Модификация входных параметров}

Модифицировать входные параметры, не являющиеся одновременно и~выходными, \termin{нельзя}.

Если возникает необходимость изменить значение, переданное как входной параметр, оно должно быть описано ещё и~как выходной.


Рассмотрим код, который увеличивает переменную $foo$ на значение переменной $bar$.
В~данном случае $bar$ может быть только входным параметром, а~$foo$ "--- модифицируемым, то есть  одновременно и~входным, и~выходным.

В~следующем фрагменте неименованный параметр \lstinline!%0! является входным и~выходным одновременно (точнее, входной параметр \lstinline!%1! располагается там же, где и~выходной \lstinline!%0!).
Это определяется ограничением размещения входного параметра \lstinline!%1! "--- %вместо  ограничений 
там указан номер параметра \lstinline!%0!.
\begin{lstlisting}[style=lstsmall]
asm ("addl %2, %0"
    : "=r" (foo)
    : "0" (foo), "g" (bar)
    : "cc"
); // foo += bar
\end{lstlisting}
Аналогичные вычисления с~использованием именованных параметров (\lstinline![S]! здесь "--- %и~входной и~выходной параметр
выходной параметр в~регистре, и~в~том же регистре расположен неименованный входной параметр) выглядят следующим образом.
% \begin{lstlisting}[style=lstsmall]
% asm("addl %[A], %[X]\n"
%     : [X]"=r"(foo)
%     :"[X]"(foo), [A]"g" (bar)
%     :"cc"
% ); // foo += bar
% \end{lstlisting}
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
); // foo += bar
\end{lstlisting}
% Используя \lstinline![S]! как приёмник сложения, мы фактически модифицируем неименованный выходной параметр \lstinline!%1!
Мы используем  неименованный выходной параметр \lstinline!%1!, чтобы задать начальное значение входному~\lstinline![S]!.
В данном случае (входной параметр инициализируется исходным значением $foo$ "--- приёмника совмещённого с~ним выходного параметра~\lstinline![S]!) можно было и~не вводить дополнительный входной параметр, а~заменить описание% %ограничение расположения
~\lstinline![S]! на~\lstinline![S]"+r" (foo)!.


Описание параметра как выходного и~входного одновременно (точнее, однорасположенной пары параметров <<выходной-входной>>), в~частности, делает параметр сохраняющим предсказуемое значение на всём протяжении вставки.
Если такой параметр размещается в~регистре, никакой другой параметр данной вставки не будет помещён в~этот регистр.

Отличие такого описания параметра от выходного с~начальным значением (расположение которого начинается с~\lstinline!+!) "--- то, что источник начального значения  может отличаться от исходного значения назначения.
Так, следующий фрагмент кода устанавливает начальное значение параметра-регистра \lstinline![S]! нулём, а~значение этого регистра после завершения вставки записывается в~переменную~$foo$:
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}
% Если для инициализации выходного параметра не требуется значение, отличное от~исходного значения его приёмника,

Также для входного параметра, расположенного на месте выходного, можно задать отдельный псевдоним. %, так как %, в~отличие от 
\begin{lstlisting}[style=lstsmall]
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : [S_initial_value]"[S]"(0), [A]"g"(bar)
    : "cc"
); // foo = 0 + bar
\end{lstlisting}


\subsubsection{Конфликт выходных и~входных долгоживущих параметров}

При размещении параметров в~регистрах компилятор считает, что входные параметры используются в~начале вставки, а~выходные "--- в~конце, \emph{после} использования всех входных.
Соответственно, <<только входные>> параметры часто располагаются в~тех же регистрах, что и~<<только выходные>>, чтобы освободить максимальное количество регистров для других переменных.

Это может привести к~конфликту, если какой-либо входной параметр используется в~конце вставки, после присваивания хотя бы одного из выходных параметров.
При размещении этих двух параметров в~одном регистре присваивание уничтожит оригинальное значение входного параметра.

В частности, данный фрагмент (вычисляющий $y = \left\{\begin{array}{ll}
1, & x \geqslant 0 \\
0, & x < 0 \\
\end{array}\right.$) в~случае размещения входного параметра \lstinline![Zero]! и~выходного \lstinline![y]! в~одном регистре работает некорректно ($y$ всегда равен $1$, так как инициализация выходного параметра  \lstinline![y]! единицей выполняется до чтения  входного параметра \lstinline![Zero]!, и~в~момент условного присваивания \lstinline!cmovll %[Zero], %[y]! регистр, где расположены оба этих параметра, равен $1$).
\begin{lstlisting}[style=lstsmall, caption=Параметр $y$ конфликтует с~$Zero$]
int x = 10, y;
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
); // y = 1 независимо от x
\end{lstlisting}
Это можно исправить, объявив \lstinline![y]! выходным параметром с~начальным значением (\lstinline!+! вместо \lstinline!=! в~расположении), хотя нам и~не требуется исходное значение переменной~$y$.
Такое ограничение не позволит компилятору совместить  какой-либо входной параметр с~\lstinline![y]!.
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"+r"(y)
  :[x]"rm" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
% 
Другой способ "--- явно указать, какой входной параметр следует расположить на месте выходного~\lstinline![y]!.
Здесь мы можем совместить с~\lstinline![y]! входной \lstinline![x]!, так как последнее чтение~\lstinline![x]! (сравнение \lstinline![x]! с~нулём) выполняется до инициализации~\lstinline![y]!:
\begin{lstlisting}[style=lstsmall]
asm
(
  "cmpl $0, %[x]\n"
  "movl $1, %[y]\n"
  "cmovll %[Zero], %[y]\n"
  :[y]"=r"(y)
  :[x]"[y]" (x), [Zero]"rm"(0)
  : "cc"
);
\end{lstlisting}
Оба этих способа позволяют разрешить конфликт и~получить корректное значение~$y$.
% $y = \left\{\begin{array}{ll}
% 1, & x \geqslant 0 \\
% 0, & x < 0 \\
% \end{array}\right.$

\subsection{%Типы размещения параметров% 
Ограничения на расположение операнда}
\label{sec:Constraints}
\epigraph{\begin{limerick}
    Некий доктор, раскрыв свой баул, \\
    Попросил: «Принесите мне стул».\\
    В тот же миг эскулапу\\
    Принесли его шляпу\\
    И сказали: «Чем \emph{это} не стул?»\\
\end{limerick}
}
{\Lear}
% \footnote{Использованы материалы:
% {https://gcc.gnu.org/onlinedocs/gcc/Constraints.html\#Constraints}
% }

% https://gcc.gnu.org/ml/gcc/1999-10n/msg00488.html
% Типы параметров:
Некоторые общие ограничения (типы размещения параметров)~\cite{gcc.gnu.org/onlinedocs/gcc}:
\begin{description}
\item[r] "--- регистр; %- register
\item[m] "--- память; %- memory effective address
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); %- immediate value, 0..0xffffffff
\item[g] "--- память, регистр общего назначения или непосредственное значение (обычно этот тип эквивалентен \lstinline"rim"); %- general effective address
\item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
\end{description}

% But there are some i386-specific ones described in the processor-specific
% part of the manual and in more detail in GCC's i386.h:
Некоторые ограничения (типы), специфичные для i386 (определены в~файле i386.h GCC)
\begin{description}
% \item[q] "--- регистр, который можно адресовать по байтам младшего слова (EAX, EBX, ECX, EDX); %- byte-addressable register (eax, ebx, ecx, edx)
% \item[A] "--- пара регистров  EDX:EAX;
\item[q] "--- регистр, который можно адресовать по байтам младшего слова ($A, B, C, D$); %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров $D:A$;
\item[a, b, c, d, S, D] "--- регистры %eax, ebx, ecx, edx, esi, edi 
$A, B, C, D, si, di$ соответственно;

\item[I..P] "--- машинно-зависимые ограничения для констант:
% \end{description}
% 
% Ограничения для констант:
% \begin{description}
% \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% %     ("i" would allow an address known only at link time)
\begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% \item[K] "--- Signed 8-bit integer constant. ?  255
% \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (сдвиги, которые может выполнить \lstinline!lea!);
\index{Команды!lea}

\item[N] "--- непосредственное значение в~диапазоне 0..255 (беззнаковое однобайтовое).
% \item[O] "--- непосредственное значение в~диапазоне 0..32
\end{description}
\end{description}


\subsection{Модификаторы параметров}
\epigraph{\begin{limerick}
Осмотрительный старец из Кёльна \\
    Отвечал на расспросы окольно.\\
    На вопрос: «Вы здоровы?»\\
    Говорил он: «А кто вы?» "---\\
    Подозрительный старец из Кёльна.\\
\end{limerick}
}
{\Lear}

\newcommand{\moddesc}[1]{\textbf{#1}}

Иногда в~коде программы требуется подставить не  значение параметра в~неизменённом виде, а~какую-либо его характеристику.
В~этом случае необходимо использовать так называемые модификаторы параметров (таблица~\ref{tab:inline-par-modifiers}).

\begin{table}[!ht]
\caption{Модификаторы параметров ассемблерных вставок GCC}
\label{tab:inline-par-modifiers}

\begin{tabularx}{\linewidth}{|>{\bfseries}c|L|}
\hline
\thead{Модификатор} & \thead{Действие} \\\hline
z & Печать суффикса команды для размера операнда \\\hline
c & Печать константы без префикса \lstinline!$! \\\hline
b & Печать имени младшего байта регистра 
\mbox{(\lstinline!\%al! для регистра $A$)}
\\
h & Печать имени старшего байта младшего слова регистра \mbox{(\lstinline!\%ah! для регистра $A$)} \\
w & Печать имени младшего слова регистра \mbox{(\lstinline!\%ax! для регистра $A$)} \\
k & Печать имени младшего двойного слова регистра \mbox{(\lstinline!\%eax! для регистра $A$)} \\
q & Печать 64-битного варианта имени регистра \mbox{(\lstinline!\%rax! для регистра $A$)}\\\hline
\end{tabularx}
\end{table}

% Modifier 	Description 	Operand 	masm=att 	masm=intel
% z 	Print the opcode suffix for the size of the current integer operand (one of b/w/l/q). 	%z0 	l 	
% b 	Print the QImode name of the register. 	%b0 	%al 	al
% h 	Print the QImode name for a “high” register. 	%h0 	%ah 	ah
% w 	Print the HImode name of the register. 	%w0 	%ax 	ax
% k 	Print the SImode name of the register. 	%k0 	%eax 	eax
% q 	Print the DImode name of the register. 	%q0 	%rax 	rax
% l 	Print the label name with no punctuation. 	%l2 	.L2 	.L2
% c 	Require a constant operand and print the constant expression with no punctuation. 	%c1 	2 	

Модификатор указывается между префиксом \lstinline!%! и~именем параметра.

В~частности, при инициализации параметра~\lstinline![dmem]!, находящегося в~памяти, необходимо указать  размер приёмника.
В~GCC это делается при помощи суффикса размера (раздел~\ref{sec:att-suffixes}).
Явное указание суффикса сделает программу неустойчивой к~изменению типа переменной, передающейся как~\lstinline![dmem]!.
Если суффикс указан с~помощью модификатора \lstinline!z!:
\begin{lstlisting}[numbers=none]
"mov%z[dmem] $0, %[dmem]\n"
\end{lstlisting}
данная команда будет корректно инициализировать переменную как~типа~$short$, так и~$int$ или~$long~long$.

Печать константы без префикса \lstinline!$! необходима, если эта константа используется не как непосредственный операнд команды, а~как-то иначе.
В~частности, такая константа может быть частью адреса.
% Адреса полей 
% Следующий фрагмент
\begin{lstlisting}[numbers=none]
"movl $13,  %c[FieldDisp](%[Struct])\n"
\end{lstlisting}
Приведённый фрагмент ассемблерной вставки инициализирует поле структуры, расположенной по адресу~\lstinline![Struct]!.
Смещение поля задано параметром~\lstinline![FieldDisp]!.

Модификаторы печати имени части регистра доступны только для параметров в~регистрах,
причём печать младшего байта и~старшего байта младшего слова "--- только в~тех, где %младший байт
эти байты
можно адресовать.
\index{REX, префикс}%
В~тридцатидвухбитном режиме как младший байт, так и~следующий за ним можно адресовать только для~$A{-}D$.
В~шестидесятичетырёхбитном младший байт адресуется для всех шестнадцати регистров общего назначения с~помощью префикса~$REX$. Второй байт доступен только для $A{-}D$, причём не в~любой ситуации (использование префикса $REX$ запрещает доступ к~$ah{-}dh$).
% (если в~команде используется префикс $REX$).

% Модификатор печати имени старшего байта младшего слова  доступен только для тех регистров, где младший байт можно адресовать.

\addquestion{Какие стадии включает компиляция программы с~помощью GCC?}

\addquestion{Какое расширение имеет файл с~исходным кодом на языке ассемблера?}
\addquestion{Какое расширение имеет файл с~исходным кодом на языке C++?}
\addquestion{Как изменить имя выходного файла при сборке?}
\addquestion{Как собрать программу, состоящую из нескольких модулей?}
\addquestion{Какие~вы знаете соглашения о~вызове?}
% \addquestion{Как подключить к~проекту используемой вами IDE модуль на ассемблере?}
\addquestion{Как импортировать ассемблерную функцию в~проект на C++?}
\addquestion{Каким ключевым словом открывается ассемблерная вставка?}
\addquestion{Как из ассемблерной вставки обратиться к~локальным переменным?}

\addquestion{Какие вы знаете ограничения на размещение параметров ассемблерных вставок?}



\printquestions
