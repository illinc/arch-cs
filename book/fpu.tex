


\section{Математический сопроцессор}

\epigraph{
"--*  Фапофадофажди, "--- сказала Алиса Пашке, пользуясь старым школьным кодом. "--- Фамыфаосфатафанемфася фаодфани.

"--*  Фапофанял, "--- ответил Пашка.

"--*  Фавлефасу, "--- сказала Алиса.
}
{Кир.\,Булычёв}


% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX
% }  



Математический сопроцессор (Floating Point Unit, FPU) "--- устройство для обработки числовых данных в~формате с~плавающей точкой.
% 
Первый математический сопроцессор для линейки x86 "--- FPU 8087 "--- был выпущен в~1980 году.
Он представлял собой отдельную микросхему, устанавливаемую в~специальный сокет на системной плате.
% Использование сопроцессора 8087 ускоряло вычисления с плавающей точкой, но, так как сопроцессор мог отсутствовать, 
Начиная с~процессора i486DX математический сопроцессор интегрирован в~процессор.
При этом сопроцессор долгое время (вплоть до линейки микропроцессоров Atom) имел почти независимое ядро, так что обработка целых чисел CPU и~вещественных FPU могла выполняться параллельно.
% С одной стороны, это позволяло
Из-за этого в~систему команд была введена команда ожидания завершения работы сопроцессора, а~многие команды управления сопроцессором реализованы в~двух вариантах "--- с~ожиданием и~без.
В~современных  процессорах FPU настолько плотно интегрирован с~ядром CPU, что их параллельная работа невозможна и~ожидание не требуется.


FPU выполняет все вычисления в~80-битном расширенном формате.
Для обмена данными с~памятью используются также 
вещественные числа одинарной  (32 бита) и~двойной  (64 бита) точности, соответствующие стандарту IEEE 754-2008.


\subsection{Регистры сопроцессора}
\addquestion Какие регистры используются в~сопроцессоре для хранения операндов?
% 
% Восемь 80-разрядных регистров, образующих стек (кольцевой буфер).

FPU x87 предоставляет восемь 80-разрядных регистров для хранения данных и~шесть вспомогательных регистров~\cite{intelBasic}.
При обращении к~ним в~GAS надо указывать тот же префикс~\lstinline!%!, что и~для регистров основного процессора (CPU).

\begin{illustration}
% \includegraphics[width=\approvedImageWidth]{fpu_reg}

\resizebox{\linewidth}{!}
{
\input{book/fragments/fpureg}
}

\caption{Регистры FPU}
\label{ris:fpu_reg}
\end{illustration}

% Регистры данных ($R0$--$R7$) не адресуются по именам, как регистры основного процессора. 
% Вместо этого эти восемь регистров рассматриваются как стек, вершина которого называется $st(0)$, а~более глубокие элементы "--- $st(1)$, $st(2)$ и~так далее до $st(7)$. 
% Если, например, в~какой-то момент времени регистр $R5$ называется $st(0)$, то после записи в~этот стек числа оно будет записано в~регистр $R4$, который станет называться $st(0)$, $R5$ станет называться $st(1)$ и~т.\,д.~\cite{zubkov}.
% ^^^ прямая цитата

Восемь регистров данных, согласно документации Intel~\cite{intelBasic}, носят имена $r_0-r_7$, но обратиться к~ним по этим именам невозможно.
Они образуют стек с~плавающей вершиной, построенный по принципу кольцевого буфера.
К~регистру, находящемуся сейчас в~вершине стека, можно обратиться как к~$st(0)$; если стек содержит более одного элемента, то к~более глубоким элементам можно обращаться по именам $st(1)$, $st(2)$ и~так далее до $st(7)$~\cite{zubkov}. 
Регистры данных сопроцессора хранят вещественные числа в~80-битном расширенном формате.
Мантисса занимает 64 бита, порядок "--- 15 бит, под знак отводится один бит.

Шестнадцатибитный регистр (слово) тегов $tw$ (Tag Word, также используется сокращение $twr$ "--- Tag Word Register)  хранит состояние регистров данных.
Каждому регистру $r_0-r_7$ соответствует два бита слова тегов (рис.~\ref{ris:fpu-tw}):
\begin{alphenumerate}
\item $00$ "--- в~соответствующем регистре корректное ненулевое значение;
\item $01$ "--- в~регистре ноль;
\item $10$ "--- в~регистре специальное значение: некорректное значение (\lstinline$nan$ или значение, не соответствующее формату вещественного числа с~расширенной точностью), бесконечность или денормализованное число; % Special: invalid (NaN, unsupported), infinity, or denormal
\item $11$ "--- регистр пуст.
\end{alphenumerate}
\begin{illustration}

\resizebox{\linewidth}{!}{\input{book/fragments/fpureg-tw}}

\caption{Слово тегов FPU}
\label{ris:fpu-tw}
\end{illustration}
Если регистр $r_i$ помечен в~слове тегов как пустой, его значение при этом  может быть каким угодно "--- попытка чтения из него приведёт к~ошибке стека.

Флаги математического сопроцессора разбиты на два шестнадцатибитных регистра (рис.~\ref{ris:fpu-sw-cw}) "--- 
управляющие флаги составляют управляющее слово $cw$ (Control Word, также $cwr$),
флаги состояния сгруппированы в~слово состояния "--- $sw$ (Status Word, также $swr$).

\begin{illustration}
% \includegraphics[width=\linewidth,keepaspectratio,valign=t]{swr}
% 
% \includegraphics[width=\linewidth,keepaspectratio,valign=t]{cwr}

\resizebox{\linewidth}{!}
{
\input{book/fragments/fpureg-sw-cw}
}

\caption{Слово состояния и~управляющее слово FPU}
\label{ris:fpu-sw-cw}
\end{illustration}

Управляющее слово содержит 
шесть масок исключений ($IM{-}PM$),
поле управления точностью $PC$,
и~поле управления округлением $RC$.
% Исключением

Слово состояния отображает  текущее состояние сопроцессора после выполнения последней команды.
Младший байт слова состояния
включает %флаг $IE$, соответствующей незамаскированному исключению,   
семь флагов, показывающих корректность операций ($IE{-}SF$) и~флаг $ES$, показывающий, что сбой не только был, но и привёл к~прерыванию.
Старший байт включает
флаги $C0{-}C3$, хранящие результаты сравнения чисел,
% Также слово состояния содержит 
а~также трёхбитный текущий номер вершины стека $top$.
Последний бит~$B$ в~настоящее время не используется.

%  ТОР "--- указатель  вершины стека.
%  шесть флагов исключительных ситуаций;


Таким образом, стек сопроцессора организован с~помощью восьми регистров данных $r_0-r_7$, соответствующих восьми полей слова тегов~$tag(0){-}tag(7)$ и~поля~$top$ слова состояния.
Вершина стека $st(0)$ находится в~регистре $r_{top}$, обозначение $st(1)$ получает следующий регистр~$r_{top+1}$ и так далее.
За $r_7$ по принципу кольцевого буфера следует $r_0$.
На рис.~\ref{ris:fpu-r-st} показаны соотношения между физическими $r_i$ и~логическими $st(i)$ именами регистров данных сопроцессора при различных значениях номера вершины стека $top$.


% \begin{illustration}
% \includegraphics[width=\linewidth,keepaspectratio,valign=c]{fpu_push_pop}
% \caption{Стек FPU}
% \label{ris:fpu-r-st}
% \end{illustration}

\begin{illustration}
\resizebox{\linewidth}{!}
{
\input{book/fragments/fpu-top-change}
}

\caption{Стек FPU}
\label{ris:fpu-r-st}
\end{illustration}

Положение дна стека определяется словом тегов $tw$ (первый пустой регистр).



После инициализации стек пуст.
% В~начале работы стек пуст. 
После завершения вычислений (перед выходом из функции или ассемблерной вставки) его также необходимо оставить пустым. 
Если функция возвращает вещественное значение через стек сопроцессора, в~стеке не должно остаться ничего, кроме возвращаемого значения.

Для вычислений хотя бы один операнд должен быть загружен в~стек сопроцессора.





% Last Instruction Opcode intelBasic
Два 48-битных регистра указателей (на последнюю команду "---  FPU Instruction Pointer, $fip$, в~некоторых источниках также~$ipr$~\cite{urov} и~последний загруженный операнд  Data (Operand) Pointer, $fdp$, также~$dpr$), а~также десятибитный регистр кода операции последней неуправляющей команды (FPU Opcode Register, $fop$) используются в~обработке исключений для определения места сбоя.



\subsection{Структура вещественных чисел}
\index{Представление данных!вещественных!расширенной точности}


% IEEE 754

% http://stackoverflow.com/questions/612507/what-are-the-applications-benefits-of-an-80-bit-extended-precision-data-type
Значения в~сопроцессоре представлены в 80-битном формате (с~двойной расширенной точностью соответственно IEEE 754-1985~\cite{ieeeFloat1985rus}).
Этот формат исключён из современной версии стандарта IEEE 754~\cite{ieeeFloat2008}, но из-за соображений совместимости формат данных FPU не изменился.

Нормализованное двоичное представление вещественного числа имеет вид~\cite{urov,av-assembler-asm-real-normalization}:
\begin{equation}
\label{eq:float-rus}
(-1)^s \cdot 2^p \cdot m, ~~ %0 \leqslant m < 1
0,1_2 \leqslant m < 1
\end{equation}
где
% $0,1_2 \leqslant m < 1$ нормализованное число,
% \\
% $0 \leqslant m < 0,1_2$ денормализованное число.
$p$ "--- порядок числа, $m$ "--- мантисса, $s$ определяет знак.

Старший бит 80-битного формата "--- знак~$s$,
порядок занимает следующие 15 бит и~представляется кодом с~избытком $2^{14}-2$ %(см. раздел~\ref{sec:digits-negcodes}),
(так называемый смещённый порядок).
% % то есть соответствующее поле содержит натуральный двоичный код числа~$p + 2^{14}$,
% мантисса занимает 64 бита, % и~представляется натуральным кодом
% причём её представление  включает ведущую единицу (рис.~\ref{ris:fpu_digits}),
В~оставшиеся 64 бита записывается дробная часть мантиссы, включая ведущую единицу.

В~частности, единица в~нормализованном представлении имеет вид~$(-1)^0 \cdot 2^1\cdot 0,1_2$.
Тогда значение смещённого порядка (после добавления избытка) будет равно $2^{14}-1$:
$$
\begin{array}{rrrr}
1 = (-1)^0 \cdot 2^1\cdot 0,1_2 &\to &\regfloat[fill=none]{0}{2^{14}-1}{100...} &=\\
% = 0~~0\underbrace{11...11}_{14 \text{единиц}}%\,1111\,1111\,1111
% ~~\underbrace{100...}_{64 \text{бита}}
&=& \regfloat[fill=none]{0}{011...11}{100...} &\\
\end{array}
$$
% После 
Таким образом, %шестнадцатеричное представление вещественного числа 
вещественное число расширенной точности, равное единице, имеет вид
\lstinline$3FFF$\,\lstinline$8000$\,~\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$~\,\lstinline$0000$\,\lstinline$0000$.
Это подтверждает исследование с~помощью отладчика.

Значение порядка, состоящее из пятнадцати нулей, зарезервировано под специальные значения, таким образом, 
минимально возможное значение порядка корректного вещественного числа имеет вид $00...001$ и~равно~$p_{min} = 1 + \left(-2^{14}+2\right) = -2^{14}+3$.
Соответственно, минимальное положительное  число, представимое в~нормализованном виде в~%80-битном формате FPU, 
формате расширенной точности,
равно 
$\xi_{min} = 2^{p_{min}} \cdot 0,1_2 = 2^{-2^{14}+2} = $ \lstinline$0001$\,\lstinline$8000...00$.
Числа в~диапазоне $(0, \xi_{min})$ представляются в~виде $2^{p_{min}} \cdot m, ~~ 0 < m < 0,1_2$ и~называются \termin{денормализованными}.
В~поле смещённого порядка таких чисел при этом записываются нули.
В~частности, $\frac{\xi_{min}}{2} = 2^{p_{min}} \cdot 0,01_2 = 2^{p_{min}-1} \cdot 0,1_2$, но представляется это число как \lstinline$0000$\,\lstinline$4000...00$, 
% хотя порядок 
в~чём можно убедиться при помощи отладчика.
Если попытаться прочесть такую запись как корректное число, то получим нулевой знаковый бит, нулевой смещённый порядок, что соответствует порядку $p_{min}-1$, 
и~мантиссу $0,0100..._2$, то есть $(-1)^0 \cdot 2^{p_{min}-1}\cdot 0,01_2 = \frac{\xi_{min}}{4}$, что неверно.
Денормализованные числа "--- один из видов \termin{специальных значений,} которые нельзя раскодировать по общему правилу.
% Если попытаться 

Представление отрицательных вещественных чисел, в~том числе из диапазона $(-\xi_{min}, 0)$ ,
отличается от представления их модулей только знаковым битом.


В~зарубежных источниках то же самое представление вещественных чисел в~FPU интерпретируется иначе~\cite{intelBasic} (хотя суть от этого не меняется).
% 
Там считается, что мантисса нормализованного числа включает целую часть (рис.~\ref{ris:fpu_digits-en}):
\begin{illustration}
\includegraphics[width=\linewidth]{X86_Extended_Floating_Point_Format_ru}
\caption{Внутренний 80-битный формат сопроцессора}
\label{ris:fpu_digits-en}
\end{illustration}
\begin{equation}
\label{eq:float-en}
(-1)^s \cdot 2^{\tilde{p}} \cdot \widetilde{m},~~ 1 \leqslant \widetilde{m} < 10_2
\end{equation}
% тогда нормализованные числа соответствуют мантиссам $1 \leqslant \widetilde{m} < 10_2$,
тогда денормализованные числа соответствуют мантиссам $0 \leqslant \widetilde{m} < 1$.

Формы~\eqref{eq:float-rus} и~\eqref{eq:float-en} взаимно однозначно соответствуют друг другу:
$$
\left\{
\begin{array}{lll}
\tilde{p} &=& p - 1\\
\widetilde{m} &=& 2\cdot m\\
\end{array}
\right.
$$
Так как двоичная запятая не может быть сохранена в~регистре~$r_i$, а~только \emph{подразумевается} на той или иной позиции,
двоичное представление мантиссы в~формах~\eqref{eq:float-rus} и~\eqref{eq:float-en} \emph{полностью совпадает.}
Порядок~$\tilde{p}$ формы~\eqref{eq:float-en}, %в~этом случае 
соответственно,
записывается с~избытком $2^{14} -1$, так что полученное значение смещённого порядка в~результате также совпадает с~формой~\eqref{eq:float-rus}.
Таким образом, двоичное представление одинаковых чисел (как нормализуемых в~формате расширенной точности, так и~денормализованных) одинаково и~не зависит от формы нормализованного представления.

\subsubsection{Виды значений}
Регистры сопроцессора могут содержать следующие значения:
\begin{itemize}
\item  вещественные числа "--- порядок не равен $0$ и~не состоит из всех единиц, %то есть не равен 0x7FFF
% целая часть мантиссы равна 1; %, корректно представимые
старший бит мантиссы равен~$1$;
\item денормализованные вещественные числа "--- порядок и~%целая часть
старший бит мантиссы равны $0$, но мантисса не равна нулю;
\item нули ($+0,0$ и~$-0,0$, в~соответствии со знаковым битом) "--- порядок и~мантисса равны нулю;
\item бесконечности ($+\infty$ и~$-\infty$, в~соответствии со знаковым битом, обозначаются как \lstinline!+inf! и~\lstinline!-inf!) "--- порядок состоит из всех единиц, 
% целая часть мантиссы "--- единица, дробная часть равна нулю;
старший бит мантиссы "--- единица, остальные равны нулю;
\item нечисла двух типов:
\begin{itemize}
\item сигнальные нечисла (при  появлении такого значения в~стеке генерируется исключение недействительной операции);
\item тихие нечисла (не генерируют исключения, но результат вычислений с~операндом-нечислом "--- тоже нечисло):
\begin{itemize}
\item вещественная неопределённость \lstinline!nan! (знаковый бит не имеет значения) "--- порядок состоит из всех единиц, 
% целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные нули;
\item другие тихие нечисла "--- порядок состоит из всех единиц, %целая часть и~старший бит дробной части 
два старших бита мантиссы
"--- единицы, остальные "--- не все нули;
\end{itemize}
\end{itemize}
\item недопустимые значения.
\end{itemize}
Начиная с~80387 некоторые ранее недопустимые значения стали нечислами различного типа, и~наоборот "--- многие недопустимые для современных сопроцессоров значения были корректными нечислами в~ранних дискретных моделях.

% Регистр состояний SW содержит слово состояния FPU.
% Регистр управления CW содержит управляющие биты и~маски.
% 
% Регистр тегов TW содержит восемь пар бит, описывающих содержание каждого регистра данных, "--- биты 15--14 описывают регистр R7, 13--12 "--- R6 и~т.\,д. Если пара бит (тег) равна 11, соответствующий регистр пуст. 00 означает, что регистр содержит число; 01 "--- ноль; 10 "--- нечисло, бесконечность, денормализованное число, неподдерживаемое число.
% 
% Регистры FIP и~FDP содержат адрес последней выполненной команды (кроме finit, fclex, fldcw, fstcw, fstsw, fstswax, fstenv, fldenv, fsave, frstor и~fwait) и~адрес её операнда соответственно и~используются в~обработчиках исключений для анализа вызвавшей его команды.

\subsection{Исключения сопроцессора}

В~языках 


\subsection{Взаимодействие сопроцессора с~памятью и~регистрами CPU}

Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора или, наоборот, выгрузить значение из стека FPU в~регистр CPU.
% 
Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры, использующиеся как аргументы инструкций сопроцессора, должны располагаться в~памяти:
\begin{lstlisting}[style=lstsmall]
const double a = 12;
double x = 1, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "faddl %[A]\n"  // st(0) = %[SRC] + %[A]
    "fstpl %[DST]\n"// %[DST] = %[SRC] + %[A], стек пуст
    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = x + a
\end{lstlisting}

В~списке  перезаписываемых регистров GCC не позволяет описывать элементы стека сопроцессора.
Это, как правило, не приводит к~ошибкам, так как временные переменные не помещаются в~стек сопроцессора.

При выходе из вставки 
или функции
стек сопроцессора должен быть таким же, как на входе "--- обычно пустым,
% При выходе из функции стек сопроцессора также должен быть пуст, 
если только через него не возвращается значение (тогда в~стеке не должно быть ничего, кроме возвращаемого значения).


\subsection{Набор инструкций x87}
% http://www.studfiles.ru/preview/4034449/

Мнемоническое обозначение команд сопроцессора характеризует особенности их работы:

Все мнемонические обозначения начинаются с~символа \lstinline!f! (FPU).

Вторая буква мнемонического обозначения определяет тип операнда в~памяти, с~которым работает команда:
\begin{itemize}
\item \lstinline!i! "--- целое двоичное число со знаком;

\item \lstinline!b! "--- целое двоично-десятичное (BCD) число;

\item отсутствие буквы "--- вещественное число.
\end{itemize}

Последняя буква \lstinline!p! в~мнемоническом обозначении команды означает, что последним действием команды обязательно является извлечение операнда из стека (удвоенная \lstinline!pp! "---  из стека извлекаются оба операнда). 

\subsubsection{Сброс сопроцессора}

% Перед началом работы с~сопроцессором его состояние обычно сбрасывается командой finit.
% Если программа написана целиком на ассемблере, программист должен вызвать finit вручную.

Так как ранние модели сопроцессора были отдельными устройствами, 
перед началом работы было необходимо определить, есть ли сопроцессор в~системе, и, в~случае его наличия, инициализировать сопроцессор.
Для инициализации предназначена команда \lstinline!finit! "--- сброс сопроцессора.

Команда \lstinline!finit! восстанавливает значения по умолчанию в~регистрах $cw$, $sw$, $tw$, а~начиная с~80387 "--- $fip$ и~$fdp$. Управляющее слово инициализируется значением \lstinline$0x037F$ (округление к~ближайшему, 64-битная мантисса, все исключения замаскированы "--- то есть можно спокойно делить на $0$, брать корень из отрицательных чисел и~т.\,п., но результат будет не числом). Слово состояния обнуляется ($top = 0$, никакие флаги исключений не установлены). Регистры данных никак не изменяются, но все они помечаются пустыми в~слове тегов $tw$. Регистры $fip$ и~$fdp$ обнуляются. 

Современные операционные системы сбрасывают и~настраивают сопроцессор во время загрузки. 
Выполнять сброс вручную не стоит, так как это может повлиять на выполнение дальнейших расчётов на ЯВУ.



\subsubsection{Загрузка данных в~стек сопроцессора}
\index{Команды!сопроцессора!загрузки}

% Данные для обработки необходимо поместить в~стек сопроцессора. 
Для загрузки данных в~стек сопроцессора предназначен набор инструкций \lstinline!f*ld!.
После загрузки значение преобразуется в~число с~двойной расширенной точностью (80 бит).
Ячейка, куда было помещено значение, получает обозначение $st(0)$.

В~стек можно поместить значение одного из элементов стека сопроцессора, значение из памяти или одну из предопределённого набора констант.
Невозможно напрямую загрузить в~стек сопроцессора значение регистра основного процессора.
% 
% Это необходимо учитывать при написании ассемблерных вставок "--- все входные и~выходные параметры
\begin{table}[!ht]
\caption{Команды загрузки данных в~стек сопроцессора}
\label{tab:fpu-fld-list}
% \begingroup
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/fragments/fpu-fld-list.tex}

% \endgroup

\end{table}


\subsubsection{Выгрузка и~пересылка данных% из~стека сопроцессора
}
\index{Команды!сопроцессора!выгрузки}
\index{Команды!сопроцессора!пересылки}

\label{sec:fcmovCC}
\index{Флаги!проверка}
\index{Команды!условной пересылки}
% \index{Команды!сопроцессора!пересылки}

Для выгрузки данных из~стека сопроцессора предназначен набор инструкций \lstinline!f*st[p]!.


\begingroup
\let\oldnormalsize\normalsize
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/fragments/fpu-fst-list.tex}

\endgroup



Ниже показан пример использования команд загрузки и~выгрузки.
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
double x = 5.7, y;
float f;
long double l;
int i = 10;

asm(                //          st(0),st(1),st(2),st(3)
    "fldl %[x]\n"   // в стеке: [x]
    "fldz\n"        // в стеке: 0,    [x]
    "fld1\n"        // в стеке: 1,    0,    [x]
    "fildl %[i]\n"  // в стеке: [i],  1,    0,    [x]
    "fstps %[f]\n"  // в стеке: 1,    0,    [x]       [f] = [i] 
    "fstpt %[l]\n"  // в стеке: 0,    [x]             [l] = 1   
    "fstpl %[y]\n"  // в стеке: [x]                   [y] = 0   
    "fistpl %[i]\n" // стек пуст                      [i] = [x]

    :[y]"=m"(y), [i]"+m"(i), [f]"=m"(f), [l]"=m"(l)
    :[x]"m"(x)
    :"cc"
)

#define PRINT(val) cout << #val << " = " << val << "  ";

PRINT(x)
PRINT(y)
PRINT(i)
PRINT(f)
PRINT(l)
\end{lstlisting}
Вначале в~стек сопроцессора последовательно загружаются четыре значения:
вещественная переменная двойной точности $x = 5.7$, константы "--- ноль и~единица, а~также целое 32-битное число $i = 10$.
% При загрузке данных из памяти размер источника определяется суффиксом. 
% Команда $fldl$ загружает из памяти длинное вещественное значение (64-битное, $double$),
% $fildl$ "--- длинное целое (32-битное, $int$).

После загрузки всех четырёх значений в~стеке сопроцессора находятся следующие значения:
$$
\begin{array}{l}
st(0) =10= i \\
st(1) = 1 \\
st(2) = 0 \\
st(3)= 5.7 = x \\
\end{array}
$$
Все они внутри стека хранятся в~80-битном вещественном формате.

Затем верхнее значение $st(0)$, равное последнему загруженному значению~$i = 10$, выталкивается из стека и~записывается по адресу параметра $[f]$, преобразованное в~вещественное число одинарной точности.
% (суффикс $s$ для вещественных команд обозначает короткое вещественное число, то есть 32-битное $float$).
Новое значение вершины стека $st(0)$ после выталкивания %значения $10$
"--- единица. Соответственно, изменятся и~обозначения более глубоких элементов стека: $st(1) = 0$ и~$st(2) = x$.

Затем новое значение вершины стека, равное единице, выталкивается в~параметр~$[l]$ как 80-битное число (суффикс $t$ "--- $ten~bytes$, что для компиляторов GCC соответствует типу $long~double$).
Ноль выталкивается из стека и~записывается в~$[y]$ как число двойной точности.
Последний оператор выталкивает значение~$x$ в~параметр~$[i]$ как длинное целое ($int$), после чего стек остаётся пустым.
Значение $5.7$ округляется в~соответствии с~текущими настройками округления.

Соответственно, результат отладочной печати в~конце листинга выглядит следующим образом:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
x = 5.7  y = 0  i = 6  f = 10  l = 1 
\end{lstlisting}

Используя команды выгрузки или загрузки из памяти, необходимо внимательно следить за суффиксами команд.
% , так как только по суффиксу определяется размер "--- единственная
В~вышеописанном примере команда \lstinline!fstp %[y]! не вызвала бы ошибки ни во время компиляции, ни во время выполнения, но переменная $y$ получила бы весьма странное значение.
По умолчанию (без указания суффикса) \lstinline$fstp$ записывает снятое с~вершины стека значение как вещественное число одинарной точности, то есть из 64 бит переменной $y$ будут перезаписаны только первые 32, причём в~формате, не соответствующем типу $double$.


\subsubsection{Основные арифметические команды}
\index{Команды!сопроцессора!арифметические}
\addquestion Какие команды используются для выполнения арифметических операций над вещественными числами?

Основные арифметические команды сопроцессора выполняют базовые бинарные арифметические операции "--- сложение, вычитание, умножение и~деление.
Хотя бы один операнд должен быть %в~стеке сопроцессора.
в~вершине стека сопроцессора~$st(0)$.
Результат помещается на место одного из операндов (приёмника) в~стек сопроцессора, заменяя старое значение.
Приёмник должен быть в~стеке сопроцессора, но не обязательно на его вершине. %, таким образом, .

Сопроцессор использует шесть  форм~\cite{frolov} основных арифметических команд, различающихся положением источника и~приёмника.
Также некоторые формы после вычисления результата выталкивают источник из стека сопроцессора (таблица~\ref{tab:fpu-arcommon-typelist}).
Строка XXX соответствует выполняемой операции %и~может быть
(\lstinline!add!, \lstinline!sub!, \lstinline!subr!, \lstinline!mul!, \lstinline!div!, \lstinline!divr!).


\begin{table}[!htpb]
\caption{Шесть форм основных арифметических команд}
\label{tab:fpu-arcommon-typelist}

\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/fragments/fpu-arcommon-typelist.tex}

\end{table}
% \FloatBarrier

% Основные арифметические операции (источник обозначается как src, приёмник "--- как dst).
% Каждой операции соответствует шесть команд в~соответствии с~таблицей выше.
Так, для операции сложения \lstinline!fadd! возможны следующие формы:
\begin{alphenumerate}[wide=\parindent]
\item \lstinline!faddp!
"--- $st(1) := st(0) + st(1)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(0)$	(синоним \lstinline!fadd!,
эквивалент \lstinline!faddp %st(0), %st(1)!);
\item \lstinline!fadd src!	"--- $st(0) := st(0) + \text{вещественное}~src$;
\item \lstinline!fiadd src!	"--- $st(0) := st(0) + \text{целое}~src$;
\item \lstinline!fadd %st(i), %st(0)!	"--- $st(0) := st(0) + st(i)$;
\item \lstinline!fadd %st(0), %st(i)!	"--- $st(i) := st(i) + st(0)$;
\item \lstinline!faddp %st(0), %st(i)!	"--- $st(i) := st(i) + st(0)$ и~выталкивание  $st(0)$ из стека, так что после этой операции результат оказывается в~$st(i-1)$.
\end{alphenumerate}


\warning{ 
Внимание!

Ассемблер Unix исторически использовал для некоторых команд FPU \emph{в~некоторых ситуациях} обратное расположение операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel и~большинстве учебников.
}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
всегда, в~том числе
в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
% в~таком случае 
для двух регистров
вычисляет $st(0) - st(i)$ независимо от того, какой из этих регистров является приёмником (в~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры). 
Обратное вычитание~\lstinline!fsubr! вычисляет $st(i) - st(0)$.

% Соответственно, шесть форм команды прямого вычитания \lstinline$fsub$ и~обратного вычитания \lstinline$fsubr$ в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-fsub-r-typelist}.
% 
% \begin{table}[!ht]
% \caption{Прямое и~обратное вычитание в~синтаксисе \Att}
% \label{tab:fpu-fsub-r-typelist}
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/fragments/fpu-fsub-r-typelist.tex}
% 
% \end{table}


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub[p] %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!~\cite{trouble-with-fsub}.
Анализ сгенерированного компилятором из коллекции GCC кода это подтверждает.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.

Приёмником, в~соответствии с~синтаксисом \Att, является второй аргумент.
Если команда вызывается с~одним аргументом или без них, то приёмником является $st(0)$, что соответствует документации Intel.
Таким образом,
% Соответственно, 
шесть форм несимметричных операций (вычитания и~деления) в~GAS действуют, % следующим образом.
как показано в~таблице~\ref{tab:fpu-att-r-typelist}.

\begin{table}[!ht]
\caption{Прямые и~обратные вычитание и~деление в~синтаксисе \Att}
\label{tab:fpu-att-r-typelist}

\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/fragments/fpu-att-r-typelist.tex}

\end{table}

Такое поведение в~случае сочетания синтаксиса AT\&T и~платформы x86 в~некоторых источниках описывается как баг GCC~\cite{sourceware-i386_002dBugs}, но из соображений совместимости с~имеющимся кодом меняться не будет.
Из-за него, кроме всего прочего, в~GCC для всех основных арифметических команд доступна <<нелегальная>> седьмая форма записи, например, \lstinline!fsubp %st(i), %st(0)!.
Такая запись вызывает при компиляции предупреждение, но не ошибку (хотя по сути является ошибочной, источник $st(i)$ невозможно вытолкнуть из стека) и~преобразуется в~\lstinline!fsubp %st(0), %st(i)! (а~при ассемблировании "--- в~опкод \lstinline!fsubr!), то есть в~$st(i)$ записывается $st(0) - st(i)$, а~затем $st(0)$ выталкивается из стека.
Подобную некорректную форму лучше не использовать.

Поведение Intel и~GAS совпадает в~тех случаях, когда приёмником является~$st(0)$, в~том числе в~ситуациях, когда источник находится в~памяти.

Также поведение Intel и~GAS полностью совпадает для симметричных операций "--- сложения и~умножения (таблица \ref{tab:fpu-ar-list}).

\begin{table}[!ht]
\caption{Основные арифметические операции над вещественными числами}
\label{tab:fpu-ar-list}
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/fragments/fpu-arcommon-mnemlist.tex}

*
%Один из операндов всегда находится на вершине стека~$st(0)$.
% Обозначим другой операнд как~$x$.
$\xi$ "--- операнд, не лежащий на~вершине стека.

Может быть как источником, так и~приёмником, в~зависимости от используемой формы.

\end{table}


Ниже показан 
пример использования 
основных арифметических команд для расчёта значения выражения $x + \frac{1}{i} + a \cdot \pi$, где $x$ и~$i$ "--- значения переменных.
% 
Так как используется GAS, \lstinline!fdivr! рассчитывает %прямое деление 
$st(1)/st(0)$, после чего источник $st(0)$ выталкивается из стека.
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 0.01;
double x = 5, y;
int i = 10;
asm(                           //          st(0),    st(1), st(2), st(3)
    "fldl %[x]\n"              // в стеке: x
    "fldpi\n"                  // в стеке: pi,       x
    "fld1\n"                   // в стеке: 1,        pi,    x
    "fildl %[i]\n"             // в стеке: i,        1,     pi,    x
    "fdivr\n"                  // в стеке: 1/i,      pi,    x
    "fldl  %[A]\n"             // в стеке: A,        1/i,   pi,    x
    "fmulp %%st(0), %%st(2)\n" // в стеке: 1/i,      pi*A,  x
    "faddp\n"                  // в стеке: 1/i+pi*A, x
    "faddp\n"                  // в стеке: 1/i+pi*A+x
    "fstpl %[y]\n"             // y = 1/i + pi*A + x, стек пуст

    :[y]"=m"(y)
    :[x]"m"(x), [A]"m"(a), [i]"m"(i)
    :"cc"
);// y = x + 1/i + a*pi
\end{lstlisting}
Приведённый код "--- не единственный способ расчёта значения указанного выражения.
% Как порядок вычислений, так и~используемые команды могут различаться.
В~зависимости от того, в~каком порядке программист будет рассчитывать компоненты выражения, может различаться как порядок команд, так и~сами команды.


\subsubsection{Дополнительные арифметические и~трансцендентные команды}
% \footnote{Использованы: %http://devotes.narod.ru/Books/3/
% Зубков С.\,В. Assembler для DOS, Windows и~UNIX} 

Дополнительные арифметические и~трансцендентные команды~\cite{zubkov, intelInstructionSet} работают с~вершиной стека $st(0)$ и,~при необходимости, с~$st(1)$. Они не имеют явных аргументов и~соответствующих пяти форм.

Использование этих команд не перезаписывает значения, лежащие в~стеке ниже неявных аргументов. 
Если у~команды только один аргумент в~$st(0)$ и~один результат, результат записывается в~$st(0)$ на место аргумента.
Если у~команды один аргумент в~$st(0)$ и~два результата (\lstinline$fptan$, \lstinline$fsincos$ и т.\,д.), то один из результатов помещается в~$st(0)$, второй затем помещается в~стек сверху (так что первый результат оказывается в~$st(1)$, второй "--- в~$st(0)$).
% В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом (или наоборот "--- с~одним аргументом $st(0)$ и~двумя результатами)
% изменятся номера нижележащих значений, но ни одно значение, кроме аргументов, не исчезнет и~не появится ни одной «дырки».
% Если результатом выполнения команды являются два числа, а~аргументом "--- $st(0)$, одно из %них 
% полученных значений заменяет аргумент в~$st(0)$, другое помещается сверху, так что 

В~случае команд с~двумя аргументами $st(0), st(1)$ и~одним результатом
чаще всего результат помещается в~$st(1)$, затем $st(0)$ выталкивается из стека, так что после этой операции результат оказывается в~$st(0)$. 
Таким образом, результат замещает собой аргументы (в~таблице~\ref{tab:fpu-arex-list} такая ситуация соответствует обозначению $\big[st(1)\to st(0)\big]$ для результата).

Иногда (в~частности, \lstinline$fscale$) команда с~двумя аргументами в~$st(0)$ и~$st(1)$ записывает результат в~$st(0)$, оставляя аргумент в~$st(1)$ в~стеке.

Для всех тригонометрических команд операнд считается заданным в~радианах и~не может быть больше $2^{63}$ или меньше $-2^{63}$. 
% Если операнд выходит за эти пределы, флаг С2 устанавливается в 1, значение st(0) и~стек не изменяются. 

Некоторые дополнительные арифметические и~трансцендентные команды перечислены в~таблице \ref{tab:fpu-arex-list}.
\index{Команды!сопроцессора!трансцендентные}
\index{Команды!сопроцессора!дополнительные}

\begin{table}[p]
\caption{Дополнительные арифметические и~трансцендентные команды FPU}
\label{tab:fpu-arex-list}
\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/fragments/fpu-arex-list.tex}

\end{table}



Пример использования:
\begin{lstlisting}[style=lstsmall,xleftmargin=0mm]
const double a = 100;
double x = M_PI/6, y;
asm(
    "fldl %[SRC]\n" // st(0) = %[SRC]
    "fsincos\n"     // st(0) = cos(%[SRC]), st(1) = sin(%[SRC])
    "fmull %[A]\n"  // st(0) = %[A]*cos(%[SRC]), st(1) = sin(%[SRC])
    "fadd\n"        // st(0) = %[A]*cos(%[SRC]) + sin(%[SRC])
    "fstpl %[DST]\n"// %[DST] = %[A]*cos(%[SRC]) + sin(%[SRC]) стек пуст

    :[DST]"=m"(y)
    :[SRC]"m"(x), [A]"m"(a)
    :"cc"
);	// y = a*cos(x) + sin(x)
\end{lstlisting}

\subsection{Сравнение вещественных чисел}


\begingroup

\subsubsection{Флаги сопроцессора}
\colorlet{csControl}{green!50}
\colorlet{csExceptionStatus}{green!7!yellow!7!white}
\colorlet{csSystem}{blue!20!red!10}
\index{Флаги!сопроцессора}

Математический сопроцессор имеет собственный регистр флагов "--- слово состояния \Reg{SW}.
Аналогично \Reg{eflags}, биты слова состояния сопроцессора представляют те или иные характеристики последней операции сопроцессора~\cite{intelBasic, club155}.
В~таблице~\ref{tab:fpu-status} представлено краткое описание структуры слова состояния, а~также соответствие старшего байта слова состояния сопроцессора \Reg{SW} и~младшего байта регистра флагов основного процессора~\Reg{eflags}.



\begin{table}[!ht]
\caption{Слово состояния FPU}
\label{tab:fpu-status}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{\Reg{SW}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{csExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}\Reg{eflags}, f(n)stsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{csMarker}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{csMarker}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{csMarker}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{csSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{csSystem}12 	& 	&&\cellcolor{csMarker}4 	&\cellcolor{csMarker}AF 	&\cellcolor{csMarker}Auxiliary Carry Flag\\
\rowcolor{csSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{csMarker}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{csExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\end{table}

\paragraph{IE (бит 0)} Флаг недействительной операции (Invalid operation).
Устанавливается в~единицу при выполнении недопустимой стековой (в~этом случае устанавливается также флаг $SF$) или арифметической операции.

Недействительной арифметической операцией считается операция, проводимая над некорректными аргументами.
В~этом случае могут быть установлены также флаги $DE$, $ZE$, $OE$, $UE$ или $PE$.

\paragraph{DE (бит 1)} Флаг денормализованного операнда (Denormalized operand).
Устанавливается в~единицу при выполнении арифметической операции над денормализованным числом или загрузке такого числа в~стек.

\paragraph{ZE (бит 2)} Флаг деления на ноль (Zero Divide).
Устанавливается в~единицу при делении на ноль.

\paragraph{ОЕ (бит 3)} Флаг переполнения порядка (Overflow).
Устанавливается в~единицу, если порядок результата выходит за максимально допустимое значение.
% 
Для команд выгрузки из стека \lstinline!f*st! переполнение возможно в~том случае, если размер порядка приёмника недостаточен.

\paragraph{UE (бит 4)} Флаг антипереполнения, или исчезновения порядка (Underflow).
Устанавливается в~единицу, если порядок результата выходит за минимально допустимое значение (денормализованный результат).
%
Для команд выгрузки из стека \lstinline!f*st! переполнение возможно в~том случае, если размер порядка приёмника недостаточен.


\paragraph{РЕ (бит 5)} Флаг неточного результата (Precision).
Устанавливается в~единицу, если результат невозможно точно представить в~формате назначения (например, $\frac{1}{3}$, $\sqrt{2}$).

Команды вычисления трансцендентных функций (\lstinline!fsin!, \lstinline!fcos!, \lstinline!fsincos!, \lstinline!fptan!, \lstinline!fpatan!, \lstinline!f2xm1!, \lstinline!fyl2x!, \lstinline!fyl2xp1!) всегда приводят к~неточному результату.

\paragraph{SF (бит 6)} Флаг стековой ошибки (Stack Fault).
Устанавливается в~единицу при попытке записи в~полностью заполненный стек или чтения из пустой ячейки стека.



\paragraph{ES (бит 7)} Флаг суммарной ошибки (Error Summary Status).
Равен единице, если возникает хотя бы одно незамаскированное исключение.
Таким образом, если не замаскировано ни одно из исключений, 

В~некоторых источниках говорится, что $ES$ равен единице  в~том случае, когда в~разрядах $0...6$ есть хотя бы одна единица~\cite{mikroprocessorniesistemi2002}.
Это в~общем случае неверно.
Если какое-то исключение замаскировано% (например, в~C++ деление на ноль не приводит к~исключению)
, $ES$ не дублирует состояние соответствующего флага.

В~частности,  в~C++ деление на ноль не должно приводить к~прерыванию работы программы, поэтому соответствующее исключение при настройке сопроцессора стартовым кодом маскируется.

Соответственно, при попытке деления единицы на ноль, как можно убедиться при помощи отладчика, результат принимает специальное значение $inf$ ($+\infty$), устанавливается флаг $ZE$, но
флаг $ES$ не устанавливается.
\begin{lstlisting}
double y;
asm(
    "fld1\n"
    "fldz\n"
    "fdivrp\n"
    "fstpl %[y]\n"
    :[y]"=m"(y)
);
\end{lstlisting}


\subsubsection{Сравнение вещественных чисел}


Команды сравнения оригинального FPU 8087 (fcom, fcomp, fcompp, ftst) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (fucom, fucomp, fucompp), не генерирующее исключений при сравнении некоторых нечисел, сохраняют результат сравнения в~биты C3, C0 и,~в~случае несравнимости операндов, в~бит~C2 слова состояния.



% \pagebreak[3]
Для анализа результата сравнения вещественных чисел в~ранних (отдельных) моделях сопроцессора было необходимо вручную перенести его в~регистр флагов \Reg{eflags} основного процессора.  
\index{Флаги!установка}
\pagebreak[3]

Это выполнялось в~два этапа:
\begin{itemize}
\item 
\index{Команды!fstsw}
\index{Команды!fnstsw}
\index{Команды!sahf}
слово состояния \Reg{SW} выгружалось в~регистр \Reg{AX} командами fstsw (проверяет на наличие отложенных необработанных исключений) или~fnstsw (также данные команды могут выгрузить \Reg{SW}  в~память);
\item старший байт \Reg{AX} загружался в~младший байт регистра флагов \Reg{flags} командой sahf.
\end{itemize}
\pagebreak[3]
%слово состояния \Reg{SW} могло быть выгружено в~память или регистр \Reg{AX} командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки \Reg{SW} в~регистр \Reg{AX} его старший байт загружал

После этого флаги C3 и~C0 помещались в~биты ZF и~CF, а~бит C2 "--- в~бит~PF. 
В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.

Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (fcomi, fcomip, fucomi, fucomip), которые напрямую устанавливают флаги ZF, CF, PF в~\Reg{eflags}.
Эти команды не изменяют биты C0,  C3 регистра \Reg{SW}.
% и~не дублируют туда результат сравнения.


Таким образом, после выполнения команды сравнения (%и~%пары команд 
% \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% или при использовании совместимых с~ними 
при использовании совместимых с~ранними моделями 
команд %f*com[p[p]]
без суффикса~\lstinline!i! 
необходимы также \lstinline!fstsw %ax! + \lstinline!sahf!)
результат  можно 
анализировать как результат сравнения беззнаковых целых чисел.
% 

\subsubsection{Команды сравнения}
% \footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается

\index{Команды!сравнения!вещественных чисел}
\index{Команды!сопроцессора!сравнения}

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

Все команды сравнения вещественных чисел~\cite{club155} сравнивают вершину стека $st(0)$ с~другим операндом (источником $src$).

\subsubsection{Команды, устанавливающие флаги сопроцессора}

Команды сравнения, унаследованные от ранних (дискретных) моделей сопроцессора, выставляют по результатам сравнения биты C0, C2, C3 слова состояния сопроцессора (рис.~\ref{fig:fcom}).
Бит~C3 взводится в~случае равенства операндов, бит~C0 "---  в~случае $st(0) < src$.
% ; бит C2 в~этих случаях равен $0$. 
Если операнды несравнимы, взводится бит~C2, а~также оба бита C0 и~C3.

К командам, помещающим результат в~слово состояния сопроцессора, относятся:
\begin{description}
\item[fcom] %Семейство команд сравнения.
Источник может быть указан явно (\lstinline!fcom %st(i)!, \lstinline!fcom mem!) или не указан (\lstinline!fcom!, находится в~$st(1)$). Источник в~памяти может иметь одинарную~или двойную точность.

Команда может иметь формы \lstinline!fcom [src]! (из стека ничего не выталкивается), \lstinline!fcomp [src]! (из стека выталкивается $st(0)$), \lstinline!fcompp! (из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$).

\item[fucom] Семейство команд, аналогичное \lstinline!fcom!. Отличается тем, что при сравнении тихих нечисел не генерируется исключений. 
% Сравнение чисел выполняется аналогично

\item[ficom] Источник "--- целое число (16 или 32 бита), находится в~памяти и~должен быть указан явно (\lstinline!ficom mem!).
Команда может иметь формы \lstinline!ficom src! (из стека ничего не выталкивается) и~\lstinline!ficomp src! (из стека выталкивается $st(0)$).
Если $st(0)$ "--- нечисло, генерируется исключение и~выставляются флаги, как для несравнимых значений.

\item[ftst] Источник равен нулю. Действие аналогично \lstinline!fcom!.

\end{description}

\begin{illustration}

$\left.
\begin{tabular}{l@{}l}
$src$ "--- st(i) или в~памяти & 
$\left\{\begin{tabular}{@{}r@{}}
\termin{fcom[p[p]]} \farg{[src]}\\
\termin{fucom[p[p]]} \farg{[src]}
\end{tabular}\right.$\\
$src$ "--- целое в~памяти & \termin{ficom[p]} \farg{src}\\
$src = 0$ & \termin{ftst}
\end{tabular}
\right\}$
% 
\begin{tabular}{c|@{~}c@{~}c@{~}c}
Условие & C3 & C0 &C2\\\hline
$st(0)>src$ & 0 & 0 & 0 \\
$st(0)<src$ & 0 & 1 & 0 \\
$st(0)=src$ & 1 & 0 & 0 \\
несравнимы& 1 & 1 & 1
\end{tabular}

{
\termin{f[n]stsw + sahf:} C3, C0, C2 $\to$ ZF, CF, PF.
\centering

}

\caption{Команды, выставляющие флаги сопроцессора (\Reg{SW})}
\label{fig:fcom}
\end{illustration}

Так как условные команды, в~частности, команды условной пересылки регистров сопроцессора fcmovCC, используют флаги \Reg{eflags}, а~не слово состояния сопроцессора,
% 
после выполнения команд сравнения этой группы необходимо перенести результат сравнения в~\Reg{eflags} парой команд \lstinline!fstsw %ax! + \lstinline!sahf!.

После этого значение C3 помещается в~аналогичный ему по смыслу флаг нуля ZF ($st(0) - src = 0$), C0 "--- в~флаг переноса~CF ($st(0) - src < 0$),
то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
Бит несравнимости C2 попадает на место флага чётности~PF. 


\subsubsection{Команды, устанавливающие флаги CPU}
\index{Флаги!установка}

Современные процессоры включают два семейства команд сравнения, напрямую выставляющие флаги ZF, CF, PF (рис.~\ref{fig:fcomi}):
\begin{description}
\item[fcomi] %Семейство команд сравнения.
Источник должен находиться в~стеке сопроцессора, при этом и~источник, и~приёмник $st(0)$ должны быть указаны явно (\lstinline!fcomi %st(i), %st(0)!).

Команда может иметь формы \lstinline!fcomi %st(i), %st(0)! (из стека ничего не выталкивается) и~\lstinline!fcomip %st(i), %st(0)! (из стека выталкивается $st(0)$).

\item[fucomi] Отличается от \lstinline!fcomi! тем, что при сравнении тихих нечисел не генерируется исключений. 
\end{description}


\begin{illustration}

\begin{tabular}{r}
\termin{fcomi[p]} \farg{src, \%st(0)}\\
\termin{fucomi[p]} \farg{src, \%st(0)}\\
% $src$ "--- st(i)\hfill \strut сравнивают вершину стека с операндом-источником, который может быть регистром или операндом в памяти (коротким или длинным вещественным).
\end{tabular}
% 
% 
\begin{tabular}{c|c@{~}c@{~}c|c@{~}c@{~}c}
Условие & ZF & CF &PF	&OF& SF & AF \\\hline
$st(0)>src$ & 0 & 0 & 0 &\multirow{4}{*}{0} &\multirow{4}{*}{0}  &\multirow{4}{*}{0} \\
$st(0)<src$ & 0 & 1 & 0 &&&\\
$st(0)=src$ & 1 & 0 & 0 &&&\\
несравнимы& 1 & 1 & 1&&&
\end{tabular}
\caption{Команды, выставляющие флаги основного процессора (\Reg{eflags})}
\label{fig:fcomi}
\end{illustration}



Неиспользуемые три флага состояния \Reg{eflags} сбрасываются в~$0$; биты C0, C2,  C3 слова состояния сопроцессора не изменяются.

\endgroup


% \subsection{Условная пересылка в~стеке FPU}
% 
% \label{sec:fcmovCC}
% \index{Флаги!проверка}
% \index{Команды!условной пересылки}
% \index{Команды!сопроцессора!пересылки}
% 
% \lstinline!fcmovCC  %st(i), %st(0)! %"--- 
% 
% $st(0) := st(i)$ при %некотором условии
% некоторой комбинации флагов \Reg{eflags}
% 
% 
% \begin{tabularx}{1\linewidth}{|l|@{}c@{}|%K{7em}|
% L|}
% % {|K{6em}|X|H|}
% \hline
% \thead{Команда} 
% &
% % \thead{Условие (флаги)}  
% $
% \begin{array}{c}
% \text{\textbf{\theadfont Условие}}\\[-0.8ex]
% \text{\textbf{\theadfont (флаги)}}\\
% \end{array}
% $
% % & %\theadfont Условие (sub src, dst или \mbox{cmp  src, dst})
% % % \thead{Условие (sub src, dst или \mbox{cmp  src, dst})}
% % % \thead{Условие (арифметика)}
% % % &
% % \theadfont Условие (\mbox{cmp  src, dst}) 
% & \theadfont Условие \mbox{(f[u]comi[p] src, \%st(0))}
% \\\hline
% fcmove
% &	
% $ZF = 1$
% % &
% % %\multicolumn{2}{c|}
% % {$dst = src$}
% &
% $st(0) = src$\\\hline
% fcmovne
% &	
% $ZF = 0$
% % &
% % $dst \neq src$
% &
% $st(0) \neq src$
% % 
% \\\hline
% fcmovb/fcmovnae
% &	
% $CF = 1$
% % &
% % $dst < src$ как беззнаковое 
% &
% $st(0) < src$\\\hline
% fcmovna/fcmovbe 	
% &
% $
% \left[
% \begin{array}{l}
% CF = 1\\
% ZF = 1
% \end{array}
% \right.
% $
% % &
% % $dst \leqslant src$ как беззнаковое 
% &
% $st(0) \leqslant src$\\\hline
% fcmovnb/fcmovae
% &	
% $CF = 0$
% % &
% % $dst \geqslant src$ как беззнаковое 
% &
% $st(0) \geqslant src$\\\hline
% fcmova/fcmovnbe
% &
% $
% \left\{
% \begin{array}{l}
% CF = 0\\
% ZF = 0
% \end{array}
% \right.
% $
% % &
% % $dst > src$ как беззнаковое 
% &
% $st(0) > src$\\\hline
% fcmovu
% &	
% $PF = 1$
% &
% % Число единиц младшего байта чётно &
% $st(0)$ и~$src$ несравнимы
% \\\hline
% fcmovnu
% &	
% $PF = 0$
% &
% % Число единиц младшего байта нечётно &
% $st(0)$ и~$src$ сравнимы
% \\\hline
% 
% 
% 
% \end{tabularx}
