
\subsection{Шаблоны C++}





\begin{lstlisting}
template<typename T>
int foo(T x)
{
...
}
\end{lstlisting}

\begin{lstlisting}
template<typename T>
T bar(T x)
{
  T y = x + 12;
  ....
}
\end{lstlisting}

\begin{lstlisting}
int i = 0, j, k, n;
double x = 1, y;

j = foo(i);
k = foo(x);

n = bar(i);
y = bar(x);
\end{lstlisting}







\subsubsection{Отладочная печать с~помощью шаблонов}

% Для автоматизации отладочной печати можно воспользоваться  шаблонами. 
% Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.

Для автоматизации отладочной печати лучше реализовать её в~виде отдельной функции, чтобы упростить внесение изменений.
Назовём эту функцию  \lstinline!MemoryDump()!.
Пусть  \lstinline!MemoryDump()! получает в~качестве аргумента исследуемый объект \lstinline!x!, печатает данные о~нём в~стандартном потоке вывода и~возвращает ничего (\lstinline!void!).

Чтобы избежать приведения типа аргумента и,~соответственно, искажения данных о~нём,
необходима отдельная реализация \lstinline!MemoryDump()! для каждого возможного типа аргумента; 
при этом текст реализаций \lstinline!MemoryDump()! для различных типов аргументов будет полностью совпадать.
Для этого идеально подходит механизм \termin{шаблонов (templates).}
Эта возможность C++ позволяет определить семейство функций, которые могут работать с различными типами данных.
Так как нам нужно варьировать только тип аргумента, у~шаблона будет один параметр "--- имя типа аргумента функции:
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T ...x)
{
...
}
\end{lstlisting}

Для доступа к~памяти, где реально находится объект, необходимо передать этой функций указатель или ссылку на него.
С~точки зрения низкого уровня указатель и~ссылка "--- одно и~то же; на уровне C++ передача по ссылке позволит использовать те же синтаксические конструкции, что и~для исследования локальной переменной.
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(T &x)
...
\end{lstlisting}
Так как планируется не изменение, а~только печать аргумента, правила хорошего тона требуют для него спецификатора \lstinline!const! (соответственно, используемый в~тексте \lstinline!MemoryDump()! указатель \lstinline!p! тоже должен быть константным):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void MemoryDump(const T &x)
{
    const unsigned char *p 
        = reinterpret_cast<const unsigned char *>(&x);

    cout << "Type: " << typeid(x).name() << " Value: " << x << endl
	 << "Size: " << sizeof(x) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < sizeof(x); ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Эта функция позволяет вывести в~стандартный поток вывода байты любой переменной в~том порядке, в~котором они лежат в~памяти.
В~частности, результатом следующего кода:
\begin{lstlisting}[style=lstsmall]
int i = 1;
double d = 1;
long double ld = 1;

MemoryDump(i);
MemoryDump(d);
MemoryDump(ld);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: i Value: 1
Size: 4
Dump: 01 00 00 00 

Type: d Value: 1
Size: 8
Dump: 00 00 00 00 00 00 F0 3F 

Type: e Value: 1
Size: 12
Dump: 00 00 00 00 00 00 00 80 FF 3F 00 00 
\end{lstlisting}
Для каждого такого вызова компилятор формирует отдельную функцию "---  реализацию шаблона \lstinline!MemoryDump()! для конкретного типа аргумента.  
Такие реализации перегружают друг друга и~имеют одно имя для C++; с~точки зрения линкера разные реализации имеют разные имена, так как по-разному декорируются.

При вызове шаблонной функции  \lstinline!MemoryDump()! конкретная вызываемая реализация определяется типом передаваемого фактического параметра.
Указывать реализацию явно (например, \lstinline!MemoryDump<int>(i)!) здесь не только не нужно, но и~вредно "--- если указанный тип реализации не совпадёт с~настоящим типом передаваемого параметра, результат будет некорректен.

Для указателя данная функция выведет размер и~представление в~памяти самой переменной-указателя, а~не тот фрагмент памяти, куда он указывает.
Если необходимо напечатать именно память, на которую указывает аргумент, необходимо модифицировать функцию (\lstinline!CellCount! "--- количество ячеек типа \lstinline!T! по адресу \lstinline!px!):
\begin{lstlisting}[style=lstsmall]
template<typename T>
void PointerMemoryDump(T *px, int CellCount)
{
    const unsigned char *p
        = reinterpret_cast<const unsigned char *>(px);

    size_t BytesCount = sizeof(*px)*CellCount;

    cout << "Type: " << typeid(px).name() << " Value: " << px << endl
	 << "Size: " << sizeof(px) << endl
	 << "Dump: " << hex << uppercase << setfill('0');
    for(size_t i = 0; i < BytesCount; ++i)
    {
        cout << setw(2)<< static_cast<unsigned>(*(p+i)) << " ";
    }
    cout << dec << endl << endl;
}
\end{lstlisting}
Тогда результатом кода:
\begin{lstlisting}[style=lstsmall]
char *s = "abcdef";

MemoryDump(s);
PointerMemoryDump(s,8);
\end{lstlisting}
будет:
\begin{lstlisting}[style=lstsmall]
Type: Pc Value: abcdef
Size: 4
Dump: 08 96 04 08 

Type: Pc Value: abcdef
Size: 4
Dump: 61 62 63 64 65 66 00 54
\end{lstlisting}
% \section{Порядок выполнения лабораторной работы}
% Выполните задания, оформите отчёт и~покажите работу преподавателю.

% \section{Требования}
% \begin{enumerate}
% \item При подготовке к~работе (дома) студент должен подготовить конспект, содержащий: название
% работы, выполненные теоретически задания \ref{task:intcode}--\ref{task:char} и~тексты программы (или набора программ) для заданий \ref{task:prog:start}--\ref{task:prog:end}.
% 
% \item При выполнении работы оформите отчёт. %, дополнив конспект ответами на вопросы, которые
% указаны в~тексте соответствующих заданий (синим цветом). 
% Также проверьте, соответствуют ли
% ваши теоретические результаты практическим результатам для заданий \ref{task:intcode}--\ref{task:char}.
% % Объясните   расхождения
% 
% Объясните совпадения и~различия результатов на разных платформах.
% \end{enumerate}
