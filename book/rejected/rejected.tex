

\colorlet{csArch}{orange!70!black}
\newcommand{\terminModel}[1]{{\textcolor{csArch}{#1}}}
\newcommand{\terminComment}[1]{{\textcolor{gray}{#1}}}

\begin{tabularx}{1\linewidth}{@{}l@{~}L@{}}

\termin{4-битные:}& 4004, 4040\\

\termin{8-битные:}& 8008, 8080 \terminComment{(адрес "--- %16 или 
14),} 8085 \terminComment{(частота "--- 5 МГц)}\\

\termin{16-битные:}& \termin{8086} \terminComment{(адрес "--- 20, \termin{слово "--- 16 бит}, %отдельный 
FPU 8087),} 8088 \rlap{\terminComment{(8 бит),}}\\
&80186, 80188,\\
&80286 \terminComment{(адрес "--- 24)}\\
\termin{32-битные:}& \textcolor{clRegisterDark}{
iAPX 432 %, 80960, 80860, 
"--- не x86-совместим
}
\\
&80386DX, 80386SX\\
&80486DX \terminComment{(встроенный FPU),} 80486SX\\
\end{tabularx}

\begin{tabularx}{1\linewidth}{@{}l@{}L@{}}
&Pentium (P5, P54, P54C, \terminComment{данные "--- 64}), Pentium MMX\\
&Pentium Pro, Pentium II \terminModel{(Klamath, Deschutes)}, Celeron \terminModel{(Covington, Mendocino)},\\
&Pentium III (SSE, \terminModel{Katmai, Coppermine, Tualatin}), Celeron \terminModel{(Coppermine, Tualatin)}...\\
\end{tabularx}
\\
\includegraphics[width=1\linewidth,keepaspectratio,valign=t]{IntelProcessorRoadmap}




\begin{equation}
\label{eq:command:mod00}
\text{Адрес} = 
\left\{
\begin{array}{ll}
Displacement, &R/M = 101 \\%(bp)\\
\zeta, & R/M \neq 101
\end{array}
\right.
\end{equation}


\begin{equation}
\label{eq:command:zeta}
\zeta = 
\left\{
\begin{array}{ll}
Base, & R/M = 100, Index = 100\\
2^{Scale} \cdot Index, & R/M = 100, Mod=00, Base = 101\\
Base + 2^{Scale} \cdot Index, & R/M = 100, \text{иначе}\\
Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}









\begin{equation}
\label{eq:command:baseonly-displacementonly}
\text{Адрес} = 
\left\{
\begin{array}{ll}
Displacement, &R/M = 101 \\%(bp)\\
2^{Scale} \cdot Index + Displacement, & R/M = 100, Mod=00, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}


При $Mod=00$ это косвенная адресация без смещения (кроме одного специального случая%~\eqref{eq:command:displacement-only}
, когда, наоборот, остаётся только смещение).
Поле $R/M$  "--- номер базового регистра, значения $100$ и~$101$ (соответствующие в~таблице~\ref{tab:command:reg} регистрам~$sp$ и~$bp$) считаются специальными:
\begin{equation}
\label{eq:command:baseonly-displacementonly}
\text{Адрес} = 
\left\{
\begin{array}{ll}
Displacement, &R/M = 101 \\%(bp)\\
Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}

Значения поля $Mod$ $01$ и~$10$ показывают наличие поля $Displacement$ различной длины, содержащего смещение.
\begin{equation}
\label{eq:command:base+displacement}
\text{Адрес} = 
\left\{
\begin{array}{ll}
Base + 2^{Scale} \cdot Index + Displacement, & R/M = 100\\
Base + Displacement, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}

Значение $R/M=100$, соответствующее номеру $sp$, трактуется как специальное:
после байта $Mod~R/M$ следует байт~$SIB$.
Первые два его бита "--- масштаб "--- целое число $Scale \in [0, 3]$.



В~этом случае адрес операнда  может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Displacement
\end{equation}
где $Scale$ "--- масштаб "--- константа,
$\Reg{Base}$ и~$\Reg{Index}$ "--- регистры "--- поля байта~$SIB$. 


($Mod=$)
.

Поле $R/M$ в~совокупности с~последующими "--- $SIB$ и~$Displacement$
задают операнд, который может быть как регистром, так и~переменной в~памяти.
%, в~зависимости от поля $Mod$, 
может задавать номер регистра, где находится второй (правый) операнд (при $Mod=11$),
либо номер регистра $Base$ для %классической 
косвенной адресации со смещением: %, где находится адрес, 
% тогда адрес операнда
\begin{equation}
\label{eq:command:rm}
\text{Адрес} = \Reg{Base} + Displacement
\end{equation}
Частным случаем~\eqref{eq:command:rm} является 
прямая адресация.
% Определённая комбинация 
При определённом значении поля ($R/M=100$ и~$Mod\neq11$)
после байта $Mod~R/M$ следует байт~$SIB$.
% В~системе команд x86 косвенная адресация может включать до четырёх компонент адреса (косвенная базовая индексная адресация со смещением):
В~этом случае адрес второго операнда  может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Displacement
\end{equation}
где $Scale$ "--- масштаб "--- константа,
$\Reg{Base}$ и~$\Reg{Index}$ "--- регистры "--- поля байта~$SIB$. 
% Эти три компоненты задаются полем $R/M$ байта $Mod~R/M$ и~байтом~$SIB$. % (последний используется, если база).
$Displacement$ "--- смещение, заданное соответствующим полем.
% Частными случаями~\cite{eq:command:addressing} являются 
% Частным случаем~\eqref{eq:command:addressing} является 
% прямая адресация.

Подробно формат команды описан в~официальной документации~\cite{intelInstructionSet} и~у~исследователей кода~\cite{nezumi-disasm}.
% Описание формата  изобилует оговорками и~
% При этом практически в






(кроме одного специального случая~\eqref{eq:command:displacement-only}, когда, наоборот, остаётся только смещение), 
\begin{equation}
\label{eq:command:modbase}
\text{Адрес} = \Reg{Base}, ~~\text{где}~Base = R/M = A, B, C, D, si, di
\end{equation}
значения поля $Mod$ $01$ и~$10$ показывают наличие поля $Displacement$ различной длины, содержащего смещение.
\begin{equation}
\label{eq:command:rm}
\text{Адрес} = \Reg{Base} + Displacement
\end{equation}
номер регистра  $Base$ при этом находится в~поле $R/M$.

При $Mod=00$ значение $R/M$, соответствующее номеру $bp$, трактуется как специальное:
\begin{equation}
\label{eq:command:displacement-only}
\text{Адрес} = Displacement
~~\text{при}~
\left\{
\begin{array}{ccl}
Mod&=&00\\
R/M&=&101 (bp)\\
\end{array}
\right.
\end{equation}
Частным случаем~\eqref{eq:command:modbase} является 
прямая адресация.





Значение $R/M=100$, соответствующее номеру $sp$, трактуется как специальное:
после байта $Mod~R/M$ следует байт~$SIB$.
В~этом случае адрес второго операнда  может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Displacement
\end{equation}
где $Scale$ "--- масштаб "--- константа,
$\Reg{Base}$ и~$\Reg{Index}$ "--- регистры "--- поля байта~$SIB$. 


($Mod=$)
.

Поле $R/M$ в~совокупности с~последующими "--- $SIB$ и~$Displacement$
задают операнд, который может быть как регистром, так и~переменной в~памяти.
%, в~зависимости от поля $Mod$, 
может задавать номер регистра, где находится второй (правый) операнд (при $Mod=11$),
либо номер регистра $Base$ для %классической 
косвенной адресации со смещением: %, где находится адрес, 
% тогда адрес операнда
\begin{equation}
\label{eq:command:rm}
\text{Адрес} = \Reg{Base} + Displacement
\end{equation}
Частным случаем~\eqref{eq:command:rm} является 
прямая адресация.
% Определённая комбинация 
При определённом значении поля ($R/M=100$ и~$Mod\neq11$)
после байта $Mod~R/M$ следует байт~$SIB$.
% В~системе команд x86 косвенная адресация может включать до четырёх компонент адреса (косвенная базовая индексная адресация со смещением):
В~этом случае адрес второго операнда  может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = \Reg{Base} + 2^{Scale} \cdot \Reg{Index} + Displacement
\end{equation}
где $Scale$ "--- масштаб "--- константа,
$\Reg{Base}$ и~$\Reg{Index}$ "--- регистры "--- поля байта~$SIB$. 
% Эти три компоненты задаются полем $R/M$ байта $Mod~R/M$ и~байтом~$SIB$. % (последний используется, если база).
$Displacement$ "--- смещение, заданное соответствующим полем.
% Частными случаями~\cite{eq:command:addressing} являются 
% Частным случаем~\eqref{eq:command:addressing} является 
% прямая адресация.

Подробно формат команды описан в~официальной документации~\cite{intelInstructionSet} и~у~исследователей кода~\cite{nezumi-disasm}.
% Описание формата  изобилует оговорками и~
% При этом практически в





1938 "--- механическая счётная машина Z1 Конрада Цузе, Германия, была использована уже двоичная система счисления.
Для ввода-вывода данные преобразовывались в~десятичный вид.

1939 "--- усовершенствованный вариант вычислителя Цузе, Z2 на основе телеграфных реле.

1941 "--- Z3

% http://wiki.livid.pp.ru/students/cs/lectures/1.html
% В~механической счётной машине Z1 Конрада Цузе (1938~г.) была использована уже двоичная система счисления.
% Это позволило существенно уменьшить размеры устройства.
% Усовершенствованный вариант вычислителя Цузе, Z2 на основе телеграфных реле (1939),  закрепил использование двоичной логики.



1943 "--- ЭНИАК (ENIAC, Electronic Numerical Integrator and Computer) на  вакуумных лампах и десятичной СС
% Эниак иногда называют первой ЭВМ, но он не являлся вычислительной машиной (компьютером) в~современном понимании, так как не программировался.

% 
% Реле может находиться только в~двух состояниях "--- оно открыто либо закрыто.
% Именно в~электромеханическом реле в~Mark II (1946), согласно легенде, был обнаружен первый баг.

1943--1950 "--- Z4 на реле, первый ЯВУ (Планкалкюль)

1946  первый баг,  Mark 2, Гарвард

1952~г. Первый компилятор, {A-0}

1954~г.
ПП-1

1957~г.
Фортран
APL

1958~г.
Алгол
Lisp, 


1959~г.  Кобол, США

1959~г. троичная ЭВМ Сетунь, МГУ
% https://habrahabr.ru/company/ua-hosting/blog/273929/

1967-1969 троичная ЭВМ Сетунь-70
язык ДССП "--- одно слово программы соответствует одному слову кода. 

1968 Паскаль


2000 компилятор Планкалкюль

% https://habrahabr.ru/company/ua-hosting/blog/273929/
% С 2008 года в университете « California Polytechnic State University of San Luis Obispo» функционирует цифровая компьютерная система TCA2, основанная на троичной системе счисления.
2008 "--- троичная ЭВМ TCA2, Калифорнийский политехнический университет




\chapter{Краткий обзор уровней современной ВС }
\nsection{Контрольные вопросы}

\includegraphics[width=\approvedImageWidth,valign=t]{multi-level-abstract}



\includegraphics[width=\approvedImageWidth,valign=c]{multi-level-asm}


\includegraphics[width=\approvedImageWidth,valign=c]{Layered_computer_structure}


Сигналы и~вентили

\newcolumntype{Y}{>{$}C<{$}}
\newcolumntype{Z}{>{\columncolor{csMarker}}Y}
\begin{tabularx}{1\linewidth}{YY|YZZ|YYY}
a 	&	b &	\lnot a 	&	\overline{a \land b} 	&	\overline{a \lor b} & a \land b 	&	a \lor b & a \oplus b\\\hline
0 	&	0 	&\multirow{2}{*}{$1$}&	1         	&	1         &0         	&	0         &	0\\
0 	&	1 	&		&	1         	&	0         &0         	&	1         &	1\\\hline
1 	&	0 	&\multirow{2}{*}{$0$}&	1         	&	0         &0         	&	1         &	1\\
1 	&	1 	&		&	0         	&	0         &1         	&	1         &	0\\\hline
\end{tabularx}



\subsection{%Микроархитектура %процессора 
Структура
Intel 8008
и~Core2}

\begin{tabularx}{1\linewidth}{@{}l@{\,}l@{}}
% \includegraphics[width=0.7\linewidth,valign=c]{data-path}


\includegraphics[width=0.595\linewidth,keepaspectratio,valign=c]{Intel_8008_arch}\centering
&

\includegraphics[width=0.395\linewidth,keepaspectratio,valign=c]{Intel_Core2_arch}
\end{tabularx}



\subsection{Магистрали}
% \subsection{Макроархитектура}
% \subsection{Функциональная схема компьютера}
% \begin{frame}{\insertsubsection}
% \footnotesize
% {
% \includegraphics[height=\slideheigth,valign=t]{func-comp}\centering
% 
% }
% 
% \end{frame}


\resizebox{0.8\linewidth}{!}{
\input{book/drawings/arch-bus-controllers}
}

\section{С плавающей точкой}


Если рассматривать вещественное число $X$ в~виде~\eqref{eq:digits:position-exponentiation-realsweaexsdd},
мантисса нормализованного представления $X$ включает 
% все двоичные цифры, начиная со старшей ненулевой цифры $x_k$ (так как двоичные цифры могут принимать только значения $0$ и~$1$, $x_k=1$),
все цифры, начиная со старшей ненулевой,
а~порядок 
на единицу больше  степени основания~$N$ в~\eqref{eq:digits:position-exponentiation-realsweaexsdd} при этой старшей ненулевой цифре.
% равен~$w+1$.

% \begin{equation}
% % \label{eq:digits-floatpoint-position}
% \begin{array}{c}
% X = \overline{x_k \ldots x_1 x_0,x_{-1}\ldots} 
% = x_k\cdot 2^w + \ldots + x_1\cdot 2 + x_0 + \dfrac{x_{-1}}{2} + \ldots  = \\[2ex]
% = 2^{w+1}\cdot \left( \dfrac{x_k}{2} + \ldots + \dfrac{x_1}{2^w} + \dfrac{x_0}{2^{w+1}} + \dfrac{x_{-1}}{2^{w+2}} + \ldots  \right) = \\[2ex]
% = 2^{w+1}\cdot\overline{0, x_k \ldots x_1 x_0x_{-1}\ldots}, ~~ 0\leqslant x_i < 2 ~\text{"--- целые}, x_k \neq 0
% \end{array}
% \end{equation}
% При переходе к~\eqref{eq:digits-floatpoint-def} запятая сместилась от~разряда $x_{-1}$ к~$x_k$.
Таким образом, в~нормализованном представлении десятичная или двоичная  запятая в~мантиссе всегда стоит перед старшей ненулевой цифрой.
При обратном переходе от~нормализованного представления~\eqref{eq:digits-floatpoint-def} к~позиционному~\eqref{eq:digits:position-exponentiation-realsweaexsdd}  запятая сместится от начала мантиссы 
% к~$p=w+1$ (начиная от старшего) разряду $x_{0}$.
к~разряду~$p$ (начиная от старшего). 
В~зависимости от значения порядка  запятая в~мантиссе может быть поставлена после любого разряда, поэтому представление 
вещественного числа в~виде комбинации знака, порядка и~мантиссы называется представлением с~плавающей запятой (в~западных источниках "--- с~плавающей точкой).

После нормализации мантисса округляется до заданной длины.

Но, так как порядок $p$ кодируется конечным числом бит, он может принимать только ограниченный диапазон значений.
\begin{equation}
p_{min} \leqslant p \leqslant p_{max}
\end{equation}
Соответственно, и~диапазон представимых в~нормализованном виде чисел также ограничен.
% 
Значения, большие максимального нормализованного числа, невозможно представить в~формате с~плавающей запятой.
% 
Некоторые значения, меньшие минимального нормализованного числа, могут быть представлены %в~денормализованном виде:
в~форме~\eqref{eq:digits-floatpoint-def} с~$p = p_{min}$ и~$\mu < 0,1_N$.
Такие числа называются денормализованными.
% \begin{equation}
% X = (-1)^{s} \cdot 2^{p} \cdot \mu, ~~ s \in \{0, 1\}, p \in \Integerset, 0 \leqslant \mu < 0,1
% \end{equation}


В~частности, рассмотрим нормализацию двух чисел в~десятичной системе счисления:
\begin{equation}
\begin{array}{c}
512,12 = 0,51212 \cdot 10^3\\
0,0017 = 0,17 \cdot 10^{-2}
% 512,12\ldots = 0,51212\ldots \cdot 10^3\\
% 0,0017\ldots = 0,17\ldots \cdot 10^{-2}
\end{array}
\end{equation}
и в~двоичной:
\begin{equation}
\begin{array}{c}
1000000000,0001111\ldots = 0,10000000000001111\ldots \cdot 2^9\\
% 0,00000000011011 = 0,11011 \cdot 2^{-9}
  0,00000000011011110110100\ldots
 = 0,11011110110100\ldots \cdot 2^{-9}
\end{array}
\end{equation}


Вещественные числа, 
(Согласно стандарту двоичной арифметики с~плавающей точкой IEEE 754~\cite{ieeeFloat1985rus, ieeeFloat2008},
% представляются в~виде знака, экспоненты (порядка) и~мантиссы
рис.~\ref{ris:ieee754_1}).


% Это представление основано на двоичной экспоненциальной форме вещественного числа $F$, то есть:
Число $F$ представляется в~двоичной экспоненциальной форме "--- в~виде произведения трёх компонент:
\begin{itemize}
\item знак ($+1$ или $-1$);
\item двойка в~некоторой степени~$\epsilon$, называемой \emph{порядком}, или экспонентой; %(порядок "--- зна);
% (для записи очень маленьких чисел порядок должен быть отрицательным);
\item \emph{мантиссы $\mu$} "--- двоичной дроби $1 \leqslant \mu <2$, то есть $\mu = 1,\beta_1\beta_2\beta_3\ldots\beta_n$, где $\beta_i$ "--- двоичный разряд.
\end{itemize}
$$
F = (-1)^{\sigma} \cdot 2^{\epsilon} \cdot \mu
% \big( 1,\beta_1\beta_2\beta_3\ldots\beta_n \big)
$$
В~такой форме можно представить любое конечное число, кроме нуля.

Старший бит (S) "--- бит знака, если $S=0$ "--- число положительное, если $S=1$ "--- число отрицательное.
Следующие $b$ бит отводятся под  порядок, смещённый на $2^{b-1} - 1$ (то есть 
знаковое значение порядка представляется не дополнительным кодом, а~кодом с~избытком:
% для отр
порядок~$0$ представляется числом $2^{b-1} - 1$,
% отрицательные порядки представляются малыми беззнаковыми числами
порядок~$-2^{b-1}+1$ "--- нулём%
).
% S - бит знака, если S=0 - положительное число; S=1 - отрицательное число
% E - смещенная экспонента двоичного числа;
% exp2 = E - (2(b-1) - 1) - экспонента двоичного нормализованного числа с плавающей точкой
% (2(b-1) -1) - заданное смещение экспоненты (в 32-битном ieee754 оно равно +127 см.выше)
Оставшиеся $n$ бит кодируют $M$ остаток мантиссы двоичного нормализованного числа с плавающей точкой (мантиссу без ведущей единицы).

Таким образом, значение вещественного числа (рис.~\ref{ris:ieee754_1}) для всех комбинаций битов, кроме исключительных (таблица~\ref{tab:ieee754-singular})   вычисляется по формуле:
\begin{illustration}
\includegraphics[width=\approvedImageWidth]{ieee754_1}
\caption{Представление числа в формате IEEE 754}
\label{ris:ieee754_1}
\end{illustration}
$$
F = (-1)^S \cdot 2^{E - 2^{b-1} + 1} \cdot \left( 1 + \dfrac{M}{2^n}\right)
$$

\begin{table}

\caption{Исключительные значения представления IEEE 754}
\label{tab:ieee754-singular}
\begin{tabular}%{l>{$}l<{$}}
{ll}
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+0} & $+0$\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-0} & $-0$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754den} & денормализованные числа \\
\\\hline
\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+inf} & $+\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-inf} & $-\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754nan} & $NaN$ (нечисла) \\
\end{tabular}
\end{table}

% Денормализованные числа. Это числа, мантиссы которых лежат в диапазоне 0.1 <= M <1.

Денормализованные числа находятся ближе к нулю, чем наименьшие по модулю нормализованные. 
% Их мантиссы (при минимально возможном по)
% 
% Денормализованные числа как бы разбивают минимальный разряд нормализованного числа на некоторое подмножество. Сделано так потому, что в технической практике чаще встречаются величины близкие к нулю. 

Стандарт %двоичной арифметики с~плавающей точкой
IEEE 754-2008 описывает
%  \begin{itemize}
% \item 
три двоичных вещественных формата разрядностью 32, 64, и 128 бита. %;
% \item два двоично-десятичных формата "--- 64 и~128 бита.
% \end{itemize}
% 
Более старый вариант этого стандарта    IEEE 754-1985 определяет также формат с~двойной расширенной точностью (double-extended precision) $\geqslant$ 79 бит. % (обычно используют 80 бит).
\index{Представление данных!вещественных!расширенной точности}

\begin{illustration}
\includegraphics[width=\wideImageWidth]{ieee754_32}\\
a)\\

\includegraphics[width=\wideImageWidth]{ieee754_64}\\
б)
\caption{Формат чисел а) одинарной (single-precision, 32 бита)  и~б) двойной точности (double-precision, 64 бита)}
\label{ris:ieee754_32}
\end{illustration}


\resizebox{0.8\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=16ex,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]


\node[file,on chain=cpp] (prog1_s) {prog.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog.o};
\node[stage,on chain=cpp] (linker) {Компоновщик};

  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);


\end{tikzpicture}
}






\warning{ 
Внимание!

Ассемблер Unix исторически использовал для некоторых команд FPU \emph{в~некоторых ситуациях} обратное расположение операндов.
% \footnote{Использованы:
%  The Trouble With FSUB 
%  }.
% http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html
% http://sourceware.org/binutils/docs/as/i386_002dBugs.html

% Таким образом, в~GAS мнемоникам \lstinline!fsub! и~\lstinline!fdiv! соответствуют опкоды, которые согласно документации Intel и~большинству учебников описаны как 
% \lstinline!fsubr! и~\lstinline!fdivr! соответственно (и~наоборот).
% не всегда

Таким образом, в~GAS поведение мнемоник несимметричных операций (\lstinline!fsub!/\lstinline!fsubr! и~\lstinline!fdiv!/\lstinline!fdivr!)
% в~том случае, когда источник~$src$ и~приёмник~$dst$ оба являются регистрами,
качественно иное, чем описанное в~документации Intel и~большинстве учебников.
}

% Именно, с
Согласно документации Intel (и~в~ассемблерах с~синтаксисом Intel) прямое вычитание~\lstinline!fsub! 
% в~таком случае
всегда, в~том числе
в~случае, когда $src$ и~$dst$ являются регистрами,
 вычисляет $dest - src$, а~обратное~\lstinline!fsubr!  "--- $src-dest$, то есть результаты команд \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)!
 не только записываются в~различные регистры, но и~отличаются знаком.

В~GAS, в~соответствии с~традиционным поведением Unix-ассемблеров, \lstinline!fsub! 
\label{sec:fpu-trouble-with-fsub}
% в~таком случае 
для двух регистров
вычисляет $st(0) - st(i)$ независимо от того, какой из этих регистров является приёмником (в~частности, команды \lstinline!fsub %st(0), %st(i)! и~\lstinline!fsub %st(i), %st(0)! вычисляют одно и~то же значение, но помещают его в~разные регистры). 
Обратное вычитание~\lstinline!fsubr! вычисляет $st(i) - st(0)$.

% Соответственно, шесть форм команды прямого вычитания \lstinline$fsub$ и~обратного вычитания \lstinline$fsubr$ в~GAS действуют, % следующим образом.
% как показано в~таблице~\ref{tab:fpu-fsub-r-typelist}.
% 
% \begin{table}[!ht]
% \caption{Прямое и~обратное вычитание в~синтаксисе \Att}
% \label{tab:fpu-fsub-r-typelist}
% 
% \small
% \def\normalsize{\small}
% 
% \LTXtable{\textwidth}{book/tables/fpu-fsub-r-typelist.tex}
% 
% \end{table}


Таким образом, команде 
% \lstinline!fsub %st(0), %st(1)!
% (или любой иной записи, где приёмником будет $st(1)$, в~частности, просто \lstinline!fsub!)
\lstinline!fsub[p] %st(0), %st(i)!
соответствует опкод, который, согласно документации Intel, должен соответствовать команде \lstinline!fsubr!~\cite{trouble-with-fsub}.
Анализ сгенерированного компилятором из коллекции GCC кода это подтверждает.
Аналогично ведут себя \lstinline!fdiv!/\lstinline!fdivr!.

Приёмником, в~соответствии с~синтаксисом \Att, является второй аргумент.
Если команда вызывается с~одним аргументом или без них, то приёмником является $st(0)$, что соответствует документации Intel.
Таким образом,
% Соответственно, 
шесть форм несимметричных операций (вычитания и~деления) в~GAS действуют, % следующим образом.
как показано в~таблице~\ref{tab:fpu-att-r-typelist}.

\begin{table}[!ht]

\small
\def\normalsize{\small}

\LTXtable{\textwidth}{book/tables/fpu-att-r-typelist.tex}

\end{table}




\subsubsection{Флаги сравнения}
% \subsubsection{Сравнение вещественных чисел}

Если при сравнении целых чисел выставляется значение %флагов из того же набора,
тех же флагов, которые выставляются по результатам арифметических действий,
то в~FPU %флаги сравнения и~флаги, выставляемые при вычислениях, разделены.
% Арифметические и~трансцендентные команды влияют на флаги исключительных ситуаций;
% команды сравнения "--- на специальную группу флагов.
флаги, выставляемые командами сравнения, отличаются от тех, что устанавливаются, в~частности, при вычитании.

Команды сравнения выставляют значения трёх флагов в~соответствии с~результатом сравнения $st(0)$ и~$src$ (знаком разности~$st(0)-src$):
флаг отрицательности, флаг нуля и~флаг несравнимости (таблица~\ref{tab:fpu-cmp-flags}).


\begin{table}[!ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-flags.tex}
\end{table}

По набору используемых флагов команды сравнения делятся на две группы "--- часть их выставляет биты слова состояния~$sw$ ($C3, C0$ и~$C2$),
часть "--- биты регистра~$flags$ ($CF, ZF$ и~$PF$).


Команды сравнения оригинального FPU 8087 (\texttt{fcom, fcomp, fcompp, ftst}) и~добавленное в~сопроцессоре 80387 семейство команд неупорядоченного сравнения (\texttt{fucom, fucomp, fucompp})
% , не генерирующее исключений при сравнении некоторых нечисел, 
сохраняют результат сравнения в~биты $C3, C0$ и,~в~случае несравнимости операндов, в~бит~$C2$ слова состояния.



% \pagebreak[3]
Для анализа результата сравнения вещественных чисел в~ранних (отдельных) моделях сопроцессора было необходимо вручную перенести его в~регистр флагов $flags$ основного процессора.  
\index{Флаги!установка}
\pagebreak[3]

В~таблице~\ref{tab:fpu-status} представлено краткое описание структуры слова состояния, а~также соответствие старшего байта слова состояния сопроцессора $sw$ и~младшего байта регистра флагов основного процессора~$flags$.

% \colorlet{csControl}{green!50}
% \colorlet{csExceptionStatus}{green!7!yellow!7!white}
% \colorlet{csSystem}{blue!20!red!10}


\begin{table}[!ht]
\caption{Слово состояния FPU}
\label{tab:fpu-status}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}c@{~}|l@{~}|L@{~}|c@{~}|l@{~}|l@{~}}
% № 	& 	&Название 	\\\hline
\multicolumn{3}{c}{$sw$}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}0 	&IE 	& Недействительная операция %(#I)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}1 	&DE 	& Денормализованный операнд %(#D)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}2 	&ZE 	& Деление на ноль %(#Z)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}3 	&ОЕ 	& Переполнение %(#O)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}4 	&UE 	& Антипереполнение %(#U)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}5 	&РЕ 	& Неточный результат %(#P)	
&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}6 	&SF 	& Стековая ошибка	&\multicolumn{3}{c}{\cellcolor{white}}\\\hhline{---~~~}
\rowcolor{clFlagExceptionStatus}7 	&ES 	& Бит суммарной ошибки&\multicolumn{3}{c}{\cellcolor{white}$flags$, f(n)stsw + sahf} %&&\multirow{-8}{*}{f(n)stsw/sahf}&
\\\hline
\rowcolor{clFlagStatus}8 	&C0 	&&0 	&CF 	&Carry Flag\\\hline
\rowcolor{clFlagStatus}9 	&C1 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}10 	&C2 	&&2 	&PF 	&Parity Flag\\\hline
\rowcolor{clFlagSystem}11 	& 	&&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\%\hhline{-~~---}
\rowcolor{clFlagSystem}12 	& 	&&\cellcolor{clFlagStatus}4 	&\cellcolor{clFlagStatus}AF 	&\cellcolor{clFlagStatus}Auxiliary Carry Flag\\
\rowcolor{clFlagSystem}13 	&\multirow{-3}{*}{TOP} 	&\multirow{-3}{*}{Указатель вершины стека сопроцессора}&\multicolumn{3}{c}{{\cellcolor{white}}игнорируется}\\\hline
\rowcolor{clFlagStatus}14 	&C3 	& 	&6 	&ZF 	&Zero Flag\\\hline
\rowcolor{clFlagExceptionStatus}15 	&В 	&Дублирует ES	&7 	&SF 	&Sign Flag \\\hline
\end{tabularx}
\end{table}

Это выполнялось в~два этапа:
\begin{itemize}
\item 
% \index{Команды!fstsw}
\index{Команды!fnstsw}
\index{Команды!sahf}
слово состояния $sw$ выгружалось в~регистр $ax$ 
% командами \lstinline!fstsw! (проверяет на наличие отложенных необработанных исключений) или~\lstinline!fnstsw! (также данные команды могут выгрузить $sw$  в~память);
командой~\lstinline!fnstsw!;
\item старший байт $ax$ загружался в~младший байт регистра флагов $flags$ командой \lstinline!sahf!.
\end{itemize}
\pagebreak[3]
%слово состояния $sw$ могло быть выгружено в~память или регистр $ax$ командами fstsw (проверяет на наличие отложенных необработанных исключений) и~fnstsw. После выгрузки $sw$ в~регистр $ax$ его старший байт загружал

После этого флаги $C3$ и~$C0$ помещались в~биты $ZF$ и~$CF$, а~бит $C2$ "--- в~бит~$PF$. 
Другие флаги младшего байта~$flags$ получали фактически неопределённое значение.

В~настоящее время такой способ также доступен в~силу преемственности набора команд x86, но неоптимален. 
Начиная с~Pentium Pro, доступен более быстрый вариант.
% 
Современные процессоры включают команды сравнения с~суффиксом~\lstinline!i! (\texttt{fcomi, fcomip, fucomi, fucomip}), которые напрямую устанавливают флаги $ZF, CF, PF$ в~$flags$.
Эти команды не изменяют биты $C0,  C3, C2$ регистра~$sw$.
% и~не дублируют туда результат сравнения.


Таким образом, после выполнения команды сравнения (%и~%пары команд 
% \lstinline!fstsw %ax + sahf! %в~ранних моделях %сопроцессоров  
% или при использовании совместимых с~ними 
при использовании совместимых с~ранними моделями 
команд %f*com[p[p]]
без суффикса~\lstinline!i! 
необходимы также \lstinline!fnstsw %ax! + \lstinline!sahf!)
результат  можно 
анализировать как результат сравнения беззнаковых целых чисел.
% 

\subsubsection{Команды сравнения}
% \footnote{Использованы материалы \texttt{club155.ru}}
% нельзя \url, два раза подряд не собирается

\index{Команды!сравнения!вещественных чисел}
\index{Команды!сопроцессора!сравнения}

\newcommand{\farg}[1]{\textbf{\textcolor{green!30!black}{#1}}}

В~таблице~\ref{tab:fpu-cmp-list} приводится сводная информация по семействам команд сравнения FPU.

\begin{table}[ht]
\small\def\normalsize{\small}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\LTXtable{\textwidth}{book/tables/fpu-cmp-list.tex}
\end{table}

Все команды сравнения вещественных чисел~\cite{club155} сравнивают вершину стека "--- приёмник $st(0)$ с~другим операндом (источником $src$).
По результатам сравнения  (в~соответствии со знаком разности~$st(0)-src$) устанавливается значение трёх флагов
% флаг отрицательности, флаг нуля и~флаг несравнимости 
в~соответствии с~таблицей~\ref{tab:fpu-cmp-flags}.
Действие команд сравнения одинаково для синтаксиса AT\&T и~синтаксиса Intel.

Мнемоника может включать суффикс~\lstinline!p!, в~этом случае приёмник~$st(0)$ после сравнения выталкивается из стека.
Если явный операнд не задан (то есть источником считается~$st(1)$), может также использоваться суффикс \lstinline!pp! "--- в~этом случае после сравнения из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$.

Если источник задан явно и~находится в~памяти, необходимо указывать также суффикс размера по тем же правилам, что и~для арифметических команд.

Если одно из сравниваемых значений "--- нечисло,
для б\'{о}льшей части команд сравнения (без префикса~\lstinline!u!) это недействительная арифметическая операция \#IA.
Если это исключение не замаскировано, работа программы прерывается, так что флаг несравнимости не устанавливается.

Команды неупорядоченного сравнения, мнемоники которых включают префикс~\lstinline!u! после префикса FPU~\lstinline!f!,
не генерируют исключений при сравнении некоторых нечисел,  в~частности, вещественной неопределённости.

??? Удалить до конца раздела  ???

\subsubsection{Команды, устанавливающие флаги сопроцессора}

Команды сравнения, унаследованные от ранних (дискретных) моделей сопроцессора, выставляют по результатам сравнения биты $C0, C2, C3$ слова состояния сопроцессора (рис.~\ref{fig:fcom}).
% Бит~$C3$ взводится в~случае равенства операндов, бит~$C0$ "---  в~случае $st(0) < src$.
% % ; бит C2 в~этих случаях равен $0$. 
% Если операнды несравнимы, взводится бит~$C2$, а~также оба бита $C0$ и~$C3$.


\begin{illustration}

$\left.
\begin{tabular}{l@{}l}
$src$ "--- st(i) или в~памяти & 
$\left\{\begin{tabular}{@{}r@{}}
\termin{fcom[p[p]]} \farg{[src]}\\
\termin{fucom[p[p]]} \farg{[src]}
\end{tabular}\right.$\\
$src$ "--- целое в~памяти & \termin{ficom[p]} \farg{src}\\
$src = 0$ & \termin{ftst}
\end{tabular}
\right\}$
% 
\begin{tabular}{c|@{~}c@{~}c@{~}c}
Условие & C0 & C3 &C2\\\hline
$st(0)>src$ & 0 & 0 & 0 \\
$st(0)=src$ & 0 & 1 & 0 \\
$st(0)<src$ & 1 & 0 & 0 \\
несравнимы& 1 & 1 & 1
\end{tabular}

{
\termin{fnstsw + sahf:} $C0, C3, C2$ $\to$ $CF, ZF, PF$.
\centering

}

\caption{Команды, выставляющие флаги сопроцессора ($sw$)}
\label{fig:fcom}
\end{illustration}


К командам, помещающим результат в~слово состояния сопроцессора, относятся:
\begin{description}
\item[fcom] %Семейство команд сравнения.
Источник может быть указан явно (\lstinline!fcom %st(i)!, \lstinline!fcom smem!) или не указан (\lstinline!fcom!, находится в~$st(1)$). Источник в~памяти может иметь одинарную~или двойную точность.

% Команда может иметь формы \lstinline!fcom [src]! (из стека ничего не выталкивается), \lstinline!fcomp [src]! (из стека выталкивается $st(0)$), \lstinline!fcompp! (из стека выталкиваются оба операнда, $st(0)$ и~$st(1)$).

\item[fucom] Семейство команд, аналогичное \lstinline!fcom!. Отличается тем, что при сравнении тихих нечисел не генерируется исключений. 
% Сравнение чисел выполняется аналогично

\item[ficom] Источник "--- целое число (16 или 32 бита), находится в~памяти и~должен быть указан явно (\lstinline!ficom mem!).
Команда может иметь формы \lstinline!ficom src! (из стека ничего не выталкивается) и~\lstinline!ficomp src! (из стека выталкивается $st(0)$).
Если $st(0)$ "--- нечисло, генерируется исключение и~выставляются флаги, как для несравнимых значений.

\item[ftst] Источник равен нулю. Действие аналогично \lstinline!fcom!.

\end{description}

??? Удалить до конца подраздела как повторение ???


Так как условные команды, в~частности, команды условной пересылки регистров сопроцессора \lstinline!fcmovCC!, используют флаги $flags$, а~не слово состояния сопроцессора,
% 
после выполнения команд сравнения этой группы необходимо перенести результат сравнения в~$flags$ парой команд \lstinline!fnstsw %ax! + \lstinline!sahf!.

После этого значение $C3$ помещается в~аналогичный ему по смыслу флаг нуля $ZF$ ($st(0) - src = 0$), $C0$ "--- в~флаг переноса~$CF$ ($st(0) - src < 0$),
то есть результат можно анализировать как результат сравнения беззнаковых целых чисел.
Бит несравнимости $C2$ попадает на место флага чётности~$PF$. 


\subsubsection{Команды, устанавливающие флаги CPU}
\index{Флаги!установка}

Современные процессоры включают два семейства команд сравнения, напрямую выставляющие флаги $ZF, CF, PF$ (рис.~\ref{fig:fcomi}).

\begin{illustration}

\begin{tabular}{r}
\termin{fcomi[p]} \farg{src, \%st(0)}\\
\termin{fucomi[p]} \farg{src, \%st(0)}\\
% $src$ "--- st(i)\hfill \strut сравнивают вершину стека с операндом-источником, который может быть регистром или операндом в памяти (коротким или длинным вещественным).
\end{tabular}
% 
% 
\begin{tabular}{c|c@{~}c@{~}c|c@{~}c@{~}c}
Условие & CF & ZF &PF	&OF& SF & AF \\\hline
$st(0)>src$ & 0 & 0 & 0 &\multirow{4}{*}{0} &\multirow{4}{*}{0}  &\multirow{4}{*}{0} \\
$st(0)=src$ & 0 & 1 & 0 &&&\\
$st(0)<src$ & 1 & 0 & 0 &&&\\
несравнимы& 1 & 1 & 1&&&
\end{tabular}
\caption{Команды, выставляющие флаги основного процессора ($flags$)}
\label{fig:fcomi}
\end{illustration}

\begin{description}
\item[fcomi] %Семейство команд сравнения.
Источник должен находиться в~стеке сопроцессора, при этом и~источник, и~приёмник $st(0)$ должны быть указаны явно (\lstinline!fcomi %st(i), %st(0)!).

Команда может иметь формы \lstinline!fcomi %st(i), %st(0)! (из стека ничего не выталкивается) и~\lstinline!fcomip %st(i), %st(0)! (из стека выталкивается $st(0)$).

\item[fucomi] Отличается от \lstinline!fcomi! тем, что при сравнении тихих нечисел не генерируется исключений. 
\end{description}




Неиспользуемые три флага состояния $flags$ сбрасываются в~$0$; биты $C0, C2,  C3$ слова состояния сопроцессора не изменяются.
