
Базовые типы C++ описаны в~разделе Fundamental types (basic.fundamental) стандарта C++~\cite{isocpp}.
Раздел Types (basic.types) описывает общие характеристики хранения данных в~памяти.

% В~данном разделе также дана ссылка на раздел 5.2.4.2.1 стандарта C, где описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов.

% \subsection{Целые типы и~указатели}
\subsection{Целые типы}
% \subsection{Требования стандарта к~целым типам}

Существует пять стандартных \termin{знаковых целых типов}:  
\begin{itemize}
\item \lstinline!signed char!, 
\item \lstinline!signed short int! (синонимы: \lstinline!short, signed short!),  
\item \lstinline!signed int! (синонимы: \lstinline!int, signed!),
\item \lstinline!signed long int! (синонимы: \lstinline!long, signed long!),  
\item \lstinline!signed long long int! (синонимы: \lstinline!long long, signed long long!)
\end{itemize}
% компилятор может поддерживать и~д
и~пять соответствующих \termin{беззнаковых целых типов} (каждый из них имеет тот же размер и~те же требования к~выравниванию, что и~соответствующий знаковый):
\begin{itemize}
\item \lstinline!unsigned char!, 
\item \lstinline!unsigned short int! (синонимы: \lstinline!unsigned short!),  
\item \lstinline!unsigned int! (синонимы: \lstinline!unsigned!),
\item \lstinline!unsigned long int! (синонимы: \lstinline!unsigned long!),  
\item \lstinline!unsigned long long int! (синонимы: \lstinline!unsigned long long!).
\end{itemize}
Тип \lstinline!char!, в~зависимости от реализации, может быть знаковым или беззнаковым.
Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! имеют один размер и~одинаковые требования к~выравниванию.


Стандарт C++ не содержит явных значений разрядности типов.

Согласно стандарту,
% размер типа \lstinline!char! "--- минимально возможный размер какого-то объекта в~памяти, кроме того, размер любого объекта кратен размеру~\lstinline!char!;
% также в~разделе Sizeof указано, что 
\lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! занимают 1~байт.
При этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! \emph{однобайтовый,} но \emph{не однооктетный,}
то есть занимает не~8~бит.
% 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта

% Оператор \lstinline!sizeof! возвращает, сколько раз \lstinline!char! укладывается в~аргументе. 
Таким образом, всякий объект любого типа (обозначим его \lstinline!T!) может быть скопирован в~массив \lstinline!char [sizeof(T)]!.

В~ряду целых типов каждый следующий тип имеет размер (и~диапазон значений)  не меньше предыдущего:
$$
\begin{array}{c}
\mathlst{sizeof(char)} \leqslant \mathlst{sizeof(short)} \leqslant \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
\leqslant \mathlst{sizeof(long long)}
\end{array}
$$
Размеры стандартных целых типов C++ также должны соответствовать ограничениям раздела 5.2.4.2.1 стандарта C.
В~этом разделе описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов (при этом указанные значения не обязательно должны быть граничными).
% $$
% \begin{array}{lcl}
% \mathlst{sizeof(char)} \geqslant 
% \mathlst{sizeof(short)} \leqslant 
% \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
% \leqslant \mathlst{sizeof(long long)}
% \end{array}
% $$
Анализ этих значений приводит к~следующим выводам о~минимально допустимой разрядности стандартных типов:\\
\strut\hfill
\begin{tabular}{l|l}
Тип & Разрядность, бит (не менее) \\\hline
 \lstinline!char! & 8 \\
 \lstinline!short! & 16 \\
 \lstinline!int! & 16 \\
 \lstinline!long! & 32 \\
 \lstinline!long long! & 64 \\
\end{tabular}
\hfill\strut\bigskip




Тип \lstinline!int! должен соответствовать «естественной» разрядности архитектуры.
% ; расплывчатость этой формулировки приводит к тому, что практически на 64-битной платформе тип \lstinline!int! чаще всего 32-разряден.

% \subsubsection{интерпретация}
%  и~называются ещё \termin{узкими (narrow)}

% Размер типа \lstinline!char! 

Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! называются ещё \termin{узкими (narrow) символьными типами}, так как 
% хранящееся в~переменных так
они могут быть интерпретированы не только как числа, но и~как символы; соответственно
их размер должен быть таким, чтобы хранить представление любого символа из \termin{базового набора.}

Единственное отличие %типа \lstinline!char! 
узких символьных типов
от других целых (кроме размера) "--- то, что операторы ввода/вывода в~поток для них перегружены так, что отображают не значение переменной, а~символ, код которого равен этому значению.
Все арифметические операции для \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! выполняются точно так же, как и для любого другого целого типа.


Для  типа \lstinline!unsigned char!
каждой возможной  комбинации разрядов должно соответствовать отдельное число. 
Для других типов это не обязательно.

Для представления \termin{расширенного набора  символов} введён специальный тип \lstinline!wchar_t!, имеющий такой же размер, знаковость и~требования к~выравниванию, что и~один из~целых типов.


Тип \lstinline!bool! может хранить только два значения "--- \lstinline!true! и~\lstinline!false!.

\subsubsection{Практическая реализация}

\warning{Всё, что явно не прописано в~стандарте C++, может быть реализовано по-разному на различных платформах.

% Соответственно, в
Всё, написанное  в~этом разделе и~в~аналогичных разделах ниже, описывает в~основном платформу x86 и~наиболее популярные компиляторы.
На других программно/аппаратных платформах (в~частности, при использовании экзотического компилятора) эти закономерности могут быть нарушены.
}

Для представления беззнаковых чисел используется натуральный двоичный код;
знаковые представляются дополнительным кодом (таблица~\ref{tab:naturalbincode}).
Таким образом, для всех целых типов, в~частности, для \lstinline!unsigned char!, каждой возможной  комбинации разрядов  соответствует отдельное число.
\index{Представление данных!целых!натуральный код}

\begingroup
%  \scriptsize
% \renewcommand{\arraystretch}{1.05}
\newcolumntype{Y}{>{$}R<{$}}
\renewcommand\theadlong[1]{\multicolumn{1}{@{}R@{}}{{\bfseries\small #1\par
\vspace*{-1\baselineskip}
\strut
}}}

\begin{table}

\caption{Натуральный двоичный и~дополнительный коды}
\label{tab:naturalbincode}

% \noindent
\begin{tabularx}{1\linewidth}{YYYY@{\hspace{4em}}}
\theadlong{Тетрада}& \theadlong{16-ричный код} & \theadlong{Беззнаковое представление}
& \theadlong{Дополнительный код (доп. до 2)} 
	\\\hline

0000 & 0	& 0 &	0  			\\%\hline
0001 & 1	& 1 &	+1 			\\%\hline
0010 & 2	& 2 &	+2 			\\%\hline
0011 & 3	& 3 &	+3 			\\\hline
0100 & 4	& 4 &	+4 			\\%\hline
0101 & 5	& 5 &	+5 			\\%\hline
0110 & 6	& 6 &	+6 			\\%\hline
0111 & 7	& 7 &	+7 			\\\hline
1000 & 8	& 8 &	-8 		\\%\hline
1001 & 9	& 9 &	-7 			\\%\hline
1010 & A	& 10 &	-6 			\\%\hline
1011 & B	& 11 &	-5 			\\\hline
1100 & C	& 12 &	-4 			\\%\hline
1101 & D	& 13 &	-3 			\\%\hline
1110 & E	& 14 &	-2 			\\%\hline
1111 & F	& 15 &	-1 			\\\hline


\end{tabularx}
\end{table}

Как видно из таблицы~\ref{tab:naturalbincode}, минимальное беззнаковое четырёхбитное число "--- ноль ($0b0000$),
максимальное "--- $2^4 - 1 = 15$ ($0b1111$).
Минимальное знаковое четырёхбитное число "---  $-2^3 = -8$  ($0b1000$),
максимальное "--- $2^3 - 1 = +7$ ($0b0111$).

Для знаковых и~беззнаковых типов по-разному реализованы некоторые арифметические и~битовые операции, в~частности, умножение (\lstinline!*!), деление (\lstinline!/, %!), битовые сдвиги (\lstinline!<<,>>!), расширение при присваивании (если приёмник больше источника).

\paragraph{char, wchar\_t%
\footnote{Использованы материалы forum.ishodniki.ru}%
}

% % Соответственно,
% Для большинства программно/аппаратных платформ 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта, занимает один байт
% (при этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! однобайтовый, но не однооктетный).
% % , как минимально  размер любого типа кратен \lstinline!char!.
% % , хотя есть и~исключения (как правило, платформы, где байт не восьмибитен).

Тип \lstinline!char! "--- восьмибитный и~знаковый.
При этом  \lstinline!char! и~\lstinline!signed char! не являются синонимами, хотя вычисления с~их использованием компилируются в~одинаковые конструкции.
% 
Именно, при перегрузке  \lstinline!f(char)! и~\lstinline!f(signed char)! считаются разными функциями и~их имена декорируются по-разному (для сравнения, \lstinline!f(int)! и~\lstinline!f(signed int)! не различаются и~декорируются одинаково).


Базовым набором символов является ASCII.
% Изначально стоит текущая для всего локаль "C" в котрой мало что известно, по сути это просто US ASCII как правило. не Linux
% 
При интерпретации переменной типа \lstinline!char! как символа
значение этой переменной трактуется как ASCII-код.
% , если оно лежит в~пре
% от 0 до 127 интерпретируется
Таким образом, 64, 0x40 и '@' "--- это разные формы записи одного и того же числа (ASCII-код символа «собака» равен шестидесяти четырём).

Символы не из ASCII, в~частности, русские буквы, в~зависимости от реализации, могут быть представлены 
одной переменной типа  \lstinline!char! (кодировки koi8, cp1251, cp866; в~этом случае с учётом знаковости \lstinline!char! коды русских букв "--- 128--255 "--- трактуются как отрицательные, то есть \lstinline!'ы' < 0 < 's'!)
или цепочкой из нескольких 
% переменными типа  
\lstinline!char!'ов (кодировка UTF-8; в~этом случае можно описать строку из русских букв как \lstinline!char []!, но невозможно описать одну такую букву как \lstinline!char!).
% Представление одного символа несколькими  переменными не очень удобно

% http://forum.ishodniki.ru/index.php/topic,19509.msg80866.html?PHPSESSID=0231dfe0510c43d48470048b3716466b#msg80866

Понятие расширенного набора  символов и~тип  \lstinline!wchar_t! возникли с~появлением Unicode.
Широкий символьный тип \lstinline!wchar_t! может содержать любое количество байтов.
% С появлением юникода появился и тип "широких" символов wchar_t. Вот уж сколько в нем байтов или char-ов совершенно неизвестно. Но про него известны 2 хорошие вещи которые как правило создатели компиляторов и API закладывают в него :
% - Он используется как правило для преставления какой либо Unicode кодировки.
% - У него фиксированная длина символов. Это достаточно важно. Как известно символы в юникоде представленны абстрактным кодовым пространством (UCS).  А в реальных устройствах эти абстрактные ккоды кодируются различными "юникодными" кодировками (UTF). Причем на разные символы у этих юникодных кодировок может быть переменное число байт. Так вот прелесть wchar_t в том, что в нем обычно используются такие юникодные кодировки или их части в которых каждый логический символ занимает ровно один wchar_t.
Как правило,  при хранении символьной информации в~\lstinline!wchar_t! используются такие юникодные кодировки или их части, в~которых каждый логический символ занимает ровно один \lstinline!wchar_t! (UTF-32, или, если поддерживается только часть набора символов Unicode "--- UTF-16).
Расширенный набор символов, соответственно "--- та часть набора символов Unicode, которая поддерживается и~может быть записана одним \lstinline!wchar_t!.

Литералы, соответствующие широким строкам и~символам, предваряются префиксом \lstinline!L!.
Для ввода/вывода широких символов и~строк используются те же операторы, что и~для узких, но другие потоки (\lstinline!wcin/wcout!). Поток \lstinline!cout! при выводе  \lstinline!wchar_t! отображает число, при выводе \lstinline!wchar_t*! "--- адрес в~шестнадцатеричном виде. 


% http://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c
% char is always a byte , but it's not always an
% octet. A byte is the smallest addressable unit of
% memory (in most definitions), an octet is 8-bit
% unit of mem

\paragraph{int, short, long, long long}


% Нечёткость требований к~размеру стандартных типов формулировки приводит к тому, что практически 
Тип \lstinline!int! на 16-разрядных платформах занимал 16 бит, на 32-разрядных "--- 32 бита.
На 64-битной платформе \lstinline!int! чаще всего 32-разряден.

Тип \lstinline!short! 16-разряден на 16-, 32- и~64-разрядных платформах.

Тип \lstinline!long! на 16- и~32-разрядных платформах занимал 32 бита.
На 64-битной платформе "--- 64.

Тип \lstinline!long long!, если поддерживается, 64-разряден.

\subsection{Вещественные типы}

Существует три стандартных \termin{вещественных типа}:  
\begin{itemize}
\item \lstinline!float!, 
\item \lstinline!double!,  
\item \lstinline!long double!.
\end{itemize}
тип \lstinline!double! обеспечивает не меньшую точность, чем \lstinline!float!,
\lstinline!long double! "---  не меньшую точность, чем \lstinline!double!.

Множество значений типа \lstinline!float! является подмножеством множества  значений типа  \lstinline!double!;
множество значений типа \lstinline!double! является подмножеством множества  значений типа  \lstinline!long double!:
$$
\mathlst{float} \subseteq \mathlst{double} \subseteq \mathlst{long double}
$$

\subsubsection{Практическая реализация}
\index{Представление данных!вещественных!расширенной точности}
\index{Представление данных!вещественных!двойной точности}
\index{Представление данных!вещественных!одинарной точности}

% \footnote{Использованы материалы: 
% В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
% с~плавающей точкой;
% текст стандарта IEEE Std 754™-2008
% }%
Вещественные числа представляются в~форматах с~плавающей запятой различной точности, в~соответствии со стандартом двоичной арифметики с~плавающей точкой IEEE 754~\cite{ieeeFloat1985rus, ieeeFloat2008}.

Модуль операций с~плавающей запятой процессоров семейства x86 (floating point unit, FPU) %— часть процессора для выполнения широкого спектра математических операций над вещественными числами.
поддерживает три типа вещественных чисел 
\begin{itemize}
\item  одинарной точности (32 бита), 
\item  двойной точности (64 бита), 
\item  с~двойной расширенной точностью (80 бит, внутренний формат FPU "--- 15 разрядов отводится под порядок,  64 под мантиссу), отводится под экпоненту).
\end{itemize}
Типу \lstinline!float! соответствует число одинарной точности, 
типу \lstinline!double! "--- двойной.

{
Типу \lstinline!long double! чаще всего соответствует 10-байтовое число расширенной точности. % при этом они могут требовать выравнивания
Размер выделяемой под переменную \lstinline!long double! памяти при этом %может превышать реальный размер числа и, 
в~зависимости от флагов компиляции (\verb!-m96bit-long-double! и~\verb!-m128bit-long-double! в~GCC), может быть равен 12 или 16 байт. 
Используются только первые 80 бит (10 байт), остальное "--- неиспользуемая память (заполнение). 
% -m96bit-long-double
% -m128bit-long-double
% These switches control the size of long double type. The i386 application binary interface specifies the size to be 96 bits, so -m96bit-long-double is the default in 32 bit mode.
% Modern architectures (Pentium and newer) would prefer long double to be aligned to an 8 or 16 byte boundary.
% \sloppy

}

В~Microsoft Visual Studio типу \lstinline!long double!  соответствуют числа двойной точности (64 бита), хотя \lstinline!long double! не считается синонимом \lstinline!double!.


\subsection{Специальные типы}

Множество значений типа  \lstinline!void! пусто.
Он используется для описания функций, которые не возвращают значения.

% Любое выражение может быть приведено к~типу 
% \lstinline!void!.


\subsection{Указатели}

Указатели:
% 
void*, char*, ...

Разность указателей:
% 
ptrdiff\_t

Длина: size\_t

