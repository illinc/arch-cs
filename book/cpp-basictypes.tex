
Базовые типы C++ описаны в~разделе Fundamental types (basic.fundamental) стандарта C++.
Раздел Types (basic.types) описывает общие характеристики хранения данных в~памяти.

% В~данном разделе также дана ссылка на раздел 5.2.4.2.1 стандарта C, где описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов.

% \subsection{Целые типы и~указатели}
\subsection{Целые типы}
% \subsection{Требования стандарта к~целым типам}

Существует пять стандартных \termin{знаковых целых типов}:  
\begin{itemize}
\item \lstinline!signed char!, 
\item \lstinline!signed short int! (синонимы: \lstinline!short, signed short!),  
\item \lstinline!signed int! (синонимы: \lstinline!int, signed!),
\item \lstinline!signed long int! (синонимы: \lstinline!long, signed long!),  
\item \lstinline!signed long long int! (синонимы: \lstinline!long long, signed long long!)
\end{itemize}
% компилятор может поддерживать и~д
и~пять соответствующих \termin{беззнаковых целых типов} (каждый из них имеет тот же размер и~те же требования к~выравниванию, что и~соответствующий знаковый):
\begin{itemize}
\item \lstinline!unsigned char!, 
\item \lstinline!unsigned short int! (синонимы: \lstinline!unsigned short!),  
\item \lstinline!unsigned int! (синонимы: \lstinline!unsigned!),
\item \lstinline!unsigned long int! (синонимы: \lstinline!unsigned long!),  
\item \lstinline!unsigned long long int! (синонимы: \lstinline!unsigned long long!).
\end{itemize}
Тип \lstinline!char!, в~зависимости от реализации, может быть знаковым или беззнаковым.
Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! имеют один размер и~одинаковые требования к~выравниванию.


Стандарт C++ не содержит явных значений разрядности типов.

Согласно стандарту,
% размер типа \lstinline!char! "--- минимально возможный размер какого-то объекта в~памяти, кроме того, размер любого объекта кратен размеру~\lstinline!char!;
% также в~разделе Sizeof указано, что 
\lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! занимают 1~байт.
При этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! \emph{однобайтовый,} но \emph{не однооктетный,}
то есть занимает не~8~бит.
% 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта

% Оператор \lstinline!sizeof! возвращает, сколько раз \lstinline!char! укладывается в~аргументе. 
Таким образом, всякий объект любого типа (обозначим его \lstinline!T!) может быть скопирован в~массив \lstinline!char [sizeof(T)]!.

В~ряду целых типов каждый следующий тип имеет размер (и~диапазон значений)  не меньше предыдущего:
$$
\begin{array}{c}
\mathlst{sizeof(char)} \leqslant \mathlst{sizeof(short)} \leqslant \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
\leqslant \mathlst{sizeof(long long)}
\end{array}
$$
Размеры стандартных целых типов C++ также должны соответствовать ограничениям раздела 5.2.4.2.1 стандарта C.
В~этом разделе описаны значения, которые обязательно должны быть включены в~диапазоны значений соответствующих типов (при этом указанные значения не обязательно должны быть граничными).
% $$
% \begin{array}{lcl}
% \mathlst{sizeof(char)} \geqslant 
% \mathlst{sizeof(short)} \leqslant 
% \mathlst{sizeof(int)} \leqslant \mathlst{sizeof(long)}  \leqslant\\
% \leqslant \mathlst{sizeof(long long)}
% \end{array}
% $$
Анализ этих значений приводит к~следующим выводам о~минимально допустимой разрядности стандартных типов:\\
\strut\hfill
\begin{tabular}{l|l}
Тип & Разрядность, бит (не менее) \\\hline
 \lstinline!char! & 8 \\
 \lstinline!short! & 16 \\
 \lstinline!int! & 16 \\
 \lstinline!long! & 32 \\
 \lstinline!long long! & 64 \\
\end{tabular}
\hfill\strut\bigskip




Тип \lstinline!int! должен соответствовать «естественной» разрядности архитектуры.
% ; расплывчатость этой формулировки приводит к тому, что практически на 64-битной платформе тип \lstinline!int! чаще всего 32-разряден.

% \subsubsection{интерпретация}
%  и~называются ещё \termin{узкими (narrow)}

% Размер типа \lstinline!char! 

Типы \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! называются ещё \termin{узкими (narrow) символьными типами}, так как 
% хранящееся в~переменных так
они могут быть интерпретированы не только как числа, но и~как символы; соответственно
их размер должен быть таким, чтобы хранить представление любого символа из \termin{базового набора.}

Единственное отличие %типа \lstinline!char! 
узких символьных типов
от других целых (кроме размера) "--- то, что операторы ввода/вывода в~поток для них перегружены так, что отображают не значение переменной, а~символ, код которого равен этому значению.
Все арифметические операции для \lstinline!char!,  \lstinline!signed char! и~\lstinline!unsigned char! выполняются точно так же, как и для любого другого целого типа.


Для  типа \lstinline!unsigned char!
каждой возможной  комбинации разрядов должно соответствовать отдельное число. 
Для других типов это не обязательно.

Для представления \termin{расширенного набора  символов} введён специальный тип \lstinline!wchar_t!, имеющий такой же размер, знаковость и~требования к~выравниванию, что и~один из~целых типов.


Тип \lstinline!bool! может хранить только два значения "--- \lstinline!true! и~\lstinline!false!.

\subsubsection{Практическая реализация}

\warning{Всё, что явно не прописано в~стандарте C++, может быть реализовано по-разному на различных платформах.

% Соответственно, в
Всё, написанное  в~этом разделе и~в~аналогичных разделах ниже, описывает в~основном платформу x86 и~наиболее популярные компиляторы.
На других программно/аппаратных платформах (в~частности, при использовании экзотического компилятора) эти закономерности могут быть нарушены.
}

Для представления беззнаковых чисел используется натуральный двоичный код;
знаковые представляются дополнительным кодом (таблица~\ref{tab:naturalbincode}).
Таким образом, для всех целых типов, в~частности, для \lstinline!unsigned char!, каждой возможной  комбинации разрядов  соответствует отдельное число.

\begingroup
%  \scriptsize
% \renewcommand{\arraystretch}{1.05}
\newcolumntype{Y}{>{$}R<{$}}
\renewcommand\theadlong[1]{\multicolumn{1}{@{}R@{}}{{\bfseries\small #1\par
\vspace*{-1\baselineskip}
\strut
}}}

\begin{table}

\caption{Натуральный двоичный и~дополнительный коды}
\label{tab:naturalbincode}

% \noindent
\begin{tabularx}{1\linewidth}{YYYY@{\hspace{4em}}}
\theadlong{Тетрада}& \theadlong{16-ричный код} & \theadlong{Беззнаковое представление}
& \theadlong{Дополнительный код (доп. до 2)} 
	\\\hline

0000 & 0	& 0 &	0  			\\%\hline
0001 & 1	& 1 &	+1 			\\%\hline
0010 & 2	& 2 &	+2 			\\%\hline
0011 & 3	& 3 &	+3 			\\\hline
0100 & 4	& 4 &	+4 			\\%\hline
0101 & 5	& 5 &	+5 			\\%\hline
0110 & 6	& 6 &	+6 			\\%\hline
0111 & 7	& 7 &	+7 			\\\hline
1000 & 8	& 8 &	-8 		\\%\hline
1001 & 9	& 9 &	-7 			\\%\hline
1010 & A	& 10 &	-6 			\\%\hline
1011 & B	& 11 &	-5 			\\\hline
1100 & C	& 12 &	-4 			\\%\hline
1101 & D	& 13 &	-3 			\\%\hline
1110 & E	& 14 &	-2 			\\%\hline
1111 & F	& 15 &	-1 			\\\hline


\end{tabularx}
\end{table}

Как видно из таблицы~\ref{tab:naturalbincode}, минимальное беззнаковое четырёхбитное число "--- ноль ($0b0000$),
максимальное "--- $2^4 - 1 = 15$ ($0b1111$).
Минимальное знаковое четырёхбитное число "---  $-2^3 = -8$  ($0b1000$),
максимальное "--- $2^3 - 1 = +7$ ($0b0111$).

Для знаковых и~беззнаковых типов по-разному реализованы некоторые арифметические и~битовые операции, в~частности, умножение (\lstinline!*!), деление (\lstinline!/, %!), битовые сдвиги (\lstinline!<<,>>!), расширение при присваивании (если приёмник больше источника).

\paragraph{char, wchar\_t%
\footnote{Использованы материалы forum.ishodniki.ru}%
}

% % Соответственно,
% Для большинства программно/аппаратных платформ 
% тип \lstinline!char!, как минимально адресуемый кусочек памяти, размеру которого кратен размер любого объекта, занимает один байт
% (при этом, если байт на используемой программно/аппаратной платформе не восьмибитен, то и~\lstinline!char! однобайтовый, но не однооктетный).
% % , как минимально  размер любого типа кратен \lstinline!char!.
% % , хотя есть и~исключения (как правило, платформы, где байт не восьмибитен).

Тип \lstinline!char! "--- восьмибитный и~знаковый.
При этом  \lstinline!char! и~\lstinline!signed char! не являются синонимами, хотя вычисления с~их использованием компилируются в~одинаковые конструкции.
% 
Именно, при перегрузке  \lstinline!f(char)! и~\lstinline!f(signed char)! считаются разными функциями и~их имена декорируются по-разному (для сравнения, \lstinline!f(int)! и~\lstinline!f(signed int)! не различаются и~декорируются одинаково).


Базовым набором символов является ASCII.
% Изначально стоит текущая для всего локаль "C" в котрой мало что известно, по сути это просто US ASCII как правило. не Linux
% 
При интерпретации переменной типа \lstinline!char! как символа
значение этой переменной трактуется как ASCII-код.
% , если оно лежит в~пре
% от 0 до 127 интерпретируется
Таким образом, 64, 0x40 и '@' "--- это разные формы записи одного и того же числа (ASCII-код символа «собака» равен шестидесяти четырём).

Символы не из ASCII, в~частности, русские буквы, в~зависимости от реализации, могут быть представлены 
одной переменной типа  \lstinline!char! (кодировки koi8, cp1251, cp866; в~этом случае с учётом знаковости \lstinline!char! коды русских букв "--- 128--255 "--- трактуются как отрицательные, то есть \lstinline!'ы' < 0 < 's'!)
или цепочкой из нескольких 
% переменными типа  
\lstinline!char!'ов (кодировка UTF-8; в~этом случае можно описать строку из русских букв как \lstinline!char []!, но невозможно описать одну такую букву как \lstinline!char!).
% Представление одного символа несколькими  переменными не очень удобно

% http://forum.ishodniki.ru/index.php/topic,19509.msg80866.html?PHPSESSID=0231dfe0510c43d48470048b3716466b#msg80866

Понятие расширенного набора  символов и~тип  \lstinline!wchar_t! возникли с~появлением Unicode.
Широкий символьный тип \lstinline!wchar_t! может содержать любое количество байтов.
% С появлением юникода появился и тип "широких" символов wchar_t. Вот уж сколько в нем байтов или char-ов совершенно неизвестно. Но про него известны 2 хорошие вещи которые как правило создатели компиляторов и API закладывают в него :
% - Он используется как правило для преставления какой либо Unicode кодировки.
% - У него фиксированная длина символов. Это достаточно важно. Как известно символы в юникоде представленны абстрактным кодовым пространством (UCS).  А в реальных устройствах эти абстрактные ккоды кодируются различными "юникодными" кодировками (UTF). Причем на разные символы у этих юникодных кодировок может быть переменное число байт. Так вот прелесть wchar_t в том, что в нем обычно используются такие юникодные кодировки или их части в которых каждый логический символ занимает ровно один wchar_t.
Как правило,  при хранении символьной информации в~\lstinline!wchar_t! используются такие юникодные кодировки или их части, в~которых каждый логический символ занимает ровно один \lstinline!wchar_t! (UTF-32, или, если поддерживается только часть набора символов Unicode "--- UTF-16).
Расширенный набор символов, соответственно "--- та часть набора символов Unicode, которая поддерживается и~может быть записана одним \lstinline!wchar_t!.

Литералы, соответствующие широким строкам и~символам, предваряются префиксом \lstinline!L!.
Для ввода/вывода широких символов и~строк используются те же операторы, что и~для узких, но другие потоки (\lstinline!wcin/wcout!). Поток \lstinline!cout! при выводе  \lstinline!wchar_t! отображает число, при выводе \lstinline!wchar_t*! "--- адрес в~шестнадцатеричном виде. 


% http://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c
% char is always a byte , but it's not always an
% octet. A byte is the smallest addressable unit of
% memory (in most definitions), an octet is 8-bit
% unit of mem

\paragraph{int, short, long, long long}


% Нечёткость требований к~размеру стандартных типов формулировки приводит к тому, что практически 
Тип \lstinline!int! на 16-разрядных платформах занимал 16 бит, на 32-разрядных "--- 32 бита.
На 64-битной платформе \lstinline!int! чаще всего 32-разряден.

Тип \lstinline!short! 16-разряден на 16-, 32- и~64-разрядных платформах.

Тип \lstinline!long! на 16- и~32-разрядных платформах занимал 32 бита.
На 64-битной платформе "--- 64.

Тип \lstinline!long long!, если поддерживается, 64-разряден.

\subsection{Вещественные типы}

Существует три стандартных \termin{вещественных типа}:  
\begin{itemize}
\item \lstinline!float!, 
\item \lstinline!double!,  
\item \lstinline!long double!.
\end{itemize}
тип \lstinline!double! обеспечивает не меньшую точность, чем \lstinline!float!,
\lstinline!long double! "---  не меньшую точность, чем \lstinline!double!.

Множество значений типа \lstinline!float! является подмножеством множества  значений типа  \lstinline!double!;
множество значений типа \lstinline!double! является подмножеством множества  значений типа  \lstinline!long double!:
$$
\mathlst{float} \subseteq \mathlst{double} \subseteq \mathlst{long double}
$$

\subsubsection{Практическая реализация%
\footnote{Использованы материалы: 
В.\,Яшкардин. IEEE 754 "--- стандарт двоичной арифметики
с~плавающей точкой;
текст стандарта IEEE Std 754™-2008
}%
}


Вещественные числа, согласно стандарту двоичной арифметики с~плавающей точкой IEEE 754,
представляются в~виде знака, экспоненты (порядка) и~мантиссы
(рис.~\ref{ris:ieee754_1}).


% Это представление основано на двоичной экспоненциальной форме вещественного числа $F$, то есть:
Число $F$ представляется в~двоичной экспоненциальной форме "--- в~виде произведения трёх компонент:
\begin{itemize}
\item знак ($+1$ или $-1$);
\item двойка в~некоторой степени~$\epsilon$, называемой \emph{порядком}, или экспонентой; %(порядок "--- зна);
% (для записи очень маленьких чисел порядок должен быть отрицательным);
\item \emph{мантиссы $\mu$} "--- двоичной дроби $1 \leqslant \mu <2$, то есть $\mu = 1,\beta_1\beta_2\beta_3\ldots\beta_n$, где $\beta_i$ "--- двоичный разряд.
\end{itemize}
$$
F = (-1)^{\sigma} \cdot 2^{\epsilon} \cdot \mu
% \big( 1,\beta_1\beta_2\beta_3\ldots\beta_n \big)
$$
В~такой форме можно представить любое конечное число, кроме нуля.

Старший бит (S) "--- бит знака, если $S=0$ "--- число положительное, если $S=1$ "--- число отрицательное.
Следующие $b$ бит отводятся под  порядок, смещённый на $2^{b-1} - 1$ (то есть 
знаковое значение порядка представляется не дополнительным кодом, а~кодом с~избытком:
% для отр
порядок~$0$ представляется числом $2^{b-1} - 1$,
% отрицательные порядки представляются малыми беззнаковыми числами
порядок~$-2^{b-1}+1$ "--- нулём%
).
% S - бит знака, если S=0 - положительное число; S=1 - отрицательное число
% E - смещенная экспонента двоичного числа;
% exp2 = E - (2(b-1) - 1) - экспонента двоичного нормализованного числа с плавающей точкой
% (2(b-1) -1) - заданное смещение экспоненты (в 32-битном ieee754 оно равно +127 см.выше)
Оставшиеся $n$ бит кодируют $M$ остаток мантиссы двоичного нормализованного числа с плавающей точкой (мантиссу без ведущей единицы).

Таким образом, значение вещественного числа (рис.~\ref{ris:ieee754_1}) для всех комбинаций битов, кроме исключительных (таблица~\ref{tab:ieee754-singular})   вычисляется по формуле:
\begin{illustration}
\includegraphics[width=\approvedImageWidth]{ieee754_1}
\caption{Представление числа в формате IEEE 754}
\label{ris:ieee754_1}
\end{illustration}
$$
F = (-1)^S \cdot 2^{E - 2^{b-1} + 1} \cdot \left( 1 + \dfrac{M}{2^n}\right)
$$

\begin{table}

\caption{Исключительные значения представления IEEE 754}
\label{tab:ieee754-singular}
\begin{tabular}%{l>{$}l<{$}}
{ll}
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+0} & $+0$\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-0} & $-0$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754den} & денормализованные числа \\
\\\hline
\\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754+inf} & $+\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754-inf} & $-\infty$ \\
\includegraphics[width=\approvedImageWidth,valign=c]{ieee754nan} & $NaN$ (нечисла) \\
\end{tabular}
\end{table}

% Денормализованные числа. Это числа, мантиссы которых лежат в диапазоне 0.1 <= M <1.

Денормализованные числа находятся ближе к нулю, чем наименьшие по модулю нормализованные. 
% Их мантиссы (при минимально возможном по)
% 
% Денормализованные числа как бы разбивают минимальный разряд нормализованного числа на некоторое подмножество. Сделано так потому, что в технической практике чаще встречаются величины близкие к нулю. 

Стандарт %двоичной арифметики с~плавающей точкой
IEEE 754-2008 описывает
%  \begin{itemize}
% \item 
три двоичных вещественных формата разрядностью 32, 64, и 128 бита. %;
% \item два двоично-десятичных формата "--- 64 и~128 бита.
% \end{itemize}
% 
Более старый вариант этого стандарта    IEEE 754-1985 определяет также формат с~двойной расширенной точностью (double-extended precision) $\geqslant$ 79 бит. % (обычно используют 80 бит).

\begin{illustration}
\includegraphics[width=\wideImageWidth]{ieee754_32}\\
a)\\

\includegraphics[width=\wideImageWidth]{ieee754_64}\\
б)
\caption{Формат чисел а) одинарной (single-precision, 32 бита)  и~б) двойной точности (double-precision, 64 бита)}
\label{ris:ieee754_32}
\end{illustration}




Модуль операций с~плавающей запятой процессоров семейства x86 (floating point unit, FPU) %— часть процессора для выполнения широкого спектра математических операций над вещественными числами.
поддерживает три типа вещественных чисел 
\begin{itemize}
\item  одинарной точности (32 бита), 
\item  двойной точности (64 бита), 
\item  с~двойной расширенной точностью (80 бит, внутренний формат FPU "--- 15 разрядов отводится под порядок,  64 под мантиссу), отводится под экпоненту).
\end{itemize}
Типу \lstinline!float! соответствует число одинарной точности, 
типу \lstinline!double! "--- двойной.

{
Типу \lstinline!long double! чаще всего соответствует 10-байтовое число расширенной точности. % при этом они могут требовать выравнивания
Размер выделяемой под переменную \lstinline!long double! памяти при этом %может превышать реальный размер числа и, 
в~зависимости от флагов компиляции (\verb!-m96bit-long-double! и~\verb!-m128bit-long-double! в~GCC), может быть равен 12 или 16 байт. 
Используются только первые 80 бит (10 байт), остальное "--- неиспользуемая память (заполнение). 
% -m96bit-long-double
% -m128bit-long-double
% These switches control the size of long double type. The i386 application binary interface specifies the size to be 96 bits, so -m96bit-long-double is the default in 32 bit mode.
% Modern architectures (Pentium and newer) would prefer long double to be aligned to an 8 or 16 byte boundary.
% \sloppy

}

В~Microsoft Visual Studio типу \lstinline!long double!  соответствуют числа двойной точности (64 бита), хотя \lstinline!long double! не считается синонимом \lstinline!double!.


\subsection{Специальные типы}

Множество значений типа  \lstinline!void! пусто.
Он используется для описания функций, которые не возвращают значения.

% Любое выражение может быть приведено к~типу 
% \lstinline!void!.

\section{Преобразование типов\footnote{Использована статья 
Е.\,Сагалаевой «Приведение типов в C++»
% «Приведение типов»% (\url{http://habrahabr.ru/post/106294/})
}}
В~С++ есть четыре оператора явного преобразования (приведения) типов: \lstinline!const_cast!, \lstinline!static_cast!, \lstinline!dynamic_cast! и~\lstinline!reinterpret_cast!. 
Кроме того, для совместимости поддерживается приведение в~стиле C.

\begin{description}

\item[const\_cast] убирает (или добавляет, но это редко используется) так называемые cv-спецификаторы (cv qualifiers), то есть const и volatile. volatile встречается не очень часто, так что  \lstinline!const_cast! более известен как приведение типов, предназначенное для убирания const. Если приведение типов не удалось, выдается ошибка на этапе компиляции.
При использовании остальных приведений типов cv-спецификаторы останутся как были.
\begin{lstlisting}[style=lstsmall]
int i;
const int * pi = &i;
// *pi имеет тип const int,
// но pi указывает на int, который константным не является
int* j = const_cast<int *> (pi);
\end{lstlisting}

% http://rsdn.ru/article/cpp/static_cast.xml
\item[static\_cast]
% Синтаксис:
% TYPE static_cast<TYPE> (object);
преобразует выражения одного статического типа в объекты и значения другого статического типа. 
% Самый популярный вид преобразования.
Может быть использован везде, где допустимо неявное преобразование типов (в~частности, преобразования чисел вроде \lstinline!int i = 1.3;! или указателя произвольного типа в~нетипизированный \lstinline!void *up = &i;!), а~также для преобразования:
\begin{itemize}
\item    любого типа к типу void (допустимое, но обычно ненужное на практике преобразование);
\item указателя \lstinline!void *! в~указатель произвольного типа;
\item    базового класса к ссылке на производный класс (допустимо, но опасно, если объект на самом деле не того производного класса; в~этих случаях часто лучше использовать  \lstinline!dynamic_cast!);
\item указателя на базовый класс  в~указатель на производный класс (аналогично, надёжнее использовать \lstinline!dynamic_cast!, если это возможно);
% \item    инверсия некоторых стандартных преобразований, в~частности:
% \begin{itemize}
\item    интегральных типов в перечисляемые%;
% \item    (возможно cv-квалифицированный) Base * в (с не меньшей cv-квалификацией) Derived *
% \item    (возможно cv-квалифицированный) T Base:: * в (с не меньшей cv-квалификацией) T Derived:: *
% \item    (возможно cv-квалифицированный) void * в любой T *
% \end{itemize}
.
\end{itemize}
Если приведение типов не удалось, выдается ошибка на этапе компиляции.

\item[dynamic\_cast]
"--- безопасное приведение по иерархии наследования, в том числе виртуального.
Используется для преобразования
\begin{itemize}
\item указателя на базовый класс  в~указатель на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class *>(base_class_ptr_expr)
\end{lstlisting}
если приведение невозможно, будет возвращён NULL;

\item    базового класса к ссылке на производный класс:
\begin{lstlisting}[style=lstsmall]
dynamic_cast<derv_class &>(base_class_ref_expr)
\end{lstlisting}
если приведение невозможно, 
% Работа со ссылками происходит аналогично, но в случае ошибки во время выполнения 
будет выброшено исключение \lstinline!bad_cast!.
\end{itemize}
% Используется RTTI (Runtime Type Information), чтобы привести один указатель на объект класса к другому указателю на объект класса. 
Для корректного преобразования классы должны быть полиморфными, то есть в базовом классе должна быть хотя бы одна виртуальная функция. Если это условие не соблюдено, ошибка возникнет на этапе компиляции.
 Если приведение невозможно, это станет ясно только на этапе выполнения программы.

\item[reinterpret\_cast]
"--- приведение без проверок. Не может быть приведено одно значение к другому значению. Обычно используется, чтобы привести указатель к указателю, указатель к целому, целое к указателю. Умеет также работать со ссылками.

Возможные варианты использования
\begin{lstlisting}[style=lstsmall]
reinterpret_cast<whatever *>(some *)
reinterpret_cast<integer_expression>(some *)
reinterpret_cast<whatever *>(integer_expression)
\end{lstlisting}
Например, допустимо:
\begin{lstlisting}[style=lstsmall]
double x = 1;
int i = -1;
char *pc = reinterpret_cast<char *>(&x);

// refu -- ссылка на то же место в памяти, где расположена переменная i,
// но интерпретируется этот фрагмент памяти уже как unsigned
unsigned &refu = reinterpret_cast<unsigned &>(i);

// pu указывает на то же место в памяти, где расположена переменная i (аналогично)
unsigned *pu = reinterpret_cast<unsigned *>(&i);

// u -- новая переменная, инициализированная текущим значением i в беззнаковой интерпретации (0xFFFFFFFF)
unsigned u = reinterpret_cast<unsigned &>(i);

// lox ссылается на первые (в x86 -- младшие) 4 байта x и интерпретирует их как беззнаковое целое
unsigned &lox = reinterpret_cast<unsigned &>(x);
unsigned &hix = *(&lox + 4);
\end{lstlisting}
% используя пару разнотипных переменных 
% 
Но нельзя выполнить
\begin{lstlisting}[style=lstsmall]
int i;
unsigned u = reinterpret_cast<unsigned>(i);
\end{lstlisting}

\item[Приведение в~стиле C](C-style cast) "--- самое медленное преобразование, так как  последовательно перебираются следующие вызовы:
\begin{enumerate}
\item    \lstinline!const_cast!
\item    \lstinline!static_cast!
\item    \lstinline!static_cast + const_cast!
\item    \lstinline!reinterpret_cast!
\item    \lstinline!reinterpret_cast + const_cast!
\end{enumerate}
Допустимо во всех случаях, но не рекомендуется из-за внешнего вида.

Примеры:
\begin{lstlisting}[style=lstsmall]
double x = 1;
int i = -1;
char *pc = (char *)(&x);
unsigned &refu = (unsigned &)i;
unsigned *pu = (unsigned *)&i;
unsigned u = (unsigned)i;
\end{lstlisting}


\end{description}

\section{Литералы C++}

\subsection{Целые}

Целочисленные литералы начинаются с~цифры или знака ($+$ или $-$) и~не содержат десятичной запятой и~показателя степени. 

Для тех чисел, которые соответствуют кодам ASCII для печатных и~некоторых управляющих символов, 
%  которые можно каким-то образом задать , 
есть альтернативная форма записи "--- соответствующий символ в~одинарных кавычках, например
\lstinline!'\0'! равен 0, \lstinline!'\t'! "--- 9, \lstinline!'2'! "--- 50, \lstinline!'R'! "--- 82, \lstinline!'r'! "--- 114. 

\subsubsection{Префиксы системы счисления}
Целочисленные литералы могут предваряться префиксом, обозначающим систему счисления:
\begin{description}
\item[0x, 0X] "--- шестнадцатеричная;
\item[0] (ведущий ноль) "--- восьмеричная;
\item[0b, 0B] "--- двоичная;
\end{description}
по умолчанию (без префикса) используется десятичная система.
% 
Так, одно и~то же число может быть записано как \lstinline!13, 015, 0xD! и~\lstinline!0b1101!. 

\subsubsection{Суффиксы знаковости и~размера}

Целый литерал без суффикса имеет тип \lstinline!int! (если значение выходит за пределы \lstinline!int!, то "--- минимальный знаковый тип, в~который литерал помещается).

Для указания беззнакового типа литерала (без суффикса размера это тип \lstinline!unsigned!) используется суффикс \lstinline!u! или \lstinline!U!. 

Для указания размера используются следующие суффиксы:
\begin{description}
\item[l, L] "---  \lstinline!long!;
\item[ll, LL] "---  \lstinline!long long!.
\end{description}
Так, \lstinline!2ul! "--- беззнаковое число типа \lstinline!unsigned long! (возможна также запись \lstinline!2lu!).

Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Вещественные}
Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные точки (.) и/или показатели степени: \lstinline!34.56, 0.12, 1.! (вещественное число 1), \lstinline!1e4! ($10^4$), \lstinline!5e-4! ($5\cdot10^{-4}$), \lstinline!2.12e+2! ($2,12\cdot10^2 = 212$).

Вещественный литерал без суффикса имеет тип \lstinline!double! (если значение выходит за пределы \lstinline!double!, то "--- \lstinline!long double!).
Для указания размера используются следующие суффиксы:
\begin{description}
\item[f, F] "---  \lstinline!float!;
\item[l, L] "---  \lstinline!long double!.
\end{description}
Если значение литерала не помещается в~тип, соответствующий суффиксу, выбирается более ёмкий.
 
\subsection{Строки}

Строковые литералы заключаются в~двойные кавычки.
Перед «широкими» строками ставится префикс \lstinline!L!.

