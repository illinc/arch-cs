\chapter{Понятие вычислительной системы (ВС)}
% \epigraphcensoredtwo[
\epigraph{
Это требует, чтобы о~нём написать. И~напишу.
}
{\Vvm[Я~сам]}
% ]{
% \epigraph{\begin{stanza}
% <<Вот где водится Снарк!>> "--- возгласил Балабон\\
% Указав на вершину горы;\\
% И~матросов на берег вытаскивал он,\\
% Их подтягивал за вихры.\end{stanza}}
% {\Snark}
% }

Вычислительная система описывается как %взаимодействием своих компонентов, 
компонентами этой системы,
так и~языком программирования, предназначенным для взаимодействия %программиста 
с~вычислительной машиной.
% 
% Рассмотрим основные понятия, определения и~применим 
В~данной главе 
% архитектура x86 рассматривается с~обеих точек зрения.
обе точки зрения рассматриваются на примере семейства x86,
% Также данная глава включает историю развития вычислительной техники
а~также в~разрезе истории развития вычислительной техники.

% Обозначением x86 описывают целый класс вычислительных систем,
% включающий уже практически не используемую шестнадцатибитную архитектуру,
% тридцатидвухбитную архитектуру IA-32 (i386--i686),
% шестидесятичетырёхбитную x86-64 (amd64).

\section{Терминология}
% \epigraphcensoredtwo[
\epigraph{
"--*  ...Дамы и господа! Вашему вниманию предлагается магический компьютер, сокращённо «магокомпьютер». Это новое слово в технологиях.

Сен напряг память, но был вынужден согласиться, что слово «магокомпьютер» "--- действительно новое.
}{\ZhvalevskijMytko[Девять подвигов Сена Аесли. Подвиги 5-9]}
% ]{
% \epigraph{\begin{stanza}Так внемлите, друзья! Вам поведаю я\\Пять бесспорных и~точных примет,\\
% По которым поймёте "--- если только найдёте, "---\\Кто попался вам "--- Снарк или нет.\end{stanza}}
% {\Snark}
% }
% \epigraph{\begin{stanza}[0mm]
%  Одно и то же равно самому себе.
% \end{stanza}}
% {М.\,В.\,Ломоносов том 1 поиск есть}

% Базовы
Перед тем, как рассматривать архитектуру вычислительных систем,
приведём  определения из основных стандартов и~справочной литературы.

{\sloppy
% http://infosys2006.narod.ru/struct/architec.htm
\termin{Архитектура системы}  в~стандарте ANSI/IEEE Std 1471-2000 (IEEE Recommended Practice for Architectural Description of Software-Intensive Systems) 
определяется как 
фундаментальная организация системы, реализованная в~её~компонентах, их~взаимоотношениях друг с~другом и~средой, а~также в~принципах, определяющих её~конструкцию (проектирование, дизайн) и~развитие~\cite{infosys2006.narod.ru}. 

}

Таким образом, архитектура вычислительной системы реализована в~компонентах этой  системы и~их взаимоотношениях\picturecensored{ (рис.~\ref{ris:strela})}.
Что же такое вычислительная система?
\picturecensored{
\begin{illustration}
% https://habrahabr.ru/company/ua-hosting/blog/273665/
\includegraphics[width=\linewidth]{strela}
\caption{Принцип взаимодействия узлов ЭВМ Стрела\index{Стрела}-1% (иллюстрация к~ЭВМ Стрела-1)
}
\label{ris:strela}
\end{illustration}
}

\termin{Вычислительная система} (ВС), согласно Воройскому~\cite{voroiskij}, определяется двояко:
\begin{enumerate}
\item Совокупность ЭВМ и~средств программного обеспечения, предназначенная для выполнения вычислительных процессов.

\item Любая автоматизированная система, основанная на использовании ЭВМ.
\end{enumerate}


Термин {«автоматизированная система»} (АС), %[automated system]
в~свою очередь, словарь Воройского также  определяет двумя способами:
% в~словаре

\begin{enumerate}
\item    Совокупность управляемого объекта и~автоматических управляющих устройств, в~которых часть функций управления выполняет человек-оператор.

\item    Комплекс технических, программных, др. средств и~персонала, предназначенный для автоматизации различных процессов. \\В отличие от автоматической системы не может функционировать без~участия человека.
\end{enumerate}

% \textterminblue{
% Информатика. Новый систематизированный толковый словарь.    
% \\
% Воройский Ф.\,С.
% }
Если же обратиться к~комплексу стандартов на автоматизированные системы~\cite{ksas-def}, %(КСАС),
% то, согласно ГОСТ 34.003-90 (Комплекс стандартов на автоматизированные системы. Автоматизированные системы. Термины и~определения),
получим третье определение:
% Документация на \termin{автоматизированные системы (АС).}
% 
% Согласно ГОСТ 34.003-90 Комплекс стандартов на автоматизированные системы. Автоматизированные системы. Термины и~определения,
% \termin{Автоматизированная система (АС)}
% \termin{АС}
{автоматизированная система}
 "--- система, состоящая из персонала и~комплекса средств автоматизации его деятельности, реализующая информационную технологию выполнения установленных функций.
%  \textterminblue{ГОСТ 34.003-90}
 
% АС  \termin{не является ПО} в~чистом виде.

Таким образом, вычислительная система глобально может быть представлена как совокупность человека (оператора или программиста), технических средств (вычислительной машины, или компьютера% "--- computer, вычислитель
)
и~связывающих их программных средств.

Соответственно, архитектура вычислительной системы может быть описана двояко:
\begin{itemize}
\item \termin{структурная декомпозиция} 
рассматривает ВС с~точки зрения её аппаратных составляющих и~физических связей между ними
и~позволяет выделить её функциональные компоненты,
% вычислительной системы, %(её программной и~аппаратной частей, а~также человека)
% и~описать их взаимодействие;
% в~том числе аппаратную составляющую "--- вычислительную машину, или компьютер, программную составляющую и~взаимодействующего с~ними человека;
% вычислительной машины, 
в~том числе компоненты, предназначенные для хранения и~обработки программ,
и~компоненты, взаимодействующие с~пользователем;


\item \termin{иерархическая декомпозиция} 
рассматривает ВС с~точки зрения её логическо-информационной структуры
и~описывает %взаимодействие вычислительной машины (компьютера) с~программным обеспечением и~с~человеком.
языки  взаимодействия программиста с~программ%ами и, опосредованно
ными и~техническими средствами системы. %, а~также .
\end{itemize}

\section{Структурная декомпозиция вычислительной системы}
\epigraph{\begin{stanza}[0mm]
Кура \\
дура \\
процедура \\
\hspace{\stanzaoddindent}состоит из трёх частей: \\
карбюратор \\
вентилятор \\
\hspace{\stanzaoddindent}и~коробка скоростей!\\
\end{stanza}}{Надпись на парте}

Структурная декомпозиция применяется к~аппаратной части 
% вычислительной системы
ВС
"--- вычислительной машине, или компьютеру.

Если посмотреть на персональный компьютер, то он, как правило, состоит из \termin{системного блока} и~\termin{внешних устройств,} среди которых обязательно присутствуют \termin{устройства ввода-вывода,} предназначенные для взаимодействия с~пользователем "--- экран, клавиатура, мышь и~т.\,д.
% (рис.~\ref{ris:arch-comp-struct}).

% % При более внимательном рассмотрении
% Системный блок, в~свою очередь, состоит из корпуса и~\termin{внутренних устройств.} %, внутри которого располагаются
Внутри системного блока находятся \termin{внутренние устройства,}
из которых основными являются:
\begin{itemize}
\item системная, или материнская плата;\index{Системная (материнская) плата}
\item центральный процессор;\index{Процессор}
\item оперативная память (оперативное запоминающее устройство "--- ОЗУ);\index{Память!оперативная}
\item внешняя, или долговременная память (жёсткие диски, SSD и~т.\,д.);\index{Память!внешняя}
\item видеокарта;
\item звуковая карта и~т.\,д.
\end{itemize}
Внутренние устройства защищены корпусом системного блока и~получают постоянный ток через блок питания.
% Некоторые из них, хотя конструктивно выполнены внутри корпуса, не обязательны для работы компьютера.


% \begin{illustration}
% \includegraphics[width=\wideImageWidth]{arch-comp-struct}
% 
% \caption{Устройство компьютера}
% \label{ris:arch-comp-struct}
% \end{illustration}

% Основным компонентом 
Все компоненты компьютера связывает воедино системная плата (рис.~\ref{ris:motherboard_diagram}).
\index{Системная (материнская) плата}%
Важную роль играют входящие в~её состав два  мощных контроллера-концентратора "--- северный мост и~южный мост,
обеспечивающие согласование и~передачу информационных потоков между различными компонентами системного блока и~внешними устройствами.

\begin{illustration}
% \includegraphics[width=
% 0.8\approvedImageWidth
% % \wideImageWidth
% % 1.2\approvedImageWidth
% ,valign=c]{Motherboard_diagram_ru}

% \tikzstyle{arrowline}	= [-latex'new]
\tikzstyle{blockdraw}	= [draw, very thick]
% \tikzstyle{blockdraw}	= [draw, thick]

\tikzstyle{slot}	= [rectangle, blockdraw, minimum width=1em, minimum height=8em, fill=white]
\tikzstyle{widetext}	= [text width=12em]
% \tikzstyle{hubhei}	= [minimum height=8em]
\tikzstyle{hub}	= [widetext, blockdraw, text badly centered, minimum height=12em]

\tikzstyle{bus}	= [draw, double, thick]
% \tikzstyle{bus}	= [draw, double]

% \resizebox{\approvedImageWidth}{!}
\resizebox{\linewidth}{!}
{
% \singlespacing

\schemafont
\footnotesize
% \scriptsize
% \tiny

\begin{tikzpicture}[
start chain=Mem going right,
% node distance=12em,
start chain=Txt going below,
start chain=Ex going left,
% every node/.style={scale=0.5}
node distance=5em and 10em, % y and x 
x = 10em, y = 4em,
% baseline=(current bounding box.north)
]

% \tikzstyle{minitext}	= [widetext, left, on chain=Txt, solidchaincell] не работает
\tikzstyle{minitext}	= [solidchaincell, widetext, align=right, on chain=Txt, inner ysep = 0.5ex]

%   \node[minitext, text badly centered] (u_caption) {\normalsize Южный мост\par\footnotesize (контроллер"=концентратор ввода-вывода)\par};
  \node[minitext, text badly centered, inner ysep = 1ex] (u_caption) {\textbf{Южный мост}\par (контроллер"=концентратор ввода-вывода)\par};
\foreach \i/\n in {SATA, USB, Ethernet, Аудио/audio}
{
  \node[minitext] (\n) {\i};
}
%   \node[minitext] (audio) {\footnotesize Аудио\par};

  \node[hub, fit=(u_caption) (audio), inner sep = 0em] (sbridge) {};
  
  \node[slot, left=of sbridge, on chain=Ex] (ex0)  {};
{  
  \tikzset{node distance=1em}
  \node[slot, on chain=Ex]   {};
  \node[slot, on chain=Ex]   {};
  \node[slot, on chain=Ex]  (exlast) {};
}
\node[fit=(ex0) (exlast), inner sep = 0em] (ex) {};
\node[above=0em of ex] {Слоты PCI Express};

  \node[hub, above= of sbridge] (nbridge)  {\textbf{Северный мост}\par (контроллер"=концентратор памяти)};
%   \node[hub, below=of nbridge] (sbridge)  {Южный мост\par\footnotesize (контроллер-концентратор ввода-вывода)
%   \par
%   \hfill SATA\par\hfill USB};

  \path[bus] (nbridge) -- node[auto] {Внутренняя шина} (sbridge);

  \node[draw, dashed, fit=(nbridge) (sbridge), inner sep = 2em] (chipset) {};
  \node[above=0em of chipset.north west, anchor=south west] {Чипсет};

%   \node[slot, left=of nbridge] (gra)  {};
   \node[slot] (gra) at (nbridge-|exlast) {};
\node[above=0em of gra, text width=6em, text badly centered] {Слот графического контроллера};
   
 \node[slot, right=of nbridge, on chain=Mem] (mem0)  {};
{  
  \tikzset{node distance=1em}
  \node[slot, on chain=Mem]   {};
  \node[slot, on chain=Mem]   {};
  \node[slot, on chain=Mem] (memlast)  {};
}
\node[fit=(mem0) (memlast), inner sep = 0em] (mem) {};
\node[above=0em of mem] {Слоты памяти};

\tikzstyle{widetext}	= [text width=10em]
\tikzstyle{minihub}	= [hub, minimum height=8em]

%   \node[minitext, text badly centered, below=4em of sbridge.east|-chipset.south, outer ysep=1em] (m_caption) {\textbf{Мультиконтроллер}};
  \node[minitext, text badly centered, below=4em of chipset.south east, outer ysep=1em] (m_caption) {\textbf{Мультиконтроллер}};
\foreach \i/\n in {Клавиатура/kb, Мышь/mouse}
{
  \node[minitext] (\n) {\i};
}
  \node[minihub, fit=(m_caption) (mouse), inner sep = 0em] (mk) {};
  
\tikzstyle{minihub}	= [hub, minimum height=6em]
\tikzstyle{microhub}	= [hub, minimum height=5em, text width = 6em]
 
  \node[microhub, anchor=south] (bios) at (mk.south-|sbridge.west)  {\textbf{ПЗУ}\par (BIOS)};
  
  \node[minihub, above=1.5 of chipset] (cpu) {\textbf{ЦПУ}};
  \path[bus] (cpu) -- coordinate[pos=0.2] (from_tgen) node[auto, pos=0.5] {Фронтальная шина} (nbridge);
  
  \node[microhub, left=2em of from_tgen-|chipset.west] (tgen) {Тактовый генератор};
  \draw (tgen) -- (from_tgen);
  
\begin{pgfonlayer}{background}
  \path[bus] (nbridge) --  node[auto] {Шина памяти} (mem0) -- (memlast);
  \path[bus] (gra) --  node[auto] {Шина графического контроллера} (nbridge);
  \path[bus] (exlast)--(ex0) --  node[auto] {Шина PCI Express} (sbridge);

\end{pgfonlayer} 

  \path[bus] (mk) -- (mk-|sbridge);
  \path[bus] (sbridge) |- node[auto, swap, pos=0.25] {Шина LPC} (bios);
  
  
  \node[text width = 7em, text badly centered] (rmlabel) at (memlast|-Ethernet) {Разъёмы на~системной плате};
  \tikzstyle{rmstyle}	= [circle, draw, thick, minimum height=0.5em, inner sep = 0.1em]

\foreach \n in {SATA, USB, Ethernet, audio}
{
  \node[rmstyle] (r\n) at (\n-|rmlabel.west) {};
  \draw (\n-|sbridge.east) -- (r\n);
}  
\tikzmath{
coordinate \dc, \mklabeldiff, \a, \b;
\dc = ($(rUSB) - (rSATA)$);
\mklabeldiff = ($(mk.east)-(rmlabel.west)$);
% \a = 0.5*(\mkd+(\dcy,0));
\a = ($0.5*(\mklabeldiffx,0) + 0.5*(\dcy,0)$);	% dcy < 0
\b = ($(\a) - (\dcy,0)$);
}

  \node[rmstyle] (rkb) at ($(raudio) + (\dc)$) {};
  \node[rmstyle] (rmouse) at ($(rkb) + (\dc)$) {};
  
% \foreach \n/\dx in {kb/3em, mouse/2em}
% {
%   \coordinate[left = \dx of r\n] (vr\n);
%   \draw (\n-|mk.east) -| (vr\n) -- (r\n);
% } 
%   \draw (kb-|mk.east) -| ($(rkb) + 0.67*(\mklabeldiffx,0)$) -- (rkb);
%   \draw (mouse-|mk.east) -| ($(rmouse) + 0.33*(\mklabeldiffx,0)$) -- (rmouse);
  \draw (kb-|mk.east) -| ($(rkb) + (\a)$) -- (rkb);
  \draw (mouse-|mk.east) -| ($(rmouse) + (\b)$) -- (rmouse);


\end{tikzpicture}
}


\caption{Схема системной платы}
\label{ris:motherboard_diagram}
\end{illustration}%



\termin{Северный мост} 
определяет частоту системной шины, тем самым "--- вид и~объём ОЗУ, тип шины видеоадаптера (обычно это PCI Express или AGP),
осуществляет обмен между центральным процессором и~скоростными устройствами,
это
% частота шины, вид и~объём ОЗУ, тип шины видеоадаптера.
\begin{itemize}
\item оперативная память (ОЗУ);
\item видеокарта;
\item южный мост.
\end{itemize}

% Процессор связан с~

\termin{Южный мост} 
осуществляет обмен с~устройствами по низкоскоростным интерфейсам, это
% "--- часы, память CMOS,
% работа с~низкоскоростными интерфейсами:
\begin{itemize} 
\item часы;
\item энергозависимая память (ПЗУ);
\item контроллер  SATA;
\item контроллер IDE;
\item контроллер прерываний;
\item контроллер USB;
\item контроллер прямого доступа.
\end{itemize}
Внутренняя шина, связывающая северный мост и~южный мост, обеспечивает непрерывность потоков информации.


Взаимосвязь различных элементов системной платы и~устройств обеспечивают различные системные шины (магистрали).
Иногда \termin{системной шиной} называют только шину, связывающую процессор и~северный мост.

Совокупность проводов системной магистрали можно разбить на четыре группы (рис.~\ref{ris:bus-controllers}):
\begin{illustration}

% \resizebox{0.8\linewidth}{!}{
% \resizebox{\approvedImageWidth}{!}{
% \resizebox{\wideImageWidth}{!}{
\resizebox{\linewidth}{!}{
\schemafont
% \setlength{\leftmargini}{14ex}
% \setlist{leftmargin=*,topsep=0pt,itemsep=0pt}
\input{book/drawings/arch-bus-controllers}
}
\caption{Структура системной шины}
\label{ris:bus-controllers}
\end{illustration}
\begin{itemize} 
\item шина питания (так как по этой шине не передаётся никакой информации, её часто опускают на схемах);
\item шина управления, используемая для организации обмена самой магистрали;
\item шина данных;
\item шина адреса.
\end{itemize}
\index{Тактовый генератор}%
Шины питания и~управления связывают все устройства, %; шины данных и~адреса охватывают только устройства, связанные с~обработкой данных.
в~том числе \termin{тактовый генератор,}
предназначенный для синхронизации работы различных устройств системной платы.
Тактовый генератор задаёт частоту работы процессора как самого быстрого устройства; частоты  более медленных устройств являются делителями частоты процессора.

\index{ПЗУ}%
Кроме оперативной, в~ВС имеется \termin{постоянное запоминающее устройство (ПЗУ)} "--- энергонезависимая память,
в~которой записана неизменяемая информация, которая сохраняется после отключения питания.
Там
% В~\termin{постоянном запоминающем устройстве} (энергонезависимой памяти) 
хранится микропрограмма управления вычислительной машиной.
Она обязательно включает программы начальной загрузки и~самотестирования.

\index{BIOS}%
В~постоянном запоминающем устройстве персонального компьютера записывается BIOS (Basic­ Input/Output­ System "--- базовая­ система­ ввода/вывода),
включающая, кроме загрузчика, также настройки и~функции ввода/вывода с~помощью программных прерываний.
Ввод-вывод при помощи BIOS доступен только в~реальном режиме работы компьютера.
Современные операционные системы сразу после загрузки переводят компьютер в~защищённый режим и~не используют BIOS.

Сама операционная система, как и~загружаемые ею программы, располагается в~\termin{оперативной} (энергозависимой) памяти.



\termin{Центральный процессор} (центральное процессорное устройство, ЦПУ)
является «мозгом» ВС. Он исполняет код программ.
% Кроме центрального процессора, на материнской плате 
ЦПУ часто называют просто процессором, иногда "--- микропроцессором (МП).
Исторически микропроцессор "--- это процессор, выполненный на одной микросхеме; сейчас другие варианты исполнения нерентабельны
и~эти два термина стали синонимами.
% 
Ранее для специализированных процессоров, расширяющих функциональность ЦПУ, использовался термин «сопроцессор»,
но в~настоящее время
сопроцессоры либо вошли в~состав ЦПУ (в~частности, математический сопроцессор x87 входит в~ядро современных ЦПУ семейства x86), 
либо получили иные %собственные 
названия (так, графический сопроцессор обычно называется видеокартой или графическим ускорителем).

{Центральный процессор} %(центральное процессорное устройство, ЦПУ) 
включает
\index{Процессор}%
\index{АЛУ}%
\index{УУ}%
\index{Регистры}%
\begin{itemize}
\item арифметико-логическое устройство (АЛУ), выполняющее обработку данных;
\item управляющее устройство (УУ), декодирующее поступающие в~процессор команды и~формирующее на их основе сигналы для АЛУ;
\item регистры "--- сверхбыструю память особой структуры и~малого объёма, предназначенную
% , предназначенные 
для временного хранения данных.
% (в~частности, %специальные регистры хранят сл
% регистр команд содержит декодируемую в~данный момент команду,
% указатель команды содержит адрес следующей команды
% и~т.\,п.;
% % другие специальные
% регистры общего назначения могут быть использованы программистом по своему усмотрению).
Часть регистров может быть использована программистом по своему усмотрению (регистры общего назначения), часть используется для специальных целей.
\end{itemize}
\index{Кеш-память}%
Также современные процессоры содержат кеш-память (сверхоперативную память), предназначенную для прозрачного временного хранения фрагментов оперативной памяти.
Время обращения к~кеш-памяти больше, чем к~регистрам, но меньше, чем к~ОЗУ.
% Кеш-память быстрее ОЗУ, но медленнее регистров
\pagebreak[3]

\subsection{Единицы измерения}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
Нам в школе выдали линейку, \\Чтобы мерить объём головы.
\end{stanza}}
{\Bg[Растаманы из~глубинки]}
% ]{
% \epigraph{\begin{limerick}
%     Жил-был старичок между ульями,\\
%     От пчёл отбивавшийся стульями.\\
%     Но он не учёл\\
%     Числа этих пчёл\\
%     И пал смертью храбрых меж ульями.
% \end{limerick}
% }
% {\Lear}
% }
% \epigraph{
% % \begin{stanza}
% Будьте верны в мерянии, когда вы мерите для других; и весьте весами правильными: это самое доброе и~самое лучшее по отношению к тому, в~чём требуется определённость. 
% % \end{stanza}
% }
% {\Quran{17.37}}
\label{sec:byte}
\index{Бит}%
\index{Байт}%
\index{Октет}%
\index{Слово!машинное}%
Базовой единицей измерения информации в~современных ЭВМ является \termin{бит} "--- двоичный разряд.

В~соответствии с~характеристиками магистрали и~регистров вводятся дополнительные 
платформозависимые
единицы измерения:
% характеризующие конкретную вычислительную систему:
\begin{itemize}
\item машинное \termin{слово}  "--- разрядность регистров процессора и/или шины данных;
\item \termin{байт} "--- %совокупность битов, обрабатываемая компьютером одномоментно (обычно байт=октет).
минимальный независимо адресуемый \rlap{набор данных.}
\end{itemize}
Понятие машинного слова возникло раньше понятия байта.
Вначале минимально адресуемый блок памяти (байт) и~блок, загружаемый или обрабатываемый за один раз (слово) всегда совпадали.
% Машинное слово равно или кратно байту.
В~настоящее время машинное слово может быть как равно, так и~кратно байту.

% http://forum.ixbt.com/topic.cgi?id=8:20632
В~настоящее время байт обычно составляет восемь бит, но существуют  DSP-процессоры, для которых байт состоит из шестнадцати или двенадцати бит.
На начальных этапах развития вычислительной техники размер байта вообще не был стандартизирован.
Впервые термин «байт» был употреблён для совокупности шести битов.

Если необходимо описать именно восемь двоичных разрядов, используется термин  \termin{октет.}
% \termin{Октет} "--- 8 бит ($2^8 = 256$ состояний).
В~частности, эта единица измерения используется при описании сетевых протоколов.
% где, строго говоря, невозможно определить байт, так как нет единой архитектуры

В~семействе процессоров x86 используется восьмибитный байт.
Длина машинного слова менялась от шестнадцати бит у~первых моделей до шестидесяти четырёх у~современных.
\index{Слово!x86}%
При этом для совместимости документации термин «слово» остался за шестнадцатью битами.
\index{Слово!двойное}%
Тридцать два бита называют двойным словом,
\index{Слово!четверное}%
шестьдесят четыре "--- четверным и~так далее.

Далее по тексту везде подразумевается, что байт состоит из восьми бит.


\subsection{Порядок следования байтов% в~словах
}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
Вот в руке письмо, но вижу только буквы\\
И мне не вспомнить, как они собирались в слова.
% В полной пустоте круги на воде
% Voulez vous coucher avec moi?
\end{stanza}}
{\Bg[\mbox{Voulez-Vous Coucher Avec Moi?}]}
% \epigraph{
%  Корпускулы, не имеющие плоскости соприкосновения, не~сцепляются.
% }
% {М.\,В.\,Ломоносов}
% ]{
% \epigraph{\begin{limerick}
% Злополучную даму в~Байраме\\
% Много раз прищемляло дверями.\\
% «А~может быть, впредь\\
% В~дверях не сидеть?» "---\\
% Подумала дама в~Байраме.\\
% \end{limerick}
% }
% {\Lear}
% }
\index{Байт!порядок байтов}%
\label{sec:byteorder}
% Так как байт "--- минимальный адресуемый блок памяти, невозможно судить о~

Для начала уточним:
в~современных ВС память адресуется побайтово, при этом начальный адрес равен нулю, и~адрес каждого следующего байта возрастает на единицу.
То есть в~качестве модели памяти можно рассматривать непрерывную ленту из последовательно расположенных байтов
с~непрерывно возрастающими на единицу номерами "--- адресами.
% ?????
Подобные последовательности принято записывать, следуя обычному направлению письма, то есть адреса возрастают слева направо.
% То есть адреса возрастают слева направо.
Адресом слова считается адрес его самого левого байта (далее будем обозначать его~$\zeta$).

Кроме того, число в~вычислительных системах представляется в~двоичной позиционной системе счисления, то есть в~виде совокупности двоичных разрядов "--- битов.
Каждый бит имеет свой вес, соответственно которому разряды также можно упорядочить "--- от младшего к~старшему.
\begin{equation}
X = x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k, ~~x_i \in \{0,1\}
\end{equation}
% Количество битов числа всегда кратно размеру байта. % (если значащих двоичных цифр меньше, «лишние»)
Если число включает восемь бит (занимает один байт), то никакой неоднозначности нет "--- число имеет адрес, равный адресу единственного байта.
Биты внутри байта не имеют адресов, но ранжируются по весу.

Если число включает %16 бит или более, оно записывается несколькими байтами.
шестнадцать бит, оно записывается двумя байтами.
Каждый байт включает восемь смежных по старшинству разрядов числа (рис.~\ref{ris:word-bytes},~а).
\begin{equation}
% X = \chi_0 + \chi_1\cdot 2^8 + \ldots + \chi_{\kappa}\cdot (2^8)^{\kappa}, ~~\chi_i \in \{0,1,\ldots 255\}
X = \chi_0 + \chi_1\cdot 256, 
% + \ldots + \chi_{\kappa}\cdot 256^{\kappa}
~~\chi_i \in \{0,1,\ldots 255\}
\end{equation}



\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=5 ex]
\tikzstyle{bit}	= [reg, solidchaincell, minimum width=5 ex]
\tikzstyle{byte}	= [reg, fill=clMemoryLight, solidchaincell, minimum width=8*5 ex]

% \newcommand{\byteorder}[3][]
% {
% \begin{tikzpicture}[
% start chain=going left,
% node distance=0.5ex,
% ]
% 
% 
%   \tikzmath{
%     int \lastbyte, \lastbit;
%     \lastbyte = #2;
%     \lastbit = 8*(\lastbyte)+7; 
%     \linedistex = 12;
%   }
%   
%   
%   \foreach \bitnum in {0,...,\lastbit}
%   {
%     \node[bit, on chain, label=below:$\bitnum$] (b\bitnum) {$x_{\bitnum}$};
%   };
%     
%   \foreach \bytenum in {0,...,\lastbyte}
%   {
%     \tikzmath{
%       int \bs, \be;
%       \bs = 8*\bytenum;
%       \be = 8*(\bytenum+1)-1;
%     }
%     \draw [decorate,decoration={brace,amplitude=1em},xshift=0pt,yshift=0.5ex]
%     (b\be.north west)--(b\bs.north east)
%     node [black,midway,yshift=4ex] 
% %     {байт $\bytenum$ ($\chi_{\bytenum}$)};
%     {#3};
% 
%     \tikzmath{
%       int \intel, \motor;
%       \intel = \lastbyte - \bytenum;
%       \motor = \bytenum;
%     }
%     \node[byte, label=below:$\byteaddr{\bytenum}$, below = \linedistex ex of b\bs.east, anchor = east] (i\bytenum) {$\chi_\intel$};
%     \node[byte, label=below:$\byteaddr{\bytenum}$, below = 2*\linedistex ex of b\bs.east, anchor = east] (m\bytenum) {$\chi_\motor$};
% 
%   };  
% 
%   \foreach \leftline in {b\lastbit, i\lastbyte, m\lastbyte}
%   {
%     \node[left = 2ex of \leftline] {\asbuk{risletter})\stepcounter{risletter}};
%   };  
% 
% 
% \end{tikzpicture}
% }

\begin{illustration}
\setcounter{risletter}{1}
\tikzmath{
  let \byted{1} = старший;
  let \byted{0} = младший;    
  let \byteaddr{1} = \zeta;
  let \byteaddr{0} = \zeta+1;    
}
  
\resizebox{\linewidth}{!}
{
% \byteorder{1}{\byted{\bytenum} байт ($\chi_{\bytenum}$)}
\begin{tikzpicture}[
start chain=going left,
node distance=0.5ex,
]


  \tikzmath{
    int \lastbyte, \lastbit;
    \lastbyte = 1;
    \lastbit = 8*(\lastbyte)+7; 
    \linedistex = 12;
  }
  
  
  \foreach \bitnum in {0,...,\lastbit}
  {
    \node[bit, on chain, label=below:$\bitnum$] (b\bitnum) {$x_{\bitnum}$};
  };
    
  \foreach \bytenum in {0,...,\lastbyte}
  {
    \tikzmath{
      int \bs, \be;
      \bs = 8*\bytenum;
      \be = 8*(\bytenum+1)-1;
    }
    \draw [decorate,decoration={brace,amplitude=1em},xshift=0pt,yshift=0.5ex]
    (b\be.north west)--(b\bs.north east)
    node [black,midway,yshift=4ex] 
%     {байт $\bytenum$ ($\chi_{\bytenum}$)};
    {\byted{\bytenum} байт ($\chi_{\bytenum}$)};

    \tikzmath{
      int \intel, \motor;
      \intel = \lastbyte - \bytenum;
      \motor = \bytenum;
    }
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = \linedistex ex of b\bs.east, anchor = east] (i\bytenum) {$\chi_\intel$};
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = 2*\linedistex ex of b\bs.east, anchor = east] (m\bytenum) {$\chi_\motor$};

  };  

  \foreach \leftline in {b\lastbit, i\lastbyte, m\lastbyte}
  {
    \node[left = 2ex of \leftline] {\asbuk{risletter})\stepcounter{risletter}};
  };  


\end{tikzpicture}
}

\caption{Двухбайтовое число: а)~биты старшего и~младшего байтов, б)~прямой порядок байтов в~памяти, {в)~обратный порядок байтов в~памяти}}
\label{ris:word-bytes}
\end{illustration}

При этом каждому байту числа можно сопоставить и~его вес (старшинство его битов в~числе), 
и~адрес (расположение в~памяти).
На любой платформе байты двухбайтового числа (младший~$\chi_0$ и~старший~$\chi_1$) расположены в~памяти рядом,
но друг относительно друга они могут располагаться  по-разному.
% По младшему адресу (обозначим его~$\zeta$) может находиться как младший байт~$\chi_0$ (такой порядок называется прямым и~показан на рис.~\ref{ris:word-bytes}, б), так и~старший~$\chi_1$ (такой порядок называется обратным, рис.~\ref{ris:word-bytes}, в).

Для двухбайтового числа возможны только два варианта:
\begin{itemize}
\item прямой порядок (также называемый little-endian, Intel или VAX)  "--- младший байт слова расположен по~младшему адресу (рис.~\ref{ris:word-bytes}, б);
\item обратный (big-endian, Motorola или сетевой порядок) "--- младший байт слова расположен по~старшему адресу (рис.~\ref{ris:word-bytes}, в).
\end{itemize}

Числа в~любой позиционной системе счисления принято записывать в~арабской традиции "--- младший разряд справа, старший слева.
Содержимое памяти (дамп памяти), напротив, записывается, следуя европейскому направлению письма "--- младшие адреса слева, старшие справа.
% Таким образом, обратный порядок байтов позволяет легко читать числа, записанные в~памяти.
% Обратный порядок принят в~протоколе TCP/IP. % и~иногда на
Из-за этого на рис.~\ref{ris:word-bytes} именно прямой порядок выглядит «перевёрнутым», а~обратный "--- соответствует привычной позиционной записи числа.

Значение каждого  байта в~дампе записывается 
двумя шестнадцатеричными цифрами
в~арабской традиции (как  число, которое уже не может быть разделено на части с~разными адресами).
% в~шестнадцатеричной системе счисления. Для записи восьмибитного значения байта достаточно двух шестнадцатеричных цифр.
Соответственно, конкретные числа в~дампе памяти выглядят ещё экзотичнее.
Пусть необходимо записать в~память вычислительной машины с~восьмибитным байтом
шестнадцатибитное число $x=\hex{0x0A\,0B}$.
Оно содержит два байта: старший $\chi_1=\hex{0A}$, младший $\chi_0 = \hex{0B}$.
Дамп памяти с~прямым порядком байтов, соответственно, будет выглядеть как $\chi_0 \chi_1 = \hex{0B\,0A}$ (то есть разряды  числа  несколько «перетасованы»),
с~обратным порядком "--- как $\chi_1 \chi_0 = \hex{0A\,0B}$.

Если %машинное слово
число
состоит из нескольких байтов, эти байты в~памяти ВС также могут быть расположены друг относительно друга по-разному.
% 
Чаще всего используется 
% один из следующих вариантов:
% \begin{itemize}
% \item прямой порядок (также называемый little-endian, Intel или VAX)  "--- младший байт слова расположен по~младшему адресу;
% \item обратный (big-endian, Motorola или сетевой порядок) "--- младший байт слова расположен по~старшему адресу.
% \end{itemize}
прямой или обратный порядок (рис.~\ref{ris:dword-bytes}).

% Прямой порядок %исторически сложился 
% % позволяет обрабатывать числа, состоящие из 

\begin{illustration}
\setcounter{risletter}{1}
\tikzmath{
  let \byteaddr{3} = \zeta;
  let \byteaddr{2} = \zeta+1;    
  let \byteaddr{1} = \zeta+2;
  let \byteaddr{0} = \zeta+3;    
}
  
\resizebox{\linewidth}{!}
{
% \byteorder{3}{$\chi_{\bytenum}$}
\begin{tikzpicture}[
start chain=going left,
node distance=0.5ex,
]


  \tikzmath{
    int \lastbyte, \lastbit;
    \lastbyte = 3;
    \lastbit = 8*(\lastbyte)+7; 
    \linedistex = 9;
  }


\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=4 ex]
\tikzstyle{bit}	= [reg, solidchaincell, minimum width=2 ex]
\tikzstyle{byte}	= [reg, fill=clMemoryLight, solidchaincell, minimum width=16 ex]
  
  
  \foreach \bitnum in {0,...,\lastbit}
  {
    \node[bit, on chain, label=below:\scriptsize$\bitnum$] (b\bitnum) {};
  };
    
  \foreach \bytenum in {0,...,\lastbyte}
  {
    \tikzmath{
      int \bs, \be;
      \bs = 8*\bytenum;
      \be = 8*(\bytenum+1)-1;
    }
    \draw [decorate,decoration={brace,amplitude=1em},xshift=0pt,yshift=0.5ex]
    (b\be.north west)--(b\bs.north east)
    node [black,midway,yshift=4ex] 
%     {байт $\bytenum$ ($\chi_{\bytenum}$)};
    {$\chi_{\bytenum}$};

    \tikzmath{
      int \intel, \motor;
      \intel = \lastbyte - \bytenum;
      \motor = \bytenum;
    }
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = \linedistex ex of b\bs.east, anchor = east] (i\bytenum) {$\chi_\intel$};
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = 2*\linedistex ex of b\bs.east, anchor = east] (m\bytenum) {$\chi_\motor$};

  };  

  \foreach \leftline in {b\lastbit, i\lastbyte, m\lastbyte}
  {
    \node[left = 2ex of \leftline] {\asbuk{risletter})\stepcounter{risletter}};
  };  


\end{tikzpicture}
}

\caption{Четырёхбайтовое число: а) байты и~биты числа, б)~прямой~порядок байтов в~памяти, \mbox{в) обратный порядок байтов в~памяти}}
\label{ris:dword-bytes}
\end{illustration}


Пусть необходимо записать в~память вычислительной машины с~восьмибитным байтом
тридцатидвухбитное число $x=\hex{0x0A\,0B\,0C\,0D}$.
Оно займёт четыре смежных байта с~адресами $\zeta, \zeta+1, \zeta+2$ и~$\zeta+3$.
Наименьший из них (младший)  адрес $\zeta$ будет адресом числа~$x$.
% 
Рассмотрим, как оно будет расположено в~памяти при разных порядках размещения.

% Число \hex{0x0A\,0B\,0C\,0D}, записанное  
При записи
с~обратным порядком байтов это число
при просмотре дампа памяти будет выглядеть как \hex{0A\,0B\,0C\,0D}, то есть старший байт \hex{0A} будет записан по младшему адресу $\zeta$
и,~соответственно, напечатан первым (левее всего),
байт \hex{0B} "--- по адресу $\zeta+1$, \hex{0C}"--- по адресу $\zeta+2$,
младший байт \hex{0D} окажется записанным по самому старшему адресу  $\zeta+3$ и~при просмотре или печати дампа памяти окажется правее остальных.

% То же число 
При записи
с~прямым порядком байтов это число будет выглядеть как \hex{0D\,0C\,0B\,0A}:
младший байт \hex{0D} записан по младшему адресу  $\zeta$,
\hex{0C} "--- по адресу $\zeta+1$, \hex{0D} "--- по адресу $\zeta+2$,
старший байт \hex{0A} "--- по старшему адресу  $\zeta+3$.
% (то есть разряды [??? байты?] числа в~памяти несколько «перетасованы»)

Очевидно, что обратный порядок байтов позволяет легко читать числа, записанные в~памяти.
Обратный порядок принят в~протоколе TCP/IP. % и~иногда на

Прямой порядок байтов удобен при обработке чисел большой разрядности с~помощью процессора малой разрядности,
так как позволяет %, в~частности, 
при сложении таких чисел обращаться к~памяти последовательно в~порядке возрастания адресов, а~такие запросы выполняются быстрее
(это учитывается в~схемной реализации алгоритмов обработки).
% В~частности, в~процессорах семейства x86 используется прямой порядок байтов (порядок Intel).
% так как восьмибитные предки этого семейства (8008 и~8080) 

Некоторые системы позволяют переключать используемый порядок байтов при помощи перемычки на материнской  плате или программно (bi-endian, bytesexual).

Также иногда используется смешанный (middle-endian, mixed-endian) порядок байтов:
% байты в~словах расположены в~обратном порядке, но, если число состоит из нескольких слов, слова расположены в~прямом порядке ()
% либо наоборот.
байты в~словах расположены в~одном порядке, но, если число состоит из нескольких слов, слова располагаются наоборот.
В~частности, в~PDP-11 младший байт слова расположен по младшему адресу, но младшее слово числа "--- по старшему (PDP-endian), так что наше
число \hex{0x0A\,0B\,0C\,0D} имеет в~памяти вид \hex{0B\,0A\,0D\,0C}.
Другой вариант смешанного порядка "--- младший байт слова по старшему адресу, а~младшее слово числа "--- по младшему, "--- даст \hex{0C\,0D\,0A\,0B}. 

В~процессорах семейства x86 используется прямой порядок байтов (порядок Intel).
Он применяется даже к~вещественным числам, которые не имеет смысла обрабатывать по частям:
число  \hex{3F\,F0\,00\,00\,00\,00\,00\,00} ($1.0$, то есть единица с~плавающей запятой двойной точности)
будет записано в~памяти как
\hex{00\,00\,00\,00\,00\,00\,F0\,3F}.



\subsection{Цикл выполнения команды}
% \subsection{Выполнение программ}
\epigraph{\begin{stanza}[0mm]
А ну,\\
раз взмахнул,\\
и~ещё взмахну.
\end{stanza}
}
{\Vvm[Мистерия-буфф]}
% \epigraphcensoredtwo[
% \epigraph{\begin{stanza}[0mm]
% В моей альтернативе есть логический блок,\\
% Спасающий меня от ненужных ходов,\\
% Некий переносной five o'clock,\\
% Моя уверенность в том, что я не готов.\\
% \end{stanza}}
% {\Aquarium}
% % \epigraph{
% %  Теоретическая часть химии состоит в философском познании изменений смешанного тела.
% % }
% % {М.\,В.\,Ломоносов}
% ]{
% \epigraph{\begin{limerick}
%     Жил один старичок в Мэриленде \\
%     Пивший соевый соус и бренди;\\
%     Он их пил понемножку\\
%     За ложкою ложку\\
%     При свете луны в Мэриленде.\\
% \end{limerick}
% }
% {\Lear}
% }
\label{sec:command-cycle}
% Естественный ход выполнения программы "--- последовательное выполнение её команд.
\index{Цикл выполнения команды}%

Проходящие через ВС потоки информации можно разделить на две основные группы: 
команды и~данные.

Данные представляют собой информацию, подлежащую обработке и,~как правило, размещаются в~памяти ВС.

Команды предназначены организовать и~выполнить обработку данных процессором ВС.
Последовательность команд называется программой и~также расположена в~памяти ВС.

% http://www.excode.ru/art6449.html
Выполнение команды процессором можно разбить на ряд этапов.
Эту последовательность называют циклом выполнения команды, или рабочим циклом процессора.
\begin{enumerate}
\item Выборка (загрузка) команды из памяти.
% Выполнение команды начинается с~её загрузки (выборки) из памяти.
Адрес загружаемой команды хранится в~специальном регистре "--- указателе команды ({instruction pointer,} $ip$).
На рис.~\ref{ris:command-cycle} указатель команд хранит адрес команды К-1.

\begin{illustration}
% \resizebox{\wideImageWidth}{!}{
\resizebox{\linewidth}{!}{
\schemafont
\input{book/drawings/command-cycle}
}
\index{Флаги}

\caption{Цикл выполнения команды}
\label{ris:command-cycle}
\end{illustration}

Двоичный код выбранной команды К-1  попадает в~другой специальный регистр "--- регистр команд.

\item %После выборки команда декодируется, в~частности
Декодирование команды.
На этом этапе определяется, выбрана ли команда целиком или  необходима дозагрузка (разные команды могут иметь различную длину).
Когда команда загружена полностью, 
определяется наличие у~неё операндов и~их расположение,
наличие числового результата и~его расположение,
а~также 
формируется сигнал для АЛУ в~соответствии с~типом команды.

\item Выборка операндов.
% Загрузка данных.
На следующем этапе из памяти %или регистров общего назначения ? не грузятся
загружаются операнды команды,
% После загрузки они 
которые затем помещаются в~специальные регистры.
% http://henu3gu.narod.ru/evm/133-143.html
Если операнды располагаются в~регистрах общего назначения, они поступают в~АЛУ на этапе выполнения~\cite{zilker}.

\item Выполнение инструкции.
% \item Установка флагов
Этап выполнения команды протекает различным образом для различных команд.
В~случае арифметических команд операнды поступают из регистров на вход АЛУ, 
АЛУ выполняет операцию, соответствующую команде,
результат записывается в~специальный регистр результата, формируются признаки результата (нулевое значение, некорректный результат и~так далее).
\index{Флаги}

\item   Запись результатов и~установка флагов.
На этом этапе результат загружается из регистра результата в~расположение, определённое при декодировании (это может быть как ячейка памяти, так и~регистр общего назначения).
Признаки результата записываются в~регистр флагов,
доступный для анализа дальнейшими командами.
% по значению которого программа.

\item Формирование адреса следующей команды.
% 
% После этого в~указатель команд 
В~регистр указателя команд
помещается адрес следующей команды.
% Чаще всего это команда, непосредственно следующая за выполненной (К-2), но, 
Если К-1 была командой условного или безусловного перехода, вызова или возврата из функции и~т.\,п., адрес следующей команды можно узнать только после выполнения К-1.

\end{enumerate}

\modifytwo[\subsubsection{Конвейер}]{}
% Для каждой команды необходимо последовательно выполнить все этапы.
% Для некоторых команд необходима только часть этапов, но последовательность нарушена быть не может.
Обработка разных команд при этом может вестись параллельно.
% Таким  образом, время выполнения команды будет 
Для этого цикл выполнения команды разбивают на несколько стадий "--- от двух для ранних ЭВМ, в~частности, для ЭЦВМ Урал, до нескольких десятков в~настоящее время.
Выполнение каждой из этих стадий реализуется независимо от других.
% "--- так, чтобы работа компонента, выполняющего каждую из стадий, не

При подобной реализации обработка следующей команды может выполняться, не дожидаясь конца текущей;
такой способ организации вычислений называется \termin{конвейером.}
\index{Конвейер}%

Так, в~большинстве случаев  после команды К-1 будет выполняться команда, непосредственно следующая за ней в~программе  (К-2)
"--- подобная последовательность называется естественным ходом выполнения.
Таким образом, уже после полной выборки К-1    можно обновить указатель команд.
Соответственно, если конвейер включает шесть стадий, описанных выше,
то, 
\begin{itemize}
\item пока К-1 будет декодироваться, можно выполнить выборку К-2;
\item во время выборки операндов К-1 освободится блок декодирования, так что можно декодировать К-2;
\item во время выполнения К-1 можно выбрать из памяти операнды К-2 и~так далее.
\end{itemize}
Если нет сбоев или задержек, %среднее 
время выполнения команды будет определяться временем выполнения самой длинной стадии.

% http://old.computerra.ru/terralab/235537/
Сбои конвейерной обработки возможны в~нескольких случаях:
\begin{enumerate}
\item Различные времена выполнения стадий для разных команд. Для решения этой проблемы перед блоками, исполняющими каждую стадию, вставляются блоки-диспетчеры, организующие очередь.
\item Конфликты по данным (в~частности, операндом К-2 может быть результат К-1).
Подобные зависимости отслеживаются на этапе декодирования и~учитываются планировщиком на этапе выполнения.
В~некоторых процессорах планировщик может изменить порядок выполнения команд так, чтобы избежать зависимостей по данным между соседними командами.
\item Выполняемая команда нарушает естественный ход выполнения программы (например, %переходы, вызов и~возврат из функции
К-1 может быть командой перехода к~К-4).
Это приводит к~очистке и~повторной загрузке конвейера, что существенно снижает быстродействие.
Для предотвращения постоянной очистки конвейера в~циклах современные процессоры используют различные алгоритмы %предсказания
прогнозирования переходов.
\end{enumerate}

% https://habrahabr.ru/post/182002/
В~линейке x86 конвейер впервые появился в~процессоре i486 и~включал пять стадий, что позволило более чем вдвое увеличить производительность.

% \index{Суперскалярные ЭВМ}%
\index{Суперскалярность}%
Если процессор включает несколько конвейеров, возможна полностью одновременная обработка нескольких команд.
% Некоторые узлы конвейера могут быть продублированы, тогда соответствующие стадии могут проходить параллельно несколько команд.
Подобные процессоры называются \termin{суперскалярными}.
При этом параллельно могут выполняться только команды, не связанные зависимостями по данным.
Отслеживание зависимостей и~планирование исполнения реализуется внутри суперскалярных процессоров.

Перед выполнением программы её код должен быть загружен в~память.
Выполнение программы начинается с~помещения  в~указатель команд~$ip$
адреса той команды, которая должна быть выполнена первой (точки входа).


% \termin{Конвейер:}
% \begin{itemize}
% \item выборка и~декодирование инструкции
% \item    загрузка данных
% \item    выполнение инструкции
% \item   запись результатов
% \end{itemize}

\subsubsection{Классификация по набору команд}

По количеству и~структуре команд архитектуры делятся на два  основных типа.
\begin{enumerate}
\item    CISC\index{CISC} (complex instruction set computer "--- компьютер с~набором сложных команд) "--- набор команд огромен и~разнообразен, 
сами команды имеют переменную длину и~сложную структуру, а~также используют сложные режимы адресации; 
регистров мало и~функции многих из них предопределены.

Это было сделано для упрощения программирования в~машинных кодах, компактности программ и~удешевления самого процессора.

\item    RISC\index{RISC} (reduced instruction set computer "--- компьютер  с~набором упрощённых  команд, архитектуры load/store)
"--- набор команд включает команды простой постоянной структуры и~фиксированной длины; при этом процессор содержит множество регистров, так что обращение к~памяти производится только для загрузки (load) данных в~регистры и~выгрузки (store) их оттуда.

Такая архитектура позволяет поднять частоту и~параллельность
и~хорошо подходит для компиляции с~языка высокого уровня.
\end{enumerate}

Естественным продолжением идеологии RISC\index{RISC} являются архитектуры типа    VLIW (very long instruction word "--- сверхдлинное командное слово).
Команда VLIW объединяет несколько команд RISC\index{RISC} по числу конвейеров\index{Конвейер} процессора; эти команды выполняются параллельно на соответствующих конвейерах.

В~отличие от суперскалярных процессоров, где распределение команд по конвейерам\index{Конвейер} происходит во время выполнения специальным устройством в~составе процессора,
командные слова VLIW формируются компилятором\index{Компилятор} на этапе сборки программы.
\index{Суперскалярность}%
Это позволяет упростить и~удешевить процессор, но усложняет разработку компиляторов и~увеличивает длину программы.
% , так как в~некоторых командных словах часть команд 
% (если компилятор не)


\begingroup
% \setstretch{1.5}
% \renewcommand{\baselinestretch}{2}
% \setlength{\baselineskip}{1.15\baselineskip}
\subsection{Расположение программ и~данных}
% \epigraphcensoredtwo[
\epigraph{
\begin{stanza}
Аксиома:\\
Все люди имеют шею.\\
Задача:\\
Как поэту пользоваться ею?
\end{stanza}
}
{\Vvm[Пятый Интернационал]}
% ]{
% \epigraph{\begin{limerick}
%     Старичок, проживавший в Рангуне,\\
%     Погулять как-то вышел в июне.\\
%     Возвращаясь назад,\\
%     Нёс он двух поросят,\\
%     Арестованных лично в Рангуне.\\
% \end{limerick}
% }
% {\Lear}
% }

Данные и~команды поступают в~процессор по системной шине из памяти.
% Системная шина, кроме всего прочего, реализует связь процессора с~памятью, хранящей программы и~данные.
% Эта связь может быть реализована двояко.
Соответственно, память может быть общей для команд и~данных "--- в~этом случае для связи с~процессором достаточно одной общей шины (рис.~\ref{ris:harvard-prinston}, а).
Такая архитектура требует меньшего количества элементов и~дорожек, поэтому она дешевле и~компактнее.

\begin{illustration}

\newcommand{\DoublearrowYRight}[2]
{
  \path[blockarrow] (#2) ++(0,0.5ex) coordinate(tmpUp) -- (tmpUp-|#1);
  \path[blockarrow] (#2-|#1)   ++(0,-0.5ex) coordinate(tmpDown) -- (tmpDown-|#2) ;
}

% \resizebox{\wideImageWidth}{!}{
\resizebox{\linewidth}{!}{
\schemafont
\begin{tikzpicture}[
node distance=2ex and 4ex,
baseline=(current bounding box.north)
]
\tikzstyle{strokednode}	= [text badly centered, draw=black, thick, minimum height=4ex]
\tikzstyle{block}	= [strokednode, text width=16ex]
\tikzstyle{blockarrow}	= [-latex', draw]
\tikzstyle{hiblock}	= [block, minimum height=8ex]

\coordinate (Pr);
% \UuAluBlock{Pr}

\coordinate[right = 40ex of Pr] (Gv);
% \UuAluBlock{Gv}

% \foreach \i/\s in {Pr/Фон-неймановская (принстонская) архитектура, Gv/Гарвардская архитектура}
\foreach \i/\s in {Pr/а), Gv/б)}
{
  \node[block, fill=clRegisterLight] ({\i}Output)  at (\i) {Вывод};
  \node[hiblock, above = of {\i}Output, fill=clCalcLight] ({\i}Alu) {АЛУ};
  \node[block, above = of {\i}Alu, fill=clRegisterLight] ({\i}Input) {Ввод};

  \node[strokednode, left = of {\i}Input, rotate=90, anchor=south, inner xsep=1.5ex, fill=clDeviceLight] ({\i}Uu) {Управляющее устройство};
  
  \path[blockarrow] ({\i}Input) -- ({\i}Alu);
  \path[blockarrow] ({\i}Alu) -- ({\i}Output);
  
  \DoublearrowYRight{{\i}Uu.south}{{\i}Alu.west}
  
  \node[text width=40ex, text badly centered, below = of {\i}Output)] {\s};
}
  \node[hiblock, above = of {Pr}Input, fill=clMemoryLight] (PrMemory) {Общая память};
  \DoublearrowYRight{{Pr}Uu.south}{PrMemory.west}
  \path[blockarrow] (PrMemory) -- ({Pr}Input);
  \path[blockarrow] ({Pr}Output.east) -- ++(4ex,0) |- (PrMemory);
  
\tikzstyle{narrowblock}	= [strokednode, text width=8ex]
%   \node[narrowblock, above = of {Gv}Input.north east] (GvDataMemory) {Память данных};
% %   \node[narrowblock, above = of {Gv}Input.north west|-GvDataMemory.north] (GvProgMemory) {Память команд};
%   \node[narrowblock, above = of {Gv}Input.north west|-GvDataMemory.north, anchor=west] (GvProgMemory) {Память команд};

  \coordinate[right= 5.5ex of {Gv}Input.north] (GvInputFromData);
  \coordinate[left= 5.5ex of {Gv}Input.north] (GvInputFromProg);
  \node[narrowblock, above = of GvInputFromData, fill=clMemoryLight] (GvDataMemory) {Память данных};
  \node[narrowblock, above = of GvInputFromProg|-GvDataMemory, fill=clMemoryLight] (GvProgMemory) {Память команд};

  \DoublearrowYRight{{Gv}Uu.south}{GvProgMemory.west}
  \DoublearrowYRight{{Gv}Uu.south}{GvDataMemory.west}
  \path[blockarrow] (GvProgMemory) -- (GvInputFromProg);
  \path[blockarrow] (GvDataMemory) -- (GvInputFromData);
  \path[blockarrow] ({Gv}Output.east) -- ++(4ex,0) |- (GvDataMemory);

\end{tikzpicture}
}
\caption{Расположение программ и~данных 
в~фон-неймановской~(а) и~гарвардской~(б) архитектурах
% в~принстонской~(а) и~гарвардской~(б) архитектурах
% в~архитектуре с~общей (а) и~раздельными (б) шинами (???)
}
\label{ris:harvard-prinston}
\end{illustration}


\index{Архитектура!фон-неймановская (принстонская)}%
\index{Мокли, Джон}%
\index{Экерт, Джон Преспер}%
\index{фон Нейман, Джон}%
\index{Цузе, Конрад}%
Идея общей памяти и~общей шины для программ и~данных 
% была высказана ещё Бэббиджем в~раннем проекте аналитическая машины и~% неавторитетный источник
впервые была реализована Конрадом Цузе в~Германии.
В~США подобная архитектура разрабатывалась %в~Принстонском университете 
в~школе Мура при Пенсильванском университете
научным коллективом, куда входили, в~частности, Джон Мокли и~Джон Преспер Экерт.
% Незадолго до окончания работ её описание было опубликовано одним из консультантов проекта, Джоном фон Нейманом, без указания соавторов~\cite{Neumann:1945:FDR:1102046}.
Незадолго до окончания работ результаты были описаны одним из участников проекта, Джоном фон Нейманом, без указания соавторов, 
а~затем и~опубликованы в~таком виде куратором со стороны армии, Германом Голдштейном~\cite{Neumann:1945:FDR:1102046}.
Так как  фон Нейман к~тому времени уже был известным математиком,
архитектуру с~общей шиной обычно называют фон-неймановской (или принстонской, по основному месту работы фон Неймана).

\index{Архитектура!гарвардская}%
Общая шина для памяти программ и~данных "--- узкое место 
%архитектуры фон Неймана.
% принстонской архитектуры.
фон-неймановской архитектуры.

Ускорить обмен с~памятью можно, введя раздельные шины и,~соответственно,
физически раздельные запоминающие устройства для программ и~для данных (рис.~\ref{ris:harvard-prinston}, б).
Это дороже и~сложнее в~реализации, 
поэтому, хотя 
% проект архитектуры с~раздельными шинами разрабатывался в~Гарвардском университете США одновременно с~проектом школы Мура,
\index{Бэббидж, Чарльз}%
сама идея раздельных шин  использовалась  в~позднем проекте Бэббиджа,
а~практический проект подобной архитектуры разрабатывался в~Гарвардском университете США одновременно с~проектом школы Мура,
% (соответственно, архитектура с~раздельными шинами программ и~данных называется гарвардской),
\picturecensored[широко]{}
использоваться на практике этот подход стал относительно недавно.
Архитектура с~раздельными шинами программ и~данных обычно называется гарвардской.

% В~персональных компьютерах используются процессоры линейки x86 с~фон-неймановской архитектурой. материнская плата и память тоже!
В~персональных компьютерах используется фон-неймановская архитектура.
В~первых процессорах линейки x86 и~соответствующих системных платах такое решение было использовано для удешевления,
в~последующих  из соображений совместимости
также используется единое пространство памяти.
При этом современные процессоры имеют раздельную кеш-память для программ и~данных.
% третья "--- для трансляции адресов
\index{Кеш-память}%

\endgroup

\subsection{Память}
% \epigraphcensoredtwo[
\epigraph{
На каждого с именем приходится тысяча, имеющих только фамилию. На~каждого с~фамилией приходятся тысячи "--- ни~имя, ни~фамилия которых никого не~интересуют, кроме консьержки.
}
{\Vvm[Семидневный смотр французской живописи]}
% ]{
% \epigraph{\begin{limerick}
%     Жил один старичок с кочергой,\\
%     Говоривший: «В душе я другой».\\
%     На вопрос: «А какой?»\\
%     Он лишь дрыгал ногой\\
%     И лупил всех подряд кочергой.\\
% \end{limerick}
% }
% {\Lear}
% }
\index{Память!виды}


Память в~вычислительных системах образуют запоминающие устройства различной природы, имеющие разные характеристики по объёму памяти, по скорости обмена и~по времени создания контакта (рис.~\ref{ris:hierarchy}).

\begin{illustration}
% \includegraphics[width=\wideImageWidth,valign=c]{4-hierarchy}

\newlength{\commenttonext}
\setlength{\commenttonext}{1.3em}

\resizebox{\linewidth}{!}
{
% \singlespacing

\schemafont
\footnotesize
% \scriptsize
% \tiny

\begin{tikzpicture}[
start chain=Mem going right,
start chain=Lvl going above,
start chain=Ex going left,
% every node/.style={scale=0.5}
node distance=5em and 10em, % y and x 
x = 10em, y = 4em,
% baseline=(current bounding box.north)
]
% \tikzstyle{blockdraw}	= [draw, very thick]
\tikzstyle{blockdraw}	= [draw, thick]
% \tikzstyle{block}	= [solidchaincell, rectangle, blockdraw, minimum height=4em, text badly centered, inner sep =1ex]
\tikzstyle{block}	= [solidchaincell, rectangle, minimum height=4em, text badly centered, inner sep =1ex]
% \tikzstyle{vzustyle}	= [block, text width=8em, fill=white]
% \tikzstyle{blockstyle}	= [block, text width=6em, minimum width=8em, fill=white]
\tikzstyle{blockstyle}	= [block, text width=6em, minimum width=8em]
\tikzstyle{thinblockstyle}	= [blockstyle, minimum height=1em, inner sep = 0.8ex]
% \tikzstyle{commentstyle}	= [scale=0.9]
\tikzstyle{commentstyle}	= []

\foreach \n/\l/\ll in {hdd/Жёсткие/диски, net/Сетевые/хранилища, flash/Портативные/накопители, rom/ПЗУ/(BIOS)}
{
  \node[blockstyle, on chain=Mem] (\n) {\l\par\ll};
} 
\node[fit = (hdd) (rom), inner sep = 0mm] (bvzu) {};
% \node[above= 0mm of bvzu, minimum width = 32em] (lvzu) {Внешние запоминающие устройства};
\node[commentstyle, above= 0mm of bvzu, minimum width = 32em] (lvzu) {Внешняя память};
% \node[fit = (bvzu) (lvzu), inner sep = -0.5\pgflinewidth, blockdraw] (ovzu) {};
% \node[ above=0mm of bvzu, block, minimum width = 32em, outer sep = -\pgflinewidth] (lvzu) {Внешние запоминающие устройства};
% \path[blockdraw] (lvzu.north west) -- (lvzu.north east);

% \tikzstyle{memstyle}	= [block, text width=8em, fill=clMemoryLight]
% \tikzstyle{blockstyle}	= [block, text width=8em, fill=clMemoryLight]


\tikzstyle{blockstyle}	= [block, text width=6em, minimum width=11em]

\node[blockstyle, on chain=Mem, above= \commenttonext of lvzu.north, anchor = south east] (phis) {Физическое ОЗУ};
\node[blockstyle, %above= 0mm of lvzu.north, anchor = south west
on chain=Mem] (virt) {Виртуальная память};

\node[fit = (phis) (virt), inner sep = 0mm] (bozu) {};
\node[commentstyle, above= 0mm of bozu, minimum width = 32em] (lozu) {Оперативная память};

% \tikzstyle{blockstyle}	= [block, text width=7em, fill=white]

\node[thinblockstyle, on chain=Lvl, above= \commenttonext of lozu] (L3) {L3};
\node[thinblockstyle, on chain=Lvl] (L2) {L2};
\node[thinblockstyle, on chain=Lvl] (L1) {L1};
\node[commentstyle, above= 0mm of L1, minimum width = 32em] (lL) {Кеш-память};

\node[blockstyle, on chain=Lvl, above= \commenttonext of lL] (reg) {Регистры процессора};

\coordinate[above=2.6em of bvzu|-reg.north] (lvlTop);
\coordinate[right=\commenttonext of rom.south east] (lvlRight);
\coordinate[left=\commenttonext of hdd.south west] (lvlLeft);

\path[blockdraw, name path=cliptriangle] (lvlRight) -- (lvlTop) -- (lvlLeft)  -- cycle;



% \path[name path=lbottom] (reg.south-|lvlLeft) --  (reg.south-|lvlRight);
% \path[name intersections={of=lbottom and cliptriangle, by={bl, br}}];
% \path[blockdraw] (bl) -- (br);
% \begin{pgfonlayer}{background}
%   \fill[fill=clRegisterLight] (br) -- (lvlTop) -- (bl) -- cycle;
% \end{pgfonlayer} 

\foreach \n/\l in {reg/reg, lL/, L1/, L2/, L3/, lozu, bozu/mem, lvzu/hddtop}
{
\path[name path=ltop] (\n.north-|lvlLeft) --  (\n.north-|lvlRight);
\path [name intersections={of=ltop and cliptriangle, by={tl\l, tr\l}}];

\path[name path=lbottom] (\n.south-|lvlLeft) --  (\n.south-|lvlRight);
\path[name intersections={of=lbottom and cliptriangle, by={bl\l, br\l}}];

% \path[blockdraw] (tl\l) -- (tr\l);
\path[blockdraw] (bl\l) -- (br\l);
} 

\begin{pgfonlayer}{background}
  \fill[fill=clRegisterLight] (brreg) -- (lvlTop) -- (blreg) -- cycle;
  \fill[fill=clMemoryLight] (brmem) -- (trmem) -- (tlmem) -- (blmem) -- cycle;
\end{pgfonlayer} 

\path[blockdraw] (trmem-|lvlTop) -- (brmem-|lvlTop);
\path[blockdraw] (brhddtop-|lvlTop) -- (lvlLeft-|lvlTop);

\foreach \v in {lvlTop, flash.east, net.west}
{
\path[blockdraw] (brhddtop-|\v) -- (lvlLeft-|\v);

} 

% \path[name path=ltop] (hdd.north-|lvlLeft) --  (hdd.north-|lvlRight);
% \path [name intersections={of=ltop and cliptriangle, by={tl, tr}}];
% \path[blockdraw] (tl) -- (tr);
% \path[blockdraw] (tl-|lvlTop) -- (lvlLeft-|lvlTop);
\tikzstyle{bigcommentstyle}	= [text width=10em]

\foreach \nstart/\nend/\comment/\style in 
% {lvlLeft/trhddtop/Косвенный доступ (с~помощью функций операционной системы)/bigcommentstyle, brmem/lvlTop/Прямой доступ/}
{tlhddtop/lvlRight/Косвенный доступ (с~помощью функций операционной системы)/bigcommentstyle, lvlTop/blmem/Прямой доступ/}
{
  \draw [decorate,decoration={brace,amplitude=2ex}]
  (\nstart) -- (\nend) node [%midway, 
  pos=0.52,
  auto, %sloped, 
  xshift=2ex, commentstyle, text badly centered, \style] {\comment};
  
}

\end{tikzpicture}
}


\caption{Иерархия запоминающих устройств.
Сверху вниз увеличивается объём и~уменьшается скорость обмена}
\label{ris:hierarchy}
\end{illustration}


Самыми быстрыми "--- но при этом и~самыми дорогими "--- являются регистры.
Поэтому объём регистровой памяти очень ограничен.
% и~предназначена такая память для использования в~специальных случаях.

Оперативное запоминающее устройство "--- ОЗУ "--- характеризуется оптимальным соотношением цена-быстродействие.
ОЗУ в~современных вычислительных системах имеют довольно большие объёмы памяти, но и~они не беспредельны.

Внешние запоминающие устройства "--- ВЗУ "--- характеризуются большим временем создания контакта и~низкой скоростью обмена.
Но при этом они, во-первых, могут иметь очень большие объёмы, и,~во-вторых, несколько ВЗУ могут быть поочерёдно подключены и~либо считаны, либо записаны.
На заре компьютерной эры программист вручную организовывал обмен с~нужными устройствами, учитывая их особенности и~протоколы обмена.

Сейчас программисту не надо заботиться об этом.
Операционные системы предоставляют ему необходимый объём памяти "--- в~виртуальном адресном пространстве "--- и~программист пользуется им, не заботясь о~физических протоколах обмена.
Операционная система сама организует и~поддерживает соответствие между физическими адресами реальной памяти и~адресами виртуальной памяти.

\subsubsection{Плоская модель памяти}
\index{Память!плоская модель}

% Современные операционные системы предоставляют каждой исполняющейся программе (процессу)
Современные операционные системы используют так называемую \termin{плоскую модель памяти}.
% \index{Модель памяти!плоская}%
Каждой исполняющейся программе (процессу) предоставляется
диапазон виртуальных адресов от~$0$ до $2^N$, где $N$ "--- разрядность системы (32 или~64).
Каждому адресу соответствует один байт памяти.

При обращении к~определённому виртуальному адресу он транслируется в~физический аппаратным механизмом трансляции адресов, %процессора 
контролируемым операционной системой~\cite{amd64System}.
Виртуальный адрес может быть некорректным %, если ему не соответствует никакой
либо соответствовать байту в~оперативной памяти или специализированной области жёсткого диска (в~разделе подкачки; некоторые операционные системы также могут использовать файл подкачки).
% Физическое расположение данных %, соответствующее некоторому виртуальному адресу, может меняться операционной системой.
Операционная система может перемещать данные в~оперативной памяти или из памяти на диск и~обратно.
Виртуальные адреса и,~соответственно, указатели в~программе при этом не изменяются.

% Физические адреса в~ОЗУ занимают диапазон от
Диапазон доступных физических адресов зависит от объёма установленных ОЗУ и~возможностей системной платы.
% When the physical-address size extensions are enabled (see “Physical-Address Extensions (PAE)
% Bit” on page 121), the page-translation mechanism can be extended to support 52-bit physical
% addresses. 52-bit physical addresses allow up to 4 petabytes of physical-address space to be
% supported. (Currently, the AMD64 architecture supports 40-bit addresses in this mode, allowing
% up to 1 terabyte of physical-address space to be supported.
% Long Mode—This mode is unique to the AMD64 architecture. This mode supports up to 4
% petabytes of physical-address space using 52-bit physical addresses. Long mode requires the use of
% page-translation and the physical-address size extensions (PAE).
Разрядность физического адреса может составлять как 32, так и~40 или 52~бита~\cite{amd64System}.

Процесс %при нормальной работе операционной системы 
не может обратиться к~физическому адресу, принадлежащему другому процессу,
% (но при участии обоих взаимодействующих процессов возможно выделение )
% (но можно создать область общей памяти).
без специальных средств межпроцессного взаимодействия. % (или сбоя).

\subsubsection{Страничная организация памяти}

% Минимальным квантом памяти
Виртуальное адресное пространство плоской модели памяти делится на части определённого размера $pagesize$ "--- страницы.

Каждая страница %виртуальной памяти 
включает непрерывный последовательный диапазон виртуальных адресов $[\zeta, \zeta+pagesize)$ и~соответствует последовательному фрагменту ОЗУ или раздела подкачки на жёстком диске.
Страница может быть вытеснена из ОЗУ на диск или загружена с~диска в~ОЗУ только целиком, то есть страница "--- минимальный квант памяти при её распределении между процессами.

Страницы в~принципе могут иметь различные атрибуты защиты (разрешения чтения, записи, исполнения и~т.\,д.).


\bottompagebreak[6\baselineskip]
\subsection{Регистры}
% \label{sec:registers}
% \epigraphcensoredtwo[
\epigraph{
Позволь нам пройти землею твоею: мы не пойдем по полям и по виноградникам и не будем пить воды из колодезей твоих; но пойдем дорогою царскою, не своротим ни направо, ни налево, доколе не перейдем пределов твоих.
}{Чс. 20:17}
% \epigraph{
% Доказал это знаменитый В.
% {М.\,В.\,Ломоносов}
% ]{
% \epigraph{\begin{limerick}
%     Старушенция из Саламанки\\
%     Век жила, не вылазя из банки,\\
%     Никогда не грустила,\\
%     Улыбалася мило\\
%     И дарила детишкам баранки.\\
% \end{limerick}
% }
% {\Lear}
% }

Чем более объёмно запоминающее устройство, тем, как правило, медленнее оно работает.
% 
Оперативная память обладает меньшей скоростью, чем процессор;
хотя частоты работы как оперативной памяти, так и~процессора непрерывно растут, это соотношение сохраняется.
В~настоящее время частоты процессоров измеряются в~гигагерцах, памяти "--- в~сотнях %и~тысячах 
мегагерц.
% За один такт

Соответственно, использование только данных, расположенных в памяти, сильно замедлило бы работу.
% 
Частично обмен данными ускоряется при помощи кеширования, но оно не уравнивает скорости процессора и~памяти.

% Без задержек данные можно считать или сохранить из \termin{регистров.}
% Регистры "--- часть процессора и~работает с~ним на одной частоте.


Кроме того, АЛУ процессора не может обрабатывать данные, расположенные непосредственно в~оперативной памяти, так что оператор %\lstinline!++i! 
${+}{+}i$ (или соответствующая ему команда ассемблера \lstinline$inc i$) будет выполняться в~несколько приёмов (раздел~\ref{sec:command-cycle}):
\begin{itemize}
\item загрузка значения переменной~$i$ из оперативной памяти в~специальную ячейку внутри процессора "--- регистр; % "--- операнд;
\item расчёт значения $i+1$; % в~специальном регистре;
\item выгрузка значения~$i+1$ из  регистра в~память по адресу переменной~$i$,
\end{itemize}
причём загрузка-выгрузка в~ОЗУ  занимает больше времени, чем расчёт значения.
% В~современных процессорах 
% не в память, а~в~более быстрый кеш.
Для ускорения работы часто используемые переменные
логично хранить прямо  в~процессоре,
% Для этого предназначены специальные ячейки "--- регистры общего назначения.
выделив для этого некоторое количество регистров, не используемых в~цикле обработки команд.
Они называются регистрами  общего назначения.

В~отличие от специальных регистров, недоступных программисту, их можно указать в~команде как источник или приёмник значения,
то есть использовать как сверхбыстрые ячейки памяти.
% 
На уровне машинных команд регистры общего назначения обозначаются короткими номерами, % 3 бита, стр 65 intel vol2
на уровне ассемблера "--- именами.

Специальные регистры процессора также имеют имена, но они используются только в~документации~\cite{intelModelSpecificRegisters}.
Значение специальных регистров программист может узнать или модифицировать только косвенно, с~помощью специальных команд.
% Регистры, специфичные для модели~\cite{intelModelSpecificRegisters}.
% Эти команды 
% В~частности, указатель команд~$ip$ изменяется командами условного или безусловного перехода.


\section{Иерархическая декомпозиция ВС}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
Государь мой, прости, но для этой песни "--- я заимствую твой язык\\
Ибо жизнь заставляет заняться работой, к которой я не привык.
\end{stanza}}{\Sk[Открытое письмо ефрейтору~Расчёскину]}
% ]{
% \epigraphcensored[
% \epigraph{
% В ветвях ясеня живет орёл, обладающий великой мудростью. А~меж глаз у~него сидит ястреб Ведрфёльнир. Белка по имени Грызозуб снуёт вверх и~вниз по ясеню и~переносит бранные слова, которыми осыпают друг друга орёл и дракон Нидхёгг. Четыре оленя бегают среди ветвей ясеня и объедают его листву. 
% }{\Edda}
% ]{
% \epigraph{
% Вертикальная структура мирового древа складывалась из трёх частей, или уровней: нижнего (корни), среднего (ствол) и~верхнего (ветви)%.
% ...\\ 
% % Так сформировались в~воображении древних основные космические зоны, а~с~ними и~сдвоенные противоположности: Земля "--- Небо, Земля "--- Преисподняя, огонь (сухое) "--- влага (мокрое), прошлое "--- настоящее, настоящее "--- будущее, день "--- ночь. Эти пары перемещались в~структуре древа с~троичными единствами: прошлое "--- настоящее "--- будущее; предки "--- современники "--- потомки; три части тела: голова "--- туловище "--- ноги; три стихии: огонь "--- вода "--- земля. Пары и~тройки обнимали самые разнообразные формы жизни. 
% Люди постигали взаимосвязь противоположностей, суть всякого развития.
% }{Г.\,Белякова}
% }
% }

Согласно Таненбауму~\cite{tanenbaum-arch}, вычислительную систему можно представить в~виде ряда уровней абстракции.
Каждому уровню соответствует свой язык, программы на котором  путём компиляции или интерпретации переводятся на язык нижележащего уровня.

Большинство современных систем включает шесть уровней~\cite{tanenbaum-arch}:
\begin{itemize}
\item уровень языка прикладных программистов;
\item уровень ассемблера;
\item уровень операционной системы;
\item уровень архитектуры команд;
\item микроархитектурный уровень;
\item цифровой логический уровень.
\end{itemize}
Над этой иерархией языков находится прикладной программист и~воплощаемый им алгоритм;
под цифровым логическим уровнем "--- физическая элементная база.

Современная шестиуровневая структура сформировалась далеко не сразу и~не является пределом развития.
Примитивные счётные устройства (абак, суанпан, русские счёты) %не содержат ни одного уровня абстракции.
рассчитаны на взаимодействие человека напрямую с~элементной базой.
Развитие вычислительной техники и~программной инженерии ведёт к~постепенному наращиванию уровней абстракции.
% Уже сейчас 

Иногда между уровнем языка прикладных программистов и~уровнем операционной системы находится
уровень байт-кода или p-кода, интерпретируемого виртуальной машиной.
Он не эквивалентен уровню ассемблера, так как не отражает специфику аппаратной части вычислительной системы.


\subsection{Цифровой логический уровень}
% \epigraphcensored[
\epigraph{
% Порри снилось, что он маленький транзистор в плате, выполненной по 0,13-микронной технологии. 
Он лежит и~ждёт, когда придёт сигнал. После этого нужно быстро "--- очень быстро "--- изменить ноль на~единицу или единицу на ноль. Но сигнала всё нет.
}{\ZhvalevskijMytko[Порри~Гаттер и~Каменный~Философ]}
% ]{
% \epigraph{
%  К~каждой из трёх частей древа относились определённые существа. Вверху, на ветвях изображали птиц, посередине, у~ствола "--- копытных (оленей, лосей, коров, лошадей), иногда человека и~пчёл, а~у~корней "--- змей, лягушек, рыб и~бобров. 
% %  Бог восседал на самой верхушке древа. Иногда он вступал в~битву со змеем или драконом и~освобождал похищенный ими скот. Древо, символизировавшее зачатие и~плодородие, изображали на женских одеждах.
%  }{Г.\,Белякова}
% }

% сигналы и~вентили, 0 и~1, триггер как элементарная ячейка памяти, полусумматор, однобитовый сумматор


На цифровом логическом уровне существуют цифровые \termin{сигналы},
которые могут принимать ограниченный набор значений.
Для современных ЭВМ эти значения "--- $0$ и~$1$.

Соответственно количеству состояний сигнала определяется базовая единица измерения информации.
Так как современные ЭВМ двоичны, 
единицей информации считается {бит} "--- один двоичный разряд, который может находиться в~двух состояниях "--- $0$ и~$1$.
\index{Бит}%
Для троичных ЭВМ, таких как Сетунь\index{Сетунь}, информация измеряется в~тритах\index{Трит}.

Сигналы обрабатываются базовыми элементами схем "--- \termin{логическими вентилями\index{Логический вентиль},}
преобразующими множество входных сигналов в~выходной
в~соответствии с~какой-либо из логических операций \picturecensored[(в~частности, «и», «или», «не», «и-не»).]{.
% (рис.~\ref{ris:logic-gates}).
На рис.~\ref{ris:logic-gates} показаны таблицы истинности некоторых из них "--- «и», «или», «не», «и-не».

\begin{illustration}

\includegraphics[width=\approvedImageWidth,valign=t]{rn-22}

\caption{Различные виды логических вентилей}
\label{ris:logic-gates}
\end{illustration}
}

Существует множество стандартов изображения логических вентилей.
% (рис.~\ref{ris:logic-gates-legend}).
В~отечественной литературе чаще всего используются либо обозначения, описанные в~стандарте IEC 60617-12 (1997) \picturecensored{~изображённые в~первой строке рис.~\ref{ris:logic-gates-legend}},
либо похожие обозначения  ГОСТ  2.743-91 из единой системы конструкторской документации (ЕСКД).
\picturecensored{
\begin{illustration}

\includegraphics[width=\wideImageWidth,valign=t]{Logic-gate-index}

\caption{Различные обозначения логических вентилей}
\label{ris:logic-gates-legend}
\end{illustration}
}

Из-за особенностей элементной базы основными  для построения схем являются вентили «и-не» и~«или-не» (NOR и NAND),
реализующие соответственно операции $\lnot(x \lor y)$ и~$\lnot(x \land y)$ для входных сигналов $x$ и~$y$.

Из вентилей конструируются более сложные элементы, в~частности, двоичный полусумматор, рассчитывающий сумму двух входов,
формируя два выходных сигнала:
сумму входов по модулю $2$ и~разряд переноса,
или полный одноразрядный сумматор, рассчитывающий сумму трёх входов (на один из них при построении многоразрядного сумматора подаётся перенос из предыдущего разряда).
% и~также формирующий два выхода

% Также к~цифровому логическому уровню относятся элементарные ячейки памяти, %"--- быстрые (триггеры) и~
% хранящие каким-либо образом один бит информации.


Цифровой логический уровень "--- хронологически первый уровень абстракции.
Впервые он появился ещё в~%суммирующей машине Паскаля.
непрограммируемых счётных машинах,
в~том числе вавилонских и~греческих астрономических калькуляторах\index{Калькулятор},
но при этом отсутствует в~простых устройствах наподобие счётов, где перенос между разрядами осуществляется вручную.

% В~современной европейской истории цифровой логический уровень %впервые 
% присутствует в~проекте тринадцатиразрядной машины Леонардо да Винчи, 
% впервые реализован в~1623~г. в~счётной машине Вильгельма Шиккарда, позже %независимо 
% "--- в~суммирующей машине Паскаля.

\subsection{Микроархитектурный уровень}
% \epigraphcensored[
\epigraph{
...Антагонизмы в~области материального производства делают необходимой надстройку из~идеологических сословий, деятельность которых, "--- хороша ли она или дурна, "--- хороша потому, что необходима... 
}
{\Kapital}
% ]{
% \epigraph{\begin{limerick}
% Говорят, в~самом сердце Тибета\\
% в~страшной тайне содержится
% Это.\\
% Но есть мнение, что\\
% Это "--- вовсе не То;\\
% ничего даже общего где-то.\\
% \end{limerick}
% }
% {С.\,Сатин}
% }


Микроархитектура %микро
процессора "--- это 
аппаратная организация и~логическая структура микропроцессора:
\begin{itemize}
\item регистры "--- сверхбыстрые ячейки памяти внутри процессора;
\item набор микрокоманд;
\item управляющие схемы\index{УУ}; % (УУ), 
\item арифметико-логические устройства (АЛУ\index{АЛУ}); 
\item запоминающие устройства; 
\item %и~
связывающие их информационные магистрали \rlap{(шины).}
\end{itemize}

В~частности, к~микроархитектуре относятся 
все решения, касающиеся цикла выполнения команды:
% конвейер обработки команд.
% и~тракт данных, 
декодирование команды вышележащего уровня в~последовательность
микрокоманд,
конвейер, кеширование команд и~данных, прогнозирование переходов и~т.\,п.

Микроархитектурный уровень впервые начал отделяться от уровня архитектуры команд 
в~ЭВМ EDSAC-2 в~1957~г.,
когда впервые было применено микропрограммирование для реализации команды как последовательности микрокоманд.

В~настоящее время микроархитектура процессора качественно отличается от архитектуры уровня команд.
Так, на уровне микроархитектуры все современные процессоры семейства x86 (то есть процессоры с~CISC\index{CISC}-набором команд)
организованы по принципу RISC\index{RISC}.
Именно, они имеют набор  микрокоманд простой структуры и~множество регистров, которые поочерёдно играют роль восьми регистров общего назначения за счёт механизма переименования.
Это позволяет ускорить выполнение программ, сохраняя при этом совместимость на уровне архитектуры команд.


% % 
% % \termin{Тракт данных:}
% % \begin{itemize}
% % \item локальная память
% % % \rlap
% % {(набор регистров);}
% % 
% % \item АЛУ.
% % % арифметико-логическое устройство (АЛУ).
% % \end{itemize}


\subsection{Уровень архитектуры команд}
\epigraph{
\begin{stanza}
И на семь чудес с семи концов света,\\
Я не стану размениваться на мелочь:\\
Ведь очень скоро у~меня будет Это \\
и~я~буду ясно знать, что с~Этим делать.\\
\end{stanza}
}{\Bg[\mbox{Красота (это~страшная сила)}]}

% память, адресация, указатель, команды


Уровень архитектуры команд включает
\begin{itemize}
\item    архитектуру памяти;
\item    взаимодействие с~внешними устройствами ввода/вывода;
\item    режимы адресации;
\item    регистры;
\item    набор машинных команд;

\item    различные типы внутренних данных (целочисленные, с~плавающей запятой и~т.\,д.);
\item   обработчики прерываний и~исключений.
\end{itemize}
Эти пункты во многом %практически полностью 
повторяют компоненты микроархитектуры.
Различие состоит в~том, что уровень архитектуры команд доступен программисту %и~его компоненты, как 
и,~как всякий интерфейс, должен соответствовать документации и~относительно редко меняется.
% стандартизирован
Микроархитектура скрыта от программиста и~может различаться даже у~разных партий процессоров %с~одним и~тем же названием
одной и~той же модели.

\index{Байт}%
\index{Слово!машинное}%
В~соответствии со структурой памяти, разрядностью шины и~регистров определяются платформозависимые единицы измерения "--- байт и~машинное слово.

Программа уровня архитектуры команд "--- последовательность двоичных машинных кодов.
Программы ранних поколений записывались непосредственно в~двоичном коде в~виде отверстий на перфокартах и~перфолентах (отверстие соответствовало единице, нетронутая позиция "--- нулю).
Позже для хранения программ стали использоваться различные виды долговременной памяти (обычно магнитные ленты и~диски),
а~запись "--- сокращать с~помощью восьмеричного и~шестнадцатеричного представления двоичных чисел.

Каждому процессору соответствует свой набор машинных кодов.

В~частности, для процессоров семейства x86
опкод пересылки непосредственного тридцатидвухбитного значения в~тридцатидвухбитный регистр общего назначения  имеет вид \hex{B8},
после этого кода записывается трёхбитный код регистра,
после чего идёт само значение.
Соответственно, запись значения \hex{CC\,CC\,CC\,CC} в~регистр с~кодом~$1$ 
выполняется командой \hex{B9\,CC\,CC\,CC\,CC}.
Часто одно и~то же действие можно выполнить с~помощью различных машинных команд.

Уровень архитектуры команд,
отличающий программируемую вычислительную машину (компьютер)\index{Компьютер} от калькулятора\index{Калькулятор} или арифмометра\index{Арифмометр},
появился в~проекте аналитической машины Чарльза Бэббиджа,
\index{Бэббидж, Чарльз}%
а~впервые реализован был в~%программируемой вычислительной машине 
% электромеханическом компьютере Z3 Конрадом Цузе в~1941~г.
механическом компьютере Z1 Конрадом Цузе в~1938~г.\index{Цузе, Конрад}
При этом сама идея цифровых программ появилась задолго до её применения для вычислительных машин.
Двоичные программы, записанные на перфолентах, использовались в~механических орг\'{а}нах "--- шарманках в~\RN{XV{-}XIX}~вв.,
на перфокартах "--- в~автоматизированном ткацком станке Жозефа Жаккара (1802~г.).\index{Жаккар, Жозеф}


Программирование в~машинных кодах использовалось в~течение долгого времени %уже после 
параллельно с~ассемблером и~языками высокого уровня.
Даже в~настоящее время бывает необходимо использовать вставки на машинном языке.
Это может понадобиться либо в~случае, когда ассемблер устарел и~не распознаёт мнемоническое обозначение необходимой команды,
либо при разработке защитных механизмов "--- для затруднения дизассемблирования и~обратной разработки алгоритма защиты.


\subsection{Уровень операционной системы}
\epigraph{
\begin{stanza}
Я~буду жить в~доме из костей земли \\
и~с~большой дороги будут заходить дети\\
Чтобы любоваться на мои кристаллы, \\
сияющие во фрактальном свете.\\
\end{stanza}
}{\Bg[\mbox{Красота (это~страшная сила)}]}


% управление памятью, загрузка и~выполнение программ, системные вызовы, доступ к~устройствам
% Виртуальная память
% 
% Страничная организация памяти
% 
% % Реализация виртуальных команд ввода-вывода
% Файловая система
% 
% % Виртуальные команды для параллельной работы 
% Процессы

На уровне операционной системы осуществляется:
\begin{itemize}
\item    управление памятью (распределение между процессами, организация виртуальной памяти);
\item    загрузка программ в~оперативную память и~их~выполнение;
\item    исполнение запросов программ (системные вызовы);
\item    стандартизованный доступ к~периферийным устройствам (устройства ввода-вывода);
\item    управление доступом к данным на энергонезависимых носителях (таких как жёсткий диск, оптические диски и др.), организованным в той или иной файловой системе;
\item    обеспечение пользовательского интерфейса;
\item    сохранение информации об ошибках системы.
\end{itemize}
Данный уровень является гибридным "--- большая часть команд его языка совпадает с~командами нижележащего уровня (машинного языка)
и~только некоторые интерпретируются непосредственно операционной системой.

При этом операционная система работает с~этим языком и~как компилятор\index{Компилятор} (преобразуя исполняемый файл в~готовую к~выполнению программу в~оперативной памяти, что для современных форматов исполняемых файлов не сводится к~простому копированию),
и~как интерпретатор (исполняя так называемые системные вызовы).\index{Системные вызовы}

% % Благодаря управлению памяти на уровне ОС каждый процесс имеет своё адресное пространство
% С~точки зрения прикладного программиста, операционная система "--- это то, что загружает в~память исполняемый файл, 
% передаёт управление его точке входа,
% и~в~дальнейшем интерпретирует
% % обращения 
% % так называемые 
% системные вызовы.

Именно различие в~системных вызовах и~формате исполняемых файлов
не позволяет выполнять в~Microsoft Windows программы, собранные для того же процессора под GNU/Linux и~наоборот.

В~частности, системные вызовы используются для получения параметров командной строки\index{Параметры командной строки}
% Это 
(открытие документа двойным щелчком в~Microsoft Windows %или любой графической оболочке 
"--- тоже вызов программы с~параметром!)
и~для завершения работы.
Непосредственное обращение к~системным вызовам обычно скрыты от прикладного программиста библиотечными функциями-обёртками.

% Уровень операционной системы "--- самый молодой из рассматриваемых уровней абстракции: << а нет!
Первой операционной системой 
% http://1500py470.livejournal.com/106496.html?nojs=1
%  Путь к щелкающим монстрам 
можно считать аппаратный супервизор 
релейного многоядерного компьютера Bell Model V\index{Bell Model V} (1946~г.),
обеспечивавший
загрузку следующей программы из очереди на освободившееся ядро без участия оператора и~переключение между перфолентами по команде условного перехода. %~\cite{}.
% 
% Первой операционной системой считается
Позже появилась пакетная операционная система
GM-NAA I/O (General Motors \& North American Aviation Input/Output system)  для IBM 704\index{IBM 704} (1956~г.)%,
% "--- пакетная операционная система,
% обеспечивавшая %последовательное выполнение программ.
% загрузку следующей программы из очереди% без участия оператора
~\cite{osdata.com/kind/history}.

% фирмой IBM совместно с ассоциацией Shape были созданы операционные системы SOS (Shape Operationg System) и FMS (Forta Monitor System). Эти системы явились уже непосредственными предшественниками системы ОС, появившейся в 1964~г. 
% http://bip-ip.com/sistemnoe-programmnoe-obespechenie-o-2/

В~конце 1950-х~гг. были разработаны первые широко используемые операционные системы FMS (Fortran Monitor System)~\cite{tanenbaum-arch,osdata.com/kind/history}
и~SOS (Share 709 System)~\cite{ibmSos, osdata.com/kind/history}
для IBM 709\index{IBM 709},
которые включали компиляторы\index{Компилятор} (Фортран\index{Фортран} для FMS и~ассемблер для SOS) и~%особым образом 
обрабатывали системные вызовы, представленные перфокартами со специальным содержимым.

\subsection{Уровень ассемблера}
\epigraph{
\begin{stanza}
Я~прочёл об этом в~старинных трактатах, \\
прочёл и~сразу ушёл из деревни;\\
Скоро я~буду баснословно богатым \\
и~смогу претворить в~жизнь учения древних.\\
\end{stanza}
}{\Bg[\mbox{Красота (это~страшная сила)}]}

% мнемоники, ассемблирование, ассемблеры

Программировать в~машинных кодах не слишком удобно, даже если записывать их в~компактном восьмеричном или шестнадцатеричном виде.
Намного удобнее создавать программы, используя понятное человеку символическое представление машинных команд "--- мнемоники,
а~также символические имена регистров и~адресов в~памяти (переменных, меток).

Перевод программы из подобного символического представления в~машинные команды 
реализуется путем трансляции (сборки, ассемблирования), а~не интерпретации.
Программа-транслятор для такого перевода соответственно называется ассемблером, а~язык программирования "--- языком ассемблера.
Язык ассемблера часто сокращённо называют просто ассемблером, как и~транслятор.
% Если программа в~машинных кодах представляет собой набор чисел, то язык ассе

Так как набор мнемоник "--- символическое представление набора команд процессора,
процессорам с~различным набором команд соответствуют разные языки ассемблера.

Синтаксис языка асемблера также зависит от используемого транслятора\index{Компилятор},
% Разные компиляторы также поддерживают разный синтаксис.
так что для одного и~того же процессора могут быть разработаны несколько ассемблеров.

В~частности, 
команда \hex{B9\,CC\,CC\,CC\,CC},
то есть 
команда записи значения \hex{CC\,CC\,CC\,CC} в~регистр с~кодом~$1$ для x86 (этому коду для тридцатидвухбитного регистра в~тексте программы соответствует имя $ecx$),
на уровне ассемблера будет иметь вид
\lstinline!movl $0xCCCCCCCC, %ecx!.
% или \lstinline!mov ecx, 0xCCCCCCCC!. неопределённость
\index{Команды!mov}%
Строка \lstinline!mov! называется мнемоническим обозначением, или мнемоникой команды пересылки.
Одной мнемонике может соответствовать несколько машинных команд (в~частности, обозначение \lstinline!mov! объединяет множество команд пересылки данных); кроме того, одна машинная команда может на уровне ассемблера обозначаться несколькими мнемониками (так, \lstinline!jge! "--- переход, если больше или равно и~\lstinline!jnl! "--- переход, если не меньше, "--- это одна и~та же команда)


Считается, что первый ассемблер появился в~1949~г.
По разным источникам, он был разработан 
\index{Уилер, Дэвид Джон}%
Дэвидом Джоном Уилером для  ЭВМ EDSAC\index{EDSAC}~\cite{wheeler_david}
или
Джоном Мокли и~Джоном Преспером Экертом для ЭВМ BINAC\index{BINAC}~\cite{irgups-smolasm}.
% Первым ассемблером считается разработанный в 1949~г. Мокли и~Экертом псевдокод Short Code ЭВМ BINAC~\cite{}. 
\index{Мокли, Джон}%
\index{Экерт, Джон Преспер}%
% http://www.cyberforum.ru/assembler/thread1005284-page2.html

Иногда ассемблер называют самым старым языком программирования после машинного кода, 
хотя первый язык высокого уровня появился ещё раньше.
Тем не менее, ассемблер заслуженно считается вторым поколением языков программирования.



\subsection{Языки высокого уровня}
\epigraph{
\begin{stanza}
Особенности оперы в Нижнем Тагиле\\
совсем не повлияли на мое воспитанье,\\
Меня несло, как воздушного змея,\\
Когда всем остальным отключали питание.\\
\end{stanza}
}{\Bg[\mbox{Красота (это~страшная сила)}]}



% языки, компиляторы, GCC

Третьим поколением считаются языки высокого уровня (ЯВУ),
позволяющие программисту описывать алгоритм, а~не его реализацию на данной конкретной машине.
% где описывается принцип «как нужно сделать», 
% http://cyberfac.ru/publ/informatika/informatika_i_programmirovanie/jazyki_programmirovanija_vysokogo_urovnja/30-1-0-971

Для языка высокого уровня возможна как компиляция до уровней ассемблера или операционной системы (или, иногда, до другого ЯВУ), так и~пошаговая интерпретация.
При этом программы на некоторых языках традиционно только компилируются (в~частности, Паскаль\index{Паскаль}/Delphi, C/C++), на некоторых "--- только интерпретируются (в~частности, это языки командной оболочки, наиболее известным из которых является семейство sh/bash\index{Bash}), для большинства есть и~компиляторы\index{Компилятор}, и~интерпретаторы (Python\index{Python}, PHP\index{PHP} и~т.\,д.).
В~некоторых современных языках высокого уровня (в~частности, C\#\index{C\#}, Java\index{Java})
вводится дополнительный уровень абстракции "--- 
программа на ЯВУ компилируется до байт-кода,
который затем интерпретируется. % специальной виртуальной машиной.

Идея символического языка для прикладного программирования,
который не был бы связан с~архитектурой конкретной вычислительной машины,
почти так же стара, как и~само программирование.

Первый язык высокого уровня "--- Планкалкюль\index{Планкалкюль} "--- 
был разработан Конрадом Цузе в~1943-45~гг.,
\index{Цузе, Конрад}%
но для него в~то время не был разработан компилятор\index{Компилятор}.

Первый компилятор\index{Компилятор}, 
переводивший программу в~алгебраической форме на~машинный язык,
{A-0}, был разработан в~1952~г. Грейс Хоппер.
\index{Хоппер, Грейс}%
% Несмотря на название, язык не был предшественником B и~C/C++.
% На основе этих наработок в~1959~г. под руководством Грейс Хоппер был создан язык Кобол, максимально приближённый к~английскому языку.

Первый отечественный компилятор\index{Компилятор} с~языка высокого уровня ПП-1\index{ПП-1} (программирующая программа) был разработан в~1954~г.
В~некоторых источниках считается первым компилятором с~языка высокого уровня~\cite{fedotov_yavu}.
% В~отличие от Кобола,
Язык ПП-1 (и~его  позднейшие потомки) был основан на математической нотации~\cite{ershov_180}.
% и~считается языком более высокого уровня, чем использовавшиеся ранее


% Первое руководство для Fortran появилось в октябре 1956 вместе с первым компилятором, поставленным в апреле 1957.
% http://comsatelit1.at.ua/index/0-76
Первым языком высокого уровня, дожившим до настоящего времени под оригинальным именем (но~при этом породивший другой известный язык "--- Бейсик\index{Бейсик}), является Фортран\index{Фортран}.
Он был создан в~1954-1957~гг. группой программистов под руководством Джона Бэкуса\index{Бэкус, Джон} в~IBM. %~\cite.
% Первый компилятор Фортрана был выпущен в~1957~г.
% 
Также в~1957~г. был создан первый язык функционального программирования APL\index{APL}.
%  http://www.garshin.ru/it/computer-languages/3gl.html

Как конкурент языку от IBM, в~1958~г. группой под
руководством Питера Наура\index{Наур, Питер} %(Peter Naur) 
был разработан язык Алгол\index{Алгол}
"--- родоначальник большинства современных языков общего назначения, в~частности, семейства, включающего линейки Паскаль\index{Паскаль}/Delphi/C\# и~B/C/C++.
% 
В~это же время появился язык обработки списков Lisp\index{Лисп},  существующий до сих пор под этим именем.


В~1959~г. под руководством Грейс Хоппер\index{Хоппер, Грейс} был создан язык Кобол\index{Кобол}, максимально приближённый к~английскому языку.
Сейчас аналогичную нишу в~нашей стране занимает  1С\index{1С}.

% \termin{Прикладное программирование}
% \bigskip

% \begin{tabularx}{1\linewidth}{@{}Lp{0.4\linewidth}@{}}
% Трансляция
% \begin{itemize}
% \item Фортран;
% % \item Алгол;
% \item C/Objective-C/C++;
% \item Pascal/Object Pascal/Delphi.
% \end{itemize}
% &
% Интерпретация
% \begin{itemize}
% \item sh/bash;
% \item Python;
% \item PHP.
% \end{itemize}
% \end{tabularx}
% Уровень виртуальной машины  Java.
% % \begin{itemize}
% % \item Java.
% % \end{itemize}
% 
% \termin{Сверхвысокоуровневые языки программирования}
% \begin{itemize}
% \item  Python;
% \item Ruby;
% \item AWK/Perl.
% \end{itemize}


В~настоящее время иногда выделяются также сверхвысокоуровневые языки программирования, позволяющие
описывать даже не алгоритм решения задачи, а~саму задачу, в~частности,
 Python\index{Python},  Ruby\index{Ruby}, AWK/Perl\index{Perl}.

% http://cyberfac.ru/publ/informatika/informatika_i_programmirovanie/jazyki_programmirovanija_vysokogo_urovnja/30-1-0-971
% Сверхвысокоуровневый язык программирования (язык программирования сверхвысокого уровня, VHLL — very high-level programming language) — язык программирования с очень высоким уровнем абстракции. В отличие от языков программирования высокого уровня, где описывается принцип «как нужно сделать», в сверхвысокоуровневых языках программирования описывается лишь принцип «что нужно сделать». Термин впервые появился в середине 1990-х годов для идентификации группы языков, используемых для быстрого прототипирования, написания одноразовых скриптов и подобных задач.


% Shots through the Terminator's vision shows a dump of the ROM assembler code for the Apple II operating system. If you own an Apple II, enter at the basic prompt: ] call -151 * p This will give you the terminator view. Other code visible is written in COBOL. 

% http://textarchive.ru/c-1249733.html
%  3-е
% Языки высокого уровня ЯВУ (Fortran, Basic, Pascal, PL/1, C)
% Мобильные, более человеко-ориетированные, проще в освоении, более медленные
% 
% 4-е
% Непроцедурные, генераторы отчетов, объектно-ориентированные, языки запросов, параллельные
% Ориентированы на непрофессионального пользователя; ориентированы на ЭВМ с параллельной архитектурой
% 
% 5 -
% Языки искусственного интеллекта ИИ, экспертных систем и баз знаний, естественные языки
% Повышение интеллектуального уровня ЭВМ и интерфейса с ними

Иногда объектно-ориентированные, а~также %непроцедурные
языки запросов и~другие сверхвысокоуровневые языки выделяются в~следующее "--- четвёртое поколение языков программирования.
При этом естественные языки объединяются с~языками экспертных систем и~баз знаний в~пятое поколение.

% В~данном пособии будет рассматриваться в~основном компилируемый язык высокого уровня C++.
% Он д
В~данном пособии 
уровень языка прикладных программистов
будет рассматриваться в~основном на примере компилируемого языка высокого уровня C++.
% Язык C++ реализован для  Синтаксис C++ стандартизирован и~подде

\section{История} 
% \epigraphcensored[
\epigraph{%Вместе с тем  первое, будучи  вечным,  не может  уничтожиться; в  
...В~самом
деле,  так  как возникновение  по  направлению  вверх  не  беспредельно,  то
необходимо, чтобы не  было вечным то, из чего как из первого возникло что-то
через его уничтожение.
}{\Metaphiz}
% ]
% {\epigraph{\begin{stanza}[0mm]Действительность "--- не бред собачий.\\
% Она сложнее и~богаче.\end{stanza}}
% {Валентин Берестов}}

% Современные ВС: 6 уровней; как отрастали эти шесть уровней, начиная от одноуровневых счётов и~одно?двух?уровневого жаккардова станка
Термин «компьютер»\index{Компьютер} (вычислитель) в~разное время обозначал различные понятия "--- и~клерка-вычислителя,
проводившего расчёты вручную или с~использованием простых (счёты и~подобные им устройства "--- абак, суанпан) 
или сложных (арифмометр\index{Арифмометр}, механический калькулятор\index{Калькулятор})
вспомогательных устройств;
и~сами эти устройства.
При этом в~настоящее время даже инженерные калькуляторы представляют собой миникомпьютеры, превосходящие многие ранние ЭВМ.
% 
Таким образом, многие аспекты архитектуры вычислительных систем необходимо рассматривать в~контексте развития вычислительной техники и~программного обеспечения.

Договоримся называть компьютером\index{Компьютер}, или вычислительной машиной, устройство, которое может 
исполнять заданную изменяемую последовательность вычислительных операций "--- программу.
Таким образом, компьютер содержит как минимум два уровня абстракции "--- цифровой логический и~архитектуры команд. 


Непрограммируемые вычислительные устройства назовём калькуляторами\index{Калькулятор}  или арифмометрами\index{Арифмометр}.
Калькулятор содержит  цифровой логический уровень, но не включает уровня архитектуры команд.
% так что 
% Таким образом, простые вычислительные

% Табуля?тор — электромеханическая машина, предназначенная для автоматической обработки (суммирования и категоризации) числовой и буквенной информации, записанной на перфокартах, с выдачей результатов на бумажную ленту или специальные бланки[1].
Исторически можно выделить такой вид калькуляторов\index{Калькулятор}, как табуляторы\index{Табулятор},
выполняющие единообразную обработку больших массивов данных, представленных на перфокартах.
Табуляторы можно назвать также промежуточным звеном между калькуляторами\index{Калькулятор} и~компьютерами\index{Компьютер}.

\subsection{Развитие вычислительной техники}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
И с тех пор у нас в округе гении пропали,\\
А без них кусты сирени все перезавяли.
\end{stanza}}{\Sk[Небритый гений]}
% ]{
% \epigraphcensored[
% \epigraph{
% Есть ещё и другие норны, те, что приходят ко всякому младенцу, родившемуся на свет, и~наделяют его судьбою. 
% % Некоторые из них ведут свой род от богов, другие – от альвов и третьи – от карлов.
% % Добрые норны и~славного рода наделяют доброю судьбою. Если же человеку выпали на долю несчастья, так судили злые норны.
% }
% {\Edda}
% ]{
% \epigraph{Для появления джентльмена, по убеждению англичан, нужны три благородных поколения; очевидно, это справедливо и~для вычислительных машин...}
% {Э.\,Дийкстра}
% }
% }

Вычислительные машины, как правило, разделяют на четыре поколения в~соответствии с~используемой элементной базой.
\begin{enumerate}
\item Электронные лампы.
\item Транзисторы.
\item Интегральные схемы малой и~средней плотности. % (на одном кристалле был расположен целый блок ЭВМ "---  регистр, дешифратор, счётчик и~т.\,д.).
% Появляется понятие процессора, объединяющего в~себе АЛУ (возможно, несколько специализированных АЛУ) УУ. %? иногда пишут, что термин ещё с ламп
\item Интегральные схемы большой и~сверхбольшой плотности. % (процессор на одном кристалле).
\end{enumerate}
Это деление достаточно условно.
Вычислительные машины разных поколений достаточно долгое время существовали параллельно.
% Многие компьютеры переходных периодов построены на основе нескольких различных наборов элементов.
Часто различные компоненты одного и~того же компьютера строились на различных элементных базах.
% 
Кроме того, такое деление  не отражает развития архитектуры.
% Часто встречается таблица с
% 
% Как правило, первые машины на новой элементной базе обладали упрощённой архитектурой.

В~некоторых источниках вводится понятие пятого поколения,
но нет единого его определения.
% 
Часть источников выделяет пятое поколение не по элементной базе, а~по решаемым задачам.
Одноимённый японский проект называет ЭВМ пятого поколения искусственный интеллект, направленный на обработку знаний.
% http://compact-programming.narod.ru/CP0032.htm
Также пятым поколением называют компактные персональные ЭВМ.
% http://fb.ru/article/190570/pokolenie-kompyuterov-kompyuter-buduschego-opisanie
% http://fb.ru/article/159886/pokoleniya-evm-tablitsa-harakteristiki-i-istoriya-chto-ponimayut-pod-terminom-pokolenie-evm
Таненбаум считает пятым поколением встраиваемые системы (микроконтроллеры, системы на одном кристалле)~\cite{tanenbaum-arch},
что естественным образом продолжает устоявшееся деление.
% Также пятым поколением иногда считают кластеры, объединяющие много процессоров?

% В~любом случае, как бы ни определялось пятое поколение, 
Любое из приведённых определений пятого поколения ЭВМ подразумевает, что
в~настоящее время оно успешно сосуществует с~четвёртым.
Также многие источники относят все %производимые сейчас 
современные компьютеры к~четвёртому поколению.

Часто также выделяют нулевое поколение "--- электромеханические вычислительные машины.
% 
По аналогии с~этим чисто механические  вычислительные машины %(построенные на зубчатых колёсах) 
можно назвать минус первым поколением.

% Развитие большинства поколений
Большинство поколений делится на три периода:
вначале выпускается прототип, основанный на новой элементной базе (или несколько независимо разработанных прототипов).
Такие проекты часто остаются неизвестными из-за секретности или стечения обстоятельств.
Через какое-то время множество стран и/или корпораций одновременно выпускают более совершенные компьютеры (одиночные или серийные).
% затем новая элементная база попадает в~серийные устройства.
% затем старые компьютеры .
Соответственно, для каждого поколения указывается три даты:
выпуск первого устройства, начало массового использования и~выход из употребления.
% (при этом как первая).

\subsubsection{Минус первое поколение (античность--\RN{XVIII}~в.--конец~\RN{XX}~в.) "--- зубчатые колёса и~рейки}

К~этому поколению можно отнести всего два полноценных компьютера\index{Компьютер} "--- проект Бэббиджа конца \RN{\ToRomanEmpire{19}}~в., 
реализованный только в~1985-1991 гг.,
и~Z1 Конрада Цузе (1938~г.).
\index{Цузе, Конрад}%
\index{Бэббидж, Чарльз}%

При этом, если заменить в определении компьютера «последовательность вычислительных операций» 
на просто «последовательность операций», как это сделано \picturecensored[в~некоторых источниках]{, в~частности, в~Википедии},
к~минус первому поколению компьютеров также можно отнести 
цифровые мультимедийные механические устройства, серийно выпускавшиеся в~\RN{XV{-}XIX}~вв.  (шарманки и~музыкальные шкатулки),
а~также механические станки с~ЧПУ "--- первый известный такой станок был разработан в~1802~г. Жозефом Жаккаром\index{Жаккар, Жозеф}.

Цифровые механические калькуляторы\index{Калькулятор} существенно более разнообразны.
Сохранились упоминания об античных и~вавилонских вычислительных устройствах, предназначенных для моделирования астрономических событий.
Были найдены остатки подобного устройства "--- механизма из Антикитеры, собранного, по разным оценкам, в~140-80 гг. до н.\,э.
% http://samlib.ru/h/hitech_a/kompyutery_drevnosti.shtml
% http://masterok.livejournal.com/1074028.html

В~современной европейской истории цифровой логический уровень %впервые 
присутствует в~проекте тринадцатиразрядной машины Леонардо да Винчи\index{да Винчи, Леонардо}, 
впервые реализован в~1623~г. в~счётной машине Вильгельма Шиккарда\index{Шиккард, Вильгельм}, позже %независимо 
"--- в~суммирующей машине Паскаля\index{Паскаль, Блез} (1642~г.).

% арифмометры Паскаля (1642), Лейбница (1672), Тома де Кольмара (1820), Однера (1890) и другие.
% http://samlib.ru/h/hitech_a/kompyutery_drevnosti.shtml

Позже были разработаны  механические калькуляторы\index{Калькулятор}, 
выполняющие как сложение и~вычитание, так и~умножение и~даже деление в~десятичной системе
"--- арифмометры\index{Арифмометр}
Лейбница\index{Лейбниц, Готфрид} (1672~г.), Тома де Кольмара\index{де Кольмар, Тома} (1820~г.), Однера\index{Однер, Вильгодт} (1890~г.) и другие.
% Именно арифмометры
В~СССР наиболее популярен был «Феликс»\index{Феликс} (усовершенствованный арифмометр Однера), производившийся до 1978~г.
Компактные, надёжные и~энергонезависимые
арифмометры повсеместно использовались до 1970-х гг. (а~счёты "--- ещё дольше).

% http://www.computer-museum.ru/precomp/fauler.htm
% https://geektimes.ru/post/160595/  Недвоичная логика 
Около 1840~г. Томасом Фаулером\index{Фаулер, Томас} был разработан механический  калькулятор,
работавший в~сбалансированной троичной системе.

% Дальнейшим развитием стали калькуляторы, вычисляющие значение многочлена
% "--- две модели разностной
Дальнейшим развитием стал калькулятор, вычисляющий значение многочлена в~десятичной системе
"--- малая разностная машина, успешно построенная Чарльзом Бэббиджем в~1822~г.
\index{Бэббидж, Чарльз}%
% http://kryaker.dwg.ru/?p=1944
На её основе Георг Шутц\index{Шутц, Георг} и~Мартин Виберг\index{Виберг, Мартин} создали другие разностные калькуляторы.

% Самый знаменитый проект Чарльза Бэббиджа "---
% механическая десятичная аналитическая машина,
% включавшая 
Наиболее известная сейчас работа Чарльза Бэббиджа "---
\index{Бэббидж, Чарльз}%
постоянно дорабатывавшийся им проект механической десятичной аналитической машины\picturecensored{ (рис.~\ref{ris:babbage-lovelace-color})},
% http://kryaker.dwg.ru/?p=1944
% арифметическое устройство («мельницу»),
% устройство управления,
% регистры памяти («склад»)
% и~устройство ввода/вывода, обрабатывавшее перфокарты трёх типов:
% \begin{itemize}
% \item    перфокарты операций переключали машину между режимами сложения, вычитания, деления и умножения (команды);
% \item перфокарты переменных управляли передачей данных из памяти в арифметическое устройство и обратно (адрес);
% \item числовые перфокарты использовались для ввода данных и~сохранения результатов вычислений (данные).
% \end{itemize}
% https://habrahabr.ru/post/82929/
% http://www.f-mx.ru/kommunikacii_svyaz_cifrovye_pribory_i/analiticheskaya_mashina_charlza.html
включающий
управляющий барабан (УУ\index{УУ}), хранилище (регистровую память),
мельницу (арифметическое устройство "--- АУ\index{АЛУ}).
\picturecensored{
\begin{illustration}
\includegraphics[width=\linewidth,keepaspectratio,valign=t]{babbage-lovelace-color}

\caption{Аналитическая машина из позднего проекта Бэббиджа, изображённая современным художником С.\,Падуя.
Цифрами обозначены: 1 "--- память, 2 "--- процессор, 3 "--- блок питания, 4 "--- принтер, 5 "--- программа, 6 "--- адреса переменных, 7 "--- непосредственные данные, 8 "--- микропрограммы.
Рядом с~машиной изображены Чарльз Бэббидж и~Ада Лавлейс}
\label{ris:babbage-lovelace-color}
\index{Бэббидж, Чарльз}%
\index{Лавлейс, Ада}%
\end{illustration}
}

На вход машины в~последнем варианте проекта подавались два потока перфокарт: операционные карты (команды) и карты переменных (данные),
что в~современной классификации соответствует гарвардской архитектуре~\cite{the-marvellous-analytical-engine-how-it-works}. 

% https://geektimes.ru/post/210412/
В~1930-х~гг. над своим проектом вычислительной машины
\index{Бэббидж, Чарльз}%
независимо от Бэббиджа
начал работать Конрад Цузе, в~это время "--- студент Берлинского политехнического.
\index{Цузе, Конрад}%
Компьютер Цузе был двоичным, для ввода-вывода данные преобразовывались в~десятичный вид.

% http://www.computer-museum.ru/galglory/2.htm
Цузе сформулировал основные принципы построения вычислительных машин:
\begin{itemize}
\item    двоичная система счисления;
\item    использование устройств, работающих по принципу «да/нет» (логические 1 и~0);
\item    полностью автоматизированный процесс работы вычислителя;
\item    программное управление процессом вычислений;
\item    поддержка арифметики с плавающей запятой;
 \item   использование памяти большой ёмкости. 
\end{itemize}
\index{Бит}%
\index{Слово!машинное}%
Цузе впервые ввёл понятие «да/нет-статуса», аналогичное современному биту, термин «машинное слово», объединил в~вычислителе арифметические и~логические операции.



Первая демонстрационная модель Z1\index{Z1} была  механической с~электроприводом\picturecensored{ (рис.~\ref{ris:z1})}.
\index{Бэббидж, Чарльз}%
Вместо использованных Бэббиджем шестерёнок логические и~арифметические операции
были реализованы на скользящих металлических рейках.
Z1 обрабатывал 22-битные числа с~плавающей запятой,
включал не только регистры, но и~механическую память (очень малого объёма, так что программа загружалась непосредственно с~бумажной перфоленты).
Поддерживались
команды сложения и~вычитания, умножения и~деления, ввода и~вывода, загрузки и~сохранения в~память.
В~системе команд Z1\index{Z1} не было условных переходов, так как их затруднительно выполнять на перфоленте.
Цикл реализовывался склейкой перфоленты в~кольцо~\cite{586067-ru,586067}.
\picturecensored{
\begin{illustration}
\includegraphics[width=\linewidth,keepaspectratio,valign=t]{z1}

\caption{Конрад Цузе рядом с~восстановленным Z1}
\label{ris:z1}
\index{Цузе, Конрад}%
\index{Z1}
\end{illustration}
}

В~отличие  от  проекта аналитической машины Бэббиджа, который так и~остался проектом, Z1\index{Z1} был реализован в~1938~г.
и~является первым в~истории компьютером.


Серийно выпускаться механические компьютеры общего назначения так и~не стали;
но выпуск специализированных устройств (мультимедийных проигрывателей, калькуляторов, цифровых сигнальных процессоров)
был налажен достаточно широко.

К~электромеханическим
цифровым  сигнальным процессорам (DSP) %данного поколения нулевого?
можно отнести, в~частности, знаменитую Энигму\index{Энигма} (1923-1945~гг.) и~более совершенную шифровальную машину Lorenz SZ\index{Lorenz SZ}.
% хотя механическую часть представляли не реле, а~зубчатые роторы.
Так как механическую часть представляли не реле\index{Реле}, а~зубчатые роторы, их можно условно отнести к~минус первому поколению.

% https://geektimes.ru/company/ua-hosting/blog/273264/
% ABC Атанасов электромеханическая, но не реле



\subsubsection{Нулевое поколение (1890--1941--1960) "--- реле}

% https://geektimes.ru/company/mailru/blog/289239/
Устройства нулевого поколения построены на основе  телеграфных реле\index{Реле}, идея которых была предложена ещё в~1830~г.
Реле состоит из металлического переключателя, который, в~зависимости от положения, может либо замыкать, либо размыкать электрическую цепь,
и~электромагнита, управляющего положением переключателя.

Таким образом, реле\index{Реле} "--- электромеханическая ячейка, которая, в~отличие как от более ранней механической памяти, так и~от более поздних разновидностей,
может принимать два и~только два состояния.

% https://geektimes.ru/company/mailru/blog/289239/
% http://masters.donntu.org/2005/kita/kovalchuk/library/ht.htm
В~начале~\RN{XX}~в. на основе реле были разработаны первые автоматические телефонные станции.
Для этого был разработан и~запатентован релейный регистр.

Первым счётным устройством, основанным на электромеханических реле\index{Реле},
был табулятор Германа Холлерита\index{Холлерит, Герман} (1890 г.).
Для его разработки была создана компания, которая позже будет переименована в~IBM.
% Нулевое поколение 

В~Германии на основе реле в~1939~г. Цузе разработал компьютер Z2\index{Z2} с~механической памятью, по архитектуре практически полностью повторяющий Z1.
% Программа Z2 записывалась уже не на бумажной перфоленте, а~на перфоленте из более прочной киноплёнки.
\index{Цузе, Конрад}%
В~1941~г. "---  Z3\index{Z3} с~полностью релейной памятью, к~системе команд которого было добавлено вычисление квадратного корня~\cite{586067-ru,586067}.
Перфоленты для программ Z2\index{Z2} и~Z3\index{Z3} делались уже не из бумаги, а~из более прочной киноплёнки\picturecensored{ (рис.~\ref{ris:z3})}.
\picturecensored{
\begin{illustration}
\includegraphics[width=\approvedImageWidth,keepaspectratio,valign=t]{z3}

\caption{Составные части Z3}
\label{ris:z3}
\index{Цузе, Конрад}%
\index{Z3}
\end{illustration}
}


% https://3dnews.ru/263541
% Четыре компьютера Конрада Цузе
% 01 мая 2007 	
% http://www.computer-museum.ru/galglory/2.htm
% Изобретатель компьютера
% Сергей Бобровский 
% http://www.comprice.ru/articles/detail.php?ID=42488
% КОНРАД ЦУЗЕ. ПИОНЕР КОМПЬЮТЕРОСТРОЕНИЯ
% Александр Калигин

% https://geektimes.ru/post/210412/
% 27 января 2014 в 14:41
% Наследие Конрада Цузе: Архитектура Z1 и Z3 [Перевод] из песочницы
% История IT
% Оригинал: Ra?l Rojas — «Konrad Zuse’s Legacy: The Architecture of the Z1 and Z3», IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 


% https://sites.google.com/site/historyvycislitelnojtehniki/pervye-elektromehaniceskie-cifrovye-komputery
% Первые электромеханические цифровые компьютеры

В~США независимо от Цузе,
но на основе проекта Бэббиджа,
\index{Бэббидж, Чарльз}%
%http://www.great-country.ru/articles/sssr/sov_delali/00003.html
разрабатывались две линейки релейных вычислительных устройств "--- в фирме Bell (Джордж Штибитц)\index{Штибитц, Джордж}
и~в~Гарвардском университете совместно с~IBM (Говард Айкен)\index{Айкен, Говард}.


% http://www.boatanchor.ru/article/item.php?itemid=15
% Д. Штибитц, работавший в фирме Bell, собрал на телефонных реле первые суммирующие схемы. В 1940 г. вместе с С. Уильямсом Штибитц построил «вычислитель комплексных чисел», или релейный интерполятор, который впоследствии стал известен как специализированный релейный компьютер «Bell-модель 1». Машина демонстрировалась на заседании Американского математического общества в этом же году. На демонстрации в машину ввели два комплексных числа, переданных по телеграфу, и получили произведения этих чисел с отображением результата на телеграфном печатающем аппарате, установленном в зале заседания. В последующие годы были созданы еще четыре модели этой машины. Последняя из них разработана Штибитцем в 1946 г. (модель V) — это был компьютер общего назначения, который содержал 9000 реле, занимал площадь 90 м2 и весил 10 т. Сложение на этой машине выполнялось за 0,3 с, умножение — за 1 с. Для ввода данных использовалась перфолента, для вывода — стандартное телетайпное оборудование.
% 
% Другую идею релейного компьютера выдвинул в 1937 г. аспирант Гарвардского университета Г. Айкен. Этой идеей заинтересовалась фирма IBM. В помощь Айкену подключили бригаду инженеров во главе с К. Лейком. Работа по проектированию и постройке машины, которая в дальнейшем стала называться «Марк-1», началась в 1939 г. и продолжалась 5 лет. Реле, счетчики, контактные устройства, печатающие механизмы, устройства для ввода перфокарт и перфорирующие устройства, используемые в машине, были стандартными частями табуляторов, выпускаемых в то время фирмой IBM. Эта машина, работавшая с 23-значными десятичными числами, выполняла операцию сложения за 0,3 с и операцию умножения за 3 с. Машина не имела операции условного перехода, это было ее недостатком, но свою жизнеспособность она доказала в течение 15 лет непрерывной работы.

% В~1939~г инженер Штибитц построил сумматор на реле
% https://geektimes.ru/company/mailru/blog/289239/
Первый релейный калькулятор линейки Bell, «вычислитель комплексных чисел»
был построен в~1940 г.,
последним (Bell Model V\index{Bell Model V} в 1946 г.) был полноценный многоядерный компьютер, где распределение заданий по ядрам выполнял аппаратный супервизор,
который можно назвать ранней операционной системой.
% https://geektimes.ru/company/mailru/blog/289239/
%  Забытое поколение релейных компьютеров 
Система команд Bell Model V\index{Bell Model V} включала условные переходы, реализующиеся как переключение между различными перфолентами.
% https://www.itweek.ru/themes/detail.php?ID=71978
% % Две следующие машины Bell Labs (Model III и Model IV) были по существу идентичны и также предназначались для систем ПВО. 
% % Model III, известная как "Баллистическая вычислительная машина” (Ballistic Computer), была установлена в июне 1944 г. 
% % Model IV (март 1945-го) помимо этого вычисляла значения тригонометрических функций. 
% % Вместе обе машины выполняли работу ста вычислителей с настольными счетными машинками и находились в эксплуатации полтора десятка лет.

% Линейка Гарвардского университета 
Первым из линейки Гарвардского университета и~IBM первоначально также был калькулятор
Harvard Mark I\index{Harvard Mark I}, или ASCC (1941~г.) с~релейным процессором и~механической памятью, 
который в~1944~г. был доработан до %программируемого 
компьютера, загружающего инструкции с~бумажной перфоленты.

Позже были разработаны
% https://en.wikipedia.org/wiki/Harvard_Mark_I
% Harvard Mark II (1947~г.), Mark III/ADEC (1949~г.) и~Harvard Mark IV (1952~г.).
полностью релейный Harvard Mark II\index{Harvard Mark II} (1947~г.) и~релейно-ламповый Mark III\index{Harvard Mark III}/ADEC (1949~г.).
Именно в~электромеханическом реле Harvard Mark II, согласно легенде, был обнаружен первый баг.

\index{Цузе, Конрад}%
\index{Бэббидж, Чарльз}%
В~системе команд Mark I и~Mark II, так же как и~в~ранних компьютерах Цузе, не было условных переходов, 
а~циклы выполнялись закольцовыванием перфоленты.
Программы Harvard Mark I и~Mark II %(также аналогично Z1-Z3)
(аналогично позднему проекту Бэббиджа)
хранились на перфолентах отдельно от данных, что позже получило название гарвардской архитектуры.
% Mark I was disassembled in 1959

% http://www.vokrugsveta.ru/telegraph/technics/276/
% При этом по быстродействию как Harvard Mark II, так и~Bell Model V были сравнимы с~Z3, но Z3 на порядок компактнее.  << врут, Bell Model V чуть быстрее

% http://www.vokrugsveta.ru/telegraph/technics/276/
%  И лишь в 1957 году появляется релейная машина РВМ-1 (главный конструктор Н.И.Бессонов, 1906–1963). Впрочем, машина получилась удачной. РВМ-1 была построена на 5500 реле. И при этом работала с 36-битными операндами. И быстродействие в сравнении с американскими аналогичными разработками было отменным — операция умножения занимала 0,05 сек. Машина эксплуатировалась до 1965 года. 


% http://www.pro-radio.ru/computers/9647-2/
Из-за механического элемента в~реле\index{Реле} быстродействие таких машин было ограничено.
Кроме того, у~реле  ограниченный ресурс срабатывания, поэтому релейные компьютеры были не слишком надёжны (хотя иногда надёжнее ламповых).
Релейные компьютеры устойчивы к~радиации и~потребляют мало мощности.

% В~настоящее время релейные
% http://forum.rcdesign.ru/f100/thread188531.html
% https://habrahabr.ru/post/220865/
% https://geektimes.ru/post/287344/

% https://geektimes.ru/company/ua-hosting/blog/273264/
% ABC Атанасов электромеханическая, но не реле

\subsubsection{Первое поколение (1943--1949--1965) "--- электронные лампы}

% http://dssp.petrsu.ru/p/tutorial/informatics/chapter3/6/63.htm
В~1918~г. М. А. Бонч-Бруевичем\index{Бонч-Бру­е­вич, Михаил Алек­санд­ро­вич} было изобретено электронное реле "--- триггер,\index{Триггер}
состоящее из двух электронных ламп "--- триодов\index{Триод}.
Триггер может менять своё состояние быстрее электромеханического реле, что позволило ускорить быстродействие вычислительных устройств.

% Ламповые компьютеры и~калькуляторы
 
% http://www.computer-museum.ru/frgnhist/universal_p.htm
%  Двое техников, увидев спящего шефа, перенесли раскладушку в пустовавшую комнату, а когда он проснулся, то первой его мыслью было: “ENIAC украли!”


Первым счётным устройством на электронных лампах считаются,
согласно различным источникам,
британский калькулятор Colossus Mark I\index{Colossus Mark I} %(1943~г.)
и~американский табулятор ENIAC\index{ENIAC}. %(США, 1943~г.).
Оба этих калькулятора были построены в~1943~г.


Проект Colossus\index{Colossus Mark II} был рассекречен только в~конце 1970-х~гг., поэтому большая часть источников приписывает первенство ENIAC\index{ENIAC}.
\modifyone[В~рамках этого проекта был разработан также]{}
Colossus Mark II (1944~г.)\modifyone[, который]{}
не только работал в~пять раз быстрее предшественника, но и~был программируемым, % компьютером.
так что Colossus Mark II может быть назван первым %компьютером первого поколения. % "--- первой ЭВМ.
электронным компьютером (но не первым цифровым).
В~Colossus не было памяти, так что %программы и~
данные хранились на замкнутой перфоленте. 
% http://www.dailytechinfo.org/infotech/3502-mashiny-monstry-colossus-pervyy-v-mire-elektronnyy-cifrovoy-programmiruemyy-kompyuter.html

% Первым счётным устройством на электронных лампах считается %был
% % Также первым ламповым устройством
% табулятор ENIAC (1943~г.), обрабатывавший десятичные числа.
% Табулятор ENIAC обрабатывал десятичные числа.
Табулятор ENIAC\index{ENIAC} был разработан в~школе Мура Пенсильванского Университета, США и~обрабатывал десятичные числа.
% https://geektimes.ru/post/160595/
Каждый десятичный разряд представлялся десятью двоичными, при этом включён был только один из них "--- соответствующий нужной десятичной цифре.
ENIAC\index{ENIAC} иногда называют первой ЭВМ, но он не являлся вычислительной машиной (компьютером) в~современном понимании, 
так как не имел уровня архитектуры команд.
«Программирование» ENIAC\index{ENIAC} выполнялось  перекоммутацией связей,
то есть фактически как перестройка машины.

В~1948-1950-х~гг. началась повсеместная разработка ламповых компьютеров:
EDVAC\index{EDVAC},
% (разработчики 
BINAC\index{BINAC}
 и~Harvard Mark III\index{Harvard Mark III}/ADEC в~США, EDSAC\index{EDSAC} в~Британии, % игра крестики-нолики
 МЭСМ\index{МЭСМ} и~М-1\index{М-1} в~СССР, CSIRAC\index{CSIRAC} в~Австралии.
% http://www.great-country.ru/articles/sssr/sov_delali/00003.html
% 
% https://www.osp.ru/os/2010/01/13000691
% И все же EDVAC был вторым, а первым в мае 1949 года заработал EDSAC, и с него пошла волна создания аналогичных систем, начавшаяся с австралийского компьютера CSIRAC (ноябрь 1949 года). Тем временем Джон фон Нейман продолжил популяризацию своих и чужих идей, работая в Институте перспективных исследований (Institute for Advanced Study, IAS), где под его руководством вышла книга «Предварительные исследования по логическому проектированию электронных счетных инструментов». Описанная в ней архитектура получила название IAS – так было положено начало Open Source. Для создания компьютеров хватало общераспространенных тогда радиодеталей, поэтому для многих университетов и лабораторий открывалась возможность собирать их собственными силами. По архитектуре IAS было построено почти два десятка машин: JOHNNIAC (корпорация Rand), ILLIAC I (Университет штата Иллинойс), MANIAC I (Национальная лаборатория в Лос-Аламосе). Строили такие машины в Швеции (BESK, Стокгольмский университет) и в Израиле (WEIZAC, Институт Вейцмана)
% . В ряд IAS-подобных машин попадает и отечественная БЭСМ.
% 
% % http://evmhistory.ru/history/edvac.html
% % ЭДВАК был поставлен Лаборатории Баллистики в августе 1949 года. После отладки компьютер был официально запущен в 1951 году и также как и предшественник ЭНИАК, проработал почти 10 лет, до 1961 года
% Следующий проект школы Мура, компьютер EDVAC (август 1949~г.), был уже двоичным и~имел память на ртутных трубках.
% В~этой памяти располагались как данные, так и~программа, что позже получило название фон-неймановской архитектуры.
% % Из-за конфликта разработчиков
% 
% % http://evmhistory.ru/history/edsac.html 
% % Дело в том, что в ЭДСАК-2 было реализовано микропрограммное управление, т.е. некоторые из команд составлялись из набора микроопераций, микропрограммы записывались в ПЗУ. ЭДСАК-2 был запущен в 1957 году, перед тем как будет отключён его предшественник ЭДСАК (лето 1958 года). Проработала вторая модель до 1965 года, после чего была заменена другим новым компьютером – Titan.
% В~Британии разрабатывалась другая линейка ЭВМ "--- EDSAC (май 1949~г.), позже переработанная в~EDSAC-2 (1957~г.)
% % первой известной ЭВМ  EDSAC (май 1949~г.)
% 
% % https://en.wikipedia.org/wiki/Harvard_Mark_I
% Частично ламповым был гарвардский компьютер Mark III/ADEC (1949~г., США),
% более поздний Harvard Mark IV (1952~г.)
% был полностью выполнен на электронных лампах.
% 
% https://www.osp.ru/os/2010/01/13000691
%  Начав в октябре 1948-го с нуля, коллективу Лебедева удалось через три года, 6 ноября 1950 года, осуществить пробный запуск машины. На МЭСМ работали программы вычисления суммы нечетного ряда факториала числа и возведения в степень. Пуск МЭСМ в эксплуатацию был осуществлен 25 декабря того же года. На этот раз на машине решались реальные задачи вычисления функций распределения вероятностей. Дата запуска МЭСМ регламентировалась специальным постановлением правительства, все работы осуществлялись в обстановке строгой секретности. 12 января 1952 года началось выполнение заказов по расчетам. Осенью 1952-го на МЭСМ были выполнены расчеты генераторов Куйбышевской ГЭС.
% 
% В~1949~г. были выпущены несколько 

Почти сразу, в~1951-1956~гг. был начат выпуск серийных компьютеров:
% http://www.boatanchor.ru/article/item.php?itemid=16
UNIVAC\index{UNIVAC}, Ferranti\index{Ferranti}, Минск-1\index{Минск-1}, БЭСМ-1\index{БЭСМ-1} и~БЭСМ-2\index{БЭСМ-2}, серия «Стрела\index{Стрела}», Z22\index{Z22}.
% 
В~целом поколение электронно-ламповых компьютеров было многочисленным и~разнообразным.
В~это время сложилось большинство архитектурных решений.

Кроме больших ЭВМ, занимавших иногда несколько этажей здания, стали появляться и~малые.
Так, первый мобильный компьютер общего назначения "--- Урал-1\index{Урал-1} (1955~г., СССР) "--- мог %, в~отличие от предшественников, 
перевозиться на двух грузовиках.

Ненадёжность ламп приводила в~том числе и~к~частым перестройкам и~усовершенствованиям компьютеров,
так что второе поколение включало множество моделей, большинство из которых существовали в~единственном экземпляре.
При этом программное обеспечение уже было достаточно сложным и~функциональным, так что его было нерентабельно переписывать заново под язык каждой новой машины.
% Соответственно, для повышения переносимости программ были 
% унифицированы к
Соответственно, в~%этот период 
1954--1960~гг. 
% появились два новых уровня абстракции, обеспечивающие 
началось формирование двух новых уровней абстракции, обеспечивающих
переносимость программ:
\begin{itemize}
% \item    обратная совместимость машинных языков хотя бы в~компьютерах одного семейства, << у Цузе есть
% для чего в~EDSAC-2 впервые были применены микропрограммы;
% \item    использование языков высокого уровня.
% ^^^ у Цузе есть
% \item микропрограммы, обеспечивающие возможность запуска старой программы в~машинных кодах на изменённом компьютере
% \item микропрограммы, позволяющие запустить старые программы в~машинных кодах на изменённом компьютере 
% \item декодирование машинной команды на набор микрокоманд, позволяющие запустить старые программы в~машинных кодах на изменённом компьютере 
\item декодирование машинной команды на набор микрокоманд, что позволяет нескольким различным компьютерам выполнять один и~тот же набор команд
% (EDSAC-2, уровень совместимости с~EDSAC);
% (EDSAC-2, совместимость набора команд с~EDSAC); а чёрт их знает
(EDSAC-2\index{EDSAC-2});

\item компиляция с~языков высокого уровня (Фортран\index{Фортран}, Алгол\index{Алгол}, APL\index{APL}, Кобол\index{Кобол}).
\end{itemize}
% Полноценное развитие эти уровни получили в~третьем поколении.
% Тем не менее, задачи переносимости и~стандартизации не были решены 

\subsubsection{Второе поколение (1955--1960--1970) "--- дискретные транзисторы}
В~1947~г. Уолтер Браттейн\index{Браттейн, Уолтер} и~Джон Бардин\index{Бардин, Джон}
создали первый твердотельный аналог лампы-триода\index{Триод} "--- полупроводниковый транзистор\index{Транзистор}.

% http://all-ht.ru/inf/history/p_4_0.html
% 22 октября 1925 года, когда Юлием Эдгаром Лилиенфельдом был зарегистрирован патент на принцип работы полевого транзистора. Теория работы полевых транзисторов - проще биполярных, поэтому обоснована и запатентована она была значительно раньше биполярных транзисторов. В общем случае принцип действия полевого транзистора аналогичен работе электронных ламп. Исток в полевом транзисторе подобен катоду вакуумного триода, затвор — сетке, сток — аноду. Однако, трудности в практической реализации полевых транзисторов позволили создать действующую модель лишь в 1960 году, значительно позже создания биполярного транзистора, и только в девяностых годах технология полевых транзисторов стала доминировать над биполярными. 

Транзисторы оказались компактнее, быстрее и~надёжнее, чем триоды.
% Соответственно, первым транзисторным компьютером после экспериментального ТХ-0 (1955~г., США, МТИ) считается бортовой компьютер самолёта TRADIC (1955~г., США).
Первым %экспериментальным 
транзисторным\index{Транзистор} компьютером считается экспериментальный TX-0\index{TX-0} (1955~г., США, МТИ),
на основе которого позже разработали TX-2\index{TX-2}, а~затем %относительно компактный  (относительно IBM)
PDP-1\index{PDP-1}  (1961~г., США, DEC).

Первые частично транзисторные компьютеры общего назначения появились в~1958~г.
% http://www.boatanchor.ru/article/item.php?itemid=17
% В 1955 г. в США было объявлено о создании цифрового компьютера TRADIC, построенного на 800 транзисторах и 11 000 германиевых диодах. В этом же году фирма объявила о разработке полностью транзисторной вычислительной машины. Первая такая машина «Philco-2000» была сделана в ноябре 1958 г., она содержала 56 тыс. транзисторов, 1200 диодов, но все же в ее составе использовалось 450 электронных ламп. «Philco-2000» имела 32 индексных регистра, которые позволяли производить модификацию команд, использовать относительные адреса и т. д. Сложение в машине выполнялось за 1,7 мкc, умножение — за 40,3 мкс.
% Процесс перехода на выпуск серийных компьютеров второго поколения совершился, можно сказать, сразу во многих странах и примерно в одно и то же время. Так, в Англии транзисторная ЭВМ «Elliot-803» была выпущена в 1958 г., в ФРГ «Simens-2002» — в 1958 г., в Японии Н-1 — в 1958 г., во Франции и Италии — в 1960 г. В СССР группа разработчиков под руководством Е. Л. Брусиловского в 1960 г. в НИИ математических машин в Ереване завершила разработку полупровод­никовой ЭВМ «Раздан-2», ее серийный выпуск начался в 1961 г.
% 
% Серийное производство транзисторных компьютеров началось
Сразу же началось их серийное производство:
Elliot-803\index{Elliot-803} в~Британии, Simens-2002\index{Simens-2002} в~Германии, Н-1\index{Н-1} в~Японии,  Раздан-2\index{Раздан-2},
% http://all-ht.ru/inf/history/p_4_0.html
Минск-2\index{Минск-2}\modifyone[{} (а~также его модификации Минск-22 и Минск~22М) и~Минск-32\index{Минск-32}, М-220\index{М-220} и~М-222\index{М-222}, Урал-14\index{Урал-14}, Наири-1\index{Наири-1} и~Наири-2\index{Наири-2}]{}, МИР\index{МИР}\modifyone[, БЭСМ-4\index{БЭСМ-4} и~БЭСМ-6\index{БЭСМ-6}% 1966
]{ и~5Э92б\index{5Э92б}}
в~СССР,
% http://life-prog.ru/1_46273_vtoroe-pokolenie--tranzistori--.html
PDP-1\index{PDP-1},  %1961 (DEC) % TX-0/TX-2
IBM 7030\index{IBM 7030} (Stretch) % 1961
и~CDC 6600\index{CDC 6600}
в~США
и~т.\,д.

Новая элементная база позволила уменьшить не только  габариты больших ЭВМ (до нескольких десятков шкафов), % это официальный термин
но и мобильные компьютеры общего назначения (один-два шкафа).
% https://geektimes.ru/company/ua-hosting/blog/270228/
%  Немного из истории специализированных ЭВМ военного назначения 
Такими были Раздан-2\index{Раздан-2} и~двоично-десятичный Проминь\index{Проминь} в~СССР,
PDP-4\index{PDP-4}, PDP-5\index{PDP-5} и~PDP-8\index{PDP-8} в~США. %, позже PDP-8 ИС
% http://it-history.ru/images/7/77/07_%D0%9A%D0%B0%D1%80%D1%86%D0%B5%D0%B2.pdf
% ЭВМ и многопроцессорные комплексы М . А . Карцева Ю . В . Ревич
Активно разрабатывались специализированные (обычно военные) мобильные компьютеры:
бортовой компьютер самолёта TRADIC\index{TRADIC} в~США, %(1955~г., США),
% https://geektimes.ru/company/ua-hosting/blog/270228/
Гранит\index{Гранит}, %?
%?  Специально для машины «Клен» была разработана импульсно-потенциальная система элементов с диодно-резистивной логикой и максимальной частотой работы 660 кГц. Время задержки логических элементов системы — 50 нс, время задержки элементов системы, которые использовались в последовательных цепях — 20-30 нс. В цепях сумматоров и контроля были использованы специальные логические элементы. 
Клён\index{Клён}, 
%?  «Диана-2» — ЭВМ с фиксированной запятой, разрядностью 10, одноадресной системой команд, с количеством команд — 14, командной памятью объемом 256, ЗУ константой, оперативной памятью на магнитострикционных линиях задержки. 
Диана\index{Диана},
% ЭВМ «Радон»
% В 1964 году в Научно-исследовательском институте электронных математических машин закончилась разработка ЭВМ для применения в противовоздушной обороне СССР. Это была импульсно-потенциальная с гальваническими и трансформаторными связями ЭВМ второго поколения на базе транзисторов П16 и П601.
Радон\index{Радон}
и~т.\,д. в~СССР.

\modifyone[
Также ко второму поколению относится агрегатная система средств вычислительной техники
(набор %агрегатных 
устройств с~унифицированными внешними связями, из которых можно компоновать различные вычислительные модели% с~заданными техническими параметрами
, начиная от простейших вычислительных машин сбора информации до сложных многопроцессорных систем обработки данных, систем массового обслуживания и~т.\,д.)  АСВТ-Д~\cite{EnergiaVM}.
% 
На основе АСВТ-Д собирались такие компьютеры, как 
М-1000, М-1010 (Ангара-2% для оперативного учёта и~автоматической сортировки круглых лесоматериалов
, 40 $\text{м}^2$), 
М-2000 (144 $\text{м}^2$)
и~М-3000 (170-220 $\text{м}^2$).
Для сравнения "--- площадь, занимаемая IBM 7030, составляет около 250 $\text{м}^2$.
]{}


% http://www.boatanchor.ru/article/item.php?itemid=17
% Необходимо отметить, что в этот период появились ЭВМ второго поколения, построенные на неполупро­водниковой элементной базе. Так, в Японии была выпущена ЭВМ «Senac-1» на параметронах. В СССР — «Сетунь», а во Франции — САВ-500 на магнитных элементах. «Сетунь», разработанная в МГУ коллективом под руководством Н. П. Брусенцова, стала первой в мире ЭВМ, работающей в троичной системе счисления.
% 
% Значительным событием в конструировании машин второго поколения стали ЭВМ «Atlas» (Англия), «Stretch» и CDC-6600 (США) и БЭСМ-6 (СССР).
% 
% Разработка проекта «Atlas» осуществлялась сотрудниками Манчестерского университета и фирмой Ferranti под руководством Г. Килбурна. Первый образец ЭВМ «Atlas» был изготовлен в 1961 г. В этой машине впервые была реализована концепция виртуальной (кажущейся) памяти [13].
% 
% При разработке ЭВМ «Atlas» конструкторы столкнулись с проблемой создания системы, в которой вся память (и на сердечниках и на барабане) адресовалась бы так, как если бы она была только на сердечниках. Так возник метод разделения памяти на страницы и стала возможным динамическая трансляция адресов аппаратными средствами.
Появляется механизм трансляции адресов и~страничная организация оперативной памяти.

% В~описываемое время формируются уровни архитектуры команд и~языка высокого уровня.
% 
% Во втором и~третьем поколении 
Активно развиваются компьютеры на нестандартной элементной базе: % или с~недвоичной реализацией арифметики:
Senac-1 на параметронах в~Японии,
троичная Сетунь\index{Сетунь} %и~модулярный Алмаз % схемы
% и~двоично-десятичная Мир
в~СССР,
САВ-500\index{САВ-500} на магнитных элементах во Франции.

\index{Байт}
В~процессе проектирования IBM 7030\index{IBM 7030} (Stretch)
возникло понятие байта как совокупности шести битов.
% https://www.kakprosto.ru/kak-81445-chto-takoe-bayt
% ЭВМ, произведенные компанией Burroughs Computer Corporation, использовали байт, равный 9 битам.
% В системе IDM System/360 впервые была использована байтовая адресация. Ее преимущество по сравнению с адресацией целого машинного слова заключается в более простой обработке текстовой информации. В данной системе также использовались байты, состоящие из 8 бит.
В~%более поздних компьютерах
компьютерах других производителей байт мог быть равен семи или девяти битам.

Начиная со~второго поколения, практически все компьютеры выпускаются сериями различного объёма.
Кроме того, большинство описанных названий "--- не одна модель, а~семейство компьютеров схожей архитектуры
и,~как правило, с~совместимыми наборами команд. 
%<< не факт
Разные семейства (даже разрабатываемые на основе друг друга, как PDP-1\index{PDP-1} и~PDP-4\index{PDP-4} или  IBM 7030\index{IBM 7030} и~IBM 360\index{IBM 360})
\modifyone[часто]{}
были несовместимы между собой.
\modifyone[Тем не менее, в~некоторых компьютерах, в~частности, Минск-32 в~СССР, поддерживались режимы программной совместимости с~более ранними моделями~\cite{MinskManual}.]{}


% \modifyone[Если компьютеры  первого %и~даже второго 
% поколения разрабатывались индивидуально, так что компьютеры различного назначения из одной серии (и~даже выпущенные в~разное время компьютеры одного назначения)
% могли иметь различную архитектуру, 
% то 
% начиная со второго  поколения
% % технологии третьего поколения диктуют максимальную унификацию и,~соответственно, 
% выпуск ]{}


\subsubsection{Третье поколение (1961--1966--1980) "--- малые и~средние интегральные схемы}
% В~1959 г. Жан Эрни создал первый опытный планарный транзистор.
% Первые серийные планарные транзисторы и, чуть позже, первая интегральная микросхема, объединяющая множество транзисторов и~связей между ними, были выпущены в~1960 г. компанией Fairchild.

% http://www.computer-museum.ru/histekb/integral_1.htm
% В 1956 году сотрудник фирмы Bell Labs Росс изготовил схему двоичного счётчика на основе n-p-n-p структур в едином монокристалле . В 1957 г . Ясуро Тару из японской фирмы MITI получил патент на соединение различных транзисторов в одном кристалле. Но все эти и другие им подобные разработки имели частный характер, не были доведены до производства и не стали основой для развития интегральной электроники. Развитию ИС в промышленном производстве способствовали только три проекта.
% 
% Удачливыми оказались уже упомянутый Джек Килби из Texas Instruments (TI), Роберт Нойс из Fairchild (оба из США) и Юрий Валентинович Осокин из КБ Рижского завода полупроводниковых приборов (СССР). Американцы создали экспериментальные образцы интегральных схем: Дж. Килби – макет ИС генератора ( 1958 г .), а затем триггер на меза-транзисторах ( 1961 г .), Р. Нойс – триггер по планарной технологии ( 1961 г .), а Ю. Осокин – сразу пошедшую в серийное производство логическую ИС “2НЕ-ИЛИ” на германии ( 1962 г .). Серийное производство ИС эти фирмы начали почти одновременно, в 1962 г . 

Первые %экспериментальные макеты интегральных схем 
интегральные схемы (отдельные триггеры\index{Триггер} в~США и~логические вентили\index{Логический вентиль} в~СССР) 
были созданы в~1961--1962~гг. 
параллельно
Джеком Килби\index{Килби, Джек} из Texas Instruments,  Робертом Нойсом\index{Нойс, Роберт} из Fairchild %(США) %, различные типы триггеров
и~Ю.\,В.~Осокиным\index{Осокин, Юрий Валентинович} из КБ Рижского завода полупроводниковых приборов. % (СССР).

Первые компьютеры, построенные с~использованием подобных схем, мало отличались от компьютеров, построенных только из отдельных транзисторов\index{Транзистор},
то есть граница между вторым и~третьим поколением достаточно условна.
Некоторые модели компьютеров собирались вначале из дискретных элементов, затем из интегральных схем.

С увеличением степени интеграции
появилась возможность выполнить на одном кристалле
% на одном кристалле был расположен 
целый блок ЭВМ "---  регистр, дешифратор, счётчик и~т.\,д.
\index{Процессор}%
\index{АЛУ}%
\index{УУ}%
Примерно в~это же время 
появляется понятие процессора, объединяющего в~себе АЛУ (возможно, несколько специализированных АЛУ) и~УУ. %? иногда пишут, что термин ещё с ламп


% http://all-ht.ru/inf/history/p_5_0.html
%  Серийный выпуск интегральных схем был налажен в 1961 году, тогда же была создана фирмой " Texas Instruments" по заказу ВВС США первая экспериментальная ЭВМ на интегральных схемах. Разработка велась 9 месяцев и была завершена в 1961г. ЭВМ имела всего 15 команд, была одноадресной, тактовая частота была 100 КГц, емкость запоминающего устройства – всего 30 чисел, для представления чисел использовалось 11 двоичных разрядов, потребляемая мощность составляла всего 16Вт, вес – 585гр, занимаемый объем – 100 кубических сантиметров. [1] 
%  
%  В ЭВМ третьего поколение уже четко выделяется иерархия памяти. ОЗУ делится на независимые блоки с собственными системами управления, работающие параллельно. Структура оперативной памяти делится на страницы и сегменты. [1] Развивается и внутренняя память процессора – создаются предпосылки к вводу кэширования памяти.
% Жесткий диск IBM 3340
% 
%  Среди наиболее развитых операционных систем были:
% OS/360, разработанная фирмой IBM в 1964 году для управления мейнфреймами;
% MULTICS - одна из первых операционных систем с разделением времени исполнения программ;
% UNIX, разработанная в 1969 году и, впоследствии, разросшаяся до целого семейства операционных систем, многие из которых являются одними из самых популярных на сегодняшний день.
% 
% Единой системы ЭВМ, IBM360

К~третьему поколению больших ЭВМ относятся, в~частности,
% https://sites.google.com/site/specenie/
% http://www.computer-museum.ru/articles/upravlyayushchie-evm/334/
Днепр-2\index{Днепр-2}\modifyone[
{} и~МИР-2\index{МИР-2}, Урал-11М\index{Урал-11М} и~Урал-25\index{Урал-25}, Наири-3\index{Наири-3} и~Наири-4\index{Наири-4}]{, 
Мир-2\index{Мир-2}
% http://www.digimedia.ru/articles/compyutery/raznoe/supercompyutery/supercompyutery-s-drevneyshih-vremen-i-do-nashih-dney/
и~БЭСМ-6\index{БЭСМ-6}	% 1966
}
в~СССР,
серии
IBM 360\index{IBM 360} %(семейство компьютеров с~одним набором команд), первые компьютеры которой были выпущены в~1965~г. разработка 1963-64 года,
и~IBM 370\index{IBM 370}	% Впервые анонсирована 30 июля 1970 года.
в~США.
\modifyone[Часто к~третьему поколению по особенностям архитектуры относят и~БЭСМ-6\index{БЭСМ-6}, хотя этот компьютер собирался из дискретных элементов. %По некоторым 
]{}

% Появилось множество 
Выросло количество мобильных компьютеров.
Наиболее известны  двенадцатиразрядная линейка компьютеров общего назначения PDP-8\index{PDP-8} и~шестнадцатиразрядная "--- PDP-11\index{PDP-11} фирмы DEC.
Для PDP-8\index{PDP-8} ввели термин «миникомпьютер», и,~согласно легенде, это был первый компьютер, украденный частными лицами (он занимал всего один шкаф и~весил менее 50~кг).

% 
% Первым образцом «Карата» была малогабаритная 24-разрядная машина на ГБИС «Вардува». Схемы функциональных узлов микросхем были разработаны советскими учеными, исходя из логических схем ЭВМ (в одном корпусе размещалось 8 разрядов регистра, 2 разряда АЛУ и т.п.). Эта разработка на много лет опередила создание многокристальных схем за рубежом (“мультичипы”).
% 
% Специализированная вычислительная машина «Атака» (МВМ-012) была создана в 1974 году в НПО «Агат». 
% Машина выпускалась до 1990 года, было изготовлено 255 СЦВМ «Атака».
%  СЦВМ «Арка» (специализированная вычислительная машина) предназначалась для работы с СЦВМ «Атака» и использовалась для увеличения пропускной способности вычислительной системы с СЦВМ «Атака». 
% ЭВМ «Арфа»
% Разработка машины была начата в 1979 году и предназначалась для работы в различных корабельных системах управления
% Эта машина составила совместно с ЭВМ «Арка» и «Атака» ряд программно-совместимых машин третьего поколения ЦМНИИ «Агат»
Также выпускались специализированные мобильные компьютеры.
В~СССР это были, в~частности, Карат\index{Карат},
% http://www.computer-museum.ru/histussr/sok_evm.htm
Алмаз\index{Алмаз} на основе модулярной арифметики
и~ряд программно-совместимых компьютеров Атака\index{Атака}, Арка\index{Арка} и~Арфа\index{Арфа}\modifyone[, а~также управляющий миникомпьютер Параметр\index{Параметр}]{}.
\modifyone[
% К~третьему поколению 
Параметр, в~свою очередь, послужил основой для агрегатной системы средств вычислительной техники АСВТ-М,
на основе которой собирались М-4000% (144 $\text{м}^2$)
, М-6000.
% На основе Параметра 
]{}

% http://www.computer-museum.ru/histekb/integral_1.htm
% В1963 г. в НИИРЭ в рамках ОКР “Квант” (ГК А.Н. Пелипенко, при участии Е.М. Ляховича) была разработана конструкция модуля, в котором объединялось четыре ТС Р12-2 И, как мы уже говорили, это была первая в мире ГИС с двухуровневой интеграцией, а, возможно, вообще первая ГИС.





% Наиболее известным серийным компьютером третьего поколения
% является серия
% IBM 360 (семейство компьютеров с~одним набором команд), первые компьютеры которой были выпущены в~1965~г.
% IBM 370

% 14 ноября 1968 г. директор НИЭМ С. А. Крутовских приказом министра был назначен директором НИЦЭВТ и генеральным конструктором ЕС ЭВМ (уже «Единой Серии» – авторство термина, говорят, принадлежит Сулиму).
% Рамеев, вдохновленный перспективами, принял предложение перейти с Пензенского завода, где руководил созданием «Уралов», в заместители Крутовских по разработке ЕС. Другим заместителем – по научной работе – был упомянутый Левин. У двух заместителей взгляды на то, что именно должно послужить основой ЕС, расходились: Рамеев (как и Сулим) ориентировался на Западную Европу, а Левин, как и его начальник Крутовских, – на IBM/360.
% В декабре 1969 года состоялось представительное совещание у министра радиопромышленности СССР Калмыкова, где присутствовали все ключевые фигуры из разработчиков ЭВМ и организаторов их производства (из ныне известных не было разве что В. М. Глушкова). Сулим, С. А. Лебедев (конструктор БЭСМ и директор ИТМиВТ), академик А. А. Дородницын и зампред Госплана М. Е. Раковский выступили против копирования IBM/360. Причем никогда и никого не боявшийся Лебедев прямо так и начал: «Система IBM/360 – это ряд десятилетней давности…» 

% http://iknigi.net/avtor-yuriy-revich/82541-informacionnye-tehnologii-v-sssr-sozdateli-sovetskoy-vychislitelnoy-tehniki-yuriy-revich/read/page-13.html
% Научно обоснованное решение важной проблемы – какой должна быть ЕС ЭВМ – было подменено административным приказом о копировании системы IBM 360. Руководство Минрадиопрома, АН СССР, дирекция НИЦЭВТ не посчитались с мнением ведущих ученых Советского Союза и стран СЭВ.

Как было сказано ранее, 
в~период создания машин из отдельных транзисторов или малых интегральных схем
каждая компания устанавливала свои стандарты на аппаратные интерфейсы.
% 
К~концу 1960-х гг. 
не было практически никаких общих стандартов.
Проблема переносимости программного обеспечения, актуальная ещё в~начале 1960~гг., встала крайне остро.

% В~капиталистических странах большая часть корпоративных стандартов  исчезла  вместе с~создавшими их фирмами.
В~капиталистических странах большая часть избыточных стандартов  исчезла  вместе с~создавшими их фирмами, 
так как компьютеры без программного обеспечения были непопулярны.
% Такие фирмы, как IBM, DEC
Остались несколько несовместимых между собой серий компьютеров разных фирм, %с~несовместимыми между собой наборами команд, выпускавшихся 
в~основном IBM и~DEC.

В~СССР был поставлен вопрос о~создании единственного ряда компьютеров, совместимых на уровне команд друг с~другом и~основанных на
системе команд
наиболее известной %к~тому времени, хотя и~уже устаревающей, 
западной линейки "--- IBM 360\index{IBM 360}.
Для IBM 360\index{IBM 360} к~тому времени было написано много программ, но
% сама архитектура, раз
сами эти компьютеры, разработанные в~начале 1960-х, устарели.
Официальное сотрудничество с~IBM было невозможно как из-за холодной войны, так и~из-за политики самой IBM.
Изначально выдвигался проект переориентации на сходные с~IBM 360\index{IBM 360} архитектуры английской фирмы ICL или немецкой Siemens.
Обе они были готовы официально поделиться существующими технологиями и~немедленно начать  
% совместно с~конструкторами БЭСМ-6
совместную
разработку компьютеров четвёртого поколения.

Тем не менее, в~1970~г. появился
административный приказ о~копировании устаревшей системы IBM 360\index{IBM 360}.
При этом предполагалось копировать не архитектуру команд,
а~микроархитектуру  по нелегально полученным снимкам интегральных схем и~фрагментам документации~\cite{revich_es_book,revich_es_blog}.

Чуть позже в~1970~г. IBM анонсировала линейку IBM 370\index{IBM 370}.
\modifyone[А~в~1971~г. в~СССР был выпущен морально устаревший к~этому времени клон IBM~360\index{IBM 360} "--- первый представитель линейки ЕС~ЭВМ\index{ЕС ЭВМ}.]{В~1971~г. в~СССР был выпущен первый представитель ЕС ЭВМ\index{ЕС ЭВМ} "--- линейки клонов IBM 360\index{IBM 360}, а позже и~других компьютеров, устаревавших к~моменту клонирования.}
Большая часть оригинальных разработок была прекращена и~забыта;
% При этом 
многие архитектурные решения, воплощённые в~МИР и~БЭСМ, были переоткрыты в~Intel и~AMD в~1990-2000~гг.
% Вследствие этого вычислительная техника СССР непоправимо отстала.






В~описываемое время окончательно сформировались уровни архитектуры команд и~языка высокого уровня.

Появляется ещё один уровень абстракции "--- промежуточные универсальные языки, облегчающие компиляцию
% https://habrahabr.ru/company/ua-hosting/blog/273665/
(такие, как Алмо, Эпсилон, внутренний язык системы Бета в~СССР).
При компиляции  с~$m$ языков высокого уровня для $n$ машин через промежуточный язык достаточно разработать всего $m + n$ трансляторов,
при компиляции напрямую в~машинные или ассемблерные коды  $m \cdot n$.
Этот уровень не прижился в~1970-е гг.,
% из-за сокращения количества как машинных языков, так и~компилируемых языков высокого уровня,
но в~настоящее время он активно используется для языков, подобных Java\index{Java} или C\#\index{C\#}, как уровень байт-кода.
% В~настоящее время  этот уровень уже сформировался "--- это байт-код.

\subsubsection{Четвёртое поколение (1971--1980--настоящее время) "--- большие и~сверхбольшие интегральные схемы}

Граница между третьим и~четвёртым поколением %"--- самая условная из подобных границ.
ещё более условна, чем между вторым и~третьим.
Часто считается, что переход к~четвёртому поколению "--- размещение процессора на одной микросхеме (микропроцессоре).
% Согласно другим источникам,
% % Горбачев Г. Н., Чаплыгин Е. Е. Промышленная электроника: Учебник для вузов/Под ред. В. А. Лабунцова. — М.: Энергоатом-издат, 1988, — 320 с. 
% интегральная схема называется большой, если она включает более $10^3$ элементов.
% В~этом случае четвёртое поколение также началось в~начале 1970-х.

Первой подобной микросхемой был процессор Intel 4004\index{Intel 4004} (1971~г.).
% разработанный для японского калькулятора

Естественно, что первые микропроцессоры были относительно простыми, а~сложные и~высокопроизводительные процессоры
% построенные на сверхбольших интегральных 
четвёртого поколения
по-прежнему были модульными.

В~это время выпускались как большие ЭВМ, в~основном уменьшившиеся до одного шкафа,
% которые стали называть «суперкомпьютеры» << не все?
наиболее производительные из которых стали называть суперкомпьютерами
(Cray-1\index{Cray-1} в~США, серия Эльбрус\index{Эльбрус} на основе БЭСМ-6\index{БЭСМ-6} в~СССР),
% http://www.digimedia.ru/articles/compyutery/raznoe/supercompyutery/supercompyutery-s-drevneyshih-vremen-i-do-nashih-dney/
% 1979 пришли суперкомпьютеры серии «Эльбрус
% «Cray-1», выпущенный в 1974 году — первое детище организованной Сеймуром Креем компании. Он имел производительность 133 Мфлопс – миллионов операций над числами с плавающей точкой в секунду. «Cray-1» относится к четвертому поколению компьютерной техники, поколению построенному на сверхбольших интегральных схемах. «Cray-X1E», решение, предлагаемое компанией сейчас, несмотря на гигантский скачок в производительности — до 147 Тфлопс (триллионов операций над вещественными числами в секунду) – также принадлежит к четвертому поколению ЭВМ.  
% 
% http://samag.ru/archive/article/966
% Одной из инженерных задумок Крея на стадии проектирования являлось использование в Cray-1 всего трех типов интегральных схем: элементов логики, чипов оперативной памяти и регистров, что позволяло значительно повысить надежность и отказоустойчивость системы. Впрочем, общее количество микросхем в системе в итоге достигло 350 тысяч штук, и, чтобы упаковатьтакое количество в сравнительно небольшой корпус, Крею и его инженерам пришлось изрядно потрудиться.
так и~миникомпьютеры на основе микропроцессоров, габариты и~стоимость которых %стали доступны частным лицам.
% значительно уменьшились.
также уменьшались со временем. 
\modifyone[Это DEC VAX в~США, различные линии СМ~ЭВМ в~СССР (среди них были и~продолжения АСВТ-М, и~клоны PDP-11, и~оригинальные разработки, совместимые на уровне архитектуры команд с~VAX или, позже, с~Intel x86).]{}
% 
% https://geektimes.ru/company/ua-hosting/blog/270228/
%  Позже была разработана модификация «Карат-КМ-Е» на секционных микропроцессорных больших интегральных схемах.
% 
% http://ru.uacomputing.com/stories/karat/
% В начале 80-х была завершена модернизация унифицированной ЭВМ с целью повышения быстродействия при решении задач в составе гидроакустических и других систем («Карат-КМ»).
% http://www.icfcst.kiev.ua/MUSEUM/PHOTOS/Module_r.html
% 
%? В 1982 году была разработана цифровая система управления стрельбой «Акация». 
%?  В 1986 году для надводных кораблей и подводных лодок была разработана ЭВМ «Лада-2», она состояла из трёх бортовых универсальных электронных вычислительных машин, была построена по модульному принципу, такая открытая система позволяла подключать дополнительные функциональные устройства.
Из специализированных мобильных компьютеров 1980-1990~гг. в~СССР можно отметить Карат-КМ-Е\index{Карат-КМ-Е}, Акация\index{Акация}, Лада-2\index{Лада-2}.

% http://www.securitylab.ru/analytics/439497.php
% 20.04.2013
% Исследование кристалла: недокументированные флаги микропроцессора 8085
% У микропроцессора 8085 есть два недокументированных флага состояния: V и K. Эти флаги можно исследовать, приглядевшись к кристаллу микросхемы, и их функция, как выясняется, отличается от предыдущих толкований. 

В~1973~г. появился прототип  Xerox Alto\index{Xerox Alto} "--- недорогой миникомпьютер с~экраном, клавиатурой, мышью и~сетевой картой Ethernet, 
операционная система которого, как и~Unix, поддерживала графический интерфейс пользователя.
Подобный миникомпьютер позже получил название персонального компьютера.

В~1975~г. \modifyone[поступил в~продажу]{появился} персональный компьютер MITS Altair\index{Альтаир} 8800 на основе процессора Intel 8080
и~специально разработанной системной шины S-100.
В~базовой комплектации он не имел ни экрана, ни алфавитной клавиатуры, но поддерживал карты расширения.
Благодаря низкой цене, гибкой и~открыто опубликованной архитектуре, а~также качественной рекламе
Альтаир\index{Альтаир} стал популярен, а~энтузиасты разработали для него как полноценные периферийные устройства, так и~качественное программное обеспечение.

Позже, начиная с~1977~г. были выпущены несколько недорогих 
персональных компьютеров:
Apple II\index{Apple II}, IBM 5100\index{IBM PC}, Tandy TRS-80\index{Tandy TRS-80}, Commodore PET\index{Commodore PET}, Электроника НЦ-8010\index{Электроника НЦ-8010} и~т.\,д.
При разработке базового программного обеспечения для них отказались от графического интерфейса.

В~1981~г. появился персональный компьютер IBM 5150, или IBM PC\index{IBM PC}.
В~отличие от более ранних моделей IBM, в~IBM PC\index{IBM PC} использовались сторонние компоненты, в~частности, процессор Intel 8088\index{Intel 8088}.
% Кроме того, архитектура была опубликована и~не запатентована
Архитектура IBM PC\index{IBM PC}, вопреки обычной политике IBM, была открытой, % как и~у~Альтаира
что привело к~популярности и~огромному количеству клонов (IBM PC\index{IBM PC}-совместимых компьютеров).

В~1983~г. появился первый процессор с~архитектурой ARM\index{ARM},
% , поддерживающий набор команд ARM 
% (Acorn RISC Machine)
% ARM-процессоры используются во встраиваемых системах.
% и~поддерживаются большинством ОС (GNU)
предназначенной для встраиваемых систем.

Сейчас под словом «компьютер» чаще всего понимают «IBM PC\index{IBM PC}-совместимый %персональный 
компьютер», хотя
эта архитектура (и,~соответственно, процессоры семейства x86) в~настоящее время не является самой распространённой.

Наиболее популярными персональными компьютерами
% , используемыми частными лицами, 
сейчас являются смартфоны и~планшеты, где применяются процессоры семейства ARM\index{ARM}.
Ещё более распространены цифровые сигнальные процессоры и~специализированные компьютеры.
Часто специализированный компьютер реализуется в~виде одной интегральной схемы "--- микроконтроллера.

Также в~настоящее время продолжается выпуск суперкомпьютеров, таких как Cray-X1E\index{Cray-X1E}.
С ними успешно соперничают кластеры, объединяющие множество компьютеров общего назначения.




\subsection{Операционные системы}
% \epigraphcensoredtwo[
\epigraph{\begin{stanza}[0mm]
И знать, куда бы ни легла твоя дорога,\\
Вослед тебе грядут как призрачный конвой\\
Полковник Ночка "--- суть великая подмога\\
И свет надежды, в смысле, доктор Снеговой.
\end{stanza}}{\Sk[Последний фараон]}
% ]{
%   \epigraphcensored[
%   \epigraph{
%   Тот ясень больше и прекраснее всех деревьев. 
%   Сучья его простёрты над миром и~поднимаются выше неба. Три~корня поддерживают дерево, и~далеко расходятся эти корни.}{\Edda}
%   ]{
%   \epigraph{
%   Вертикальная структура древа больше связана с~космологией, а~горизонтальная "--- с~магическими ритуалами. Чаще всего древо изображалось с~восемью ветвями, по четыре с~каждой стороны. Имело оно и~четыре главных цвета: красный, чёрный, белый, синий.}{Г.\,Белякова}
%   }
% }
\modifythree[

Уровень операционной системы, облегчающий взаимодействие прикладных программ с~аппаратной частью ВС, возник достаточно рано.
При этом первые операционные системы были неотделимы от соответствующих компьютеров и~создавались %, как правило, 
той же компанией, что и~сам компьютер.
В~них использовалось множество прогрессивных архитектурных решений и~приёмов человеко-машинного взаимодействия,
в~частности, в~1972 г. в~системе PLATO появился графический интерфейс пользователя;
но при смене компьютера приходилось менять и~систему.

Позже появились операционные системы, разработанные сторонними организациями.
Так как при смене компьютера нерационально полностью отказываться от старой операционной системы и,~соответственно, от написанного для неё ПО, появились порты таких систем на архитектуры, отличные от первоначальной, 
а~также семейства схожих систем.

В~настоящее время наиболее известным семейством являются  Unix-подобные операционные системы.
Для архитектуры x86 наиболее распространены такие представители этого семейства, как GNU/Linux и~разнообразные ветки BSD;
для ARM\index{ARM} "--- основанная на ядре Linux система Android.
Именно Android сейчас является наиболее распространённой операционной системой.

\subsubsection{История семейства Unix}
]{}

Наиболее известным семейством операционных систем является семейство Unix\index{Unix}.
% 
Первоначально операционная система Unics (Uniplexed Information and Computing System) 
была разработана %Кен Томпсон Денис Ритчи Брайан Керниган
Кеном Томпсоном\index{Томпсон, Кен}, Денисом Ритчи\index{Ритчи, Денис} и~Брайаном Керниганом\index{Керниган, Брайан}
как порт системы
Multics (Multiplexed Information and Computing Service)
на миникомпьютер DEC PDP-7\index{PDP-7}.
Первая версия Unics была написана на ассемблере~\cite{jenyay/history-unix-systems}.

Первая версия Unix (V1) появилась в~1971~г.
Начиная с~версии V6 (1975~г.)
операционная система Unix распространилась в~университетах, что привело к~появлению множества различных веток.

% Параллельно с~разработкой и~усовершенствованием Unix

% http://jenyay.net/blog/2012/02/04/history-unix-systems/
% Параллельно с разработкой Unics/UNIX Кен Томпсон и Денис Ритчи, начиная с 1969 года, разрабатывали новый язык B (Би), который был основан на языке BCPL, а тот, в свою очередь, можно считать потомком языка Algol-60
% Затем язык B развивался вместе с UNIX, пока из него не родился язык C, один из наиболее известных языков программирования, который теперь принято поливать грязью или возносить, как идеал. В 1973 году вышла третья редакция UNIX со встроенным компилятором языка C, а начиная с 5-й версии, появившейся на свет в 1974 году, считается, что UNIX был переписан полностью на C. Кстати, именно в UNIX 1973 года появилось такое понятие, как трубы (pipe).

В~настоящее время потомки операционной системы Unix
% разделяющие принципы
называются Unix-подобными операционными системами.
\modifyone[Для архитектуры x86 наиболее распространены такие представители этого семейства, как GNU/Linux и~разнообразные ветки BSD;
для ARM\index{ARM} "--- основанная на ядре Linux система Android.
Именно Android сейчас является наиболее распространённой операционной системой.
]{}

% Семейство стандартов Single UNIX Specification (SUS)
% Лицензированными Unix 
Понятие Unix-системы описывается семейством стандартов Single UNIX Specification (SUS\index{SUS}).
Зарегистрированными Unix-системами  являются коммерческие %«большие» 
операционные системы.
% соответствующие семейству стандартов Single UNIX Specification (SUS).

Кроме того, существует стандарт POSIX\index{POSIX}, описывающий взаимодействие операционной системы с~прикладной программой,
служащий для обеспечения совместимости Unix-подобных систем на уровне исходного кода.
При этом операционная система может поддерживать POSIX и~не являясь Unix-подобной.

\modifythree[
\subsubsection{Операционные системы IBM PC}

Оригинальный компьютер IBM PC\index{IBM PC} (1981~г), использовавший восьмиразрядный процессор Intel 8088\index{Intel 8088},
из-за множества аппаратных ограничений не мог использовать существовавшие в~то время многозадачные и~многопользовательские операционные системы.

Разработка специализированной системы, вопреки обычной политике IBM (но в~соответствии с~положенными в~основу IBM PC принципами модульности и~открытости), была поручена сторонней фирме "--- Microsoft, которой и~была куплена и~доработана простая однозадачная операционная система DOS, обладающая текстовым интерфейсом.
Позже была разработана графическая надстройка над DOS "--- Windows.
Дальнейшее развитие связки DOS и~Windows привело к~линейке операционных систем Microsoft Windows 95/98/Me для IBM~PC, которая так и~не стала полностью многозадачной и~была закрыта.

Практически сразу были предприняты попытки разработки для IBM PC альтернативных операционных систем (в~частности, OS/2), а~также портирования Unix. 
Начиная с~процессора 80386\index{Intel 80386}, на платформе x86 возможна работа полноценных многозадачных операционных систем, наиболее известной из которых стала Unix-подобная GNU/Linux.


В~настоящее время
д]
{Д}ля процессоров семейства x86, кроме множества вариантов Unix-подобных систем,
доступны также специфические операционные системы:
% Microsoft DOS
линейка операционных систем с~закрытым исходным кодом Microsoft Windows NT (в~настоящее время  NT является единственной поддерживаемой линейкой Microsoft Windows, поэтому обозначение NT часто опускают), 
семейство MenuetOS и~так далее.
Эти операционные системы не поддерживают стандарт POSIX\index{POSIX}, хотя для Microsoft Windows периодически заявляется частичная %или полная 
поддержка (часть POSIX\index{POSIX}, причём не для всех версий и~не для всех типов Microsoft Windows).




% \subsection{Связь уровней}
% 
% 

% 
% в~том числе компиляция и~интерпретация

% \nsection{Контрольные вопросы}
% 
% \begin{enumerate}
% % \item Какова цель курса?
% 
% \item Что включает архитектура системы?
% \item Что такое вычислительная система?
% 
% \item Какие вы знаете единицы измерения информации?
% 
% 
% % \item Какие способы представления знаковых чисел используются в~ЭВМ?
% % \item Какие логические и~битовые операции вы~знаете?
% 
% \item Какие вы знаете компоненты ЭВМ?
% 
% 
% \item Чем отличаются фон-Неймановская и~гарвардская архитектуры?
% 
% \item Из чего состоит системная шина (магистраль)?
% 
% \item Какие вы знаете основные виды регистров \rlap{x86?}
% 
% \item Как используется регистр ip?
% 
% \item Как используется регистр sp?
% \end{enumerate}

\addquestion{Что включает архитектура системы?}
\addquestion{Что такое вычислительная система?}
\addquestion{Какие вы знаете единицы измерения информации?}
\addquestion{Какие вы знаете типы наборов команд?}
\addquestion{Какие вы знаете виды архитектуры, различающиеся расположением программ и~данных?}

\addquestion{Какие уровни абстракции включает современная вычислительная система?}


\printquestions
