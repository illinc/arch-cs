\chapter{Понятие вычислительной системы (ВС)}
\epigraph{\begin{stanza}
<<Вот где водится Снарк!>> "--- возгласил Балабон\\
Указав на вершину горы;\\
И~матросов на берег вытаскивал он,\\
Их подтягивал за вихры.\end{stanza}}
{\Snark}

Вычислительная система описывается как %взаимодействием своих компонентов, 
компонентами этой системы,
так и~языком программирования, предназначенным для взаимодействия %программиста 
с~вычислительной машиной.
% 
% Рассмотрим основные понятия, определения и~применим 
В~данной главе архитектура x86 рассматривается с~обеих точек зрения.

Обозначением x86 описывают целый класс вычислительных систем,
включающий уже практически не используемую шестнадцатибитную архитектуру,
тридцатидвухбитную архитектуру IA-32 (i386--i686),
шестидесятичетырёхбитную x86-64 (amd64).

\section{Терминология}
\epigraph{\begin{stanza}Так внемлите, друзья! Вам поведаю я\\Пять бесспорных и~точных примет,\\
По которым поймёте "--- если только найдёте, "---\\Кто попался вам "--- Снарк или нет.\end{stanza}}
{\Snark}

% Базовы
Перед тем, как рассматривать архитектуру вычислительных систем,
приведём  определения из основных стандартов и~справочной литературы.

 
% http://infosys2006.narod.ru/struct/architec.htm
\termin{Архитектура системы}  в~стандарте ANSI/IEEE Std 1471-2000 (IEEE Recommended Practice for Architectural Description of Software-Intensive Systems) 
определяется как 
фундаментальная организация системы, реализованная в~её~компонентах, их~взаимоотношениях друг с~другом и~средой, а~также в~принципах, определяющих её~конструкцию (проектирование, дизайн) и~развитие~\cite{infosys2006.narod.ru}. 

Таким образом, архитектура вычислительной системы реализована в~компонентах этой  системы и~их взаимоотношениях
(рис.~\ref{ris:strela}).
Что же такое вычислительная система?
\begin{illustration}
% https://habrahabr.ru/company/ua-hosting/blog/273665/
\includegraphics[width=\linewidth]{strela}
\caption{Принцип взаимодействия узлов ЭВМ Стрела-1% (иллюстрация к~ЭВМ Стрела-1)
}
\label{ris:strela}
\end{illustration}

\termin{Вычислительная система} (ВС), согласно Воройскому~\cite{voroiskij}, определяется двояко:
\begin{enumerate}
\item Совокупность ЭВМ и~средств программного обеспечения, предназначенная для выполнения вычислительных процессов.

\item Любая автоматизированная система, основанная на использовании ЭВМ.
\end{enumerate}


Термин {«автоматизированная система»} (АС), %[automated system]
в~свою очередь, словарь Воройского также  определяет двумя способами:
% в~словаре

\begin{enumerate}
\item    Совокупность управляемого объекта и~автоматических управляющих устройств, в~которых часть функций управления выполняет человек-оператор.

\item    Комплекс технических, программных, др. средств и~персонала, предназначенный для автоматизации различных процессов. \\В отличие от автоматической системы не может функционировать без~участия человека.
\end{enumerate}

% \textterminblue{
% Информатика. Новый систематизированный толковый словарь.    
% \\
% Воройский Ф.\,С.
% }
Если же обратиться к~комплексу стандартов на автоматизированные системы~\cite{ksas-def}, %(КСАС),
% то, согласно ГОСТ 34.003-90 (Комплекс стандартов на автоматизированные системы. Автоматизированные системы. Термины и~определения),
получим третье определение:
% Документация на \termin{автоматизированные системы (АС).}
% 
% Согласно ГОСТ 34.003-90 Комплекс стандартов на автоматизированные системы. Автоматизированные системы. Термины и~определения,
% \termin{Автоматизированная система (АС)}
% \termin{АС}
{автоматизированная система}
 "--- система, состоящая из персонала и~комплекса средств автоматизации его деятельности, реализующая информационную технологию выполнения установленных функций.
%  \textterminblue{ГОСТ 34.003-90}
 
% АС  \termin{не является ПО} в~чистом виде.

Таким образом, вычислительная система глобально может быть представлена как совокупность человека (оператора или программиста), технических средств (вычислительной машины, или компьютера% "--- computer, вычислитель
)
и~связывающих их программных средств.

Соответственно, архитектура вычислительной системы может быть описана двояко:
\begin{itemize}
\item \termin{структурная декомпозиция} 
рассматривает ВС с~точки зрения её аппаратных составляющих и~физических связей между ними
и~позволяет выделить её функциональные компоненты,
% вычислительной системы, %(её программной и~аппаратной частей, а~также человека)
% и~описать их взаимодействие;
% в~том числе аппаратную составляющую "--- вычислительную машину, или компьютер, программную составляющую и~взаимодействующего с~ними человека;
% вычислительной машины, 
в~том числе компоненты, предназначенные для хранения и~обработки программ
и~компоненты, взаимодействующие с~пользователем;


\item \termin{иерархическая декомпозиция} 
рассматривает ВС с~точки зрения её логическо-информационной структуры
и~описывает %взаимодействие вычислительной машины (компьютера) с~программным обеспечением и~с~человеком.
языки  взаимодействия программиста с~программ%ами и, опосредованно
ными и~техническими средствами системы. %, а~также .
\end{itemize}

\section{Структурная декомпозиция вычислительной системы}
\epigraph{\begin{stanza}[0mm]
Кура \\
дура \\
процедура \\
\hspace{\stanzaoddindent}состоит из трёх частей: \\
карбюратор \\
вентилятор \\
\hspace{\stanzaoddindent}и~коробка скоростей!\\
\end{stanza}}{Надпись на парте}

Структурная декомпозиция применяется к~аппаратной части вычислительной системы "--- вычислительной машине, или компьютеру.

Если посмотреть на персональный компьютер, то он, как правило, состоит из \termin{системного блока} и~\termin{внешних устройств,} среди которых обязательно присутствуют \termin{устройства ввода-вывода,} предназначенные для взаимодействия с~пользователем "--- экран, клавиатура, мышь и~т.\,д.
% (рис.~\ref{ris:arch-comp-struct}).

% % При более внимательном рассмотрении
% Системный блок, в~свою очередь, состоит из корпуса и~\termin{внутренних устройств.} %, внутри которого располагаются
Внутри системного блока находятся \termin{внутренние устройства,}
из которых основными являются:
\begin{itemize}
\item системная, или материнская плата;
\item центральный процессор;
\item оперативная память (оперативное запоминающее устройство "--- ОЗУ);
\item внешняя, или долговременная память (жёсткие диски, SSD и~т.\,д.);
\item видеокарта;
\item звуковая карта и~т.\,д.
\end{itemize}
Внутренние устройства защищены корпусом системного блока и~получают постоянный ток через блок питания.
% Некоторые из них, хотя конструктивно выполнены внутри корпуса, не обязательны для работы компьютера.


% \begin{illustration}
% \includegraphics[width=\wideImageWidth]{arch-comp-struct}
% 
% \caption{Устройство компьютера}
% \label{ris:arch-comp-struct}
% \end{illustration}

% Основным компонентом 
Все компоненты компьютера связывает воедино системная плата (рис.~\ref{ris:motherboard_diagram}).
\index{Структурная декомпозиция!системная плата}%
Важную роль играют входящие в~её состав два  мощных контроллера-концентратора "--- северный мост и~южный мост,
обеспечивающие согласование и~передачу информационных потоков между различными компонентами системного блока и~внешними устройствами.

\begin{illustration}
\includegraphics[width=%\approvedImageWidth
% \wideImageWidth
1.2\approvedImageWidth
,valign=c]{Motherboard_diagram_ru}

\caption{Схема системной платы}
\label{ris:motherboard_diagram}
\end{illustration}%



\termin{Северный мост} 
определяет частоту системной шины, тем самым "--- вид и~объём ОЗУ, тип шины видеоадаптера (обычно это PCI Express или AGP),
осуществляет обмен между центральным процессором и~скоростными устройствами,
это
% частота шины, вид и~объём ОЗУ, тип шины видеоадаптера.
\begin{itemize}
\item оперативная память (ОЗУ);
\item видеокарта;
\item южный мост.
\end{itemize}

% Процессор связан с~

\termin{Южный мост} 
осуществляет обмен с~устройствами по низкоскоростным интерфейсам, это
% "--- часы, память CMOS,
% работа с~низкоскоростными интерфейсами:
\begin{itemize} 
\item часы;
\item энергозависимая память (ПЗУ);
\item контроллер  SATA;
\item контроллер IDE;
\item контроллер прерываний;
\item контроллер USB;
\item контроллер прямого доступа.
\end{itemize}
Внутренняя шина, связывающая северный мост и~южный мост, обеспечивает непрерывность потоков информации.


Взаимосвязь различных элементов системной платы и~устройств обеспечивают различные системные шины (магистрали).
Иногда \termin{системной шиной} называют только шину, связывающую процессор и~северный мост.

Совокупность проводов системной магистрали можно разбить на четыре группы (рис.~\ref{ris:bus-controllers}):
\begin{illustration}

% \resizebox{0.8\linewidth}{!}{
% \resizebox{\approvedImageWidth}{!}{
\resizebox{\wideImageWidth}{!}{
\schemafont
% \setlength{\leftmargini}{14ex}
% \setlist{leftmargin=*,topsep=0pt,itemsep=0pt}
\input{book/drawings/arch-bus-controllers}
}
\caption{Структура системной шины}
\label{ris:bus-controllers}
\end{illustration}
\begin{itemize} 
\item шина питания (так как по этой шине не передаётся никакой информации, её часто опускают на схемах);
\item шина управления, используемая для организации обмена самой магистрали;
\item шина данных;
\item шина адреса.
\end{itemize}
\index{Структурная декомпозиция!тактовый генератор}
Шины питания и~управления связывают все устройства, %; шины данных и~адреса охватывают только устройства, связанные с~обработкой данных.
в~том числе \termin{тактовый генератор,}
предназначенный для синхронизации работы различных устройств системной платы.
Тактовый генератор задаёт частоту работы процессора как самого быстрого устройства; частоты  более медленных устройств являются делителями частоты процессора.

\index{Структурная декомпозиция!ПЗУ}
Кроме оперативной, в~ВС имеется \termin{постоянное запоминающее устройство (ПЗУ)} "--- энергонезависимая память,
в~которой записана неизменяемая информация, которая сохраняется после отключения питания.
Там
% В~\termin{постоянном запоминающем устройстве} (энергонезависимой памяти) 
хранится микропрограмма управления вычислительной машиной.
Она обязательно включает программы начальной загрузки и~самотестирования.

\index{Структурная декомпозиция!BIOS}
В~постоянном запоминающем устройстве персонального компьютера записывается BIOS (Basic­ Input/Output­ System "--- базовая­ система­ ввода/вывода),
включающая, кроме загрузчика, также настройки и~функции ввода/вывода с~помощью программных прерываний.
Ввод-вывод при помощи BIOS доступен только в~реальном режиме работы компьютера.
Современные операционные системы сразу после загрузки переводят компьютер в~защищённый режим и~не используют BIOS.

Сама операционная система, как и~загружаемые ей программы, располагается в~\termin{оперативной} (энергозависимой) памяти.



\termin{Центральный процессор} (центральное процессорное устройство, ЦПУ)
является «мозгом» ВС. Он исполняет код программ.
% Кроме центрального процессора, на материнской плате 
ЦПУ часто называют просто процессором, иногда "--- микропроцессором (МП).
Исторически микропроцессор "--- это процессор, выполненный на одной микросхеме; сейчас другие варианты исполнения нерентабельны
и~эти два термина стали синонимами.
% 
Ранее для специализированных процессоров, расширяющих функциональность ЦПУ, использовался термин «сопроцессор»,
но в~настоящее время
сопроцессоры либо вошли в~состав ЦПУ (в~частности, математический сопроцессор x87 входит в~ядро современных ЦПУ семейства x86), 
либо получили иные %собственные 
названия (так, графический сопроцессор обычно называется видеокартой или графическим ускорителем).

{Центральный процессор} %(центральное процессорное устройство, ЦПУ) 
включает
\index{Структурная декомпозиция!процессор}
\index{Структурная декомпозиция!АЛУ}
\index{Структурная декомпозиция!УУ}
\index{Структурная декомпозиция!регистры}
\begin{itemize}
\item арифметико-логическое устройство (АЛУ), выполняющее обработку данных;
\item управляющее устройство (УУ), декодирующее поступающие в~процессор команды и~формирующее на их основе сигналы для АЛУ;
\item регистры "--- сверхбыструю память особой структуры и~малого объёма, предназначенную
% , предназначенные 
для временного хранения данных.
% (в~частности, %специальные регистры хранят сл
% регистр команд содержит декодируемую в~данный момент команду,
% указатель команды содержит адрес следующей команды
% и~т.\,п.;
% % другие специальные
% регистры общего назначения могут быть использованы программистом по своему усмотрению).
Часть регистров может быть использована программистом по своему усмотрению (регистры общего назначения), часть используется для специальных целей.
\end{itemize}
\index{Структурная декомпозиция!кеш-память}
Также современные процессоры содержат кеш-память (сверхоперативную память), предназначенную для прозрачного временного хранения фрагментов оперативной памяти.
Время обращения к~кеш-памяти больше, чем к~регистрам, но меньше, чем к~ОЗУ.
% Кеш-память быстрее ОЗУ, но медленнее регистров
\pagebreak[3]

\subsection{Единицы измерения}
\epigraph{\begin{limerick}
    Жил-был старичок между ульями,\\
    От пчёл отбивавшийся стульями.\\
    Но он не учёл\\
    Числа этих пчёл\\
    И пал смертью храбрых меж ульями.
\end{limerick}
}
{\Lear}
\label{sec:byte}
\index{Бит}
\index{Байт}
\index{Октет}
\index{Слово}
Базовой единицей измерения информации в~современных ЭВМ является \termin{бит} "--- двоичный разряд.

В~соответствии с~характеристиками магистрали и~регистров вводятся дополнительные 
платформозависимые
единицы измерения:
% характеризующие конкретную вычислительную систему:
\begin{itemize}
\item машинное \termin{слово}  "--- разрядность регистров процессора и/или шины данных;
\item \termin{байт} "--- %совокупность битов, обрабатываемая компьютером одномоментно (обычно байт=октет).
минимальный независимо адресуемый \rlap{набор данных.}
\end{itemize}
Понятие машинного слова возникло раньше понятия байта.
Вначале минимально адресуемый блок памяти (байт) и~блок, загружаемый или обрабатываемый за один раз (слово) всегда совпадали.
% Машинное слово равно или кратно байту.
В~настоящее время машинное слово может быть как равно, так и~кратно байту.

% http://forum.ixbt.com/topic.cgi?id=8:20632
В~настоящее время байт обычно составляет восемь бит, но существуют  DSP-процессоры, для которых байт состоит из шестнадцати или двенадцати бит.
На начальных этапах развития вычислительной техники размер байта вообще не был стандартизирован.
Впервые термин «байт» был употреблён для совокупности шести битов.

Если необходимо описать именно восемь двоичных разрядов, используется термин  \termin{октет.}
% \termin{Октет} "--- 8 бит ($2^8 = 256$ состояний).
В~частности, эта единица измерения используется при описании сетевых протоколов.
% где, строго говоря, невозможно определить байт, так как нет единой архитектуры

В~семействе процессоров x86 используется восьмибитный байт.
Длина машинного слова менялась от шестнадцати бит у~первых моделей до шестидесяти четырёх у~современных.
При этом для совместимости документации термин «слово» остался за шестнадцатью битами.
Тридцать два бита называют двойным словом,
шестьдесят четыре "--- четверным и~так далее.

Далее по тексту везде подразумевается, что байт состоит из восьми бит.


\subsection{Порядок следования байтов% в~словах
}
\epigraph{\begin{limerick}
Злополучную даму в~Байраме\\
Много раз прищемляло дверями.\\
«А~может быть, впредь\\
В~дверях не сидеть?» "---\\
Подумала дама в~Байраме.\\
\end{limerick}
}
{\Lear}
\index{Порядок байтов}
\label{sec:byteorder}
% Так как байт "--- минимальный адресуемый блок памяти, невозможно судить о~

Для начала уточним:
в~современных ВС память адресуется побайтово, при этом начальный адрес равен нулю, и~адрес каждого следующего байта возрастает на единицу.
То есть в~качестве модели памяти можно рассматривать непрерывную ленту из последовательно расположенных байтов
с~непрерывно возрастающими на единицу номерами "--- адресами.
% ?????
Подобные последовательности принято записывать, следуя обычному направлению письма, то есть адреса возрастают слева направо.
% То есть адреса возрастают слева направо.
Адресом слова считается адрес его самого левого байта (далее будем обозначать его~$\zeta$).

Кроме того, число в~вычислительных системах представляется в~двоичной позиционной системе счисления, то есть в~виде совокупности двоичных разрядов "--- битов.
Каждый бит имеет свой вес, соответственно которому разряды также можно упорядочить "--- от младшего к~старшему.
\begin{equation}
X = x_0 + x_1\cdot 2 + \ldots + x_k\cdot 2^k, ~~x_i \in \{0,1\}
\end{equation}
% Количество битов числа всегда кратно размеру байта. % (если значащих двоичных цифр меньше, «лишние»)
Если число включает восемь бит (занимает один байт), то никакой неоднозначности нет "--- число имеет адрес, равный адресу единственного байта.
Биты внутри байта не имеют адресов, но ранжируются по весу.

Если число включает %16 бит или более, оно записывается несколькими байтами.
шестнадцать бит, оно записывается двумя байтами.
Каждый байт включает восемь смежных по старшинству разрядов числа (рис.~\ref{ris:word-bytes}, а).
\begin{equation}
% X = \chi_0 + \chi_1\cdot 2^8 + \ldots + \chi_{\kappa}\cdot (2^8)^{\kappa}, ~~\chi_i \in \{0,1,\ldots 255\}
X = \chi_0 + \chi_1\cdot 256, 
% + \ldots + \chi_{\kappa}\cdot 256^{\kappa}
~~\chi_i \in \{0,1,\ldots 255\}
\end{equation}



\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=5 ex]
\tikzstyle{bit}	= [reg, solidchaincell, minimum width=5 ex]
\tikzstyle{byte}	= [reg, fill=clMemoryLight, solidchaincell, minimum width=8*5 ex]

% \newcommand{\byteorder}[3][]
% {
% \begin{tikzpicture}[
% start chain=going left,
% node distance=0.5ex,
% ]
% 
% 
%   \tikzmath{
%     int \lastbyte, \lastbit;
%     \lastbyte = #2;
%     \lastbit = 8*(\lastbyte)+7; 
%     \linedistex = 12;
%   }
%   
%   
%   \foreach \bitnum in {0,...,\lastbit}
%   {
%     \node[bit, on chain, label=below:$\bitnum$] (b\bitnum) {$x_{\bitnum}$};
%   };
%     
%   \foreach \bytenum in {0,...,\lastbyte}
%   {
%     \tikzmath{
%       int \bs, \be;
%       \bs = 8*\bytenum;
%       \be = 8*(\bytenum+1)-1;
%     }
%     \draw [decorate,decoration={brace,amplitude=1em},xshift=0pt,yshift=0.5ex]
%     (b\be.north west)--(b\bs.north east)
%     node [black,midway,yshift=4ex] 
% %     {байт $\bytenum$ ($\chi_{\bytenum}$)};
%     {#3};
% 
%     \tikzmath{
%       int \intel, \motor;
%       \intel = \lastbyte - \bytenum;
%       \motor = \bytenum;
%     }
%     \node[byte, label=below:$\byteaddr{\bytenum}$, below = \linedistex ex of b\bs.east, anchor = east] (i\bytenum) {$\chi_\intel$};
%     \node[byte, label=below:$\byteaddr{\bytenum}$, below = 2*\linedistex ex of b\bs.east, anchor = east] (m\bytenum) {$\chi_\motor$};
% 
%   };  
% 
%   \foreach \leftline in {b\lastbit, i\lastbyte, m\lastbyte}
%   {
%     \node[left = 2ex of \leftline] {\asbuk{risletter})\stepcounter{risletter}};
%   };  
% 
% 
% \end{tikzpicture}
% }

\begin{illustration}
\setcounter{risletter}{1}
\tikzmath{
  let \byted{1} = старший;
  let \byted{0} = младший;    
  let \byteaddr{1} = \zeta;
  let \byteaddr{0} = \zeta+1;    
}
  
\resizebox{\linewidth}{!}
{
% \byteorder{1}{\byted{\bytenum} байт ($\chi_{\bytenum}$)}
\begin{tikzpicture}[
start chain=going left,
node distance=0.5ex,
]


  \tikzmath{
    int \lastbyte, \lastbit;
    \lastbyte = 1;
    \lastbit = 8*(\lastbyte)+7; 
    \linedistex = 12;
  }
  
  
  \foreach \bitnum in {0,...,\lastbit}
  {
    \node[bit, on chain, label=below:$\bitnum$] (b\bitnum) {$x_{\bitnum}$};
  };
    
  \foreach \bytenum in {0,...,\lastbyte}
  {
    \tikzmath{
      int \bs, \be;
      \bs = 8*\bytenum;
      \be = 8*(\bytenum+1)-1;
    }
    \draw [decorate,decoration={brace,amplitude=1em},xshift=0pt,yshift=0.5ex]
    (b\be.north west)--(b\bs.north east)
    node [black,midway,yshift=4ex] 
%     {байт $\bytenum$ ($\chi_{\bytenum}$)};
    {\byted{\bytenum} байт ($\chi_{\bytenum}$)};

    \tikzmath{
      int \intel, \motor;
      \intel = \lastbyte - \bytenum;
      \motor = \bytenum;
    }
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = \linedistex ex of b\bs.east, anchor = east] (i\bytenum) {$\chi_\intel$};
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = 2*\linedistex ex of b\bs.east, anchor = east] (m\bytenum) {$\chi_\motor$};

  };  

  \foreach \leftline in {b\lastbit, i\lastbyte, m\lastbyte}
  {
    \node[left = 2ex of \leftline] {\asbuk{risletter})\stepcounter{risletter}};
  };  


\end{tikzpicture}
}

\caption{Двухбайтовое число: а)~биты старшего и~младшего байтов, б)~прямой порядок байтов в~памяти, {в)~обратный порядок байтов в~памяти}}
\label{ris:word-bytes}
\end{illustration}

При этом каждому байту числа можно сопоставить и~его вес (старшинство его битов в~числе), 
и~адрес (расположение в~памяти).
На любой платформе байты двухбайтового числа (младший~$\chi_0$ и~старший~$\chi_1$) расположены в~памяти рядом,
но друг относительно друга они могут располагаться  по-разному.
% По младшему адресу (обозначим его~$\zeta$) может находиться как младший байт~$\chi_0$ (такой порядок называется прямым и~показан на рис.~\ref{ris:word-bytes}, б), так и~старший~$\chi_1$ (такой порядок называется обратным, рис.~\ref{ris:word-bytes}, в).

Для двухбайтового числа возможны только два варианта:
\begin{itemize}
\item прямой порядок (также называемый little-endian, Intel или VAX)  "--- младший байт слова расположен по~младшему адресу (рис.~\ref{ris:word-bytes}, б);
\item обратный (big-endian, Motorola или сетевой порядок) "--- младший байт слова расположен по~старшему адресу (рис.~\ref{ris:word-bytes}, в).
\end{itemize}

Числа в~любой позиционной системе счисления принято записывать в~арабской традиции "--- младший разряд справа, старший слева.
Содержимое памяти (дамп памяти), напротив, записывается, следуя европейскому направлению письма "--- младшие адреса слева, старшие справа.
% Таким образом, обратный порядок байтов позволяет легко читать числа, записанные в~памяти.
% Обратный порядок принят в~протоколе TCP/IP. % и~иногда на
Из-за этого на рис.~\ref{ris:word-bytes} именно прямой порядок выглядит «перевёрнутым», а~обратный "--- соответствует привычной позиционной записи числа.

Значение каждого  байта в~дампе записывается 
двумя шестнадцатеричными цифрами
в~арабской традиции (как  число, которое уже не может быть разделено на части с~разными адресами).
% в~шестнадцатеричной системе счисления. Для записи восьмибитного значения байта достаточно двух шестнадцатеричных цифр.
Соответственно, конкретные числа в~дампе памяти выглядят ещё экзотичнее.
Пусть необходимо записать в~память вычислительной машины с~восьмибитным байтом
шестнадцатибитное число $x=\hex{0x0A\,0B}$.
Оно содержит два байта: старший $\chi_1=\hex{0A}$, младший $\chi_0 = \hex{0B}$.
Дамп памяти с~прямым порядком байтов, соответственно, будет выглядеть как $\chi_0 \chi_1 = \hex{0B\,0A}$ (то есть разряды  числа  несколько «перетасованы»),
с~обратным порядком "--- как $\chi_1 \chi_0 = \hex{0A\,0B}$.

Если %машинное слово
число
состоит из нескольких байтов, эти байты в~памяти ВС также могут быть расположены друг относительно друга по-разному.
% 
Чаще всего используется 
% один из следующих вариантов:
% \begin{itemize}
% \item прямой порядок (также называемый little-endian, Intel или VAX)  "--- младший байт слова расположен по~младшему адресу;
% \item обратный (big-endian, Motorola или сетевой порядок) "--- младший байт слова расположен по~старшему адресу.
% \end{itemize}
прямой или обратный порядок (рис.~\ref{ris:dword-bytes}).

% Прямой порядок %исторически сложился 
% % позволяет обрабатывать числа, состоящие из 

\begin{illustration}
\setcounter{risletter}{1}
\tikzmath{
  let \byteaddr{3} = \zeta;
  let \byteaddr{2} = \zeta+1;    
  let \byteaddr{1} = \zeta+2;
  let \byteaddr{0} = \zeta+3;    
}
  
\resizebox{\linewidth}{!}
{
% \byteorder{3}{$\chi_{\bytenum}$}
\begin{tikzpicture}[
start chain=going left,
node distance=0.5ex,
]


  \tikzmath{
    int \lastbyte, \lastbit;
    \lastbyte = 3;
    \lastbit = 8*(\lastbyte)+7; 
    \linedistex = 9;
  }


\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=4 ex]
\tikzstyle{bit}	= [reg, solidchaincell, minimum width=2 ex]
\tikzstyle{byte}	= [reg, fill=clMemoryLight, solidchaincell, minimum width=16 ex]
  
  
  \foreach \bitnum in {0,...,\lastbit}
  {
    \node[bit, on chain, label=below:\scriptsize$\bitnum$] (b\bitnum) {};
  };
    
  \foreach \bytenum in {0,...,\lastbyte}
  {
    \tikzmath{
      int \bs, \be;
      \bs = 8*\bytenum;
      \be = 8*(\bytenum+1)-1;
    }
    \draw [decorate,decoration={brace,amplitude=1em},xshift=0pt,yshift=0.5ex]
    (b\be.north west)--(b\bs.north east)
    node [black,midway,yshift=4ex] 
%     {байт $\bytenum$ ($\chi_{\bytenum}$)};
    {$\chi_{\bytenum}$};

    \tikzmath{
      int \intel, \motor;
      \intel = \lastbyte - \bytenum;
      \motor = \bytenum;
    }
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = \linedistex ex of b\bs.east, anchor = east] (i\bytenum) {$\chi_\intel$};
    \node[byte, label=below:$\byteaddr{\bytenum}$, below = 2*\linedistex ex of b\bs.east, anchor = east] (m\bytenum) {$\chi_\motor$};

  };  

  \foreach \leftline in {b\lastbit, i\lastbyte, m\lastbyte}
  {
    \node[left = 2ex of \leftline] {\asbuk{risletter})\stepcounter{risletter}};
  };  


\end{tikzpicture}
}

\caption{Четырёхбайтовое число: а) байты и~биты числа, б)~прямой~порядок байтов в~памяти, \mbox{в) обратный порядок байтов в~памяти}}
\label{ris:dword-bytes}
\end{illustration}


Пусть необходимо записать в~память вычислительной машины с~восьмибитным байтом
тридцатидвухбитное число $x=\hex{0x0A\,0B\,0C\,0D}$.
Оно займёт четыре смежных байта с~адресами $\zeta, \zeta+1, \zeta+2$ и~$\zeta+3$.
Наименьший из них (младший)  адрес $\zeta$ будет адресом числа~$x$.
% 
Рассмотрим, как оно будет расположено в~памяти при разных порядках размещения.

% Число \hex{0x0A\,0B\,0C\,0D}, записанное  
При записи
с~обратным порядком байтов это число
при просмотре дампа памяти будет выглядеть как \hex{0A\,0B\,0C\,0D}, то есть старший байт \hex{0A} будет записан по младшему адресу $\zeta$
и,~соответственно, напечатан первым (левее всего),
байт \hex{0B} "--- по адресу $\zeta+1$, \hex{0C}"--- по адресу $\zeta+2$,
младший байт \hex{0D} окажется записанным по самому старшему адресу  $\zeta+3$ и~при просмотре или печати дампа памяти окажется правее остальных.

% То же число 
При записи
с~прямым порядком байтов это число будет выглядеть как \hex{0D\,0C\,0B\,0A}:
младший байт \hex{0D} записан по младшему адресу  $\zeta$,
\hex{0C} "--- по адресу $\zeta+1$, \hex{0D} "--- по адресу $\zeta+2$,
старший байт \hex{0A} "--- по старшему адресу  $\zeta+3$.
% (то есть разряды [??? байты?] числа в~памяти несколько «перетасованы»)

Очевидно, что обратный порядок байтов позволяет легко читать числа, записанные в~памяти.
Обратный порядок принят в~протоколе TCP/IP. % и~иногда на

Прямой порядок байтов удобен при обработке чисел большой разрядности с~помощью процессора малой разрядности,
так как позволяет %, в~частности, 
при сложении таких чисел обращаться к~памяти последовательно в~порядке возрастания адресов, а~такие запросы выполняются быстрее
(это учитывается в~схемной реализации алгоритмов обработки).
% В~частности, в~процессорах семейства x86 используется прямой порядок байтов (порядок Intel).
% так как восьмибитные предки этого семейства (8008 и~8080) 

Некоторые системы позволяют переключать используемый порядок байтов при помощи перемычки на материнской  плате или программно (bi-endian, bytesexual).

Также иногда используется смешанный (middle-endian, mixed-endian) порядок байтов:
% байты в~словах расположены в~обратном порядке, но, если число состоит из нескольких слов, слова расположены в~прямом порядке ()
% либо наоборот.
байты в~словах расположены в~одном порядке, но, если число состоит из нескольких слов, слова располагаются наоборот.
В~частности, в~PDP-11 младший байт слова расположен по младшему адресу, но младшее слово числа "--- по старшему (PDP-endian), так что наше
число \hex{0x0A\,0B\,0C\,0D} имеет в~памяти вид \hex{0B\,0A\,0D\,0C}.
Другой вариант смешанного порядка "--- младший байт слова по старшему адресу, а~младшее слово числа "--- по младшему, "--- даст \hex{0C\,0D\,0A\,0B}. 

В~процессорах семейства x86 используется прямой порядок байтов (порядок Intel).
Он применяется даже к~вещественным числам, которые не имеет смысла обрабатывать по частям:
число  \hex{3F\,F0\,00\,00\,00\,00\,00\,00} ($1.0$, то есть единица с~плавающей запятой двойной точности)
будет записано в~памяти как
\hex{00\,00\,00\,00\,00\,00\,F0\,3F}.



\subsection{Цикл выполнения команды}
% \subsection{Выполнение программ}
\epigraph{\begin{limerick}
    Жил один старичок в Мэриленде \\
    Пивший соевый соус и бренди;\\
    Он их пил понемножку\\
    За ложкою ложку\\
    При свете луны в Мэриленде.\\
\end{limerick}
}
{\Lear}
\label{sec:command-cycle}
% Естественный ход выполнения программы "--- последовательное выполнение её команд.
\index{Цикл выполнения команды}

Проходящие через ВС потоки информации можно разделить на две основные группы: 
команды и~данные.

Данные представляют собой информацию, подлежащую обработке и,~как правило, размещаются в~памяти ВС.

Команды предназначены организовать и~выполнить обработку данных процессором ВС.
Последовательность команд называется программой и~также расположена в~памяти ВС.

% http://www.excode.ru/art6449.html
Выполнение команды процессором можно разбить на ряд этапов.
Эту последовательность называют циклом выполнения команды, или рабочим циклом процессора.
\begin{enumerate}
\item Выборка (загрузка) команды из памяти.
% Выполнение команды начинается с~её загрузки (выборки) из памяти.
Адрес загружаемой команды хранится в~специальном регистре "--- указателе команды ({instruction pointer,} $ip$).
На рис.~\ref{ris:command-cycle} указатель команд хранит адрес команды К-1.

\begin{illustration}
\resizebox{\wideImageWidth}{!}{
\schemafont
\input{book/drawings/command-cycle}
}

\caption{Цикл выполнения команды}
\label{ris:command-cycle}
\end{illustration}

Двоичный код выбранной команды К-1  попадает в~другой специальный регистр "--- регистр команд.

\item %После выборки команда декодируется, в~частности
Декодирование команды.
На этом этапе определяется, выбрана ли команда целиком или  необходима дозагрузка (разные команды могут иметь различную длину).
Когда команда загружена полностью, 
определяется наличие у~неё операндов и~их расположение,
наличие числового результата и~его расположение,
а~также 
формируется сигнал для АЛУ в~соответствии с~типом команды.

\item Выборка операндов.
% Загрузка данных.
На следующем этапе из памяти %или регистров общего назначения ? не грузятся
загружаются операнды команды,
% После загрузки они 
которые затем помещаются в~специальные регистры.
% http://henu3gu.narod.ru/evm/133-143.html
Если операнды располагаются в~регистрах общего назначения, они поступают в~АЛУ на этапе выполнения~\cite{zilker}.

\item Выполнение инструкции.
% \item Установка флагов
Этап выполнения команды протекает различным образом для различных команд.
В~случае арифметических команд операнды поступают из регистров на вход АЛУ, 
АЛУ выполняет операцию, соответствующую команде,
результат записывается в~специальный регистр результата, формируются признаки результата (нулевое значение, некорректный результат и~так далее).

\item   Запись результатов и~установка флагов.
На этом этапе результат загружается из регистра результата в~расположение, определённое при декодировании (это может быть как ячейка памяти, так и~регистр общего назначения).
Признаки результата записываются в~регистр флагов,
доступный для анализа дальнейшими командами.
% по значению которого программа.

\item Формирование адреса следующей команды.
% 
% После этого в~указатель команд 
В~регистр указателя команд
помещается адрес следующей команды.
% Чаще всего это команда, непосредственно следующая за выполненной (К-2), но, 
Если К-1 была командой условного или безусловного перехода, вызова или возврата из функции и~т.\,п., адрес следующей команды можно узнать только после выполнения К-1.

\end{enumerate}
% Для каждой команды необходимо последовательно выполнить все этапы.
% Для некоторых команд необходима только часть этапов, но последовательность нарушена быть не может.
Обработка разных команд при этом может вестись параллельно.
% Таким  образом, время выполнения команды будет 
Для этого цикл выполнения команды разбивают на несколько стадий "--- от двух для ранних ЭВМ, в~частности, для ЭЦВМ Урал, до нескольких десятков в~настоящее время.
Выполнение каждой из этих стадий реализуется независимо от других.
% "--- так, чтобы работа компонента, выполняющего каждую из стадий, не

При подобной реализации обработка следующей команды может выполняться, не дожидаясь конца текущей;
такой способ организации вычислений называется \termin{конвейером.}
\index{Конвейер}

Так, в~большинстве случаев  после команды К-1 будет выполняться команда, непосредственно следующая за ней в~программе  (К-2)
"--- подобная последовательность называется естественным ходом выполнения.
Таким образом, уже после полной выборки К-1    можно обновить указатель команд.
Соответственно, если конвейер включает шесть стадий, описанных выше,
то, 
\begin{itemize}
\item пока К-1 будет декодироваться, можно выполнить выборку К-2;
\item во время выборки операндов К-1 освободится блок декодирования, так что можно декодировать К-2;
\item во время выполнения К-1 можно выбрать из памяти операнды К-2 и~так далее.
\end{itemize}
Если нет сбоев или задержек, %среднее 
время выполнения команды будет определяться временем выполнения самой длинной стадии.

% http://old.computerra.ru/terralab/235537/
Сбои конвейерной обработки возможны в~нескольких случаях:
\begin{enumerate}
\item Различные времена выполнения стадий для разных команд. Для решения этой проблемы перед блоками, исполняющими каждую стадию, вставляются блоки-диспетчеры, организующие очередь.
\item Конфликты по данным (в~частности, операндом К-2 может быть результат К-1).
Подобные зависимости отслеживаются на этапе декодирования и~учитываются планировщиком на этапе выполнения.
В~некоторых процессорах планировщик может изменить порядок выполнения команд так, чтобы избежать зависимостей по данным между соседними командами.
\item Выполняемая команда нарушает естественный ход выполнения программы (например, %переходы, вызов и~возврат из функции
К-1 может быть командой перехода к~К-4).
Это приводит к~очистке и~повторной загрузке конвейера, что существенно снижает быстродействие.
Для предотвращения постоянной очистки конвейера в~циклах современные процессоры используют различные алгоритмы %предсказания
прогнозирования переходов.
\end{enumerate}

% https://habrahabr.ru/post/182002/
В~линейке x86 конвейер впервые появился в~процессоре i486 и~включал пять стадий, что позволило более чем вдвое увеличить производительность.

% \index{Суперскалярные ЭВМ}
\index{Суперскалярность}
Если процессор включает несколько конвейеров, возможна полностью одновременная обработка нескольких команд.
% Некоторые узлы конвейера могут быть продублированы, тогда соответствующие стадии могут проходить параллельно несколько команд.
Подобные процессоры называются \termin{суперскалярными}.
При этом параллельно могут выполняться только команды, не связанные зависимостями по данным.
Отслеживание зависимостей и~планирование исполнения реализуется внутри суперскалярных процессоров.

Перед выполнением программы её код должен быть загружен в~память.
Выполнение программы начинается с~помещения  в~указатель команд~$ip$
адреса той команды, которая должна быть выполнена первой (точки входа).


% \termin{Конвейер:}
% \begin{itemize}
% \item выборка и~декодирование инструкции
% \item    загрузка данных
% \item    выполнение инструкции
% \item   запись результатов
% \end{itemize}

\subsubsection{Классификация по набору команд}

По количеству и~структуре команд архитектуры делятся на два  основных типа.
\begin{enumerate}
\item    CISC (complex instruction set computer "--- компьютер с~набором сложных команд) "--- набор команд огромен и~разнообразен, 
сами команды имеют переменную длину и~сложную структуру, а~также используют сложные режимы адресации; 
регистров мало и~функции многих из них предопределены.

Это было сделано для упрощения программирования в~машинных кодах, компактности программ и~удешевления самого процессора.

\item    RISC (reduced instruction set computer "--- компьютер  с~набором упрощённых  команд, архитектуры load/store)
"--- набор команд включает команды простой постоянной структуры и~фиксированной длины; при этом процессор содержит множество регистров, так что обращение к~памяти производится только для загрузки (load) данных в~регистры и~выгрузки (store) их оттуда.

Такая архитектура позволяет поднять частоту и~параллельность
и~хорошо подходит для компиляции с~языка высокого уровня.

Естественным продолжением идеологии RISC являются архитектуры типа    VLIW (very long instruction word "--- сверхдлинное командное слово).
Команда VLIW объединяет несколько команд RISC по числу конвейеров процессора; эти команды выполняются параллельно на соответствующих конвейерах.

В~отличие от суперскалярных процессоров, где распределение команд по конвейерам происходит во время выполнения специальным устройством в~составе процессора,
командные слова VLIW формируются компилятором на этапе сборки программы.
\index{Суперскалярность}
Это позволяет упростить и~удешевить процессор, но усложняет разработку компиляторов и~увеличивает длину программы.
% , так как в~некоторых командных словах часть команд 
% (если компилятор не)
\end{enumerate}



\subsection{Расположение программ и~данных}
\epigraph{\begin{limerick}
    Старичок, проживавший в Рангуне,\\
    Погулять как-то вышел в июне.\\
    Возвращаясь назад,\\
    Нёс он двух поросят,\\
    Арестованных лично в Рангуне.\\
\end{limerick}
}
{\Lear}

Данные и~команды поступают в~процессор по системной шине из памяти.
% Системная шина, кроме всего прочего, реализует связь процессора с~памятью, хранящей программы и~данные.
% Эта связь может быть реализована двояко.
Соответственно, память может быть общей для команд и~данных "--- в~этом случае для связи с~процессором достаточно одной общей шины (рис.~\ref{ris:harvard-prinston}, а).
Такая архитектура требует меньшего количества элементов и~дорожек, поэтому она дешевле и~компактнее.

\begin{illustration}

\newcommand{\DoublearrowYRight}[2]
{
  \path[blockarrow] (#2) ++(0,0.5ex) coordinate(tmpUp) -- (tmpUp-|#1);
  \path[blockarrow] (#2-|#1)   ++(0,-0.5ex) coordinate(tmpDown) -- (tmpDown-|#2) ;
}

\resizebox{\wideImageWidth}{!}{
\schemafont
\begin{tikzpicture}[
node distance=2ex and 4ex,
baseline=(current bounding box.north)
]
\tikzstyle{strokednode}	= [text badly centered, draw=black, thick, minimum height=4ex]
\tikzstyle{block}	= [strokednode, text width=16ex]
\tikzstyle{blockarrow}	= [-latex', draw]
\tikzstyle{hiblock}	= [block, minimum height=8ex]

\coordinate (Pr);
% \UuAluBlock{Pr}

\coordinate[right = 40ex of Pr] (Gv);
% \UuAluBlock{Gv}

% \foreach \i/\s in {Pr/Фон-неймановская (принстонская) архитектура, Gv/Гарвардская архитектура}
\foreach \i/\s in {Pr/а), Gv/б)}
{
  \node[block, fill=clRegisterLight] ({\i}Output)  at (\i) {Вывод};
  \node[hiblock, above = of {\i}Output, fill=clCalcLight] ({\i}Alu) {АЛУ};
  \node[block, above = of {\i}Alu, fill=clRegisterLight] ({\i}Input) {Ввод};

  \node[strokednode, left = of {\i}Input, rotate=90, anchor=south, inner xsep=1.5ex, fill=clDeviceLight] ({\i}Uu) {Управляющее устройство};
  
  \path[blockarrow] ({\i}Input) -- ({\i}Alu);
  \path[blockarrow] ({\i}Alu) -- ({\i}Output);
  
  \DoublearrowYRight{{\i}Uu.south}{{\i}Alu.west}
  
  \node[text width=40ex, text badly centered, below = of {\i}Output)] {\s};
}
  \node[hiblock, above = of {Pr}Input, fill=clMemoryLight] (PrMemory) {Общая память};
  \DoublearrowYRight{{Pr}Uu.south}{PrMemory.west}
  \path[blockarrow] (PrMemory) -- ({Pr}Input);
  \path[blockarrow] ({Pr}Output.east) -- ++(4ex,0) |- (PrMemory);
  
\tikzstyle{narrowblock}	= [strokednode, text width=8ex]
%   \node[narrowblock, above = of {Gv}Input.north east] (GvDataMemory) {Память данных};
% %   \node[narrowblock, above = of {Gv}Input.north west|-GvDataMemory.north] (GvProgMemory) {Память команд};
%   \node[narrowblock, above = of {Gv}Input.north west|-GvDataMemory.north, anchor=west] (GvProgMemory) {Память команд};

  \coordinate[right= 5.5ex of {Gv}Input.north] (GvInputFromData);
  \coordinate[left= 5.5ex of {Gv}Input.north] (GvInputFromProg);
  \node[narrowblock, above = of GvInputFromData, fill=clMemoryLight] (GvDataMemory) {Память данных};
  \node[narrowblock, above = of GvInputFromProg|-GvDataMemory, fill=clMemoryLight] (GvProgMemory) {Память команд};

  \DoublearrowYRight{{Gv}Uu.south}{GvProgMemory.west}
  \DoublearrowYRight{{Gv}Uu.south}{GvDataMemory.west}
  \path[blockarrow] (GvProgMemory) -- (GvInputFromProg);
  \path[blockarrow] (GvDataMemory) -- (GvInputFromData);
  \path[blockarrow] ({Gv}Output.east) -- ++(4ex,0) |- (GvDataMemory);

\end{tikzpicture}
}
\caption{Расположение программ и~данных 
в~фон-неймановской~(а) и~гарвардской~(б) архитектурах
% в~принстонской~(а) и~гарвардской~(б) архитектурах
% в~архитектуре с~общей (а) и~раздельными (б) шинами (???)
}
\label{ris:harvard-prinston}
\end{illustration}


\index{Архитектура!фон-неймановская (принстонская)}
\index{Мокли, Джон}
\index{Экерт, Джон Преспер}
\index{фон Нейман, Джон}
Идея общей памяти и~общей шины для программ и~данных 
% была высказана ещё Бэббиджем в~раннем проекте аналитическая машины и~% неавторитетный источник
впервые была реализована Конрадом Цузе в~Германии.
В~США подобная архитектура разрабатывалась %в~Принстонском университете 
в~школе Мура при Пенсильванском университете
научным коллективом, куда входили, в~частности, Джон Мокли и~Джон Преспер Экерт.
% Незадолго до окончания работ её описание было опубликовано одним из консультантов проекта, Джоном фон Нейманом, без указания соавторов~\cite{Neumann:1945:FDR:1102046}.
Незадолго до окончания работ результаты были описаны одним из участников проекта, Джоном фон Нейманом, без указания соавторов, 
а~затем и~опубликованы в~таком виде куратором со стороны армии, Германом Голдштейном~\cite{Neumann:1945:FDR:1102046}.
Так как  фон Нейман к~тому времени уже был известным математиком,
архитектуру с~общей шиной обычно называют фон-неймановской (или принстонской, по основному месту работы фон Неймана).

\index{Архитектура!гарвардская}
Общая шина для памяти программ и~данных "--- узкое место 
%архитектуры фон Неймана.
% принстонской архитектуры.
фон-неймановской архитектуры.
Ускорить обмен с~памятью можно, введя раздельные шины и,~соответственно,
физически раздельные запоминающие устройства для программ и~для данных (рис.~\ref{ris:harvard-prinston}, б).
Это дороже и~сложнее в~реализации, 
поэтому, хотя 
% проект архитектуры с~раздельными шинами разрабатывался в~Гарвардском университете США одновременно с~проектом школы Мура,
сама идея раздельных шин  использовалась  в~позднем проекте Бэббиджа,
а~практический проект подобной архитектуры разрабатывался в~Гарвардском университете США одновременно с~проектом школы Мура,
% (соответственно, архитектура с~раздельными шинами программ и~данных называется гарвардской),
использоваться на практике этот подход стал относительно недавно.
Архитектура с~раздельными шинами программ и~данных обычно называется гарвардской.

% В~персональных компьютерах используются процессоры линейки x86 с~фон-неймановской архитектурой. материнская плата и память тоже!
В~персональных компьютерах используется фон-неймановская архитектура.
В~первых процессорах линейки x86 и~соответствующих системных платах такое решение было использовано для удешевления,
в~последующих  из соображений совместимости
также используется единое пространство памяти.
При этом современные процессоры имеют раздельную кеш-память для программ и~данных.
% третья "--- для трансляции адресов
\index{Структурная декомпозиция!кеш-память}


\subsection{Память}
\epigraph{\begin{limerick}
    Жил один старичок с кочергой,\\
    Говоривший: «В душе я другой».\\
    На вопрос: «А какой?»\\
    Он лишь дрыгал ногой\\
    И лупил всех подряд кочергой.\\
\end{limerick}
}
{\Lear}

Память в~вычислительных системах образуют запоминающие устройства различной природы, имеющие разные характеристики по объёму памяти, по скорости обмена и~по времени создания контакта (рис.~\ref{ris:hierarchy}).

\begin{illustration}
\includegraphics[width=\wideImageWidth,valign=c]{4-hierarchy}

\caption{Иерархия запоминающих устройств.
Сверху вниз увеличивается объём и~уменьшается скорость обмена}
\label{ris:hierarchy}
\end{illustration}


Самыми быстрыми "--- но при этом и~самыми дорогими "--- являются регистры.
Поэтому объём регистровой памяти очень ограничен.
% и~предназначена такая память для использования в~специальных случаях.

Оперативное запоминающее устройство "--- ОЗУ "--- характеризуется оптимальным соотношением цена-быстродействие.
ОЗУ в~современных вычислительных системах имеют довольно большие объёмы памяти, но и~они не беспредельны.

Внешние запоминающие устройства "--- ВЗУ "--- характеризуются большим временем создания контакта и~низкой скоростью обмена.
Но при этом они, во-первых, могут иметь очень большие объёмы, и,~во-вторых, несколько ВЗУ могут быть поочерёдно подключены и~либо считаны, либо записаны.
На заре компьютерной эры программист вручную организовывал обмен с~нужными устройствами, учитывая их особенности и~протоколы обмена.

Сейчас программисту не надо заботиться об этом.
Операционные системы предоставляют ему необходимый объём памяти "--- в~виртуальном адресном пространстве "--- и~программист пользуется им, не заботясь о~физических протоколах обмена.
Операционная система сама организует и~поддерживает соответствие между физическими адресами реальной памяти и~адресами виртуальной памяти.

\subsubsection{Плоская модель памяти}

% Современные операционные системы предоставляют каждой исполняющейся программе (процессу)
Современные операционные системы используют так называемую \termin{плоскую модель памяти}.
\index{Модель памяти!плоская}
Каждой исполняющейся программе (процессу) предоставляется
диапазон виртуальных адресов от~$0$ до $2^N$, где $N$ "--- разрядность системы (32 или~64).
Каждому адресу соответствует один байт памяти.

При обращении к~определённому виртуальному адресу он транслируется в~физический аппаратным механизмом трансляции адресов, %процессора 
контролируемым операционной системой~\cite{amd64System}.
Виртуальный адрес может быть некорректным %, если ему не соответствует никакой
либо соответствовать байту в~оперативной памяти или специализированной области жёсткого диска (в~разделе подкачки; некоторые операционные системы также могут использовать файл подкачки).
% Физическое расположение данных %, соответствующее некоторому виртуальному адресу, может меняться операционной системой.
Операционная система может перемещать данные в~оперативной памяти или из памяти на диск и~обратно.
Виртуальные адреса и,~соответственно, указатели в~программе при этом не изменяются.

% Физические адреса в~ОЗУ занимают диапазон от
Диапазон доступных физических адресов зависит от объёма установленных ОЗУ и~возможностей системной платы.
% When the physical-address size extensions are enabled (see “Physical-Address Extensions (PAE)
% Bit” on page 121), the page-translation mechanism can be extended to support 52-bit physical
% addresses. 52-bit physical addresses allow up to 4 petabytes of physical-address space to be
% supported. (Currently, the AMD64 architecture supports 40-bit addresses in this mode, allowing
% up to 1 terabyte of physical-address space to be supported.
% Long Mode—This mode is unique to the AMD64 architecture. This mode supports up to 4
% petabytes of physical-address space using 52-bit physical addresses. Long mode requires the use of
% page-translation and the physical-address size extensions (PAE).
Разрядность физического адреса может составлять как 32, так и~40 или 52~бита~\cite{amd64System}.

Процесс %при нормальной работе операционной системы 
не может обратиться к~физическому адресу, принадлежащему другому процессу,
% (но при участии обоих взаимодействующих процессов возможно выделение )
% (но можно создать область общей памяти).
без специальных средств межпроцессного взаимодействия. % (или сбоя).

\subsubsection{Страничная организация памяти}

% Минимальным квантом памяти
Виртуальное адресное пространство плоской модели памяти делится на части определённого размера $pagesize$ "--- страницы.

Каждая страница %виртуальной памяти 
включает непрерывный последовательный диапазон виртуальных адресов $[\zeta, \zeta+pagesize)$ и~соответствует последовательному фрагменту ОЗУ или раздела подкачки на жёстком диске.
Страница может быть вытеснена из ОЗУ на диск или загружена с~диска в~ОЗУ только целиком, то есть страница "--- минимальный квант памяти при её распределении между процессами.

Страницы в~принципе могут иметь различные атрибуты защиты (разрешения чтения, записи, исполнения и~т.\,д.).

% \subsection{Разделы памяти}
\subsection{Сегменты памяти}
\index{Сегмент}
\label{sec:mem-segments}
\label{sec:stack-segment}
\epigraph{\begin{limerick}
Самобытный старик из Милета\\
Никуда не ходил без жилета. \\
"--- «Впору ль вам ваш жилет?»\\
"--- «Разумеется, нет!»\\
"--- Отвечал всем старик из Милета.\\
\end{limerick}
}
{\Lear}

В~памяти вычислительной машины фон-неймановской архитектуры хранится как код программы, так и~данные.
Данные (переменные) в~программе на языке высокого уровня, в~частности, C++,
делятся на:
\begin{itemize}
\item глобальные, время жизни которых равно времени жизни программы;
\item локальные "--- каждый вызов функции порождает новую копию переменной;
\item динамические "--- память выделяется и~освобождается с~помощью $new/delete$ или $malloc()/free()$.
\end{itemize}

% Каждому физическому адресу соответствует  байт в~оперативной памяти.
% Корректному виртуальному адресу может соответствовать как 

Различные виды переменных и~программы находятся в~разных областях  диапазона доступных виртуальных адресов 
"--- адресного пространства процесса,
исторически называемых сегментами (рис.~\ref{ris:linuxmem}).
\begin{illustration}
\includegraphics[width=\wideImageWidth,valign=c]{linuxmem}

\caption{Распределение памяти GNU/Linux}
\label{ris:linuxmem}
\end{illustration}

Нулевой адрес и~ближайшие к~нему считаются некорректными для предотвращения ошибок (разыменования переменных, которые указателями не являются).

\subsubsection{Код и~статические данные}

Код выполняемой программы находится в~\termin{сегменте кода.}
% \termin{.text} 

Глобальные переменные программы, доступные в~любой её точке 
и~статические переменные, отличающиеся от глобальных только областью видимости,
расположены в~\termin{сегменте данных.}
% \termin{.data} 
% 
Те глобальные и~статические переменные, которые не были инициализированы при объявлении,
отделяются  в~специальный \termin{сегмент BSS.}
% \termin{.bss}
% .noinit 	Данные переменных программы 

Адреса глобальных и~статических переменных в~программе "--- неотрицательные целые константы.

Размеры кода программы и~переменных, время жизни которых совпадает со временем жизни программы,
могут быть определены ещё на этапе загрузки программы в~память,
поэтому размеры соответствующих областей памяти постоянны.

\subsubsection{Куча}
\index{Куча}
Динамические переменные
% , память для которых в~C++ выделяется  операторами $new/new[]$ или функцией $malloc()$ 
% а~освобождается, соответственно, операторами $delete/delete[]$ или функцией $free()$,
расположены в~\termin{сегменте динамической памяти,} или \termin{куче} (heap).
% Куча 
% управляется операционной системой, так что операторы языка являются обёртками вокруг соответствующих системных вызовов.
% 
% http://sannystark.github.io/architectire/memroy/2016/01/08/anatomy-of-a-program-in-memory.html
% частично управляется библиотекой языка
% 
Первоначально программе выделяется определённый объём динамической памяти,
% который распределяется 
из которого средствами  языка высокого уровня ($new/new[\,]/malloc()$ для C++)  выделяются области памяти под запросы прикладной программы.
Распределённые области помечаются в~куче как занятые.
Если в~свободных областях кучи недостаточно памяти  для обработки запроса, $new/new[\,]/malloc()$ обращается к~операционной системе для расширения кучи.
Соответственно, количество корректных адресов сегмента кучи увеличивается.
% Поэтому 

Когда прикладной программе уже не нужна какая-то динамическая переменная,
соответствующую область памяти необходимо освободить.
Для этого в~C++ используются операторы $delete/delete[\,]$ или функция $free()$,
помечающие область как свободную.
При этом  освобождать область памяти необходимо способом, соответствующим выделению.
Таким образом, если память была выделена оператором $new[\,]$:
\begin{lstlisting}
int *p_array = new int[N];
\end{lstlisting}
освобождать её нужно оператором $delete[\,]$:
\begin{lstlisting}
delete[] p_array;
\end{lstlisting}
После вызова \lstinline!delete p_array!
будет помечен как свободный  только первый элемент массива.
% 
В~некоторых языках есть механизм сбора мусора, который освобождает те области памяти, к~которым программа уже не обращается, но в~C/C++ его нет.

\subsubsection{Стек}
\index{Стек}

Локальные переменные подпрограмм находятся в~\termin{сегменте стека,}
также оптимизирующие компиляторы могут помещать часть целочисленных переменных в~регистры общего назначения.

Стек назван так потому, что организован по принципу LIFO (last in, first out) "--- последним зашёл, первым вышел.
Указателем вершины стека служит специальный регистр $sp$ "--- stack pointer.
Он содержит адрес 
% Он всегда указывает на %последнюю занятую ячейку стека.
% последний записанный в~стек элемент.
начала последнего записанного в~стек элемента.
% 
Соответственно, адреса локальных переменных в~программе отсчитываются относительно вершины стека $sp$.
% или его копии в~другом регистре.
% (обычно~$bp$).


Команды семейства x86 могут записывать в~стек элементы размером от шестнадцати бит, но в~GNU/Linux стек выравнен по long,
то есть на 32~бита (рис.~\ref{ris:stack}).

\begin{illustration}
\resizebox{\wideImageWidth}{!}{
\schemafont
% \input{book/drawings/stack-func}
\input{book/drawings/stack}
}

\caption{Стек}
\label{ris:stack}
\end{illustration}

\index{Команды!push}
\index{Команды!pop}

Стек растёт вниз (в~сторону уменьшения адресов).
Таким образом, операция помещения элемента в~стек (\lstinline!push!) уменьшает указатель стека $sp$, % на размер элемента,
операция извлечения (\lstinline!pop!) "--- увеличивает.
Таким образом, с~учётом порядка байт Intel $sp$  указывает на крайний (с~наименьшим адресом) занятый байт стека.

% \begin{lstlisting}[multicols=3,style=lstsmall]
% int foo(int s)
% {
%   int y;  
%   y = s + bar();
%   return y;
% }
% int bar()
% {
%   int z;  
%   ...
%   return z;
% }
% int main()
% {
%   int x = foo();
%   ...
%   return 0;
% }
% \end{lstlisting}

% \begin{lstlisting}[multicols=2,style=lstsmall]
% int foo(int s)
% {
%   int y = bar(s) + s;
%   return y;
% }
% int bar(int w)
% {
%   return (w << 1);
% }
% int main(int argc, 
%   char *argv[])
% {
%   int x;
%   x = foo(1);
%   cout << x;
%   return 0;
% }
% \end{lstlisting}

% В~стеке помещаются
В~частности, рассмотрим рекурсивное вычисление факториала небольшого целого числа (листинг~\ref{lst:stack-fact}). 
\begin{centeredfloat}%
\begin{lstlisting}[label=lst:stack-fact,caption={Рекурсивный вызов функции}]
\end{lstlisting}%
\begin{lstlisting}[multicols=2,style=lstsmall, 
% label=lst:stack-fact,caption={Рекурсивный вызов функции}
]
int fact(int n)
{
  int f;
  if (n <= 2)
    f = n;
  else
    f = n * fact(n-1);
  return f;
}
int main(int argc, 
  char *argv[])
{
  int x;
  x = fact(3);
  cout << x;
  return 0;
}
\end{lstlisting}
\end{centeredfloat}%
Это крайне неэффективный способ  вычисления, но в~учебниках он традиционно рассматривается как наглядный пример рекурсии.
\index{Вызов функций}

После запуска программы стартовый код запускает головную функцию $main()$.
Соответственно, в~стеке находятся данные этой функции (рис.~\ref{ris:stack-func}, а): 
\begin{illustration}%
\resizebox{1\linewidth}{!}{
\schemafont
% \input{book/drawings/stack-func-abv}
\input{book/drawings/stack-fact-abv}
}

\caption{Изменение указателя стека при вызове и~возврате из функций}
\label{ris:stack-func}
\end{illustration}%
локальная переменная $x$,
адрес возврата, показывающий, какой команде будет передано управление после возврата из $main()$,
а~также аргументы $main()$ "--- количество параметров командной строки, переданных при запуске программы
и~указатель на массив этих параметров.
В~зависимости от используемого соглашения о~вызове (подробнее в~разделе~\ref{sec:asm-calling-conventions}),
\index{Подпрограммы!соглашения о~вызовах}
часть или все параметры могут находиться в~регистрах общего назначения.


После вызова функции~$fact(3)$ в~стек добавляется ещё один слой данных (рис.~\ref{ris:stack-func}, б):
параметр $n=3$, адрес возврата из~$fact(3)$ (в~данном случае это адрес команды, записывающей результат в~переменную~$x$ в~$main()$)
и~локальная переменная~$f$.
% 
После анализа~$n$ следует рекурсивный вызов~$fact(2)$,
% Данные вызывающей функции~$fact(3)$
добавляющий в~стек 
новый параметр $n=2$, 
новый адрес возврата (адрес команды умножения на~$n$ в~$fact(3)$)
и~ещё одна копия локальной переменной~$f$ (данные $fact(2)$ на рис.~\ref{ris:stack-func}, в).
Таким образом, каждому вызову функции $fact()$ соответствует свой набор параметров и~локальных переменных.

После анализа  параметра $n$ следует возврат значения~$n$ из функции~$fact(2)$.
При этом 
управление передаётся команде по адресу возврата,
% из стека удаляются все данные этой функции "--- локальные переменные, параметры и~адрес возврата 
а~сам адрес возврата вместе с~локальными переменными и~параметрами этой функции удаляется из стека
(рис.~\ref{ris:stack-func}, г).
Удаление выполняется путём изменения указателя~$sp$,
содержимое памяти при этом не перезаписывается (рис.~\ref{ris:stack-func-del}, а) и~б). %, но для наглядности данные в~пу.
\begin{illustration}%
\resizebox{\approvedImageWidth}{!}{
\schemafont
% \input{book/drawings/stack-func-abv}
\input{book/drawings/stack-fact-abv-del}
}

\caption{Удаление данных из стека "--- изменение указателя}
\label{ris:stack-func-del}
\end{illustration}%
Соответственно, в~незанятых ячейках стека содержатся «мусорные» данные,
поэтому значение неинициализированных локальных переменных непредсказуемо.


После умножения результата $fact(2)$ на~$n$ происходит возврат в~$main()$ 
(рис.~\ref{ris:stack-func}, д).

% Не все локальные переменные находятся в~стеке одновременно
% Для больших функций 

Хотя все сегменты располагаются в~одном адресном пространстве, они могут иметь разные атрибуты защиты.
В~частности, сегмент кода для предотвращения вредоносных модификаций  доступен только для чтения, но не для записи,
а~для сегментов, доступных программе на запись (данные, стек, куча) запрещено исполнение.


% Рассмотрим взаимное расположение 
Конкретное расположение сегментов в~адресном пространстве процесса
может различаться для различных операционных систем.
Состав также может различаться, но сегменты кода, данных, кучи и~стека есть всегда.





\subsection{Регистры общего назначения}
\label{sec:registers}

\epigraph{\begin{limerick}
    Старушенция из Саламанки\\
    Век жила, не вылазя из банки,\\
    Никогда не грустила,\\
    Улыбалася мило\\
    И дарила детишкам баранки.\\
\end{limerick}
}
{\Lear}

Чем более объёмно запоминающее устройство, тем, как правило, медленнее оно работает.
% 
Оперативная память обладает меньшей скоростью, чем процессор;
хотя частоты работы как оперативной памяти, так и~процессора непрерывно растут, это соотношение сохраняется.
В~настоящее время частоты процессоров измеряются в~гигагерцах, памяти "--- в~сотнях %и~тысячах 
мегагерц.
% За один такт

Соответственно, использование только данных, расположенных в памяти, сильно замедлило бы работу.
% 
Частично обмен данными ускоряется при помощи кеширования, но оно не уравнивает скорости процессора и~памяти.

% Без задержек данные можно считать или сохранить из \termin{регистров.}
% Регистры "--- часть процессора и~работает с~ним на одной частоте.


Кроме того, АЛУ процессора не может обрабатывать данные, расположенные непосредственно в~оперативной памяти, так что оператор %\lstinline!++i! 
${+}{+}i$ (или соответствующая ему команда ассемблера \lstinline$inc i$) будет выполняться в~несколько приёмов (раздел~\ref{sec:command-cycle}):
\begin{itemize}
\item загрузка значения переменной~$i$ из оперативной памяти в~специальную ячейку внутри процессора "--- регистр; % "--- операнд;
\item расчёт значения $i+1$; % в~специальном регистре;
\item выгрузка значения~$i+1$ из  регистра в~память по адресу переменной~$i$,
\end{itemize}
причём загрузка-выгрузка в~ОЗУ  занимает больше времени, чем расчёт значения.
% В~современных процессорах 
% не в память, а~в~более быстрый кеш.
Для ускорения работы часто используемые переменные
логично хранить прямо  в~процессоре,
% Для этого предназначены специальные ячейки "--- регистры общего назначения.
выделив для этого некоторое количество регистров, не используемых в~цикле обработки команд.
Они называются регистрами  общего назначения.

В~отличие от специальных регистров, недоступных программисту, их можно указать в~команде как источник или приёмник значения,
то есть использовать как сверхбыстрые ячейки памяти.
% 
На уровне машинных команд регистры общего назначения обозначаются короткими номерами, % 3 бита, стр 65 intel vol2
на уровне ассемблера "--- именами.

Специальные регистры процессора также имеют имена, но они используются только в~документации~\cite{intelModelSpecificRegisters}.
Значение специальных регистров программист может узнать или модифицировать только косвенно, с~помощью специальных команд.
% Регистры, специфичные для модели~\cite{intelModelSpecificRegisters}.
% Эти команды 
% В~частности, указатель команд~$ip$ изменяется командами условного или безусловного перехода.
В~частности, команда безусловного перехода \lstinline!jmp label!, аналог оператора C++ $goto~label$,
модифицирует специальный регистр~$ip$ (указатель команд), но не содержит его имени. % (а~её машинный код состоит из кода операции).
% Команда \lstinline!jmp!
Напротив, команда загрузки значения в~регистр общего назначения \lstinline!mov $13, %eax! содержит его имя в~явном виде,
\index{Команды!mov}%
а~соответствующий машинный код 
\hex{B8\,00\,00\,00\,0D} 
содержит номер  регистра%~$eax$. %
~$A$ ($\digitB 8_{16} = 10111000_2$, последние три бита $000$ задают регистр-приёмник; $00\,00\,00\,0\digitD$ "--- загружаемое тридцатидвухбитное значение $13_{10} = \digitD_{16}$).
% , который может быть заменён на код другого 
Если это имя или номер заменить именем или номером другого регистра общего назначения, получим корректную команду загрузки значения в~этот регистр.

Граница между специальными регистрами и~регистрами общего назначения в~наборе команд x86 достаточно размыта.
Так как регистров в~оригинальном процессоре 8086 было мало, все %они 
% унаследованные от него
адресуемые регистры 
имели ещё и~какое-либо специальное назначение.
% В~частности, регистр~$A$ %(и~только он) 
% используется командами знакового расширения, умножения и~деления.
Со временем %большинство возможностей
специализация % регистров общего назначения 
сглаживается,
но многие команды, унаследованные от оригинального набора, обращаются к~неявному аргументу в~конкретном регистре.

Процессоры семейства x86 предназначены для обработки целых чисел,
так что в~регистрах процессора %общего назначения 
могут находиться
целочисленные переменные (адреса, индексы и~собственно целые числа).

Под номер регистра в~команде (её структура более подробно рассматривается в~разделе~\ref{sec:command-x86}) отведено всего три бита~\cite{nezumi-disasm, intelInstructionSet},
так что регистров общего назначения в~тридцатидвухбитном режиме  x86 доступно только восемь (рис.~\ref{ris:registers-32}).
% На самом деле в~современных процессорах их больше

% \begin{illustration}%
% \includegraphics[width=\wideImageWidth,keepaspectratio,valign=t]{Registers}
% 
% \caption{Регистры общего назначения x86}
% \label{ris:registers}
% \end{illustration}


% \schemafont
% \tiny
\newlength{\bytewidth}
\setlength{\bytewidth}{12ex}

% % \tikzstyle{arrowline}=[-latex',scale=2]

\tikzstyle{reg}	= [text badly centered, fill=clRegisterLight, draw=black, minimum height=3.5ex, inner ysep=0ex, textsc]
% \tikzstyle{regpart}	= [reg, solidchaincell]

\tikzstyle{r1}	= [reg, minimum width=\bytewidth]
\tikzstyle{r2}	= [reg, minimum width=2\bytewidth]
\tikzstyle{r4}	= [reg, minimum width=4\bytewidth]

\tikzstyle{commentline}	= [draw=clRegisterDark]
\tikzstyle{textsc}	= [scale=0.5]
\tikzstyle{titlesc}	= [scale=0.7]

\begin{illustration}

\newcommand{\regA}[6][]
{
    
    \node[r2, on chain, #1	,	fill=clRegisterLight!75!clRegisterDark] (h2#2) {};
    \node[r1, solidchaincell, right = of h2#2] (h1#2) {$#4$};
    \node[r1, solidchaincell, right = of h1#2	,	fill=clRegisterLight!75] (l#2) {$#3$};
    
    \node[left = 1ex of h2#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]

  \node[above = 0ex of h1#2.north east, textsc] (#5) {$#5\mathstrut$};  
  \node[below = 0ex of h2#2.south east, textsc] (#6) {$#6$};  
 
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#5/0ex/18/h1#2/l#2/north, #6/1ex/15/h2#2/l#2/south}
  {
    \ifthenelse{\equal{\side}{north}}{
      \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    }{
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
    }
  };
  
  
\end{scope}
}

\newcommand{\regsi}[4][]
{
    
    \node[r2, on chain,	fill=clRegisterLight!75!clRegisterDark,	right=7ex of l#1] (h2#2) {};
    \node[r2, solidchaincell, right = of h2#2] (l#2) {$#3$};
    
    \node[left = 1ex of h2#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]

  \node[below = 0ex of h2#2.south east, textsc] (#4) {$#4$};  
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#4/1ex/15/h2#2/l#2/south}
  {
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
  };
  
  
\end{scope}
}


\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going below,
node distance=5ex]
 
  \foreach \rname/\rbase in {A/a, B/b, C/c, D/d}
  {
    \regA{\rname}{\rbase l}{\rbase h}{\rbase x}{e\rbase x}{r\rbase x}
  };
  \foreach \r/\pos in {si/A, di/B, bp/C, sp/D}
  {
    \regsi[\pos]{\r}{\r}{e\r}
  };

    
\end{tikzpicture}
}

\caption{Регистры общего назначения в~тридцатидвухбитном режиме}
\label{ris:registers-32}
\end{illustration}



% Это

В~некоторых источниках к~регистрам общего назначения относят только четыре регистра "--- $A, B, C$ и~$D$.
Каждый из них конструктивно имеет размер машинного слова (сейчас, как правило, 64 бита),
но в~тридцатидвухбитном режиме доступны только младшие 32.
Разные их части называются разными именами.
% (а~в~команде обозначение части складывается из номера регистра и~разрядности операции).
В~частности, младший байт регистра~$A$ обозначается $al$, % (low), 
следующий байт "--- $ah$, % (high), 
младшие 16 бит "--- $ax$, % (для шестнадцатибитного 8086 это означало eXtended)
младшие 32 бита "--- $eax$,
64 бита "--- $rax$.
% 
Для краткости будем использовать однобуквенное обозначение регистра, когда его разрядность %не важна или 
может быть любой или совпадает с~разрядностью системы,
в~частности,~$A$ вместо $rax/eax/ax/al$.

% В~других "--- все регистры, которые можно указать как источник/приёмник,
% тогда
Также имена и~номера существуют для %так называемых
регистров $si, di, bp$ и~указателя вершины стека~$sp$, которые иногда также причисляют к~регистрам общего назначения.
Эти имена соответствуют младшим 16 битам регистров.
Их 32-битные варианты называются соответственно $esi, edi, ebp$ и~$esp$,
64-битные "--- $rsi, rdi, rbp$ и~$rsp$.
Младшие байты этих регистров не имеют имён % (а~соответствующие номера уже заняты $ah-dh$).
в~32-разрядном режиме. 

Для краткости будем использовать оригинальное имя регистра, когда его разрядность %не важна или 
совпадает с~разрядностью системы,
например, $sp$ вместо $rsp/esp/sp$. % или~$A$ вместо $rax/eax/ax/al$.
Это не вызовет путаницы, так как шестнадцатиразрядный код сейчас практически не используется.




Хотя %указатель стека 
$sp$ можно адресовать как регистр общего назначения, использовать его иначе, чем 
как указатель вершины стека, категорически не рекомендуется.
% Кроме того, во многих случаях номер $sp$ в~команде трактуется как «регистр не задан».
Таким образом, будем считать регистрами общего назначения следующие семь "--- %регистров
$A, B, C, D, si, di$ и~$bp$.

\index{REX, префикс}
В~64-разрядном режиме 
% доступны все 64 бита регистров.
% Кроме того,
% увеличена разрядность не только самих регистров, но и~их~номеров в~команде, нет !!!
может быть использован специальный префикс $REX$ (расширения регистров),
который добавляет ещё один бит к~номерам регистров в~команде,
так что
% добавляется 
можно адресовать
ещё восемь регистров общего назначения $r8-r15$ (рис.~\ref{ris:registers-64}).
% Префикс $REX$ игнорируется даже в~шестидесятичетырёхразрядном коде, если размер операнда менее~64. врут
Их младшие части имеют имена $r8b - r15b$ (байты "--- 8 бит),
$r8w-r15w$ (16 бит),
$r8d-r15d$ (32 бита).
% $r8 - r15$
В~32-разрядном режиме они недоступны. %, соответственно, их младшие части не имеют отдельных имён.
Также префикс $REX$ позволяет адресовать младшие байты регистров $si, di, bp$ и~$sp$ "--- $sil, dil, bpl$ и~$spl$~\cite{intelBasic}.


\begin{illustration}[p]

\newcommand{\regc}[7][]
{
    \node[r4, on chain, #1	,	fill=clRegisterLight!50!clRegisterDark] (h4#2) {};
    \node[r2, solidchaincell, right = of h4#2	,	fill=clRegisterLight!75!clRegisterDark] (h2#2) {};
    \node[r1, solidchaincell, right = of h2#2] (h1#2) {$#4$};
    \node[r1, solidchaincell, right = of h1#2	,	fill=clRegisterLight!75] (l#2) {$#3$};
    
%     \node[left = 2ex of h4#2, scale=0.7]  {$#2$}; 
    \node[left = 2ex of h4#2, titlesc] (title#2)  {$#2$}; 
    
\begin{scope}[on background layer]
    
%   \foreach \lbl/\inangle/\s/\e in {#5/10/h1#2/l#2, #6/15/h2#2/l#2, #7/20/h4#2/l#2}
%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/2ex/15/h2#2/l#2, #7/4ex/18/h4#2/l#2}
%   {
% %     \path[draw=clRegisterDark] (\s.north west)  to[out=\inangle,in=180-\inangle] node[fill=white, text=black, sloped,scale=1] {$\lbl$} (\e.north east);
% %     \path[draw=clRegisterDark] (\s.north west)  .. controls ($(\s.north east) + (0,1)$)  
% % 	  ..
% % 	  node[fill=white, text=black, sloped,scale=1] {$\lbl$} (\e.north east);       
% 
%     \node[text=black, above = \h of \s.north east] (\lbl) {$\lbl$};  
% %     \path[draw=clRegisterDark] (\s.north west)  
% %     to[out=\inangle,in=180] 
% %     (\lbl)
% %     to[out=0,in=180-\inangle] 
% %     (\e.north east);
% 
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
%     
% %      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
% %      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);
%    
%   };

%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/1ex/15/h2#2/l#2, #7/2ex/18/h4#2/l#2}
%   {
%     \node[text=black, above = \h of \s.north east, textsc] (\lbl) {$\lbl$};  
%   };
  \node[above = 0ex of h1#2.north east, textsc] (#5) {$#5\mathstrut$};  
  \node[below = 0ex of h2#2.south east, textsc] (#6) {$#6$};  
  \node[above = 0.1ex of h4#2.north east|-#5.center, textsc] (#7) {$#7$};  
 
  
  \foreach \lbl/\h/\inangle/\s/\e/\side in {#5/0ex/18/h1#2/l#2/north, #6/1ex/15/h2#2/l#2/south}
  {
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    
    \ifthenelse{\equal{\side}{north}}{
      \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    }{
      \path[commentline] (\s.south west)	to[out=-\inangle,in=180]		(\lbl);
      \path[commentline]    (\lbl)	to[out=0,in=180+\inangle]	(\e.south east);
    }
    
%      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
%      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);
   
  };
  
  
  
  \foreach \lbl/\h/\inangle/\s/\e in {#7/2ex/18/h4#2/l#2}
%   \foreach \lbl/\h/\inangle/\s/\e in {#5/0ex/10/h1#2/l#2, #6/2ex/15/h2#2/l#2, #7/4ex/18/h4#2/l#2}
  {
%     \path[commentline] (\s.north west)	to[out=\inangle,in=180]		(\lbl);
%     \path[commentline]    (\lbl)	to[out=0,in=180-\inangle]	(\e.north east);
    
%      \path[commentline]	(\lbl)		.. controls (\lbl-|\e.east) ..	(\e.north east);
%      \path[commentline]	(\s.north west)	.. controls (\lbl-|\s.west) ..	(\lbl);

%      \path[commentline]	(\lbl)		-|	(\e.north east);
%      \path[commentline]	(\s.north west)	|-	(\lbl);

     \path[commentline]	(\lbl.north-|\e.north east)	--	(\e.north east);
     \path[commentline]	(\s.north west)	|-	(\lbl.north-|\s.north west);

     \path[arrowline, commentline]	(\lbl)	--	(\lbl-|\e.north east);
     \path[arrowline, commentline]	(\lbl)	--	(\lbl-|\s.north west);
     
  };  

\end{scope}

}

\resizebox{\linewidth}{!}
{
\begin{tikzpicture}[
start chain=going below,
node distance=5ex]
 
%   \foreach \rn in {0,...,9}
%   {
%     \node[r4, on chain] (h4\rn) {};
%     \node[r2, solidchaincell, right = of h4\rn] (h2\rn) {};
%     \node[r1, solidchaincell, right = of h2\rn] (h1\rn) {};
%     \node[r1, solidchaincell, right = of h1\rn] (l\rn) {};
%   };

  \foreach \rname/\rbase in {A/a, B/b, C/c, D/d}
  {
    \regc{\rname}{\rbase l}{\rbase h}{\rbase x}{e\rbase x}{r\rbase x}
  };
  \foreach \r in {si, di, bp, sp}
  {
    \regc{\r}{\r l}{}{\r}{e\r}{r\r}
  };
  \foreach \r in {8}
  {
    \regc{r\r}{r\r b}{}{r\r w}{r\r d}{r\r}
  };
  \node[below = 1.5ex of h4r8.south east, titlesc] (rdots) {$\ldots$};
  \node[titlesc] at (rdots-|titler8) {$\ldots$};
  \foreach \r in {15}
  {
    \regc[below = 3.5ex of rdots.south, anchor = north east]{r\r}{r\r b}{}{r\r w}{r\r d}{r\r}
  };
    
\end{tikzpicture}
}

\caption{Регистры общего назначения в~шестидесятичетырёхбитном режиме}
\label{ris:registers-64}
\end{illustration}

Из специальных регистров следует отметить 
регистры состояния и~управления:
уже упоминавшийся       указатель команды $ip$ (в~32- и~64-битных системах иногда называются $eip$ и~$rip$ соответственно)
и~регистр флагов $flags$ ($eflags/rflags$).
Разряды регистра флагов либо показывают те или иные характеристики последней операции процессора (флаги состояния),
либо влияют на выполнение команд (управляющие флаги).

Современные процессоры семейства x86, кроме основного набора команд, поддерживают несколько расширений.
Для них реализованы несколько групп регистров общего назначения, доступных в~командах соответствующих наборов: %, которые могут быть 
\begin{itemize}
\item восемь 80-разрядных регистров FPU x87 ($r_0- r_7$)
могут быть использованы как командами FPU как %элементы стека FPU 
{$st(0)-st(7)$, хранящие числа с~плавающей запятой}, так и~командами расширения MMX как 64-разрядные регистры {{$mm0-mm7$, }}
(%конструктивно %64-разрядные 
$mm0-mm7$ "--- мантиссы  $r_0- r_7$);
\item восемь 128-разрядных регистров расширения SSE, или XMM {({$xmm0-xmm7$})}.
Каждый из них предназначен для хранения вектора вещественных чисел одинарной точности, а~не длинного 128-битного числа.
В~64-битных системах количество XMM-регистров, как и~количество регистров общего назначения, увеличено до шестнадцати ($xmm0-xmm15$).
Расширение AVX (YMM) вдвое увеличило их разрядность "--- до 256-разрядных $ymm0-ymm15$,
недавно появившееся  AVX-512 (ZMM) "--- до 512-разрядных $ymm0-ymm31$ (в~32-битных системах доступны только первые восемь).
При этом регистры $ymm_i$ "--- младшие половины регистров $zmm_i$, а~$xmm_i$, соответственно, "--- младшие половины $ymm_i$.
Регистры ZMM есть не во всех современных процессорах.
\end{itemize}
Также расширения могут иметь свои специальные регистры, в~частности, регистры флагов.
Например, FPU имеет обширный набор специальных регистров, так как изначально команды набора FPU выполнялись отдельным устройством "--- математическим сопроцессором.


\subsection{Регистр флагов}
\label{sec:flags}
\epigraph{\begin{limerick}
    Жил один старичок в Девоншире,\\
    Он распахивал окна пошире\\
    И кричал: «Господа!\\
    Трумбаду, трумбада!» "---\\
    Ободряя народ в Девоншире.
\end{limerick}
}
{\Lear}

% Как было сказано в~разделе~\ref{sec:digits-negcodes}, 
При сложении и~вычитании чисел ограниченной разрядности может образоваться бит переноса/заёма из старшего разряда, который сохраняется процессором в~особой ячейке "--- флаге переноса~$CF$.
Процессоры семейства x86 объединяют ячейку~$CF$ и~подобные ей биты, показывающие те или иные свойства последней операции "---
флаги состояния "--- в~специальный регистр  флагов $flags$ %/eflags/rflags$ 
(таблица~\ref{tab:flags}).
% Тридцатидвухбитная версия

Флаг считается установленным, когда он равен~1, и~сброшенным, когда равен 0.

Кроме флагов состояния, регистр флагов включает один бит, не отражающий выполнение последней операции, но влияющий на выполнение некоторых команд (управляющий флаг), а~также несколько битов, недоступных прикладным программам (системные флаги)~\cite{intelSystem,club155,sasm}.
Часть битов зарезервирована и~не используется сейчас как флаги (зарезервированный бит может иметь как произвольное, так и~фиксированное значение).

Доступные прикладным программам флаги состояния в~основном сосредоточены в~младших восьми разрядах $flags$,
% (таблица~\ref{tab:flags}),
поэтому многие команды сохранения/восстановления регистра флагов оперируют только с~младшим байтом.
Старшие восемь бит содержат один флаг состояния~$OF$, управляющий флаг~$DF$ и~несколько системных.
В~тридцатидвухбитном регистре $eflags$ в~старших шестнадцати битах добавлено ещё шесть системных флагов;
старшие тридцать два бита шестидесятичетырёхбитного $rflags$ не используются.


% \footnote{Использованы: 
% Александр Семенко
% http://sasm.narod.ru/apps/eflags/main.htm,
% http://sasm.narod.ru/apps/eflags/app\_a.htm,
% http://www.club155.ru/x86internalreg-eflags
% }

% Флаги разделяются на три группы: флаги состояний, управляющие и~системные~\cite{intelSystem, club155, sasm}.


\begin{table}[!ht]

\caption{Регистр флагов $flags$}
\label{tab:flags}
% \tiny
% \scriptsize
\footnotesize
\renewcommand{\arraystretch}{1.05}
\begin{tabularx}{\linewidth}{@{}c@{~}|l@{~}|l@{~}|L@{}|l@{}}
% № 	& 	&Название 	&Описание 	&Тип флага \\\hline
% \multicolumn{5}{c}{\Reg{flags/eflags}}\\\hline
\multicolumn{5}{c}{\Reg{flags}}\\\hline
\rowcolor{clFlagStatus}0 	&CF 	&Carry Flag 	&Флаг переноса (беззнакового переполнения) 	&Состояние\\\hline
1 	&1 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}2 	&PF 	&Parity Flag 	&Флаг чётности 	&Состояние\\\hline
3 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}4 	&AF 	&Auxiliary Carry Flag 	&Вспомогательный флаг переноса 	&Состояние\\\hline
5 	&0 	&---&Зарезервирован 	&\\\hline
\rowcolor{clFlagStatus}6 	&ZF 	&Zero Flag 	&Флаг нуля 	&Состояние\\\hline
\rowcolor{clFlagStatus}7 	&SF 	&Sign Flag 	&Флаг знака 	&Состояние\\\hline
\rowcolor{clFlagSystem}8 	&TF 	&Trap Flag 	&Флаг трассировки 	&Системный\\\hline
\rowcolor{clFlagSystem}9 	&IF 	&Interrupt Enable Flag 	&Флаг разрешения прерываний 	&Системный\\\hline
\rowcolor{clFlagControl}10 	&DF 	&Direction Flag 	&Флаг направления 	&Управляющий\\\hline
\rowcolor{clFlagStatus}11 	&OF 	&Overflow Flag 	&Флаг знакового переполнения 	&Состояние\\\hline
\rowcolor{clFlagSystem}12--13 	&IOPL 	&I/O Privilege Level 	&Уровень приоритета ввода-вывода 	&Системный\\\hline
\rowcolor{clFlagSystem}14 	&NT 	&Nested Task 	&Флаг вложенности задач 	&Системный\\\hline
15 	&0 	&---&Зарезервирован 	&\\\hline
% \\\hline
\multicolumn{5}{c}{\Reg{eflags}}\\\hline
\rowcolor{clFlagSystem}16 	&RF 	&Resume Flag 	&Флаг возобновления 	&Системный\\\hline
\rowcolor{clFlagSystem}17 	&VM 	&Virtual-8086 Mode 	&Режим виртуального процессора 8086 	&Системный\\\hline
\rowcolor{clFlagSystem}18 	&AC 	&Alignment Check 	&Проверка выравнивания 	&Системный\\\hline
\rowcolor{clFlagSystem}19 	&VIF 	&Virtual Interrupt Flag 	&Виртуальный флаг разрешения прерывания 	&Системный\\\hline
\rowcolor{clFlagSystem}20 	&VIP 	&Virtual Interrupt Pending 	&Ожидающее виртуальное прерывание 	&Системный\\\hline
\rowcolor{clFlagSystem}21 	&ID 	&ID Flag 	&Проверка на доступность инструкции CPUID 	&Системный\\\hline
22--31	&	&---&Зарезервированы 	&\\\hline
\end{tabularx}

\end{table}

Регистр $flags$ не может быть явно указан как операнд команды,
но является неявным результатом большинства арифметических команд и~неявным операндом условных команд.

\subsubsection{Флаги состояния}
\index{Флаги!состояния}

Флаги состояния отображают результаты целочисленных арифметических операций (%\lstinline!add, sub, mul! 
сложения, вычитания, умножения, поразрядных логических операций
и~пр.); этими флагами являются биты 0, 2, 4, 6, 7 и~11 регистра $flags$.

\paragraph{CF	
(бит 0)} Флаг переноса (Carry Flag = CF). Устанавливается, если происходит перенос
из старшего разряда результата за пределы разрядной сетки при сложении
или заём в старший  разряд из несуществующего  (выходящего за пределы операнда, воображаемого) разряда при вычитании, таким образом, этот флаг показывает переполнение при выполнении беззнаковых арифметических операций. 

Флаг~$CF$  часто используется и~для других целей, тогда его значение не связано с~беззнаковым  переполнением.
Так, этот бит используется 
% некоторыми 
командами сдвига "--- именно в~него выдвигается <<лишний>> бит,
командами извлечения бита %(\lstinline!btX!) 
"--- для хранения извлечённого значения
и~многими другими.
% Флаг CF наиболее удобно использовать при ветвлении программы, потому что, с~одной стороны, множество команд взаимодействует с~этим флагом, с~другой стороны, простые команды условного перехода JC и~JNC обеспечивают быстрый и~компактный способ условной передачи управления.

\paragraph{PF	
(бит 2)} Флаг чётности (Parity Flag = PF). Устанавливается, если младший байт результата команды содержит чётное число единиц, иначе "--- сбрасывается.

Флаг чётности использовался для подсчёта контрольных сумм.

\paragraph{AF	
(бит 4)} Флаг коррекции (Adjust Flag = AF). 
Устанавливается, если арифметическая операция производит 
% перенос или заём в/из 3-й бит результата, иначе "--- сбрасывается. Этот флаг используется для двоично-кодированной десятичной (BCD "--- Binary-Coded Decimal) арифметики.
% Фиксирует 
перенос (заём) из младшей тетрады младшего байта, т.\,е. из бита 3 в~старшую тетраду при сложении (вычитании). Используется только для двоично-десятичной (BCD "--- Binary-Coded Decimal)  арифметики, которая оперирует исключительно младшими байтами.

\paragraph{ZF	
(бит 6)} Флаг нуля (Zero Flag = ZF). Устанавливается, если результат операции "--- нуль, иначе "--- сбрасывается.

\paragraph{SF	
(бит 7)} Флаг знака (Sign Flag = SF). Всегда равен значению старшего бита результата. Этот бит интерпретируется как знаковый в~некоторых арифметических операциях (0/1 "--- число положительное/отрицательное).

\paragraph{OF	
(бит 11)} Флаг переполнения (Overflow Flag = OF). Устанавливается, если при знаковой интерпретации результат операции не помещается в~операнд (слишком большое положительное или слишком маленькое для отрицательных знаковых чисел); иначе "--- сбрасывается. 
При сложении этот флаг устанавливается в~1, если происходит перенос в~старший бит и~нет переноса из старшего бита (то есть сумма положительных чисел даёт результат, интерпретируемый как отрицательный), или имеется перенос из старшего бита, но отсутствует перенос в~него (сумма отрицательных чисел положительна); в~противном случае, флаг $OF$ устанавливается в~0. При вычитании он устанавливается в~1, когда возникает заём из старшего бита, но заём в~старший бит отсутствует, либо имеется заём в~старший бит, но отсутствует заём из него.

Флаг переполнения сигнализирует о~потере старшего бита результата в~связи с~переполнением разрядной сетки при работе со знаковыми числами.
% , то есть, если при вычитании $OF=1$, то старший (знаковый) бит равен не знаку, а~его инверсии.

Этот флаг используется командами знаковой целочисленной арифметики.

% Из этих флагов только $CF$ можно менять непосредственно (командами stc, clc и~cmc); также этот флаг используют команды bt, bts, btr, btc, сохраняя в~него результат.
\index{Флаги!установка}
Флаги состояния используются командами целочисленной арифметики трёх типов "--- знаковой, беззнаковой и~BCD, а~также командами условного перехода (ветвления) и~условного присваивания. 
При выполнении арифметических операций устанавливаются все три набора флагов.

При переполнении индикатором является:
\begin{itemize}
\item для знаковой арифметики "--- флаг $OF$,

\item для беззнаковой арифметики "--- флаг $CF$,

\item для BCD-арифметики "--- флаг $AF$.
\end{itemize}

% \subsubsection{Проверка флагов}
% \index{Флаги!проверка}



\subsection{Структура команды и~методы адресации}
\epigraph{\begin{limerick}
    Один старичок был не в духе, \\
    Он решил прокатиться на мухе.\\
    «Далеко не летай,\\
    За горою "--- Китай», "---\\
    Старику объяснили старухи.
\end{limerick}
}
{\Lear}

Набор команд процессоров семейства x86 имеет тип CISC.
Он создавался в~условиях жёсткой экономии памяти, так что команды имеют максимально компактную (и,~соответственно, сложную для декодирования и~понимания)
структуру и~используют разнообразные %способы задания адреса операнда.
методы адресации операндов.

Необходимость программирования в~машинных кодах возникает крайне редко, но знание формата команды помогает лучше представлять себе возможности и~ограничения архитектуры.

\subsubsection{Методы адресации}
\index{Адресация!виды}
\label{sec:addressing:common}
% \epigraph{\begin{limerick}
% Одному господину в~Версале \\
% Так внезапно глаза отказали,\\
% Что он видеть не мог\\
% Даже собственных ног "---\\
% И~просил, чтоб ему показали.\\
% \end{limerick}
% }
% {\Lear}

Адрес операнда в~машинной команде 
может быть задан одним из %четырёх 
следующих способов~\cite{asmworld}.
Они называются методами адресации операндов.
% http://asmworld.ru/uchebnyj-kurs/014-rezhimy-adresacii/
\begin{enumerate}
\item \termin{Неявная} адресация.  Местоположение операнда фиксировано и~определяется кодом операции. 
\item \termin{Непосредственная} адресация. Операнд "--- константа, которая включается непосредственно в~команду.
\item \termin{Прямая абсолютная} (прямая) адресация. Операнд "--- переменная в~памяти по~фиксированному адресу (глобальная или статическая).
Этот адрес включается непосредственно в~команду.
\item \termin{Прямая относительная} адресация. Этот режим используется в командах передачи управления. 
В~команде содержится смещение, которое прибавляется к значению указателя команд $ip$. 
% То есть указывается не сам адрес перехода, а на сколько байтов вперёд или назад надо перейти. Пример:
\item \termin{Регистровая}  адресация. Операнд находится в~регистре.
\item \termin{Косвенно-регистровая} (косвенная) адресация. Операнд "--- переменная в~памяти и~её адрес находится в~регистре (регистрах).
% Иногда выделяют косвенную базовую 
Иногда выделяют следующие виды косвенной адресации:
\begin{itemize}
\item  базовая адресация "--- адрес операнда в~регистре (базовом регистре, базе);
\item  базовая адресация со смещением "--- адрес операнда вычисляется как сумма базового регистра и~константы (смещения);
\item  базовая индексная адресация "--- адрес операнда вычисляется как сумма двух регистров "--- базового регистра и~индексного;
\item  базовая индексная адресация  со смещением "--- адрес операнда вычисляется как сумма двух регистров и~константы.
\end{itemize}
\end{enumerate}
Если необходимо обработать значение, адрес которого получается более сложным образом
(в~частности, переменная в~памяти, указатель на которую также находится в~памяти), 
этот адрес надо вычислить отдельно и~поместить в~регистр.

% Смотрите также разделы~\longref{sec:addressing} 
% и~\longref{sec:arrays}.


\subsubsection{Структура команды x86}
\label{sec:command-x86}
% \epigraph{\begin{limerick}
%     Бедный дедушка в Иокогаме \\
%     С детства был обделён пирогами.\\
%     «Ах, зачем я рождён!» "---\\
%     Приговаривал он\\
%     И обиженно дрыгал ногами.\\
% \end{limerick}
% }
% {\Lear}


Команды процессоров семейства x86  имеют переменную длину.
Структура команды показана на рис.~\ref{ris:x86-cmd_structure}.

\begin{illustration}
% \includegraphics[width=1\linewidth,keepaspectratio,valign=t]{cmd_structure}
\includegraphics[width=1\linewidth,keepaspectratio,valign=t]{cmd_structure_intel}
\caption{Структура команды x86}
\label{ris:x86-cmd_structure}
\end{illustration}

Все поля, кроме кода операции, необязательны~\cite{nezumi-disasm, intelInstructionSet}.


Команда может предваряться одним или несколькими префиксами, изменяющими её поведение.
% \begin{itemize}
% \item 
% \end{itemize}
Из префиксов x86 следует отметить префикс изменения размера операнда \lstinline!0x66!
и~префикс изменения размера адреса~\lstinline!0x67!.
Для тридцатидвухбитного режима (и~его шестидесятичетырёхбитного расширения) они уменьшают разрядность операнда или адреса соответственно до 16 бит, 
для шестнадцатибитного "--- повышают до 32.
% (по умолчанию разрядность операндов и~адреса
Восьмибитные варианты команд, как правило, представлены отдельными опкодами.

Далее идёт код операции (опкод), занимающий один, два или три байта (и, может быть, ещё три бита в~байте $Mod~R/M$).
% 
Следующие два байта, $Mod~R/M$ и~$SIB$, согласно~\cite{intelInstructionSet}, задают адресацию операндов. %, если они есть.
Каждое из них состоит из трёх полей.
% 
Поле $Displacement$ содержит смещение адреса при косвенной адресации, а~$Immediate$ "--- непосредственное значение.

Адресация в~системе команд x86 частично задаётся опкодом.
Это относится не только к~неявной адресации (что логично), но и~к~непосредственной. % и~регистровой.
При этом, если опкодом задаётся использование
двух операндов,
один из которых непосредственный, а~второй 
% в~памяти,
адресуется полем $R/M$,
то в~освободившееся поле $Reg$ байта $Mod~R/M$ может быть записана часть опкода.
% Также опкод включает поле направления, показывая
% Код операции задаёт, в~частности, неявну
% Неявная и~непосредственная адресация задаются кодом операции.
% Значение непосредственного 
% Команда загрузки значения в~регистр общего назначения \lstinline!mov $13, %eax! содержит его имя в~явном виде,
% \index{Команды!mov}%
% а~соответствующий машинный код \hex{B8\,00\,00\,00\,0D} содержит номер  регистра%~$eax$. %
% ~$A$ ($B8_{16} = 10111000_2$, последние три бита $000$ задают регистр-приёмник).


% Поле $Mod$ (первые два бита следующего байта "--- $Mod~R/M$) задаёт регистровую или косвенно-регистровую адресацию.
% Если оно равно $11$, то используется регистровая адресация и~оба следующие трёхбитовых поля ($Reg$ и~$R/M$) "--- номера регистров.
% Остальные значения задают косвенную адресацию с~различной разрядностью смещения (количеством байт в~$Displacement$). %, тогда .

Поле $Reg$ байта $Mod~R/M$ содержит трёхбитовый номер операнда-регистра (таблица~\ref{tab:command:reg}).
\index{Адресация!регистровая}
Является ли он источником или приёмником, определяет специальный бит опкода "--- поле направления.
% Поле $Reg$ задаёт номер регистра "--- первого (левого) операнда.
% В~системе команд x86, если операндов два и~более, то один из них "--- обязательно регистр.
\begin{table}[!ht]
\caption{Номера (коды) регистров}
\label{tab:command:reg}

% \begin{tabular}{|l|l|}
% \hline
% Регистр	& Код \\
% \hline
% eax/ax/al/mm0/xmm0 & 000 \\
% ecx/cx/cl/mm1/xmm1 & 001 \\
% edx/dx/dl/mm2/xmm2 & 010 \\
% ebx/bx/bl/mm3/xmm3 & 011\\
% esp/sp/ah/mm4/xmm4 & 100\\
% ebp/bp/ch/mm5/xmm5 & 101\\
% esi/si/dh/mm6/xmm6 & 110\\
% edi/di/bh/mm7/xmm7 & 111\\ 
% \hline
% \end{tabular}
\bfseries
\begin{tabularx}{1\linewidth}{|ccc|cc|C|}
\hline
\multicolumn{5}{|c|}{Регистр}	& \multirow{2}{*}{Код} \\
\cline{1-5}    
% \hhline{-----~}
32 бита & 16 бит & 8 бит	& Команда MMX & Команда XMM &	\\
\hline
$eax$ & $ax$ & $al$ & $mm0$ & $xmm0$ & $000$ \\
$ecx$ & $cx$ & $cl$ & $mm1$ & $xmm1$ & $001$ \\
$edx$ & $dx$ & $dl$ & $mm2$ & $xmm2$ & $010$ \\
$ebx$ & $bx$ & $bl$ & $mm3$ & $xmm3$ & $011$ \\
$esp$ & $sp$ & $ah$ & $mm4$ & $xmm4$ & $100$ \\
$ebp$ & $bp$ & $ch$ & $mm5$ & $xmm5$ & $101$ \\
$esi$ & $si$ & $dh$ & $mm6$ & $xmm6$ & $110$ \\
$edi$ & $di$ & $bh$ & $mm7$ & $xmm7$ & $111$ \\ 
\hline
\end{tabularx}

\end{table}
В~зависимости от разрядности команды и~от того, входит ли команда в~основной набор инструкций или в~какое-либо из расширений,
один и~тот же номер адресует разные регистры.
Из таблицы~\ref{tab:command:reg} видно, что
в~тридцатидвухбитном режиме
младшие байты  регистров $sp, bp, si, di$ не могут иметь имён, потому что соответствующие номера уже заняты $ah{-}dh$.


Поле $R/M$ в~зависимости от поля~$Mod$ может как содержать номер второго  операнда-регистра,
так и~определять адрес операнда в~памяти (совместно с~последующими "--- $SIB$ и~$Displacement$).

При $Mod=11$ поле $R/M$  "--- номер второго  операнда-регистра в~соответствии с~таблицей~\ref{tab:command:reg}.
Остальные три возможных значения $Mod$ соответствуют косвенной адресации,
\index{Адресация!косвенная}
то есть операнд находится в~памяти по некоторому адресу.

% Адрес складывается из нескольких регистров ()
Значения поля $Mod$ $01$ и~$10$ показывают наличие поля $Displacement$ различной длины, содержащего смещение.
\begin{equation}
\label{eq:command:mod10}
\text{Адрес} = \zeta + Displacement
\end{equation}
где $\zeta$ "--- комбинация регистров, определяемая полем $R/M$ и~байтом~$SIB$.
% Комбинация регистров 
$\zeta$
либо включает только один базовый регистр, код которого находится в~поле $R/M$,
либо определяется байтом~$SIB$, в~этом случае поле $R/M$ принимает специальное значение $100$
(в~таблице~\ref{tab:command:reg} оно соответствует регистру~$sp$).
\begin{equation}
\label{eq:command:zeta}
\zeta = 
\left\{
\begin{array}{ll}
Base + 2^{Scale} \cdot Index, & R/M = 100, (Scale, Index, Base) \in SIB\\
Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}
Байт~$SIB$ следует за байтом $Mod~R/M$
Первые два его бита "--- масштаб "--- целое число $Scale \in [0, 3]$,  %\{0, 1, 2,  3}$, 
определяющее коэффициент,
на который умножается индексный регистр (соответственно $1, 2, 4$ или $8$),
далее следуют трёхбитные поля $Index$ и~$Base$, хранящие номера регистров.
Значение поля $Index = 100$ считается специальным, в~этом случае в~формуле~\eqref{eq:command:zeta} используется $Index=0$.

Таким образом, адрес операнда при $Mod=01$ или~$Mod=10$ может иметь вид
\begin{equation}
\label{eq:command:base+displacement}
\text{Адрес} = 
\left\{
\begin{array}{ll}
Base + Displacement, & R/M = 100, Index = 100\\
Base + 2^{Scale} \cdot Index + Displacement, & R/M = 100\\
Base + Displacement, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}
Первая строка отличается от последней тем, что $Base$ из поля $SIB$ может соответствовать регистру $sp$ (код $100$).

При $Mod=00$ %адрес складывается
используется косвенная адресация без смещения, 
кроме специального случая $Base=101$, когда, наоборот, остаётся  смещение без базы:
\begin{equation}
\label{eq:command:baseonly-displacementonly}
\text{Адрес} = 
\left\{
\begin{array}{ll}
Displacement, &R/M = 101 \\%(bp)\\
2^{Scale} \cdot Index + Displacement, & R/M = 100, Base=101 \\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base + 2^{Scale} \cdot Index, & R/M = 100, ~\text{иначе}\\% (sp), Base \in  \{A, B, C, D, sp, si, di\}, Index \in  \{A, B, C, D, bp, si, di\}\\
Base, & R/M  = Base ~(\text{иначе}) %\in \{A, B, C, D, si, di\}\\
\end{array}
\right.
\end{equation}
Соответственно, регистр $bp$ (код $101$) не может быть базовым без смещения (но может быть базовым с~нулевым смещением при $Mod \in\{01, 10\}$ и~$Displacement=0$).

Таким образом, 
всего у~команды x86 может быть не более трёх явных операндов,
среди которых 
не более одного непосредственного значения,
не более одного  значения в~памяти
и~не более двух  регистров, причём два операнда-регистра исключают операнд в~памяти.

Адрес операнда  в~памяти может включать до четырёх компонент: %задаётся 
\begin{equation}
\label{eq:command:addressing}
\text{Адрес} = {Base} + 2^{Scale} \cdot {Index} + Displacement
\end{equation}
где масштаб $Scale \in [0, 3]$ "--- константа,
${Base}$ и~${Index}$ "--- регистры.

Каждая из компонент может быть опущена;
таким образом, прямая адресация в~x86 является частным случаем косвенной.

В~качестве компонент адреса операнда можно без ограничений использовать регистры~$A, B, C, D, si, di$ необходимой разрядности
и~ограниченно "--- $bp$ (без ограничений может быть индексным, при $Mod \in\{01, 10\}$ может быть базовым)
и~$sp$ (может быть базовым, что широко используется при адресации элементов стека, но не индексным),
номера которых совпадают со специальными значениями полей.


\index{REX, префикс}
В~шестидесятичетырёхбитном режиме между историческими префиксами и~опкодом может находиться
специальный однобайтовый префикс расширения регистров $REX$.
Его 
младшие три бита (биты 0-2)
используются для увеличения разрядности номеров регистров, % (добавления старшего бита к~номеру).
следующий (третий) бит определяет, используются ли шестидесятичетырёхбитные операнды (1) или разрядность операндов %определяется опкодом,
не изменяется (0),
старшие четыре бита равны $0100$ и~служат для идентификации.

Бит 2 префикса $REX$
 добавляется к~полю $Reg$ байта $Mod~R/M$,
бит 1 "--- к~полю $Index$ байта $SIB$,
младший бит~0, в~зависимости от используемой адресации "--- к~%номеру регистра в~поле 
полю $R/M$ байта $Mod~R/M$, полю~$Base$ байта~$SIB$ или номеру регистра внутри опкода.

Таким образом, количество адресуемых регистров общего назначения возрастает до шестнадцати.
Номера регистров $A{-}di$, указанные в~таблице~\ref{tab:command:reg},
соответствуют отсутствию префикса $REX$ или нулю  в~соответствующем бите $REX$ (в~последнем случае с~учётом $REX$ получаем четырёхбитовые коды~$0100{-}0111$).
Единица в~$REX$ в~сочетании с~трёхбитовым полем в~команде даёт номера регистров $1000{-}1111$, то есть $r8{-}r15$.

Изменяя бит 3 префикса $REX$, можно получить разрядность от 8 до 64 как для $r8{-}r15$, так и~для $A{-}di$.
% В~шестидесятичетырёхбитном режиме %префикс расширения регистров $REX$ 
% есть возможность дополнить коды регистров 
% (за счёт использования специальных префиксов расширения регистров $REX$).
% % добавить ещё восемь регистров.
При использовании восьмибитной команды в~сочетании с~$REX$ с~нулевым третьим битом (то есть разрядность не изменяется и~операнды занимают 8~бит)  коды регистров $0100{-}0111$ описывают младшие байты  регистров $sp{-}di$
"--- в~документации и~коде программы они обозначаются $spl{-}dil$.
Таким образом, в~шестидесятичетырёхбитном режиме доступны как $ah{-}dh$, так и~$spl{-}dil$.
При этом в~одной и~той же команде нельзя адресовать, например, $ah$ и~$sil$% или $ah$ и~$r8$
, так как для первого требуется обязательное отсутствие у~команды префикса $REX$, а~для второго "--- наличие $REX$ с~нулевым третьим битом.
% % Прочие регистры тридцатидвухбитного режима доступны как с~

% http://support.amd.com/TechDocs/24594.pdf
% In 64-bit mode, two groups of instructions default to 64-bit operand size without the need for a $REX$ prefix:
% • Near branches
%  —CALL, Jcc, JrCX, JMP, LOOP, and RET. 
% • All instructions, except far branches, that implicitly reference the RSP
% —CALL, ENTER, LEAVE, POP, PUSH, and RET (CALL and RET are in both groups of instructions).
\index{Команды!call}
\index{Команды!ret}
\index{Команды!push}
\index{Команды!pop}
Кроме того, в~шестидесятичетырёхбитном режиме есть две группы команд, которые по умолчанию (без указания префикса $REX$) используют шестидесятичетырёхбитные операнды: 
% и~не требуют для этого :
это команды, работающие с~указателями (условные и~безусловные переходы) и~команды, неявно использующие указатель стека (по умолчанию это~$rsp$).
Команды вызова и~возврата из функций относятся к~обеим группам, так что они по умолчанию используют шестидесятичетырёхбитные адреса и~шестидесятичетырёхбитный указатель стека~$rsp$.
% То есть 
% The 64-bit default operand size can be overridden to 16 bits using the 66h operand-size override. 
% However, it is not possible to override the operand size to 32 bits because there is no 32-bit operand-size override prefix for 64-bit mode. See “Operand-Size Override Prefix” on page 7 for details. 
Разрядность  операндов этих команд может быть понижена с~64 бит до 16 указанием соответствующего префикса, но способа понизить её до 32 бит не существует~\cite{amd64Instructions}.

% General-Purpose Programming
% 3.1.2.1  Default Operand Size
% For most instructions, the default operand size in 64-bit mode is 32 bits . To access 16-bit operand sizes, an instruction must contain an operand-size prefix (66h), as described in Section 3.2.3, “Operand Sizes and Overrides,” on page 41. To access the full 64-bit operand size, most instructions must contain a $REX$ prefix. 
Для большинства команд в~шестидесятичетырёхбитном режиме размер операнда по умолчанию "--- 32 бита.
Разрядность операндов может быть понижена до 16 бит соответствующим префиксом или повышена до 64 префиксом $REX$ с~единичным третьим битом~\cite{amd64Application}.

\section{Иерархическая декомпозиция ВС}

\epigraph{
Вертикальная структура мирового древа складывалась из трёх частей, или уровней: нижнего (корни), среднего (ствол) и~верхнего (ветви)%.
...\\ 
% Так сформировались в~воображении древних основные космические зоны, а~с~ними и~сдвоенные противоположности: Земля "--- Небо, Земля "--- Преисподняя, огонь (сухое) "--- влага (мокрое), прошлое "--- настоящее, настоящее "--- будущее, день "--- ночь. Эти пары перемещались в~структуре древа с~троичными единствами: прошлое "--- настоящее "--- будущее; предки "--- современники "--- потомки; три части тела: голова "--- туловище "--- ноги; три стихии: огонь "--- вода "--- земля. Пары и~тройки обнимали самые разнообразные формы жизни. 
Люди постигали взаимосвязь противоположностей, суть всякого развития.
}{Г.\,Белякова}

% В~соответствии 

Согласно Таненбауму~\cite{tanenbaum-arch}, вычислительную систему можно представить в~виде ряда уровней абстракции.
Каждому уровню соответствует свой язык, программы на котором  путём компиляции или интерпретации переводятся на язык нижележащего уровня.

Большинство современных систем включает шесть уровней~\cite{tanenbaum-arch}:
\begin{itemize}
\item уровень языка прикладных программистов;
\item уровень ассемблера;
\item уровень операционной системы;
\item уровень архитектуры команд;
\item микроархитектурный уровень;
\item цифровой логический уровень.
\end{itemize}
Над этой иерархией языков находится прикладной программист и~воплощаемый им алгоритм;
под цифровым логическим уровнем "--- физическая элементная база.

Современная шестиуровневая структура сформировалась далеко не сразу и~не является пределом развития.
Примитивные счётные устройства (абак, суанпан, русские счёты) %не содержат ни одного уровня абстракции.
рассчитаны на взаимодействие человека напрямую с~элементной базой.
Развитие вычислительной техники и~программной инженерии ведёт к~постепенному наращиванию уровней абстракции.
% Уже сейчас 

Иногда между уровнем языка прикладных программистов и~уровнем операционной системы находится
уровень байт-кода или p-кода, интерпретируемого виртуальной машиной.
Он не эквивалентен уровню ассемблера, так как не отражает специфику аппаратной части вычислительной системы.


\subsection{Цифровой логический уровень}

\epigraph{
 К~каждой из трёх частей древа относились определенные существа. Вверху, на ветвях изображали птиц, посередине, у~ствола "--- копытных (оленей, лосей, коров, лошадей), иногда человека и~пчёл, а~у~корней "--- змей, лягушек, рыб и~бобров. 
%  Бог восседал на самой верхушке древа. Иногда он вступал в~битву со змеем или драконом и~освобождал похищенный ими скот. Древо, символизировавшее зачатие и~плодородие, изображали на женских одеждах.
 }{Г.\,Белякова}
% сигналы и~вентили, 0 и~1, триггер как элементарная ячейка памяти, полусумматор, однобитовый сумматор


На цифровом логическом уровне существуют цифровые \termin{сигналы},
которые могут принимать ограниченный набор значений.
Для современных ЭВМ эти значения "--- $0$ и~$1$.

Соответственно количеству состояний сигнала определяется базовая единица измерения информации.
Так как современные ЭВМ двоичны, 
единицей информации считается {бит} "--- один двоичный разряд, который может находиться в~двух состояниях "--- $0$ и~$1$.
\index{Бит}
Для троичных ЭВМ информация измеряется в~тритах.

Сигналы обрабатываются базовыми элементами схем "--- \termin{логическими вентилями,}
преобразующими множество входных сигналов в~выходной
в~соответствии с~какой-либо из логических операций (рис.~\ref{ris:logic-gates}).

\begin{illustration}

\includegraphics[width=\approvedImageWidth,valign=t]{rn-22}

\caption{Различные виды логических вентилей}
\label{ris:logic-gates}
\end{illustration}

Существует множество стандартов изображения логических вентилей  (рис.~\ref{ris:logic-gates-legend}).
\begin{illustration}

\includegraphics[width=\wideImageWidth,valign=t]{Logic-gate-index}

\caption{Различные обозначения логических вентилей}
\label{ris:logic-gates-legend}
\end{illustration}

Из-за особенностей элементной базы основными  для построения схем являются вентили «и-не» и~«или-не» (NOR и NAND),
реализующие соответственно операции $\lnot(x \lor y)$ и~$\lnot(x \land y)$ для входных сигналов $x$ и~$y$.

Из вентилей конструируются более сложные элементы, в~частности, двоичный полусумматор, рассчитывающий сумму двух входов,
формируя два выходных сигнала:
сумму входов по модулю $2$ и~разряд переноса,
или полный одноразрядный сумматор, рассчитывающий сумму трёх входов (на один из них при построении многоразрядного сумматора подаётся перенос из предыдущего разряда).
% и~также формирующий два выхода

% Также к~цифровому логическому уровню относятся элементарные ячейки памяти, %"--- быстрые (триггеры) и~
% хранящие каким-либо образом один бит информации.


Цифровой логический уровень "--- хронологически первый уровень абстракции.
Впервые он появился ещё в~%суммирующей машине Паскаля.
непрограммируемых счётных машинах,
в~том числе вавилонских и~греческих астрономических калькуляторах,
но при этом отсутствует в~простых устройствах наподобие счётов, где перенос между разрядами осуществляется вручную.

% В~современной европейской истории цифровой логический уровень %впервые 
% присутствует в~проекте тринадцатиразрядной машины Леонардо да Винчи, 
% впервые реализован в~1623~г. в~счётной машине Вильгельма Шиккарда, позже %независимо 
% "--- в~суммирующей машине Паскаля.

\subsection{Микроархитектурный уровень}

\epigraph{\begin{limerick}
Говорят, в~самом сердце Тибета\\
в~страшной тайне содержится
Это.\\
Но есть мнение, что\\
Это "--- вовсе не То;\\
ничего даже общего где-то.\\
\end{limerick}
}
{С.\,Сатин}



Микроархитектура %микро
процессора "--- это 
аппаратная организация и~логическая структура микропроцессора:
\begin{itemize}
\item регистры "--- сверхбыстрые ячейки памяти внутри процессора;
\item набор микрокоманд;
\item управляющие схемы; % (УУ), 
\item арифметико-логические устройства (АЛУ); 
\item запоминающие устройства; 
\item %и~
связывающие их информационные магистрали \rlap{(шины).}
\end{itemize}

В~частности, к~микроархитектуре относятся 
все решения, касающиеся цикла выполнения команды:
% конвейер обработки команд.
% и~тракт данных, 
декодирование команды вышележащего уровня в~последовательность
микрокоманд,
конвейер, кеширование команд и~данных, прогнозирование переходов и~т.\,п.

Микроархитектурный уровень впервые начал отделяться от уровня архитектуры команд 
в~ЭВМ EDSAC-2 в~1957~г.,
когда впервые было применено микропрограммирование для реализации команды как последовательности микрокоманд.

В~настоящее время микроархитектура процессора качественно отличается от архитектуры уровня команд.
Так, на уровне микроархитектуры все современные процессоры семейства x86 (то есть процессоры с~CISC-набором команд)
организованы по принципу RISC.
Именно, они имеют набор  микрокоманд простой структуры и~множество регистров, которые поочерёдно играют роль восьми регистров общего назначения за счёт механизма переименования.
Это позволяет ускорить выполнение программ, сохраняя при этом совместимость на уровне архитектуры команд.


% % 
% % \termin{Тракт данных:}
% % \begin{itemize}
% % \item локальная память
% % % \rlap
% % {(набор регистров);}
% % 
% % \item АЛУ.
% % % арифметико-логическое устройство (АЛУ).
% % \end{itemize}


\subsection{Уровень архитектуры команд}
\epigraph{
\begin{stanza}
Ведь очень скоро у~меня будет Это \\
и~я~буду ясно знать, что с~Этим делать.\\
\end{stanza}
}{\Aquarium}

% память, адресация, указатель, команды


Уровень архитектуры команд включает
\begin{itemize}
\item    архитектуру памяти;
\item    взаимодействие с~внешними устройствами ввода/вывода;
\item    режимы адресации;
\item    регистры;
\item    набор машинных команд;

\item    различные типы внутренних данных (целочисленные, с~плавающей запятой и~т.\,д.);
\item   обработчики прерываний и~исключений.
\end{itemize}
Эти пункты во многом %практически полностью 
повторяют компоненты микроархитектуры.
Различие состоит в~том, что уровень архитектуры команд доступен программисту %и~его компоненты, как 
и,~как всякий интерфейс, должен соответствовать документации и~относительно редко меняется.
% стандартизирован
Микроархитектура скрыта от программиста и~может различаться даже у~разных партий процессоров %с~одним и~тем же названием
одной и~той же модели.


В~соответствии со структурой памяти, разрядностью шины и~регистров определяются платформозависимые единицы измерения "--- байт и~машинное слово.

Программа уровня архитектуры команд "--- последовательность двоичных машинных кодов.
Программы ранних поколений записывались непосредственно в~двоичном коде в~виде отверстий на перфокартах и~перфолентах (отверстие соответствовало единице, нетронутая позиция "--- нулю).
Позже для хранения программ стали использоваться различные виды долговременной памяти (обычно магнитные ленты и~диски),
а~запись "--- сокращать с~помощью восьмеричного и~шестнадцатеричного представления двоичных чисел.

Каждому процессору соответствует один набор машинных кодов.

В~частности, для процессоров семейства x86
опкод пересылки непосредственного тридцатидвухбитного значения в~тридцатидвухбитныйм регистр общего назначения  имеет вид \hex{B8},
после этого кода записывается трёхбитный код регистра,
после чего идёт само значение.
Соответственно, запись значения \hex{CC\,CC\,CC\,CC} в~регистр с~кодом~$1$ 
выполняется командой \hex{B9\,CC\,CC\,CC\,CC}.

Уровень архитектуры команд,
отличающий программируемую вычислительную машину (компьютер) от калькулятора или арифмометра,
появился в~проекте аналитической машины Бэббиджа,
а~впервые реализован был в~%программируемой вычислительной машине 
% электромеханическом компьютере Z3 Конрадом Цузе в~1941~г.
механическом компьютере Z1 Конрадом Цузе в~1938~г.
При этом сама идея цифровых программ появилась задолго до её применения для вычислительных машин.
Двоичные программы, записанные на перфолентах, использовались в~механический орг\'{а}нах "--- шарманках в~\RN{XV{-}XIX}~вв.,
на перфокартах "--- в~автоматизированном ткацком станке Жозефа Жаккара (1802~г.).


Программирование в~машинных кодах использовалось в~течение долгого времени %уже после 
параллельно с~ассемблером и~языками высокого уровня.
Даже в~настоящее время бывает необходимо использовать вставки на машинном языке.

\subsection{Уровень операционной системы}



\epigraph{
\begin{stanza}
Особенности оперы в Нижнем Тагиле\\
совсем не повлияли на мое воспитанье,\\
Меня несло, как воздушного змея,\\
Когда всем остальным отключали питание.\\
\end{stanza}
}{\Aquarium}

% управление памятью, загрузка и~выполнение программ, системные вызовы, доступ к~устройствам
% Виртуальная память
% 
% Страничная организация памяти
% 
% % Реализация виртуальных команд ввода-вывода
% Файловая система
% 
% % Виртуальные команды для параллельной работы 
% Процессы

На уровне операционной системы осуществляется:
\begin{itemize}
\item    управление памятью (распределение между процессами, организация виртуальной памяти);
\item    загрузка программ в~оперативную память и~их~выполнение;
\item    исполнение запросов программ (системные вызовы);
\item    стандартизованный доступ к~периферийным устройствам (устройства ввода-вывода);
\item    управление доступом к данным на энергонезависимых носителях (таких как жёсткий диск, оптические диски и др.), организованным в той или иной файловой системе;
\item    обеспечение пользовательского интерфейса;
\item    сохранение информации об ошибках системы.
\end{itemize}
Данный уровень является гибридным "--- большая часть команд его языка совпадает с~командами нижележащего уровня (машинного языка)
и~только некоторые интерпретируются непосредственно операционной системой.

При этом операционная система работает с~этим языком и~как компилятор (преобразуя исполняемый файл в~готовую к~выполнению программу в~оперативной памяти, что для современных форматов исполняемых файлов не сводится к~простому копированию),
и~как интерпретатор (исполняя так называемые системные вызовы).

% % Благодаря управлению памяти на уровне ОС каждый процесс имеет своё адресное пространство
% С~точки зрения прикладного программиста, операционная система "--- это то, что загружает в~память исполняемый файл, 
% передаёт управление его точке входа,
% и~в~дальнейшем интерпретирует
% % обращения 
% % так называемые 
% системные вызовы.

Именно различие в~системных вызовах и~формате исполняемых файлов
не позволяет выполнять в~Microsoft Windows программы, собранные для того же процессора под GNU/Linux и~наоборот.

В~частности, системные вызовы используются для получения параметров командной строки
% Это 
(открытие документа двойным щелчком в~Microsoft Windows %или любой графической оболочке 
"--- тоже вызов программы с~параметром!)
и~для завершения работы.
Непосредственное обращение к~системным вызовам обычно скрыты от прикладного программиста библиотечными функциями-обёртками.

% Уровень операционной системы "--- самый молодой из рассматриваемых уровней абстракции: << а нет!
Первой операционной системой 
% http://1500py470.livejournal.com/106496.html?nojs=1
%  Путь к щелкающим монстрам 
можно считать аппаратный супервизор 
релейного многоядерного компьютера Bell Model V (1946~г.),
обеспечивавший
загрузку следующей программы из очереди на освободившееся ядро без участия оператора и~переключение между перфолентами по команде условного перехода. %~\cite{}.
% 
% Первой операционной системой считается
Позже появилась пакетная операционная система
GM-NAA I/O (General Motors \& North American Aviation Input/Output system)  для IBM 704 (1956~г.)%,
% "--- пакетная операционная система,
% обеспечивавшая %последовательное выполнение программ.
% загрузку следующей программы из очереди% без участия оператора
~\cite{osdata.com/kind/history}.

% фирмой IBM совместно с ассоциацией Shape были созданы операционные системы SOS (Shape Operationg System) и FMS (Forta Monitor System). Эти системы явились уже непосредственными предшественниками системы ОС, появившейся в 1964~г. 
% http://bip-ip.com/sistemnoe-programmnoe-obespechenie-o-2/

В~конце 1950-х~гг. были разработаны первые широко используемые операционные системы FMS (Fortran Monitor System)~\cite{tanenbaum-arch,osdata.com/kind/history}
и~SOS (Share 709 System)~\cite{ibmSos, osdata.com/kind/history}
для IBM 709,
которые включали компиляторы (Фортран для FMS и~ассемблер для SOS) и~%особым образом 
обрабатывали системные вызовы, представленные перфокартами со специальным содержимым.

\subsection{Уровень ассемблера}
\epigraph{
\begin{stanza}
Я~прочёл об этом в~старинных трактатах, \\
прочёл и~сразу ушел из деревни;\\
Скоро я~буду баснословно богатым \\
и~смогу претворить в~жизнь учения древних.\\
\end{stanza}
}{\Aquarium}

% мнемоники, ассемблирование, ассемблеры

Программировать в~машинных кодах не слишком удобно, даже если записывать их в~компактном восьмеричном или шестнадцатеричном виде.
Намного удобнее создавать программы, используя понятное человеку символическое представление машинных команд "--- мнемоники,
а~также символические имена регистров и~адресов в~памяти (переменных, меток).

Перевод программы из подобного символического представления в~машинные команды 
реализуется путем трансляции (сборки, ассемблирования), а~не интерпретации.
Программа-транслятор для такого перевода соответственно называется ассемблером, а~язык программирования "--- языком ассемблера.
Язык ассемблера часто сокращённо называют просто ассемблером, как и~транслятор.
% Если программа в~машинных кодах представляет собой набор чисел, то язык ассе

Так как набор мнемоник "--- символическое представление набора команд процессора,
процессорам с~различным набором команд соответствуют разные языки ассемблера.

Синтаксис языка асемблера также зависит от используемого транслятора,
% Разные компиляторы также поддерживают разный синтаксис.
так что для одного и~того же процессора могут быть разработаны несколько ассемблеров.

В~частности, команда записи значения \hex{CC\,CC\,CC\,CC} в~регистр с~кодом~$1$ для x86 (этому коду для тридцатидвухбитного регистра в~тексте программы соответствует имя $ecx$),
то есть команда \hex{B9\,CC\,CC\,CC\,CC},
будет иметь вид
\lstinline!movl $0xCCCCCCCC, %ecx!.
% или \lstinline!mov ecx, 0xCCCCCCCC!. неопределённость
\index{Команды!mov}%



Считается, что первый ассемблер появился в~1949~г.
По разным источникам, он был разработан 
\index{Уилер, Дэвид Джон}
Дэвидом Джоном Уилером для  ЭВМ EDSAC~\cite{wheeler_david}
или
Джоном Мокли и~Джоном Преспером Экертом для ЭВМ BINAC~\cite{irgups-smolasm}.
% Первым ассемблером считается разработанный в 1949~г. Мокли и~Экертом псевдокод Short Code ЭВМ BINAC~\cite{}. 
\index{Мокли, Джон}
\index{Экерт, Джон Преспер}
% http://www.cyberforum.ru/assembler/thread1005284-page2.html

Иногда ассемблер называют самым старым языком программирования после машинного кода, 
но первый язык высокого уровня появился ещё раньше.
Тем не менее, ассемблер заслуженно считается вторым поколением языков программирования.



\subsection{Языки высокого уровня}
\epigraph{
\begin{stanza}
Я~буду жить в~доме из костей земли \\
и~с~большой дороги будут заходить дети\\
Чтобы любоваться на мои кристаллы, \\
сияющие во фрактальном свете.\\
\end{stanza}
}{\Aquarium}

% языки, компиляторы, GCC

Третьим поколением считаются языки высокого уровня (ЯВУ),
позволяющие программисту описывать алгоритм, а~не его реализацию на данной конкретной машине.
% где описывается принцип «как нужно сделать», 
% http://cyberfac.ru/publ/informatika/informatika_i_programmirovanie/jazyki_programmirovanija_vysokogo_urovnja/30-1-0-971

Для языка высокого уровня возможна как компиляция до уровней ассемблера или операционной системы (или, иногда, до другого ЯВУ), так и~пошаговая интерпретация.
При этом программы на некоторых языках традиционно только компилируются (в~частности, Паскаль/Delphi, C/C++), на некоторых "--- только интерпретируются (в~частности, sh/bash), для большинства есть и~компиляторы, и~интерпретаторы (Python, PHP и~т.\,д.).
В~некоторых современных языках высокого уровня (в~частности, C\#, Java)
вводится дополнительный уровень абстракции "--- 
программа на ЯВУ компилируется до байт-кода,
который затем интерпретируется. % специальной виртуальной машиной.

Идея символического языка для прикладного программирования,
который не был бы связан с~архитектурой конкретной вычислительной машины,
почти так же стара, как и~само программирование.

Первый язык высокого уровня "--- Планкалкюль "--- 
был разработан Конрадом Цузе в~1943-45~гг.,
\index{Цузе, Конрад}
но для него в~то время не был разработан компилятор.

Первый компилятор, 
переводивший программу в~алгебраической форме на~машинный язык,
{A-0}, был разработан в~1952~г. Грейс Хоппер.
\index{Хоппер, Грейс}
% Несмотря на название, язык не был предшественником B и~C/C++.
% На основе этих наработок в~1959~г. под руководством Грейс Хоппер был создан язык Кобол, максимально приближённый к~английскому языку.

Первый отечественный компилятор с~языка высокого уровня ПП-1 (программирующая программа) был разработан в~1954~г.
В~некоторых источниках считается первым компилятором с~языка высокого уровня~\cite{fedotov_yavu}.
% В~отличие от Кобола,
Язык ПП-1 (и~его  позднейшие потомки) был основан на математической нотации~\cite{ershov_180}.
% и~считается языком более высокого уровня, чем использовавшиеся ранее


% Первое руководство для Fortran появилось в октябре 1956 вместе с первым компилятором, поставленным в апреле 1957.
% http://comsatelit1.at.ua/index/0-76
Первым языком высокого уровня, дожившим до настоящего времени под оригинальным именем (но~при этом породивший Бейсик), является Фортран.
Он был создан в~1954-1957~гг. группой программистов под руководством Джона Бэкуса в~IBM. %~\cite.
% Первый компилятор Фортрана был выпущен в~1957~г.
% 
Также в~1957~г. был создан первый язык функционального программирования APL.
%  http://www.garshin.ru/it/computer-languages/3gl.html

Как конкурент языку от IBM, в~1958~г. группой под
руководством Питера Наура %(Peter Naur) 
был разработан язык Алгол
"--- родоначальник большинства современных языков общего назначения, в~частности, семейства, включающего линейки Паскаль/Delphi/C\# и~B/C/C++.
% 
В~это же время появился язык обработки списков Lisp,  существующий до сих пор под этим именем.


В~1959~г. под руководством Грейс Хоппер был создан язык Кобол, максимально приближённый к~английскому языку.

% \termin{Прикладное программирование}
% \bigskip

% \begin{tabularx}{1\linewidth}{@{}Lp{0.4\linewidth}@{}}
% Трансляция
% \begin{itemize}
% \item Фортран;
% % \item Алгол;
% \item C/Objective-C/C++;
% \item Pascal/Object Pascal/Delphi.
% \end{itemize}
% &
% Интерпретация
% \begin{itemize}
% \item sh/bash;
% \item Python;
% \item PHP.
% \end{itemize}
% \end{tabularx}
% Уровень виртуальной машины  Java.
% % \begin{itemize}
% % \item Java.
% % \end{itemize}
% 
% \termin{Сверхвысокоуровневые языки программирования}
% \begin{itemize}
% \item  Python;
% \item Ruby;
% \item AWK/Perl.
% \end{itemize}


В~настоящее время иногда выделяются также сверхвысокоуровневые языки программирования, позволяющие
описывать даже не алгоритм решения задачи, а~саму задачу, в~частности,
 Python,  Ruby, AWK/Perl.

% http://cyberfac.ru/publ/informatika/informatika_i_programmirovanie/jazyki_programmirovanija_vysokogo_urovnja/30-1-0-971
% Сверхвысокоуровневый язык программирования (язык программирования сверхвысокого уровня, VHLL — very high-level programming language) — язык программирования с очень высоким уровнем абстракции. В отличие от языков программирования высокого уровня, где описывается принцип «как нужно сделать», в сверхвысокоуровневых языках программирования описывается лишь принцип «что нужно сделать». Термин впервые появился в середине 1990-х годов для идентификации группы языков, используемых для быстрого прототипирования, написания одноразовых скриптов и подобных задач.


% Shots through the Terminator's vision shows a dump of the ROM assembler code for the Apple II operating system. If you own an Apple II, enter at the basic prompt: ] call -151 * p This will give you the terminator view. Other code visible is written in COBOL. 

% http://textarchive.ru/c-1249733.html
%  3-е
% Языки высокого уровня ЯВУ (Fortran, Basic, Pascal, PL/1, C)
% Мобильные, более человеко-ориетированные, проще в освоении, более медленные
% 
% 4-е
% Непроцедурные, генераторы отчетов, объектно-ориентированные, языки запросов, параллельные
% Ориентированы на непрофессионального пользователя; ориентированы на ЭВМ с параллельной архитектурой
% 
% 5 -
% Языки искусственного интеллекта ИИ, экспертных систем и баз знаний, естественные языки
% Повышение интеллектуального уровня ЭВМ и интерфейса с ними

\section{История} 
\epigraph{\begin{stanza}[0mm]Действительность "--- не бред собачий.\\
Она сложнее и~богаче.\end{stanza}}
{Валентин Берестов}

% Современные ВС: 6 уровней; как отрастали эти шесть уровней, начиная от одноуровневых счётов и~одно?двух?уровневого жаккардова станка
Термин «компьютер» (вычислитель) в~разное время обозначал различные вещи "--- и~клерка-вычислителя,
проводившего расчёты вручную или с~использованием простых (счёты и~подобные им устройства "--- абак, суанпан) 
или сложных (арифмометр, механический калькулятор)
вспомогательных устройств;
и~сами эти устройства.
При этом в~настоящее время даже инженерные калькуляторы представляют собой миникомпьютеры, превосходящие многие ранние ЭВМ.

Договоримся называть компьютером, или вычислительной машиной устройство, которое может 
исполнять заданную изменяемую последовательность вычислительных операций "--- программу.
Таким образом, компьютер содержит как минимум два уровня абстракции "--- цифровой логический и~архитектуры команд. 


Непрограммируемые вычислительные устройства назовём калькуляторами  или арифмометрами.
Калькулятор содержит  цифровой логический уровень, но не включает уровня архитектуры команд.
% так что 
% Таким образом, простые вычислительные

% Табуля?тор — электромеханическая машина, предназначенная для автоматической обработки (суммирования и категоризации) числовой и буквенной информации, записанной на перфокартах, с выдачей результатов на бумажную ленту или специальные бланки[1].
Можно выделить такой вид калькуляторов, как табуляторы,
выполняющие единообразную обработку больших массивов данных, представленных на перфокартах.


\subsection{Развитие вычислительной техники}
\epigraph{Для появления джентльмена, по убеждению англичан, нужны три благородных поколения; очевидно, это справедливо и~для вычислительных машин...}
{Э.\,Дийкстра}

Вычислительные машины, как правило, разделяют на четыре поколения в~соответствии с~используемой элементной базой.
\begin{enumerate}
\item Электронные лампы.
\item Транзисторы.
\item Интегральные схемы малой и~средней плотности. % (на одном кристалле был расположен целый блок ЭВМ "---  регистр, дешифратор, счётчик и~т.\,д.).
% Появляется понятие процессора, объединяющего в~себе АЛУ (возможно, несколько специализированных АЛУ) УУ. %? иногда пишут, что термин ещё с ламп
\item Интегральные схемы большой и~сверхбольшой плотности. % (процессор на одном кристалле).
\end{enumerate}
Это деление достаточно условно.
Вычислительные машины разных поколений достаточно долгое время существовали параллельно.
% Многие компьютеры переходных периодов построены на основе нескольких различных наборов элементов.
Часто различные компоненты одного и~того же компьютера строились на различных элементных базах.
% 
Кроме того, такое деление  не отражает развития архитектуры.
% Часто встречается таблица с
% 
% Как правило, первые машины на новой элементной базе обладали упрощённой архитектурой.

В~некоторых источниках вводится понятие пятого поколения,
но нет единого его определения.
% 
Часть источников выделяет пятое поколение не по элементной базе, а~по решаемым задачам.
Одноимённый японский проект называет ЭВМ пятого поколения искусственный интеллект, направленный на обработку знаний.
% http://compact-programming.narod.ru/CP0032.htm
Также пятым поколением называют компактные персональные ЭВМ.
% http://fb.ru/article/190570/pokolenie-kompyuterov-kompyuter-buduschego-opisanie
% http://fb.ru/article/159886/pokoleniya-evm-tablitsa-harakteristiki-i-istoriya-chto-ponimayut-pod-terminom-pokolenie-evm
Таненбаум считает пятым поколением встраиваемые системы (микроконтроллеры, системы на одном кристалле)~\cite{tanenbaum-arch},
что естественным образом продолжает устоявшееся деление.
% Также пятым поколением иногда считают кластеры, объединяющие много процессоров?

% В~любом случае, как бы ни определялось пятое поколение, 
Любое из приведённых определений пятого поколения ЭВМ подразумевает, что
в~настоящее время оно успешно сосуществует с~четвёртым.
Также многие источники относят все %производимые сейчас 
современные компьютеры к~четвёртому поколению.

Часто также выделяют нулевое поколение "--- электромеханические вычислительные машины.
% 
По аналогии с~этим чисто механические  вычислительные машины %(построенные на зубчатых колёсах) 
можно назвать минус первым поколением.

% Развитие большинства поколений
Большинство поколений делится на три периода:
вначале выпускается прототип, основанный на новой элементной базе (или несколько независимо разработанных прототипов).
Такие проекты часто остаются неизвестными из-за секретности или стечения обстоятельств.
Через какое-то время множество стран и/или корпораций одновременно выпускают более совершенные компьютеры (одиночные или серийные).
% затем новая элементная база попадает в~серийные устройства.
% затем старые компьютеры .
Соответственно, для каждого поколения указывается три даты:
выпуск первого устройства, начало массового использования и~выход из употребления.
% (при этом как первая).

\subsubsection{Минус первое поколение (античность--\RN{XVIII}~в.--конец~\RN{XX}~в.) "--- зубчатые колёса и~рейки}

К~этому поколению можно отнести всего два полноценных компьютера "--- проект Бэббиджа конца \RN{\ToRomanEmpire{19}}~в., 
реализованный только в~1985-1991 гг.,
и~Z1 Конрада Цузе (1938~г.).

При этом, если заменить в определении компьютера «последовательность вычислительных операций» 
на просто «последовательность операций», как это сделано, в~частности, в~Википедии,
к~минус первому поколению компьютеров также можно отнести 
цифровые мультимедийные механические устройства, серийно выпускавшиеся в~\RN{XV{-}XIX}~вв.  (шарманки и~музыкальные шкатулки),
а~также механические станки с~ЧПУ "--- первый известный такой станок был разработан в~1802~г. Жозефом Жаккаром.

Цифровые механические калькуляторы существенно более разнообразны.
Сохранились упоминания об античных и~вавилонских вычислительных устройствах, предназначенных для моделирования астрономических событий.
Были найдены остатки подобного устройства "--- механизма из Антикитеры, собранного, по разным оценкам, в~140-80 гг. до н.\,э.
% http://samlib.ru/h/hitech_a/kompyutery_drevnosti.shtml
% http://masterok.livejournal.com/1074028.html

В~современной европейской истории цифровой логический уровень %впервые 
присутствует в~проекте тринадцатиразрядной машины Леонардо да Винчи, 
впервые реализован в~1623~г. в~счётной машине Вильгельма Шиккарда, позже %независимо 
"--- в~суммирующей машине Паскаля (1642~г.).

% арифмометры Паскаля (1642), Лейбница (1672), Тома де Кольмара (1820), Однера (1890) и другие.
% http://samlib.ru/h/hitech_a/kompyutery_drevnosti.shtml

Позже были разработаны  механические калькуляторы, 
выполняющие как сложение и~вычитание, так и~умножение и~даже деление в~десятичной системе
"--- арифмометры
Лейбница (1672~г.), Тома де Кольмара (1820~г.), Однера (1890~г.) и другие.
% Именно арифмометры
В~СССР наиболее популярен был «Феликс» (усовершенствованный арифмометр Однера), производившийся до 1978~г.
Компактные, надёжные и~энергонезависимые
арифмометры повсеместно использовались до 1970-х гг. (а~счёты "--- ещё дольше).

% http://www.computer-museum.ru/precomp/fauler.htm
% https://geektimes.ru/post/160595/  Недвоичная логика 
Около 1840~г. Т. Фаулером был разработан механический  калькулятор,
работавший в~сбалансированной троичной системе.

% Дальнейшим развитием стали калькуляторы, вычисляющие значение многочлена
% "--- две модели разностной
Дальнейшим развитием стал калькулятор, вычисляющий значение многочлена в~десятичной системе
"--- малая разностная машина, успешно построенная Чарльзом Бэббиджем в~1822~г.
% http://kryaker.dwg.ru/?p=1944
На её основе Георг Шутц и~Мартин Виберг создали другие разностные калькуляторы.

% Самый знаменитый проект Чарльза Бэббиджа "---
% механическая десятичная аналитическая машина,
% включавшая 
Наиболее известная сейчас работа Чарльза Бэббиджа "---
постоянно дорабатывавшийся им проект механической десятичной аналитической машины (рис.~\ref{ris:babbage-lovelace-color}),
% http://kryaker.dwg.ru/?p=1944
% арифметическое устройство («мельницу»),
% устройство управления,
% регистры памяти («склад»)
% и~устройство ввода/вывода, обрабатывавшее перфокарты трёх типов:
% \begin{itemize}
% \item    перфокарты операций переключали машину между режимами сложения, вычитания, деления и умножения (команды);
% \item перфокарты переменных управляли передачей данных из памяти в арифметическое устройство и обратно (адрес);
% \item числовые перфокарты использовались для ввода данных и~сохранения результатов вычислений (данные).
% \end{itemize}
% https://habrahabr.ru/post/82929/
% http://www.f-mx.ru/kommunikacii_svyaz_cifrovye_pribory_i/analiticheskaya_mashina_charlza.html
включающий
управляющий барабан (УУ), хранилище (регистровую память),
мельницу (арифметическое устройство "--- АУ).


\begin{illustration}
\includegraphics[width=\linewidth,keepaspectratio,valign=t]{babbage-lovelace-color}

\caption{Аналитическая машина из позднего проекта Бэббиджа, изображённая современным художником.
Цифрами обозначены: 1 "--- память, 2 "--- процессор, 3 "--- блок питания, 4 "--- принтер, 5 "--- программа, 6 "--- адреса переменных, 7 "--- непосредственные данные, 8 "--- микропрограммы.
Рядом с~машиной изображены Чарльз Бэббидж и~Ада Лавлейс}
\label{ris:babbage-lovelace-color}
\end{illustration}

На вход машины в~последнем варианте проекта подавались два потока перфокарт: операционные карты (команды) и карты переменных (данные),
что в~современной классификации соответствует гарвардской архитектуре~\cite{the-marvellous-analytical-engine-how-it-works}. 

% https://geektimes.ru/post/210412/
В~1930-х~гг. над своим проектом вычислительной машины
независимо от Бэббиджа
начал работать Конрад Цузе, в~это время "--- студент Берлинского политехнического.
Компьютер Цузе был двоичным, для ввода-вывода данные преобразовывались в~десятичный вид.

% http://www.computer-museum.ru/galglory/2.htm
Цузе сформулировал основные принципы построения вычислительных машин:
\begin{itemize}
\item    двоичная система счисления;
\item    использование устройств, работающих по принципу «да/нет» (логические 1 и~0);
\item    полностью автоматизированный процесс работы вычислителя;
\item    программное управление процессом вычислений;
\item    поддержка арифметики с плавающей запятой;
 \item   использование памяти большой ёмкости. 
\end{itemize}
Цузе впервые ввёл понятие «да/нет-статуса», аналогичное современному биту, термин «машинное слово», объединил в~вычислителе арифметические и~логические операции.



Первая демонстрационная модель Z1 была  механической с~электроприводом (рис.~\ref{ris:z1}).
Вместо использованных Бэббиджем шестерёнок логические и~арифметические операции
были реализованы на скользящих металлических рейках.
Z1 обрабатывал 22-битные числа с~плавающей запятой,
включал не только регистры, но и~механическую память (очень малого объёма, так что программа загружалась непосредственно с~бумажной перфоленты).
Поддерживались
команды сложения и~вычитания, умножения и~деления, ввода и~вывода, загрузки и~сохранения в~память.
В~системе команд Z1 не было условных переходов, так как их затруднительно выполнять на перфоленте.
Цикл реализовывался склейкой перфоленты в~кольцо~\cite{586067-ru,586067}.

\begin{illustration}
\includegraphics[width=\linewidth,keepaspectratio,valign=t]{z1}

\caption{Конрад Цузе рядом с~восстановленным Z1}
\label{ris:z1}
\end{illustration}

В~отличие  от  проекта аналитической машины Бэббиджа, который так и~остался проектом, Z1 был реализован в~1938~г.
и~является первым в~истории компьютером.


Серийно выпускаться механические компьютеры общего назначения так и~не стали;
но выпуск специализированных устройств (мультимедийных проигрывателей, калькуляторов, цифровых сигнальных процессоров)
был налажен достаточно широко.

К~электромеханическим
цифровым  сигнальным процессорам (DSP) %данного поколения нулевого?
можно отнести, в~частности, знаменитую Энигму (1923-1945~гг.) и~более совершенную шифровальную машину Lorenz SZ.
% хотя механическую часть представляли не реле, а~зубчатые роторы.
Так как механическую часть представляли не реле, а~зубчатые роторы, их можно условно отнести к~минус первому поколению.

% https://geektimes.ru/company/ua-hosting/blog/273264/
% ABC Атанасов электромеханическая, но не реле



\subsubsection{Нулевое поколение (1890--1941--1960) "--- реле}

% https://geektimes.ru/company/mailru/blog/289239/
Устройства нулевого поколения построены на основе  телеграфных реле, идея которых была предложена ещё в~1830~г.
Реле состоит из металлического переключателя, который может, в~зависимости от положения, может либо замыкать, либо размыкать электрическую цепь,
и~электромагнита, управляющего положением переключателя.

Таким образом, реле "--- электромеханическая ячейка, которая, в~отличие как от более ранней механической памяти, так и~от более поздних разновидностей,
может принимать два и~только два состояния.

% https://geektimes.ru/company/mailru/blog/289239/
% http://masters.donntu.org/2005/kita/kovalchuk/library/ht.htm
В~начале~\RN{XX}~в. на основе реле были разработаны первые автоматические телефонные станции.
Для этого был разработан и~запатентован релейный регистр.

Первым счётным устройством, основанным на электромеханических реле,
был табулятор Германа Холлерита (1890 г.).
Для его разработки была создана компания, которая позже будет переименована в~IBM.
% Нулевое поколение 

В~Германии на основе реле в~1939~г Цузе разработал компьютер Z2 с~механической памятью, по архитектуре практически полностью повторяющий Z1.
% Программа Z2 записывалась уже не на бумажной перфоленте, а~на перфоленте из более прочной киноплёнки.
В~1941~г. "---  Z3 с~полностью релейной памятью, к~системе команд которого было добавлено вычисление квадратного корня~\cite{586067-ru,586067}.
Перфоленты для программ Z2 и~Z3 делались уже не из бумаги, а~из более прочной киноплёнки (рис.~\ref{ris:z3}).



\begin{illustration}
\includegraphics[width=\approvedImageWidth,keepaspectratio,valign=t]{z3}

\caption{Составные части Z3}
\label{ris:z3}
\end{illustration}



% https://3dnews.ru/263541
% Четыре компьютера Конрада Цузе
% 01 мая 2007 	
% http://www.computer-museum.ru/galglory/2.htm
% Изобретатель компьютера
% Сергей Бобровский 
% http://www.comprice.ru/articles/detail.php?ID=42488
% КОНРАД ЦУЗЕ. ПИОНЕР КОМПЬЮТЕРОСТРОЕНИЯ
% Александр Калигин

% https://geektimes.ru/post/210412/
% 27 января 2014 в 14:41
% Наследие Конрада Цузе: Архитектура Z1 и Z3 [Перевод] из песочницы
% История IT
% Оригинал: Ra?l Rojas — «Konrad Zuse’s Legacy: The Architecture of the Z1 and Z3», IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 


% https://sites.google.com/site/historyvycislitelnojtehniki/pervye-elektromehaniceskie-cifrovye-komputery
% Первые электромеханические цифровые компьютеры

В~США независимо от Цузе,
но на основе проекта Бэббиджа,
%http://www.great-country.ru/articles/sssr/sov_delali/00003.html
разрабатывались две линейки релейных вычислительных устройств "--- в фирме Bell (Д.\,Штибитц)
и~в~Гарвардском университете совместно с~IBM (Г.\,Айкен).


% http://www.boatanchor.ru/article/item.php?itemid=15
% Д. Штибитц, работавший в фирме Bell, собрал на телефонных реле первые суммирующие схемы. В 1940 г. вместе с С. Уильямсом Штибитц построил «вычислитель комплексных чисел», или релейный интерполятор, который впоследствии стал известен как специализированный релейный компьютер «Bell-модель 1». Машина демонстрировалась на заседании Американского математического общества в этом же году. На демонстрации в машину ввели два комплексных числа, переданных по телеграфу, и получили произведения этих чисел с отображением результата на телеграфном печатающем аппарате, установленном в зале заседания. В последующие годы были созданы еще четыре модели этой машины. Последняя из них разработана Штибитцем в 1946 г. (модель V) — это был компьютер общего назначения, который содержал 9000 реле, занимал площадь 90 м2 и весил 10 т. Сложение на этой машине выполнялось за 0,3 с, умножение — за 1 с. Для ввода данных использовалась перфолента, для вывода — стандартное телетайпное оборудование.
% 
% Другую идею релейного компьютера выдвинул в 1937 г. аспирант Гарвардского университета Г. Айкен. Этой идеей заинтересовалась фирма IBM. В помощь Айкену подключили бригаду инженеров во главе с К. Лейком. Работа по проектированию и постройке машины, которая в дальнейшем стала называться «Марк-1», началась в 1939 г. и продолжалась 5 лет. Реле, счетчики, контактные устройства, печатающие механизмы, устройства для ввода перфокарт и перфорирующие устройства, используемые в машине, были стандартными частями табуляторов, выпускаемых в то время фирмой IBM. Эта машина, работавшая с 23-значными десятичными числами, выполняла операцию сложения за 0,3 с и операцию умножения за 3 с. Машина не имела операции условного перехода, это было ее недостатком, но свою жизнеспособность она доказала в течение 15 лет непрерывной работы.

% В~1939~г инженер Штибитц построил сумматор на реле
% https://geektimes.ru/company/mailru/blog/289239/
Первый релейный калькулятор линейки Bell, «вычислитель комплексных чисел»
был построен в~1940 г.,
последним (Bell Model V в 1946 г.) был полноценный многоядерный компьютер, где распределение заданий по ядрам выполнял аппаратный супервизор,
который можно назвать ранней операционной системой.
% https://geektimes.ru/company/mailru/blog/289239/
%  Забытое поколение релейных компьютеров 
Система команд Bell Model V включала условные переходы, реализующиеся как переключение между различными перфолентами.
% https://www.itweek.ru/themes/detail.php?ID=71978
% % Две следующие машины Bell Labs (Model III и Model IV) были по существу идентичны и также предназначались для систем ПВО. 
% % Model III, известная как "Баллистическая вычислительная машина” (Ballistic Computer), была установлена в июне 1944 г. 
% % Model IV (март 1945-го) помимо этого вычисляла значения тригонометрических функций. 
% % Вместе обе машины выполняли работу ста вычислителей с настольными счетными машинками и находились в эксплуатации полтора десятка лет.

% Линейка Гарвардского университета 
Первым из линейки Гарвардского университета и~IBM первоначально также был калькулятор
Harvard Mark I, или ASCC (1941~г.) с~релейным процессором и~механической памятью, 
который в~1944~г. был доработан до %программируемого 
компьютера, загружающего инструкции с~бумажной перфоленты.

Позже были разработаны
% https://en.wikipedia.org/wiki/Harvard_Mark_I
% Harvard Mark II (1947~г.), Mark III/ADEC (1949~г.) и~Harvard Mark IV (1952~г.).
полностью релейный Harvard Mark II (1947~г.) и~релейно-ламповый Mark III/ADEC (1949~г.).
Именно в~электромеханическом реле Harvard Mark II, согласно легенде, был обнаружен первый баг.

В~системе команд Mark I и~Mark II, так же как и~в~ранних компьютерах Цузе, не было условных переходов, 
а~циклы выполнялись закольцовыванием перфоленты.
Программы Harvard Mark I и~Mark II %(также аналогично Z1-Z3)
(аналогично позднему проекту Бэббиджа)
хранились на перфолентах отдельно от данных, что позже получило название гарвардской архитектуры.
% Mark I was disassembled in 1959

% http://www.vokrugsveta.ru/telegraph/technics/276/
% При этом по быстродействию как Harvard Mark II, так и~Bell Model V были сравнимы с~Z3, но Z3 на порядок компактнее.  << врут, Bell Model V чуть быстрее

% http://www.vokrugsveta.ru/telegraph/technics/276/
%  И лишь в 1957 году появляется релейная машина РВМ-1 (главный конструктор Н.И.Бессонов, 1906–1963). Впрочем, машина получилась удачной. РВМ-1 была построена на 5500 реле. И при этом работала с 36-битными операндами. И быстродействие в сравнении с американскими аналогичными разработками было отменным — операция умножения занимала 0,05 сек. Машина эксплуатировалась до 1965 года. 


% http://www.pro-radio.ru/computers/9647-2/
Из-за механического элемента в~реле быстродействие таких машин было ограничено.
Кроме того, у~реле  ограниченный ресурс срабатывания, поэтому релейные компьютеры были не слишком надёжны (хотя иногда надёжнее ламповых).
Релейные компьютеры устойчивы к~радиации и~потребляют мало мощности.

% В~настоящее время релейные
% http://forum.rcdesign.ru/f100/thread188531.html
% https://habrahabr.ru/post/220865/
% https://geektimes.ru/post/287344/

% https://geektimes.ru/company/ua-hosting/blog/273264/
% ABC Атанасов электромеханическая, но не реле

\subsubsection{Первое поколение (1943--1949--1965) "--- электронные лампы}

% http://dssp.petrsu.ru/p/tutorial/informatics/chapter3/6/63.htm
В~1918~г. М. А. Бонч-Бруевичем было изобретено электронное реле "--- триггер,
состоящее из двух электронных ламп "--- триодов.
Триггер может менять своё состояние быстрее электромеханического реле, что позволило ускорить быстродействие вычислительных устройств.

% Ламповые компьютеры и~калькуляторы
 
% http://www.computer-museum.ru/frgnhist/universal_p.htm
%  Двое техников, увидев спящего шефа, перенесли раскладушку в пустовавшую комнату, а когда он проснулся, то первой его мыслью было: “ENIAC украли!”


Первым счётным устройством на электронных лампах считаются,
согласно различных источникам,
британский калькулятор Colossus Mark I %(1943~г.)
и~американский табулятор ENIAC. %(США, 1943~г.).
Оба этих калькулятора были построены в~1943~г.


Проект Colossus был рассекречен только в~конце 1970-х~гг., поэтому большая часть источников приписывает первенство ENIAC.
Colossus Mark II (1944~г.)
не только работал в~пять раз быстрее предшественника, но и~был программируемым, % компьютером.
так что Colossus Mark II может быть назван первым %компьютером первого поколения. % "--- первой ЭВМ.
электронным компьютером (но не первым цифровым).
В~Colossus не было памяти, так что %программы и~
данные хранились на замкнутой перфоленте. 
% http://www.dailytechinfo.org/infotech/3502-mashiny-monstry-colossus-pervyy-v-mire-elektronnyy-cifrovoy-programmiruemyy-kompyuter.html

% Первым счётным устройством на электронных лампах считается %был
% % Также первым ламповым устройством
% табулятор ENIAC (1943~г.), обрабатывавший десятичные числа.
% Табулятор ENIAC обрабатывал десятичные числа.
Табулятор ENIAC был разработан в~школе Мура Пенсильванского Университета, США и~обрабатывал десятичные числа.
% https://geektimes.ru/post/160595/
Каждый десятичный разряд представлялся десятью двоичными, при этом включён был только один из них "--- соответствующий нужной десятичной цифре.
ENIAC иногда называют первой ЭВМ, но он не являлся вычислительной машиной (компьютером) в~современном понимании, 
так как не имел уровня архитектуры команд.
«Программирование» ENIAC выполнялось  перекоммутацией связей,
то есть фактически как перестройка машины.

В~1948-1950-х~гг. началась повсеместная разработка ламповых компьютеров:
EDVAC,
% (разработчики 
BINAC 
 и~Harvard Mark III/ADEC в~США, EDSAC в~Британии, % игра крестики-нолики
 МЭСМ и~М-1 в~СССР, CSIRAC в~Австралии.
% http://www.great-country.ru/articles/sssr/sov_delali/00003.html

% https://www.osp.ru/os/2010/01/13000691
% И все же EDVAC был вторым, а первым в мае 1949 года заработал EDSAC, и с него пошла волна создания аналогичных систем, начавшаяся с австралийского компьютера CSIRAC (ноябрь 1949 года). Тем временем Джон фон Нейман продолжил популяризацию своих и чужих идей, работая в Институте перспективных исследований (Institute for Advanced Study, IAS), где под его руководством вышла книга «Предварительные исследования по логическому проектированию электронных счетных инструментов». Описанная в ней архитектура получила название IAS – так было положено начало Open Source. Для создания компьютеров хватало общераспространенных тогда радиодеталей, поэтому для многих университетов и лабораторий открывалась возможность собирать их собственными силами. По архитектуре IAS было построено почти два десятка машин: JOHNNIAC (корпорация Rand), ILLIAC I (Университет штата Иллинойс), MANIAC I (Национальная лаборатория в Лос-Аламосе). Строили такие машины в Швеции (BESK, Стокгольмский университет) и в Израиле (WEIZAC, Институт Вейцмана)
% . В ряд IAS-подобных машин попадает и отечественная БЭСМ.
 
% % http://evmhistory.ru/history/edvac.html
% % ЭДВАК был поставлен Лаборатории Баллистики в августе 1949 года. После отладки компьютер был официально запущен в 1951 году и также как и предшественник ЭНИАК, проработал почти 10 лет, до 1961 года
% Следующий проект школы Мура, компьютер EDVAC (август 1949~г.), был уже двоичным и~имел память на ртутных трубках.
% В~этой памяти располагались как данные, так и~программа, что позже получило название фон-неймановской архитектуры.
% % Из-за конфликта разработчиков
% 
% % http://evmhistory.ru/history/edsac.html 
% % Дело в том, что в ЭДСАК-2 было реализовано микропрограммное управление, т.е. некоторые из команд составлялись из набора микроопераций, микропрограммы записывались в ПЗУ. ЭДСАК-2 был запущен в 1957 году, перед тем как будет отключён его предшественник ЭДСАК (лето 1958 года). Проработала вторая модель до 1965 года, после чего была заменена другим новым компьютером – Titan.
% В~Британии разрабатывалась другая линейка ЭВМ "--- EDSAC (май 1949~г.), позже переработанная в~EDSAC-2 (1957~г.)
% % первой известной ЭВМ  EDSAC (май 1949~г.)
% 
% % https://en.wikipedia.org/wiki/Harvard_Mark_I
% Частично ламповым был гарвардский компьютер Mark III/ADEC (1949~г., США),
% более поздний Harvard Mark IV (1952~г.)
% был полностью выполнен на электронных лампах.

% https://www.osp.ru/os/2010/01/13000691
%  Начав в октябре 1948-го с нуля, коллективу Лебедева удалось через три года, 6 ноября 1950 года, осуществить пробный запуск машины. На МЭСМ работали программы вычисления суммы нечетного ряда факториала числа и возведения в степень. Пуск МЭСМ в эксплуатацию был осуществлен 25 декабря того же года. На этот раз на машине решались реальные задачи вычисления функций распределения вероятностей. Дата запуска МЭСМ регламентировалась специальным постановлением правительства, все работы осуществлялись в обстановке строгой секретности. 12 января 1952 года началось выполнение заказов по расчетам. Осенью 1952-го на МЭСМ были выполнены расчеты генераторов Куйбышевской ГЭС.

% В~1949~г. были выпущены несколько 

Почти сразу, в~1951-1956~гг. был начат выпуск серийных компьютеров:
% http://www.boatanchor.ru/article/item.php?itemid=16
UNIVAC, Ferranti, БЭСМ-1, серия «Стрела», Z22.

В~целом поколение электронно-ламповых компьютеров было многочисленным и~разнообразным.
В~это время сложилось большинство архитектурных решений.

Кроме больших ЭВМ, занимавших иногда несколько этажей здания, стали появляться и~малые.
Так, первый мобильный компьютер общего назначения "--- Урал-1 (1955~г., СССР) мог %, в~отличие от предшественников, 
перевозиться на двух грузовиках.

Ненадёжность ламп приводило в~том числе и~к~частым перестройкам и~усовершенствованиям компьютеров,
так что второе поколение включало множество моделей, большинство из которых существовали в~единственном экземпляре.
При этом программное обеспечение уже было достаточно сложным и~функциональным, так что его было нерентабельно переписывать заново под язык каждой новой машины.
% Соответственно, для повышения переносимости программ были 
% унифицированы к
Соответственно, в~%этот период 
1954--1960~гг. 
% появились два новых уровня абстракции, обеспечивающие 
началось формирование двух новых уровней абстракции, обеспечивающих
переносимость программ:
\begin{itemize}
% \item    обратная совместимость машинных языков хотя бы в~компьютерах одного семейства, << у Цузе есть
% для чего в~EDSAC-2 впервые были применены микропрограммы;
% \item    использование языков высокого уровня.
% ^^^ у Цузе есть
% \item микропрограммы, обеспечивающие возможность запуска старой программы в~машинных кодах на изменённом компьютере
% \item микропрограммы, позволяющие запустить старые программы в~машинных кодах на изменённом компьютере 
% \item декодирование машинной команды на набор микрокоманд, позволяющие запустить старые программы в~машинных кодах на изменённом компьютере 
\item декодирование машинной команды на набор микрокоманд, что позволяет нескольким различным компьютерам выполнять один и~тот же набор команд
% (EDSAC-2, уровень совместимости с~EDSAC);
% (EDSAC-2, совместимость набора команд с~EDSAC); а чёрт их знает
(EDSAC-2);

\item компиляция с~языков высокого уровня (Фортран, Алгол, APL, Кобол).
\end{itemize}
% Полноценное развитие эти уровни получили в~третьем поколении.
% Тем не менее, задачи переносимости и~стандартизации не были решены 

\subsubsection{Второе поколение (1955--1960--1970) "--- дискретные транзисторы}
В~1947~г. Уолтер Браттейн и~Джон Бардин
создали первый твердотельный аналог лампы-триода "--- полупроводниковый транзистор.

% http://all-ht.ru/inf/history/p_4_0.html
% 22 октября 1925 года, когда Юлием Эдгаром Лилиенфельдом был зарегистрирован патент на принцип работы полевого транзистора. Теория работы полевых транзисторов - проще биполярных, поэтому обоснована и запатентована она была значительно раньше биполярных транзисторов. В общем случае принцип действия полевого транзистора аналогичен работе электронных ламп. Исток в полевом транзисторе подобен катоду вакуумного триода, затвор — сетке, сток — аноду. Однако, трудности в практической реализации полевых транзисторов позволили создать действующую модель лишь в 1960 году, значительно позже создания биполярного транзистора, и только в девяностых годах технология полевых транзисторов стала доминировать над биполярными. 

Транзисторы оказались компактнее, быстрее и~надёжнее, чем триоды.
% Соответственно, первым транзисторным компьютером после экспериментального ТХ-0 (1955~г., США, МТИ) считается бортовой компьютер самолёта TRADIC (1955~г., США).
Первым %экспериментальным 
транзисторным компьютером считается экспериментальный ТХ-0 (1955~г., США, МТИ),
на основе которого позже разработали TX-2, а~затем %относительно компактный  (относительно IBM)
PDP-1  (1961~г., США, DEC).

Первые частично транзисторные компьютеры общего назначения появились в~1958~г.
% http://www.boatanchor.ru/article/item.php?itemid=17
% В 1955 г. в США было объявлено о создании цифрового компьютера TRADIC, построенного на 800 транзисторах и 11 000 германиевых диодах. В этом же году фирма объявила о разработке полностью транзисторной вычислительной машины. Первая такая машина «Philco-2000» была сделана в ноябре 1958 г., она содержала 56 тыс. транзисторов, 1200 диодов, но все же в ее составе использовалось 450 электронных ламп. «Philco-2000» имела 32 индексных регистра, которые позволяли производить модификацию команд, использовать относительные адреса и т. д. Сложение в машине выполнялось за 1,7 мкc, умножение — за 40,3 мкс.
% Процесс перехода на выпуск серийных компьютеров второго поколения совершился, можно сказать, сразу во многих странах и примерно в одно и то же время. Так, в Англии транзисторная ЭВМ «Elliot-803» была выпущена в 1958 г., в ФРГ «Simens-2002» — в 1958 г., в Японии Н-1 — в 1958 г., во Франции и Италии — в 1960 г. В СССР группа разработчиков под руководством Е. Л. Брусиловского в 1960 г. в НИИ математических машин в Ереване завершила разработку полупровод­никовой ЭВМ «Раздан-2», ее серийный выпуск начался в 1961 г.
% 
% Серийное производство транзисторных компьютеров началось
Сразу же началось их серийное производство:
Elliot-803 в~Британии, Simens-2002 в~Германии, Н-1 в~Японии,  Раздан-2,
% http://all-ht.ru/inf/history/p_4_0.html
Минск-2, Мир и~5Э92б
в~СССР,
% http://life-prog.ru/1_46273_vtoroe-pokolenie--tranzistori--.html
PDP-1,  %1961 (DEC) % TX-0/TX-2
IBM 7030 (Stretch), % 1961
и~CDC 6600
в~США
и~т.\,д.

Новая элементная база позволила уменьшить не только  габариты больших ЭВМ (до нескольких десятков шкафов), % это официальный термин
но и мобильные компьютеры общего назначения (один-два шкафа).
% https://geektimes.ru/company/ua-hosting/blog/270228/
%  Немного из истории специализированных ЭВМ военного назначения 
Такими были Раздан-2 в~СССР,
PDP-4, PDP-5 и~PDP-8 в~США. %, позже PDP-8 ИС
% http://it-history.ru/images/7/77/07_%D0%9A%D0%B0%D1%80%D1%86%D0%B5%D0%B2.pdf
% ЭВМ и многопроцессорные комплексы М . А . Карцева Ю . В . Ревич
Активно разрабатывались специализированные (обычно военные) мобильные компьютеры:
бортовой компьютер самолёта TRADIC в~США, %(1955~г., США),
% https://geektimes.ru/company/ua-hosting/blog/270228/
Гранит, %?
%?  Специально для машины «Клен» была разработана импульсно-потенциальная система элементов с диодно-резистивной логикой и максимальной частотой работы 660 кГц. Время задержки логических элементов системы — 50 нс, время задержки элементов системы, которые использовались в последовательных цепях — 20-30 нс. В цепях сумматоров и контроля были использованы специальные логические элементы. 
Клён, 
%?  «Диана-2» — ЭВМ с фиксированной запятой, разрядностью 10, одноадресной системой команд, с количеством команд — 14, командной памятью объемом 256, ЗУ константой, оперативной памятью на магнитострикционных линиях задержки. 
Диана,
% ЭВМ «Радон»
% В 1964 году в Научно-исследовательском институте электронных математических машин закончилась разработка ЭВМ для применения в противовоздушной обороне СССР. Это была импульсно-потенциальная с гальваническими и трансформаторными связями ЭВМ второго поколения на базе транзисторов П16 и П601.
Радон
и~т.\,д. в~СССР.


% http://www.boatanchor.ru/article/item.php?itemid=17
% Необходимо отметить, что в этот период появились ЭВМ второго поколения, построенные на неполупро­водниковой элементной базе. Так, в Японии была выпущена ЭВМ «Senac-1» на параметронах. В СССР — «Сетунь», а во Франции — САВ-500 на магнитных элементах. «Сетунь», разработанная в МГУ коллективом под руководством Н. П. Брусенцова, стала первой в мире ЭВМ, работающей в троичной системе счисления.
% 
% Значительным событием в конструировании машин второго поколения стали ЭВМ «Atlas» (Англия), «Stretch» и CDC-6600 (США) и БЭСМ-6 (СССР).
% 
% Разработка проекта «Atlas» осуществлялась сотрудниками Манчестерского университета и фирмой Ferranti под руководством Г. Килбурна. Первый образец ЭВМ «Atlas» был изготовлен в 1961 г. В этой машине впервые была реализована концепция виртуальной (кажущейся) памяти [13].
% 
% При разработке ЭВМ «Atlas» конструкторы столкнулись с проблемой создания системы, в которой вся память (и на сердечниках и на барабане) адресовалась бы так, как если бы она была только на сердечниках. Так возник метод разделения памяти на страницы и стала возможным динамическая трансляция адресов аппаратными средствами.
Появляется механизм трансляции адресов и~страничная организация оперативной памяти.

% В~описываемое время формируются уровни архитектуры команд и~языка высокого уровня.
% 
% Во втором и~третьем поколении 
Активно развиваются компьютеры на нестандартной элементной базе: % или с~недвоичной реализацией арифметики:
Senac-1 на параметронах в~Японии,
троичная Сетунь %и~модулярный Алмаз % схемы
в~СССР,
САВ-500 на магнитных элементах во Франции.

В~процессе проектирования IBM 7030 (Stretch)
возникло понятие байта как совокупности шести битов.
% https://www.kakprosto.ru/kak-81445-chto-takoe-bayt
% ЭВМ, произведенные компанией Burroughs Computer Corporation, использовали байт, равный 9 битам.
% В системе IDM System/360 впервые была использована байтовая адресация. Ее преимущество по сравнению с адресацией целого машинного слова заключается в более простой обработке текстовой информации. В данной системе также использовались байты, состоящие из 8 бит.
В~%более поздних компьютерах
компьютерах других производителей байт мог быть равен семи или девяти битам.

Начиная с~третьего поколения, практически все компьютеры выпускаются сериями различного объёма.
Кроме того, большинство описанных названий "--- не одна модель, а~семейство компьютеров схожей архитектуры
и,~как правило, с~совместимыми наборами команд. 
%<< не факт
Разные семейства (даже разрабатываемые на основе друг друга, как PDP-1 и~PDP-4 или  IBM 7030 и~IBM 360)
были несовместимы между собой.

\subsubsection{Третье поколение (1961--1966--1980) "--- малые и~средние интегральные схемы}
% В~1959 г. Жан Эрни создал первый опытный планарный транзистор.
% Первые серийные планарные транзисторы и, чуть позже, первая интегральная микросхема, объединяющая множество транзисторов и~связей между ними, были выпущены в~1960 г. компанией Fairchild.

% http://www.computer-museum.ru/histekb/integral_1.htm
% В 1956 году сотрудник фирмы Bell Labs Росс изготовил схему двоичного счётчика на основе n-p-n-p структур в едином монокристалле . В 1957 г . Ясуро Тару из японской фирмы MITI получил патент на соединение различных транзисторов в одном кристалле. Но все эти и другие им подобные разработки имели частный характер, не были доведены до производства и не стали основой для развития интегральной электроники. Развитию ИС в промышленном производстве способствовали только три проекта.
% 
% Удачливыми оказались уже упомянутый Джек Килби из Texas Instruments (TI), Роберт Нойс из Fairchild (оба из США) и Юрий Валентинович Осокин из КБ Рижского завода полупроводниковых приборов (СССР). Американцы создали экспериментальные образцы интегральных схем: Дж. Килби – макет ИС генератора ( 1958 г .), а затем триггер на меза-транзисторах ( 1961 г .), Р. Нойс – триггер по планарной технологии ( 1961 г .), а Ю. Осокин – сразу пошедшую в серийное производство логическую ИС “2НЕ-ИЛИ” на германии ( 1962 г .). Серийное производство ИС эти фирмы начали почти одновременно, в 1962 г . 

Первые %экспериментальные макеты интегральных схем 
интегральные схемы (отдельные триггеры в~США и~логические вентили в~СССР) 
были созданы в~1961--1962~гг. 
параллельно
Джеком Килби из Texas Instruments,  Робертом Нойсом из Fairchild %(США) %, различные типы триггеров
и~Ю.\,В.~Осокиным из КБ Рижского завода полупроводниковых приборов. % (СССР).

Первые компьютеры, построенные с~использованием подобных схем, мало отличались от компьютеров, построенных только из отдельных транзисторов,
то есть граница между вторым и~третьим поколением достаточно условна.
Некоторые модели компьютеров собирались вначале из дискретных элементов, затем из интегральных схем.

С увеличением степени интеграции
появилась возможность выполнить на одном кристалле
% на одном кристалле был расположен 
целый блок ЭВМ "---  регистр, дешифратор, счётчик и~т.\,д.
Примерно в~это же время 
появляется понятие процессора, объединяющего в~себе АЛУ (возможно, несколько специализированных АЛУ) и~УУ. %? иногда пишут, что термин ещё с ламп


% http://all-ht.ru/inf/history/p_5_0.html
%  Серийный выпуск интегральных схем был налажен в 1961 году, тогда же была создана фирмой " Texas Instruments" по заказу ВВС США первая экспериментальная ЭВМ на интегральных схемах. Разработка велась 9 месяцев и была завершена в 1961г. ЭВМ имела всего 15 команд, была одноадресной, тактовая частота была 100 КГц, емкость запоминающего устройства – всего 30 чисел, для представления чисел использовалось 11 двоичных разрядов, потребляемая мощность составляла всего 16Вт, вес – 585гр, занимаемый объем – 100 кубических сантиметров. [1] 
%  
%  В ЭВМ третьего поколение уже четко выделяется иерархия памяти. ОЗУ делится на независимые блоки с собственными системами управления, работающие параллельно. Структура оперативной памяти делится на страницы и сегменты. [1] Развивается и внутренняя память процессора – создаются предпосылки к вводу кэширования памяти.
% Жесткий диск IBM 3340
% 
%  Среди наиболее развитых операционных систем были:
% OS/360, разработанная фирмой IBM в 1964 году для управления мейнфреймами;
% MULTICS - одна из первых операционных систем с разделением времени исполнения программ;
% UNIX, разработанная в 1969 году и, впоследствии, разросшаяся до целого семейства операционных систем, многие из которых являются одними из самых популярных на сегодняшний день.
% 
% Единой системы ЭВМ, IBM360

К~третьему поколению больших ЭВМ относятся, в~частности,
% https://sites.google.com/site/specenie/
% http://www.computer-museum.ru/articles/upravlyayushchie-evm/334/
Днепр-2, 
МИР-2
% http://www.digimedia.ru/articles/compyutery/raznoe/supercompyutery/supercompyutery-s-drevneyshih-vremen-i-do-nashih-dney/
и~БЭСМ-6	% 1966
в~СССР,
серии
IBM-360 %(семейство компьютеров с~одним набором команд), первые компьютеры которой были выпущены в~1965~г. разработка 1963-64 года,
и~IBM-370	% Впервые анонсирована 30 июля 1970 года.
в~США.

% Появилось множество 
Выросло количество мобильных компьютеров.
Наиболее известны  двенадцатиразрядная линейка компьютеров общего назначения PDP-8 и~шестнадцатиразрядная "--- PDP-11 фирмы DEC.
Для PDP-8 ввели термин «миникомпьютер», и,~согласно легенде, это был первый компьютер, украденный частными лицами (он занимал всего один шкаф и~весил менее 50~кг).

% 
% Первым образцом «Карата» была малогабаритная 24-разрядная машина на ГБИС «Вардува». Схемы функциональных узлов микросхем были разработаны советскими учеными, исходя из логических схем ЭВМ (в одном корпусе размещалось 8 разрядов регистра, 2 разряда АЛУ и т.п.). Эта разработка на много лет опередила создание многокристальных схем за рубежом (“мультичипы”).
% 
% Специализированная вычислительная машина «Атака» (МВМ-012) была создана в 1974 году в НПО «Агат». 
% Машина выпускалась до 1990 года, было изготовлено 255 СЦВМ «Атака».
%  СЦВМ «Арка» (специализированная вычислительная машина) предназначалась для работы с СЦВМ «Атака» и использовалась для увеличения пропускной способности вычислительной системы с СЦВМ «Атака». 
% ЭВМ «Арфа»
% Разработка машины была начата в 1979 году и предназначалась для работы в различных корабельных системах управления
% Эта машина составила совместно с ЭВМ «Арка» и «Атака» ряд программно-совместимых машин третьего поколения ЦМНИИ «Агат»
Также выпускались специализированные мобильные компьютеры.
В~СССР это были, в~частности, Карат,
% http://www.computer-museum.ru/histussr/sok_evm.htm
Алмаз на основе модулярной арифметики
и~ряд программно-совместимых компьютеров Атака, Арка и~Арфа.

% http://www.computer-museum.ru/histekb/integral_1.htm
% В1963 г. в НИИРЭ в рамках ОКР “Квант” (ГК А.Н. Пелипенко, при участии Е.М. Ляховича) была разработана конструкция модуля, в котором объединялось четыре ТС Р12-2 И, как мы уже говорили, это была первая в мире ГИС с двухуровневой интеграцией, а, возможно, вообще первая ГИС.


% Наиболее известным серийным компьютером третьего поколения
% является серия
% IBM-360 (семейство компьютеров с~одним набором команд), первые компьютеры которой были выпущены в~1965~г.
% IBM-370

% 14 ноября 1968 г. директор НИЭМ С. А. Крутовских приказом министра был назначен директором НИЦЭВТ и генеральным конструктором ЕС ЭВМ (уже «Единой Серии» – авторство термина, говорят, принадлежит Сулиму).
% Рамеев, вдохновленный перспективами, принял предложение перейти с Пензенского завода, где руководил созданием «Уралов», в заместители Крутовских по разработке ЕС. Другим заместителем – по научной работе – был упомянутый Левин. У двух заместителей взгляды на то, что именно должно послужить основой ЕС, расходились: Рамеев (как и Сулим) ориентировался на Западную Европу, а Левин, как и его начальник Крутовских, – на IBM/360.
% В декабре 1969 года состоялось представительное совещание у министра радиопромышленности СССР Калмыкова, где присутствовали все ключевые фигуры из разработчиков ЭВМ и организаторов их производства (из ныне известных не было разве что В. М. Глушкова). Сулим, С. А. Лебедев (конструктор БЭСМ и директор ИТМиВТ), академик А. А. Дородницын и зампред Госплана М. Е. Раковский выступили против копирования IBM/360. Причем никогда и никого не боявшийся Лебедев прямо так и начал: «Система IBM/360 – это ряд десятилетней давности…» 

% http://iknigi.net/avtor-yuriy-revich/82541-informacionnye-tehnologii-v-sssr-sozdateli-sovetskoy-vychislitelnoy-tehniki-yuriy-revich/read/page-13.html
% Научно обоснованное решение важной проблемы – какой должна быть ЕС ЭВМ – было подменено административным приказом о копировании системы IBM-360. Руководство Минрадиопрома, АН СССР, дирекция НИЦЭВТ не посчитались с мнением ведущих ученых Советского Союза и стран СЭВ.

Как было сказано ранее, 
в~период создания машин из отдельных транзисторов или малых интегральных схем
каждая компания устанавливала свои стандарты на аппаратные интерфейсы.
% 
К~концу 1960-х гг. 
не было практически никаких общих стандартов.
Проблема переносимости программного обеспечения, актуальная ещё в~начале 1960~гг., встала крайне остро.

% В~капиталистических странах большая часть корпоративных стандартов  исчезла  вместе с~создавшими их фирмами.
В~капиталистических странах большая часть избыточных стандартов  исчезла  вместе с~создавшими их фирмами, 
так как компьютеры без программного обеспечения были непопулярны.
% Такие фирмы, как IBM, DEC
Остались несколько несовместимых между собой серий компьютеров разных фирм, %с~несовместимыми между собой наборами команд, выпускавшихся 
в~основном IBM и~DEC.

В~СССР был поставлен вопрос о~создании единственного ряда компьютеров, совместимых на уровне команд друг с~другом и~основанных на
системе команд
наиболее известной %к~тому времени, хотя и~уже устаревающей, 
западной линейки "--- IBM 360.
Для IBM 360 к~тому времени было написано много программ, но
% сама архитектура, раз
сами эти компьютеры, разработанные в~начале 1960-х, устарели.
Официальное сотрудничество с~IBM было невозможно как из-за холодной войны, так и~из-за политики самой IBM.
Изначально выдвигался проект переориентации на сходные с~IBM-360 архитектуры английской фирмы ICL или немецкой Siemens.
Обе они были готовы официально поделиться существующими технологиями и~немедленно начать  
% совместно с~конструкторами БЭСМ-6
совместную
разработку компьютеров четвёртого поколения.

Тем не менее, в~1970~г. появился
административный приказ о~копировании устаревшей системы IBM-360.
При этом предполагалось копировать не архитектуру команд,
а~микроархитектуру  по нелегально полученным снимкам интегральных схем и~фрагментам документации~\cite{revich_es_book,revich_es_blog}.

Чуть позже в~1970~г. IBM анонсировала линейку IBM-370.
В~1971~г. в~СССР был выпущен первый представитель EC ЭВМ "--- линейки клонов IBM-360, а позже и~других компьютеров, устаревавших к~моменту клонирования.
Большая часть оригинальных разработок была прекращена и~забыта;
% При этом 
многие архитектурные решения, воплощённые в~МИР и~БЭСМ, были переоткрыты в~Intel и~AMD в~1990-2000~гг.
% Вследствие этого вычислительная техника СССР непоправимо отстала.


В~описываемое время окончательно сформировались уровни архитектуры команд и~языка высокого уровня.

Появляется ещё один уровень абстракции "--- промежуточные универсальные языки, облегчающие компиляцию
% https://habrahabr.ru/company/ua-hosting/blog/273665/
(такие, как Алмо, Эпсилон, внутренний язык системы Бета в~СССР).
При компиляции  с~$m$ языков высокого уровня для $n$ машин через промежуточный язык достаточно разработать $m + n$ трансляторов,
при компиляции напрямую в~машинные или ассемблерные коды  $m \cdot n$.
Этот уровень не прижился в~1970-е гг.,
% из-за сокращения количества как машинных языков, так и~компилируемых языков высокого уровня,
но в~настоящее время он активно используется для языков, подобных Java или C\#, как уровень байт-кода.
% В~настоящее время  этот уровень уже сформировался "--- это байт-код.

\subsubsection{Четвёртое поколение (1971--1980--настоящее время) "--- большие и~сверхбольшие интегральные схемы}

Граница между третьим и~четвёртым поколением %"--- самая условная из подобных границ.
ещё более условна, чем между вторым и~третьим.
Часто считается, что переход к~четвёртому поколению "--- размещение процессора на одной микросхеме (микропроцессоре).
% Согласно другим источникам,
% % Горбачев Г. Н., Чаплыгин Е. Е. Промышленная электроника: Учебник для вузов/Под ред. В. А. Лабунцова. — М.: Энергоатом-издат, 1988, — 320 с. 
% интегральная схема называется большой, если она включает более $10^3$ элементов.
% В~этом случае четвёртое поколение также началось в~начале 1970-х.

Первой подобной микросхемой был процессор Intel 4004 (1971~г.).
% разработанный для японского калькулятора

Естественно, что первые микропроцессоры были относительно простыми, а~сложные и~высокопроизводительные процессоры
% построенные на сверхбольших интегральных 
четвёртого поколения
по-прежнему были модульными.

В~это время выпускались как большие ЭВМ, в~основном уменьшившиеся до одного шкафа,
% которые стали называть «суперкомпьютеры» << не все?
наиболее производительные из которых стали называть суперкомпьютерами
(Cray-1 в~США, серия Эльбрус на основе БЭСМ-6 в~СССР),
% http://www.digimedia.ru/articles/compyutery/raznoe/supercompyutery/supercompyutery-s-drevneyshih-vremen-i-do-nashih-dney/
% 1979 пришли суперкомпьютеры серии «Эльбрус
% «Cray-1», выпущенный в 1974 году — первое детище организованной Сеймуром Креем компании. Он имел производительность 133 Мфлопс – миллионов операций над числами с плавающей точкой в секунду. «Cray-1» относится к четвертому поколению компьютерной техники, поколению построенному на сверхбольших интегральных схемах. «Cray-X1E», решение, предлагаемое компанией сейчас, несмотря на гигантский скачок в производительности — до 147 Тфлопс (триллионов операций над вещественными числами в секунду) – также принадлежит к четвертому поколению ЭВМ.  
% 
% http://samag.ru/archive/article/966
% Одной из инженерных задумок Крея на стадии проектирования являлось использование в Cray-1 всего трех типов интегральных схем: элементов логики, чипов оперативной памяти и регистров, что позволяло значительно повысить надежность и отказоустойчивость системы. Впрочем, общее количество микросхем в системе в итоге достигло 350 тысяч штук, и, чтобы упаковатьтакое количество в сравнительно небольшой корпус, Крею и его инженерам пришлось изрядно потрудиться.
так и~миникомпьютеры на основе микропроцессоров, габариты и~стоимость которых %стали доступны частным лицам.
% значительно уменьшились.
также уменьшались со временем.

% https://geektimes.ru/company/ua-hosting/blog/270228/
%  Позже была разработана модификация «Карат-КМ-Е» на секционных микропроцессорных больших интегральных схемах.
% 
% http://ru.uacomputing.com/stories/karat/
% В начале 80-х была завершена модернизация унифицированной ЭВМ с целью повышения быстродействия при решении задач в составе гидроакустических и других систем («Карат-КМ»).
% http://www.icfcst.kiev.ua/MUSEUM/PHOTOS/Module_r.html
% 
%? В 1982 году была разработана цифровая система управления стрельбой «Акация». 
%?  В 1986 году для надводных кораблей и подводных лодок была разработана ЭВМ «Лада-2», она состояла из трёх бортовых универсальных электронных вычислительных машин, была построена по модульному принципу, такая открытая система позволяла подключать дополнительные функциональные устройства.
Из специализированных мобильных компьютеров 1980-1990~гг. в~СССР можно отметить Карат-КМ-Е, Акация, Лада-2.

% http://www.securitylab.ru/analytics/439497.php
% 20.04.2013
% Исследование кристалла: недокументированные флаги микропроцессора 8085
% У микропроцессора 8085 есть два недокументированных флага состояния: V и K. Эти флаги можно исследовать, приглядевшись к кристаллу микросхемы, и их функция, как выясняется, отличается от предыдущих толкований. 

В~1973~г. появился прототип  Xerox Alto "--- недорогой миникомпьютер с~экраном, клавиатурой, мышью и~сетевой картой Ethernet, 
операционная система которого, как и~Unix, поддерживала графический интерфейс пользователя.
Подобный миникомпьютер позже получил название персонального компьютера.

В~1975~г. появился персональный компьютер MITS Альтаир 8800 на основе процессора Intel 8080
и~специально разработанной системной шины S-100.
В~базовой комплектации он не имел ни экрана, ни алфавитной клавиатуры, но поддерживал карты расширения.
Благодаря низкой цене, гибкой и~открыто опубликованной архитектуре, а~также качественной рекламе
Альтаир стал популярен, а~энтузиасты разработали для него как полноценные периферийные устройства, так и~качественное программное обеспечение.

Позже, начиная с~1977~г. были выпущены несколько недорогих 
персональных компьютеров:
Apple II, IBM 5100, Tandy TRS-80, Commodore PET, Электроника НЦ-8010 и~т.\,д.
При разработки базового программного обеспечения для них отказались от графического интерфейса.

В~1981~г. появился персональный компьютер IBM 5150, или IBM PC.
В~отличие от более ранних моделей IBM, в~IBM PC использовались сторонние компоненты, в~частности, процессор Intel 8088.
% Кроме того, архитектура была опубликована и~не запатентована
Архитектура IBM PC, вопреки обычной политике IBM, была открытой, % как и~у~Альтаира
что привело к~популярности и~огромному количеству клонов (IBM PC-совместимых компьютеров).

В~1983~г. появился первый процессор с~архитектурой ARM,
% , поддерживающий набор команд ARM 
% (Acorn RISC Machine)
% ARM-процессоры используются во встраиваемых системах.
% и~поддерживаются большинством ОС (GNU)
предназначенной для встраиваемых систем.

Сейчас под словом «компьютер» чаще всего понимают «IBM PC-совместимый %персональный 
компьютер», хотя
эта архитектура (и,~соответственно, процессоры семейства x86) в~настоящее время не является самой распространённой.

Наиболее популярными персональными компьютерами
% , используемыми частными лицами, 
сейчас являются смартфоны и~планшеты, где применяются процессоры семейства ARM.
Ещё более распространены цифровые сигнальные процессоры и~специализированные компьютеры.
Часто специализированный компьютер реализуется в~виде одной интегральной схемы "--- микроконтроллера.

Также в~настоящее время продолжается выпуск суперкомпьютеров, таких как Cray-X1E.
С ними успешно соперничают кластеры, объединяющие множество компьютеров общего назначения.




% \subsection{Поколения процессоров Intel}
\subsection{История семейства x86}

 \epigraph{\begin{limerick}
   Пожилой господин на Таити \\
    Говорил: «Если вы говорите,\\
    Что мой нос длинноват,\\
    В том не я виноват,\\
    А избыток дождей на Таити».\\
\end{limerick}
}
{\Lear}    
Так как данное пособие посвящено ассемблеру процессоров семейства Intel x86,
рассмотрим их историю подробнее.

% \termin{4-битные:}& 4004, 4040\\
Архитектура x86 основана на архитектуре четырёхразрядного микропроцессора Intel 4004.
Так как микросхема 4004 была разработана для настольного калькулятора,
в~ней не были реализованы многие механизмы,  давно и~успешно применявшиеся в~более ранних компьютерах,
в~частности, аппаратная трансляция адресов.
Позже была выпущена  улучшенная версия 4004 "--- 4040,
% \termin{8-битные:}& 8008, 8080 \terminComment{(адрес "--- 14),} 8085 \terminComment{(частота "--- 5 МГц)}\\
% На базе 4040 
а~на его основе
был разработан восьмиразрядный 8008, включавший два восьмибитных регистра общего назначения~$a$ и~$b$.
В~улучшенном 8080 их было уже семь "--- $a, b, c, d, e, h, l$, объединявшиеся в~три пары $bc, de, hl$.
Шина адреса в~8080 была шестнадцатиразрядной (то есть можно было адресовать до $2^{16}$ байт, или 64 килобайта), адрес задавался парой регистров~$hl$.
% Улучшенная версия 8080 получила название 8085 из-за частоты 5 МГц.

Процессор  8086 "--- родоначальник семейства x86
"--- был шестнадцатибитным, из-за чего 16 бит при программировании для x86 обычно называют \termin{словом.}
Он включал четыре шестнадцатибитных регистра общего назначения $ax, bx, cx, dx$, каждый из которых фактически был парой восьмибитных (в~частности, $ax=ah:al$),
и~четыре неделимых шестнадцатибитных регистра $bp$, $sp$, $si$, $di$.
% Хотя эти регистры и
% http://www.firststeps.ru/asm/r.php?6
У каждого из них было и~специальное назначение: $A$ "--- accumulator (неявный аргумент большинства команд), %аккумулятор
$C$ "---	counter 	(счётчик),
$D$ "---	data		(данные), 
$B$ "---	base		(базовый регистр).
В~отличие от 32-разрядного режима, невозможно было использовать в~косвенной  адресации любые регистры.
Для задания адреса в~памяти использовались только три бита поля $R/M$ и~поле смещения (раздел~\ref{sec:command-x86}).
Базовыми могли быть только $bx$ и~$bp$ (base pointer), индексными "--- только $si$ и~$di$ (source index и~destination index).
Масштабирование индекса не использовалось.

Шина адреса при этом была двадцатиразрядной.
% Для %получения двадцатиразрядного
Для того, чтобы адресовать $2^{20}$ байт (один мегабайт) памяти шестнадцатибитными адресами,
была введена \termin{сегментная модель памяти.}
Полный адрес складывался из шестнадцатибитного адреса %, рассчитанного по базе, индексу и~смещению
и~значения специального сегментного регистра, умноженного на~16.

Область памяти, адресуемая с~помощью одного сегментного регистра, называлась сегментом.
Сегмент занимал $2^{16}$ байт, то есть 64 килобайта;
разные сегменты могли пересекаться или полностью совпадать.
% 
В~8086 было четыре сегментных регистра, соответственно в~программе использовалось четыре сегмента:
\index{Сегмент}
\begin{itemize}
\item    $cs$ (Code Segment) "--- сегмент кода; значение регистра $cs$ добавлялось к~адресам команд;
\item    $ds$ (Data Segment) "--- сегмент данных, его значение добавлялось к~адресам статических переменных;
\item    $es$ (Extra Segment) "--- дополнительный сегмент данных, иногда там располагалась куча;
\item    $ss$ (Stack Segment) "--- сегмент стека, добавлялся к~адресам в~стеке.
\end{itemize}
% Программисту не требовалось 
Добавляемый сегментный регистр определялся процессором автоматически;
для данных при необходимости можно было использовать префикс замены сегмента.

Хотя в~настоящее время используется плоская модель памяти
% , так что разрядность адреса в~регистре совпадает с~разрядностью шины адреса, 
% (без использования сегментных регистров)
(сегментные регистры присутствуют, но их значение равно нулю)
по традиции области адресного пространства, где располагаются код, данные, стек и~т.\,д., часто называются сегментами.

Так как четырёх сегментов по 64 килобайта часто не хватало,
программисту приходилось изменять значения сегментных регистров во время работы программы для доступа к~различным областям памяти.
Управлять сегментами приходилось вручную. %, операционная систем

В~8086 всё ещё не было механизма трансляции адресов,
так что прикладные программы использовали реальные физические адреса ОЗУ;
из-за этого режим совместимости с~моделью памяти 8086 
в~более поздних процессорах называется \termin{реальным режимом.}
\index{Реальный режим}
При этом каждой программе 
реального режима
была доступна вся память компьютера% и~все устройства
, что не позволяло реализовать полноценную многозадачность.


Для 8086 был разработан математический сопроцессор 8087, предназначенный для вычислений с~плавающей запятой.
Сопроцессор устанавливался в~отдельный сокет на материнской плате.
Начиная с~этой модели, стали выпускаться урезанные варианты процессоров.
Так, 8086 с~восьмибитной шиной данных получил название 8088.

На основе 8086 был построен компьютер  IBM PC, 
так что большинство последующих  процессоров Intel (и~неинтеловских x86-совместимых процессоров)
% основанные на нём более
% поддерживают 
совместимы с~8086 на уровне машинного кода.
Теоретически любой современный персональный компьютер можно загрузить в~специальном режиме совместимости и~выполнить программу, написанную для 8086.
Практически с~этим возникнут  трудности, в~частности, из-за несоответствия временн\'{ы}х характеристик.

Непосредственно следующая модель, 80186, отличалась от 8086 незначительно.
В~80286 появилась частичная поддержка \termin{защищённого режима,} когда память разных программ изолирована (защищена) друг от друга за счёт аппаратной трансляции адресов.
\index{Защищённый режим}
Шина адреса была увеличена до 24 разрядов.

Полноценная реализация защищённого режима появилась в~тридцатидвухбитном процессоре 80386 (часто называемом просто 386).
Так как разрядность процессора сравнялась с~разрядностью шины адреса, в~защищённом режиме 386 используется плоская модель памяти.
% Количество сегментных регистров возросло до шести. 
% 
Современные операционные системы используют именно защищённый режим процессора, в~котором прикладной программе недоступны многие функции реального.
При этом, так как эти функции прозрачно обеспечиваются операционной системой, прикладное программирование заметно упрощено. %, так как 

Тем не менее, из-за используемого программного обеспечения даже более поздние модели (до Pentium 4) постоянно или часть времени работали в~реальном режиме,
так что многие учебники ассемблера описывают его наравне с~защищённым.


В~целом разработка 386 "--- наиболее существенный шаг в~развитии архитектуры семейства x86.
В~настоящее время «x86» обозначает, 
% так называют,
как правило, 386-совместимый процессор (такая архитектура обозначается i386 или IA-32).
% 
Дальнейшее развитие в~основном сводилось к~добавлению новых команд, наращиванию параллелизма и~увеличению частоты.

В~определённый момент четырёх гигабайт памяти, адресуемых 32-битным указателем в~плоской модели, оказалось недостаточно.
В~первую очередь это проявилось на серверах и~специализированных высокопроизводительных рабочих станциях.
Разработчики ПО и~аппаратного обеспечения не стали возрождать неудобную сегментную модель памяти, вместо этого начали продвигаться решения с~64-битными %регистрами и~
виртуальными адресами.

Результатом совместной разработки Intel и~Hewlett Packard стала архитектура IA-64, схожая с~суперкомпьютером Эльбрус и~свободная от недостатков, унаследованных от калькулятора 4004 и~шестнадцатибитного 8086.
IA-64 несовместима с~набором команд x86.
% VLIW
Она не получила популярности в~основном из-за недостаточного количества портированного под неё ПО и~несовершенства компиляторов, а~также дороговизны и~некоторых конструктивных недоработок воплощавших её процессоров Itanium.
В~мае 2017 г. официально объявили о~закрытии этой линейки.

Ведущий конкурент Intel, компания AMD, предложила 
расширение архитектуры IA-32,
% и~длинный режим как 
% расширение %тридцатидвухбитного защищённого режима 
увеличивающее разрядность адресов до 64 бит
и~дающее возможность увеличить разрядность данных с~помощью специального префикса~$REX$.
\index{REX, префикс}%
Именно это расширение, которое в~настоящее время поддерживается и~процессорами Intel
"--- наиболее популярный способ увеличить адресуемую память персонального компьютера.

Разработанная компанией AMD шестидесятичетырёхбитная архитектура  x86-64 (также называемая amd64 %, хотя в~настоящее время поддерживается и~процессорами Intel,
и~Intel 64,
но не IA-64) не слишком существенно отличается от тридцатидвухбитной x86. 



\subsection{Операционные системы}
\epigraph{
Вертикальная структура древа больше связана с~космологией, а~горизонтальная "--- с~магическими ритуалами. Чаще всего древо изображалось с~восемью ветвями, по четыре с~каждой стороны. Имело оно и~четыре главных цвета: красный, чёрный, белый, синий.}{Г.\,Белякова}

Наиболее известным семейством операционных систем является семейство Unix.
% 
Первоначально операционная система Unics (Uniplexed Information and Computing System) 
была разработана %Кен Томпсон Денис Ритчи Брайан Керниган
Кеном Томпсоном, Денисом Ритчи и~Брайаном Керниганом
как порт системы
Multics (Multiplexed Information and Computing Service)
на миникомпьютер DEC PDP-7.
Первая версия Unics была написана на ассемблере~\cite{jenyay/history-unix-systems}.

Первая версия Unix (V1) появилась в~1971~г.
Начиная с~версии V6 (1975~г.)
операционная система Unix распространилась в~университетах, что привело к~появлению множества различных веток.

% Параллельно с~разработкой и~усовершенствованием Unix

% http://jenyay.net/blog/2012/02/04/history-unix-systems/
% Параллельно с разработкой Unics/UNIX Кен Томпсон и Денис Ритчи, начиная с 1969 года, разрабатывали новый язык B (Би), который был основан на языке BCPL, а тот, в свою очередь, можно считать потомком языка Algol-60
% Затем язык B развивался вместе с UNIX, пока из него не родился язык C, один из наиболее известных языков программирования, который теперь принято поливать грязью или возносить, как идеал. В 1973 году вышла третья редакция UNIX со встроенным компилятором языка C, а начиная с 5-й версии, появившейся на свет в 1974 году, считается, что UNIX был переписан полностью на C. Кстати, именно в UNIX 1973 года появилось такое понятие, как трубы (pipe).

В~настоящее время потомки операционной системы Unix
% разделяющие принципы
называются Unix-подобными операционными системами.
% Семейство стандартов Single UNIX Specification (SUS)
% Лицензированными Unix 
Понятие Unix-системы описывается семейством стандартов Single UNIX Specification (SUS).
Зарегистрированными Unix-системами  являются коммерческие %«большие» 
операционные системы.
% соответствующие семейству стандартов Single UNIX Specification (SUS).

Кроме того, существует стандарт POSIX, описывающий взаимодействие операционной системы с~прикладной программой,
служащий для обеспечения совместимости Unix-подобных систем на уровне исходного кода.
При этом операционная система может поддерживать POSIX и~не являясь Unix-подобной.

% Для~компьютера IBM PC, использовавшего процессор Intel 8086, фирмой Microsoft была куплена операционная система DOS


Для процессоров семейства x86, кроме множества вариантов Unix-подобных систем,
доступны также специфические операционные системы:
% Microsoft DOS
линейка операционных систем с~закрытым исходным кодом Microsoft Windows NT (в~настоящее время  NT является единственной поддерживаемой линейкой Microsoft Windows, поэтому обозначение NT часто опускают), 
семейство MenuetOS и~так далее.
Эти операционные системы не поддерживают стандарт POSIX, хотя для Microsoft Windows периодически заявляется частичная %или полная 
поддержка (часть POSIX, причём не для всех версий и~не для всех типов Microsoft Windows).




% \subsection{Связь уровней}
% 
% 

% 
% в~том числе компиляция и~интерпретация

% \nsection{Контрольные вопросы}
% 
% \begin{enumerate}
% % \item Какова цель курса?
% 
% \item Что включает архитектура системы?
% \item Что такое вычислительная система?
% 
% \item Какие вы знаете единицы измерения информации?
% 
% 
% % \item Какие способы представления знаковых чисел используются в~ЭВМ?
% % \item Какие логические и~битовые операции вы~знаете?
% 
% \item Какие вы знаете компоненты ЭВМ?
% 
% 
% \item Чем отличаются фон-Неймановская и~гарвардская архитектуры?
% 
% \item Из чего состоит системная шина (магистраль)?
% 
% \item Какие вы знаете основные виды регистров \rlap{x86?}
% 
% \item Как используется регистр ip?
% 
% \item Как используется регистр sp?
% \end{enumerate}

\addquestion{Что включает архитектура системы?}
\addquestion{Что такое вычислительная система?}
\addquestion{Какие вы знаете единицы измерения информации?}
\addquestion{Какие вы знаете типы наборов команд?}
\addquestion{Какие вы знаете виды архитектуры, различающиеся расположением программ и~данных?}
\addquestion{Какие вы знаете сегменты памяти?}
\addquestion{Чем различается размещение в~памяти локальных, глобальных и~статических переменных?}

\addquestion{Какие вы знаете регистры общего назначения x86?}


\addquestion{Какие вы знаете флаги?}
\addquestion{Какие методы адресации вы знаете?}

\addquestion{Какие уровни абстракции включает современная вычислительная система?}


\printquestions
