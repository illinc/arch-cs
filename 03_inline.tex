\input{commonpres}


% \setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
% \setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}
% \setbeamerfont{frametitle}{size=\linespread{1.0}\large}

% \addtobeamertemplate{footnote}{}{\vspace{-30ex}}

% \title{Введение в~язык ассемблера}
\title{Ассемблерные вставки в~программу на языке высокого уровня}
\graphicspath{{fig/}{fig/tanenbaum/}{fig/asm-intro/}{fig/model/}}


% \lstset{language={[x86masm]Assembler}}
% \lstset{commentline={\/}}
\lstset{xleftmargin=0mm}
% \lstset{language={[Motorola68k]Assembler}}
% alsolanguage=[
% h
% dialect
% i
% ]
% h
% language
% \lstset{language=C++, alsolanguage=[Motorola68k]Assembler}


\begin{document}
\maketitle

% \begin{frame}{Соединение кода на ЯВУ и~ассемблере}
% \begin{enumerate}
% \item Использование stdlib в~программе на ассемблере
% 
% \item Подпрограммы на ассемблере
% \item Ассемблерные вставки
% \end{enumerate}
% \end{frame}
% 




\section{Ассемблерные вставки}

\subsection{Простой синтаксис}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

Ключевое слово asm (стандарт C++)
\begin{lstlisting}
asm ( string-literal ) ;
\end{lstlisting}

GCC "--- ключевые слова \lstinline!asm!  либо \lstinline!__asm__!
\begin{lstlisting}
asm("movl %ecx, %eax");	// EAX := ECX
\end{lstlisting}
\begin{lstlisting}
__asm__("movb %bh, (%eax)");	// *EAX := BH (байт)
\end{lstlisting}
\begin{lstlisting}
asm ("movl %eax, %ebx\n"
     "movl $56, %esi\n"
     "movl %ecx, 2(%edx,%ebx,4)\n"
     "movb %ah, (%ebx)");
\end{lstlisting}
\end{frame}


\subsection{Расширенный синтаксис}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\setlength{\parskip}{0\parskip}

\begin{lstlisting}
asm [volatile] ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    : [<выходные параметры>] : [<входные параметры>] : [<перезаписываемые регистры>]
    );
\end{lstlisting}
\begin{lstlisting}
asm [volatile] goto ( 
    "команды и директивы ассемблера"
    "как последовательная текстовая строка"
    :: <входные параметры> : <перезаписываемые регистры> : <метки>
    );
\end{lstlisting}  
Количество параметров $ input + output + goto \leqslant 30$
\end{frame}


\section{Параметры вставок}

\subsection{Входные и~выходные параметры}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\setlength{\parskip}{0\parskip}

\begin{lstlisting}
     [ [<псевдоним>] ] <строка ограничений> (<выражение>)
\end{lstlisting}
\begin{lstlisting}
int foo;
asm ("movl $12, %[X]\n"  :[X]"=rm"(foo)  );	// foo = 12;
\end{lstlisting}
\begin{lstlisting}
asm ("movl %0, %%eax"    ::"i"(1)  );	// movl $1, %eax
\end{lstlisting}
\begin{lstlisting}
int src = 1, dst, tmp;
asm("movl %[SRC], %[TMP]\n"
    "movl %[TMP], %[DST]\n"
    :[DST]"=g"(dst), [TMP]"=r"(tmp)
    :[SRC]"g"(src)
);	// dst = src
\end{lstlisting}
% \vspace{-\baselineskip}
\end{frame}

\subsection{Модификация входных параметров}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

Входной параметр \lstinline!%1! совпадает с~выходным \lstinline!%0!
\begin{lstlisting}
asm ("addl %2, %0"
    :"=r" (foo)
    :"0" (foo), "g" (bar)
    :"cc"
);	// foo += bar
\end{lstlisting}
\begin{lstlisting}
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}
\end{frame}

\subsection{Ограничения размещения}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{description}[m]
\item[r] "--- регистр; 
\item[m] "--- память;
\item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки;
\item[g] "--- общий (обычно \lstinline"rim"); %- general effective address
% \item[n]"--- непосредственное значение (константа), известное на этапе компиляции.	%- immediate value known at compile time.
%     ("i" would allow an address known only at link time)
% \end{description}
% 
% % But there are some i386-specific ones described in the processor-specific
% % part of the manual and in more detail in GCC's i386.h:
% % Некоторые ограничения (типы), специфичные для i386 (определены в~файле 
% i386%.h GCC)
% \begin{description}
\item[q] "--- любой из EAX, EBX, ECX, EDX; %- byte-addressable register (eax, ebx, ecx, edx)
\item[A] "--- пара регистров  EDX:EAX;
\item[a, b, c, d, S, D] "---  EAX, EBX, ECX, EDX, ESI, EDI соответственно;

% \item[I..P] "--- машинно-зависимые ограничения для констант:
% % \end{description}
% % 
% % Ограничения для констант:
% % \begin{description}
% % \item[i] "--- непосредственное значение (константа), известное на этапе компиляции или компоновки (без ограничений по значению "--- в~диапазоне \lstinline!0..0xffffffff!); % - immediate value, 0..0xffffffff
% % \item[n]"--- непосредственное значение (константа), известное на этапе компиляции; %- immediate value known at compile time.
% % %     ("i" would allow an address known only at link time)
% \begin{description}
\item[I] "--- непосредственное значение в~диапазоне 0..31 (32-битный сдвиг);
\item[J] "--- непосредственное значение в~диапазоне 0..63 (64-битный сдвиг);
% % \item[K] "--- Signed 8-bit integer constant. ?  255
% % \item[L] "--- 0xFF or 0xFFFF, for andsi as a zero-extending move. ?  65535
\item[M] "--- непосредственное значение в~диапазоне 0..3 (lea);
\item[N] "--- непосредственное значение в~диапазоне 0..255.
% % \item[O] "--- непосредственное значение в~диапазоне 0..32
% \end{description}
\end{description}

\end{frame}


\subsection{Перезаписываемые регистры (clobbers)}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\setlength{\parskip}{0\parskip}

Специальные аргументы:
\begin{description}[m]
\item[cc]код меняет регистр флагов

\item[memory]код меняет память (не считая выходных параметров)
\end{description}

\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
asm("addl $12, %[X]\n"
    :[X]"=rm"(foo)
    :"[X]"(foo)
    :"cc"
);	// foo += 12
\end{lstlisting}
\begin{lstlisting}
asm ("addl %[A], %[S]"
    : [S]"=r" (foo)
    : "[S]"(foo), [A]"g"(bar)
    : "cc"
);	// foo += bar
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}
asm("imull %[M]\n"
    :[X]"=a"(foo)
    :"[X]"(foo), [M]"r"(3)
    :"cc", "%edx"
);	// foo *= 3
\end{lstlisting}
\begin{lstlisting}
asm("movl $12, (%[p])\n"
    ::[p]"r"(&foo)
    :"memory"
);	// foo = 12
\end{lstlisting}
\end{column}
\end{columns}


\end{frame}

\subsection{Метки}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{lstlisting}
asm goto (
    "btl %1, %0\n\t"
    "jc %l2"
    :: "r" (p1), "r" (p2)
    : "cc"
    : carry
);

return 0;

carry:
return 1;
\end{lstlisting}  
Команда BT  копирует бит, номер которого передается вторым параметром, в~флаг CF

\end{frame}



% *****************************************************************************
\section{}
% \begin{frame}{Вопросы}
% \printquestions
% \end{frame}

\begin{frame}{Вопросы}
% \setlength{\leftmargini}{0ex}
\setlength{\parskip}{0.25\parskip}
\begin{enumerate}

\item Какие команды используются для вызова и~возврата из подпрограмм?

\item Какие вы знаете соглашения о~вызове?

\item Как передаются параметры в~функцию (соглашение cdecl)?

\item Как возвращается значение функции?

\item Каким ключевым словом открывается ассемблерная вставка?

\item Как из ассемблерной вставки обратиться к~локальным переменным?

% \item Какие вы знаете ограничения на размещение параметров ассемблерных вставок?

\end{enumerate}

\end{frame}

\makethanks
\end{document}
