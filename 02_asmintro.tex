\input{commonpres}


% \setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
% \setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}
% \setbeamerfont{frametitle}{size=\linespread{1.0}\large}

% \addtobeamertemplate{footnote}{}{\vspace{-30ex}}

% \title{Введение в~язык ассемблера}
\title{Введение в~GNU Assembler}
\graphicspath{{fig/}{fig/tanenbaum/}{fig/asm-intro/}{fig/model/}}



\begin{document}
\maketitle

\section{Синтаксис}


% \subsection{Сборка программы}
% \begin{frame}{\insertsubsection}
% 
% \hfill
% \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}
% \hfill
% \includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}
% \hfill\strut
% % \centering
% 
% \end{frame}
\subsection{Сборка программы (GCC)}
\begin{frame}[fragile]{\insertsubsection}

\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=16ex,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {prog2.o};
\node[stage,on chain=S] (S_linker) {Компоновщик};


\path[blockarrow] (cpp_headers) -- (S_preprocess);


\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[below= of prog-|cpp_linker]  {extern};

\node[below= of prog-|S_linker]  {.globl};

% \begin{pgfonlayer}{background}
% \node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};
% \end{pgfonlayer} 

\end{tikzpicture}
}
\centering

\end{frame}






\begin{frame}[fragile]{\insertsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
% \setlength{\parskip}{0.5\parskip}

Пробельные символы "--- пробел и~табуляция

Комментарии  "--- /* в~стиле C */, // в~стиле C++
% #<не выражение> устаревший

Оператор оканчивается переводом строки или точкой с~запятой.
Перед оператором может быть метка.
\begin{lstlisting}[numbers=none]
the_label:     .directive    ...
another_label:           // Пустой оператор
           instruction   operand_1, operand_2, ...
\end{lstlisting}

\end{frame}



\subsection{Основные директивы}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\setlength{\parskip}{0.5\parskip}

.globl (.global)
% \lstinline!.global symbol! делает symbol доступным из других модулей
делает символ  доступным из других модулей

.func  $\ldots$  .endfunc включает отладочную информацию о~функции

\frametitlelike{Директивы определения данных (.data)}

\begin{columns}
\lstset{numbers=none}

\begin{column}{0.39\linewidth}
.byte %одно или несколько выражений, разделённых запятыми

.short

.int (.long)

.quad

.float
(.single)

.double %одно или несколько вещественных значений, разделённых запятыми

\begin{lstlisting}
foo: .int 0, 1, 2
bar: .double -8.7
\end{lstlisting}
\end{column}
\begin{column}{0.59\linewidth}

.string (.asciz) %"строка" 
\begin{lstlisting}
msg: .string "Hello, world!\n"
\end{lstlisting}

.rept $\ldots$ .endr
\begin{lstlisting}
.rept 3     .long 0
.long 0     .long 0
.endr       .long 0
\end{lstlisting}

 
\end{column}
\end{columns}
\end{frame}



% \subsection{Распределение памяти GNU/Linux}
\subsection{Разделы памяти}
\begin{frame}{\insertsubsection}
\footnotesize

\begin{tabularx}{1\linewidth}{@{}LL@{}}
% \setlength{\parskip}{2ex}

\termin{.text} 

Код выполняемой программы
\bigskip

\termin{.data} 

Глобальные переменные программы
\bigskip

\termin{.bss}

Неинициализированные глобальные переменные
\bigskip
% .noinit 	Данные переменных программы 

Куча
(динамическая память)
\bigskip

Стек 
% Локальные переменные подпрограмм

&
Распределение памяти GNU/Linux

\includegraphics[width=\linewidth,height=\slideheigth-1\baselineskip,keepaspectratio,valign=t]{linuxmem}\centering

\end{tabularx}
\end{frame}




\subsection{Структура инструкции}

% инструкция на языке ассемблера включает в себя метку,
%    мнемонику и операнды. Способ записи операндов однозначно определяет
%    способ их адресации. Мнемоника определяет операцию, выполняемую над
%    операндами. 
   
\begin{frame}[fragile]{\insertsubsection}
% \def\normalsize{\footnotesize}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\setlength{\parskip}{0.25\parskip}
% [caption=min.S]
\begin{lstlisting}[numbers=none]
[метка:] мнемоника операнды
\end{lstlisting}


\begin{columns}
\scriptsize
\renewcommand{\tabularxcolumn}[1]{m{#1}}

\begin{column}{0.49\linewidth}
Суффикс мнемоники

\begin{tabularx}{\linewidth}{|l|L|L|}
\hline
% \thead{Суффикс} 
& \theadlong{Целые (бит)} & \theadlong{Вещественные (бит)} \\\hline
    b & byte (8) &\\\hline
    s & short (16) & single (32) \\\hline
    w & word (16) &\\\hline
    l & long (32) & double (64) \\\hline
    q & quad (64) &\\\hline
    t & & ten bytes (80) \\\hline
\end{tabularx}
\end{column}

\begin{column}{0.49\linewidth}

Префикс операнда

\begin{tabularx}{\linewidth}{|l|L|L|}
\hline
\%
&регистр
&
\%eax, \%dl
\\\hline
\$ &константа / адрес глобальной переменной
& \$5, \$0xFF, \$foo
\\\hline

&значение по указанному адресу / значение глобальной переменной
& foo
\\\hline
\end{tabularx}

 
\end{column}
\end{columns}
% чаще всего
\begin{lstlisting}[numbers=none]
[метка:] мнемоника источник приёмник
\end{lstlisting}
источник и~приёмник не могут оба находиться в~памяти
\end{frame}  


% \section{Структура программы}



\subsection{Минимальная программа (GAS, stdlib)}
\begin{frame}[fragile]{\insertsubsection}
% \def\normalsize{\footnotesize}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\setlength{\parskip}{0.25\parskip}
% [caption=min.S]
\begin{lstlisting}
.globl main // точка входа (stdlib)
main:
     xorl %eax,%eax // EAX ^= EAX, то есть EAX = 0
     ret // return EAX
\end{lstlisting}
Сборка (полученный файл a.out включает stdlib и~занимает 4.6 Кб)
\begin{lstlisting}[language=Bash]
$ g++ min.S
\end{lstlisting}
Сборка с~указанием имени выходного файла:
\begin{lstlisting}[language=Bash]
$ g++ -o min min.S
\end{lstlisting}
% Файл a.out включает stdlib и~занимает 4.6 Кб

% gcc -o nsmin  nsmin.S  -nostdlib
% \begin{lstlisting}
% .globl _start
% _start: // точка входа 
%     movl $1, %eax // системный вызов № 1 — sys_exit
%     xorl %ebx, %ebx // выход с кодом 0
%     int $0x80 // вызов ядра
% \end{lstlisting}

Эквивалент на С++
\begin{lstlisting}
int main(int argc, char* argv[]){
    return 0;
}
\end{lstlisting}


\end{frame}


\section{Переменные}
\subsection{Регистры общего назначения}
\begingroup
\renewcommand{\tabularxcolumn}[1]{p{#1}} 
\begin{frame}{\insertsubsection}
% регистры общего назначения, 
% указатель команд, 
% регистр флагов и~сегментные регистры. 
\setlength{\leftmargini}{0ex}
% \small
% \footnotesize
\setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
\setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}

 
\raisebox{-2.15\baselineskip}[0mm][0mm]{%
\noindent\begin{tabularx}{1\linewidth}{@{}L@{~}l@{}}
&
\includegraphics[width=0.7\linewidth,height=\slideheigth,keepaspectratio,valign=t]{Registers}
\end{tabularx}
}
\vspace{-4\baselineskip}

% \begin{itemize}
% \item {Регистры общего назначения} 
 \begin{itemize}
\item   \Reg{a, b, c, d;}  
\item    \Reg{si, di, bp;}
\item   {указатель стека} \Reg{sp}.
 \end{itemize}    
   
% \item Сегментные %регистры 
%   \Reg{cs, ds, ss, es, fs, gs.}
% 
% \item  Регистры состояния и~управления:
% \begin{itemize}
% \item   регистр флагов \Reg{eflags/flags};
% 
% \item       указатель команды \Reg{eip/ip}.
% \end{itemize}   
% 
% \item   Регистры сопроцессора x87 \Reg{st(0)...st(7)}/расширения MMX \rlap{\Reg{mm0...mm7}}
% 
% \item        Регистры расширения XMM \rlap{(128-разрядные \Reg{xmm0...xmm7})}
% \end{itemize}

\end{frame}
\endgroup



\section{Основные команды}
\subsection{mov}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\small}
\small
\lstset{xleftmargin=0em}

\lstinline!mov источник, приёмник! \\
"--- присваивание \lstinline!приёмник = источник!
\begin{lstlisting}[numbers=none]
movl $4, %eax	// eax = 4
movb $42, %al	// al = 42
movl %eax, (%esi)	// *esi = eax
movl %eax, 4(%esi)	// *(esi+4 байта) = eax
movl $some_var, %eax	// eax = &some_var
movl $some_var+4, %eax	// eax = &some_var+4 байта
movl some_var, %eax	// eax = some_var
movl %eax, foo	// foo = eax
\end{lstlisting}



\end{frame}


% \subsection{Арифметика}
\begingroup
\ttfamily
\subsection{Арифметика: сложение и~вычитание}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{tabularx}{\linewidth}{l|L}
\lstinline!add источник, приёмник! & приёмник += источник\\
\lstinline!adc источник, приёмник! & приёмник += (источник + CF)\\\hline
\lstinline!sub источник, приёмник! & приёмник -= источник\\
\lstinline!sbb источник, приёмник! & приёмник -= (источник + CF)\\\hline
\lstinline!inc приёмник! & ++приёмник\\
\lstinline!dec приёмник! & -{}-приёмник\\\hline
\end{tabularx}
\normalfont

Флаги:
\vspace{-\baselineskip}
\setlistspacing{1}{0ex}
\begin{description}
\item[CF] беззнаковое переполнение (перенос)
\item[ZF] результат равен нулю
\item[SF] старший (знаковый) бит результата
\item[OF] знаковое переполнение
\end{description}
\end{frame}
\subsection{Арифметика: умножение и~деление}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\scriptsize}
\scriptsize
\begin{tabularx}{\linewidth}{l@{}|L}
\lstinline!mul множитель! & edx:eax = eax * множитель32

dx:ax = ax * множитель16

ax = al * множитель8\\
\lstinline!imul множитель! & 
\\\hline
\lstinline!div делитель! & eax = edx:eax/делитель32, \rlap{edx = edx:eax\%делитель32}

ax = dx:ax/делитель16, \rlap{dx = dx:ax\%делитель16}

al = ax/делитель8, ah = ax\%делитель8\\
\lstinline!idiv делитель! & \\\hline
\end{tabularx}
\begin{tabularx}{\linewidth}{l|L}
\lstinline!imul источник, приёмник! & приёмник *= источник\\
\lstinline!imul константа, источник, приёмник! & приёмник = источник*константа\\\hline

\end{tabularx}
\end{frame}
\endgroup

\subsection{Битовые операции}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize
\ttfamily

\begin{tabularx}{\linewidth}{l|L}
\lstinline!shr cдвиг, приёмник! & приёмник >{}>= cдвиг \rlap{(беззнаковый)}\\
\lstinline!sar cдвиг, приёмник! & приёмник >{}>= cдвиг (знаковый)\\
\lstinline!ror cдвиг, приёмник! & циклический сдвиг вправо\\
\hline
\lstinline!shl cдвиг, приёмник! & приёмник <{}<= cдвиг\\
\lstinline!sal cдвиг, приёмник! & приёмник <{}<= cдвиг\\
\lstinline!rol cдвиг, приёмник! & циклический сдвиг влево\\
\hline
\lstinline!and источник, приёмник! & приёмник \&= источник\\
\lstinline!or источник, приёмник! & приёмник |= источник\\
\lstinline!xor источник, приёмник! & приёмник \lstinline!^=! источник\\
\lstinline!not приёмник! & приёмник = $\sim$приёмник\\
\end{tabularx}

\end{frame}

% 29.09.2016^^^^

% \subsection{push, pop}
% \begin{frame}[fragile]{\insertsubsection}
% \lstset{basicstyle=\ttfamily\scriptsize}
% \scriptsize
% \setlength{\parskip}{0.5\parskip}
% \begin{columns}
% \lstset{numbers=none}
% 
% \begin{column}{0.5\linewidth}
% 
% \lstinline!push источник! \\
% "--- помещение источника в~стек \phantom{wwwwwwwwwwwww}
% \bigskip
% 
% % \begin{lstlisting}[numbers=none]
% % pushl $13
% % \end{lstlisting}
% \lstinline!pushl $13! эквивалентно
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(int)
% movl $13, (%esp)// *esp = 13
% \end{lstlisting}
% 
% % \begin{lstlisting}[numbers=none]
% % pushl foo
% % \end{lstlisting}
% \lstinline!pushl foo! эквивалентно
% \begin{lstlisting}[numbers=none]
% subl $4, %esp	// esp -= sizeof(int)
% movl foo, %eax	// eax= foo
% movl %eax, (%esp)// *esp = eax
% \end{lstlisting}
% 
% 
% \end{column}
% \begin{column}{0.5\linewidth}
% 
% \lstinline!pop приёмник! \\
% "--- извлечение значения из стека и~помещение его в~приёмник
% \bigskip
% 
% 
% \lstinline!popl %eax! эквивалентно
% \begin{lstlisting}
% movl (%esp), %eax // eax = *esp
% addl $4, %esp	// esp += sizeof(int)
% \end{lstlisting}
% 
% \lstinline!popl foo! эквивалентно
% \begin{lstlisting}
% movl (%esp), %eax // eax = *esp
% movl %eax, foo	// foo = eax
% addl $4, %esp	// esp += sizeof(int)
% \end{lstlisting}
% \end{column}
% \end{columns}
% 
% В Linux стек выравнен по long (соглашение).
% 
% Команды push и pop работают только с операндами размером 4 или 2 байта.
% 
% \end{frame}

% 
% \section{Подпрограммы}
% 
% \subsection{Вызов подпрограммы}
% \begin{frame}{\insertsubsection}
% \begin{enumerate}
% \item Передача параметров
% \item Сохранение адреса возврата
% \item Передача управления вызываемой подпрограмме
% \item Выполнение вызываемой подпрограммы
% \item Подготовка возвращаемого значения
% \item Возвращение управления вызывающей программе
% \end{enumerate}
% \end{frame}
% 
% \subsection{Требования}
% \begin{frame}{\insertsubsection}
% \begin{enumerate}
% \item Передача управления на произвольный адрес
% \item Возврат управления назад после завершения подпрограммы
% \item Вложенные вызовы подпрограмм
% \item Сохранение и~восстановление регистров вызывающей программы
% \item Передача заданного количества аргументов
% \item Передача и~возврат структур
% \item Выделение и~освобождение памяти под локальные переменные подпрограмм
% \end{enumerate}
% \end{frame}
% 
% \subsection{Передача и~возврат управления}
% \begin{frame}[fragile]{\insertsubsection}
% \lstset{basicstyle=\ttfamily\footnotesize}
% \footnotesize
% 
% \begin{columns}
% \lstset{numbers=none}
% 
% \begin{column}{0.65\linewidth}
% Передача управления в~подпрограмму addr:
% 
% \lstinline!call addr!
% 
% указатель команд сохраняется в~стеке,
% управление передаётся addr
% \end{column}
% \begin{column}{0.34\linewidth}
% \lstset{xleftmargin=0ex}
% \begin{lstlisting}
% pushl %eip
% jmp addr 
% ///*@@*/ movl $addr, %eip
% \end{lstlisting}
% \end{column}
% \end{columns}
% \medskip
% 
% \begin{columns}
% \lstset{numbers=none}
% 
% \begin{column}{0.68\linewidth}
% Возврат из подпрограммы:
% 
% \lstinline!ret!
% 
% \lstinline!ret n!
% 
% управление передаётся адресу, снятому со~стека (если указан аргумент n, со~стека затем снимается ещё n байт)
% \end{column}
% \begin{column}{0.31\linewidth}
% \begin{lstlisting}
% popl %eip
% \end{lstlisting}
% \end{column}
% \end{columns}
% \vspace{-1.5\parskip}
% 
% \hfill\includegraphics[width=\linewidth,height=0.3\slideheigth,keepaspectratio,valign=t]{nested-call}
% \centering
% 
% \end{frame}
% 
% 
% \subsection{Параметры и~возвращаемое значение}
% \begin{frame}[fragile]{\insertsubsection}
% \footnotesize
% \setlength{\parskip}{0.25\parskip}
% \setlength{\leftmargini}{0.5\leftmargini}
% 
% \termin{Соглашение о~вызовах} "--- протокол передачи аргументов:
% \vspace{-1\parskip}
% \begin{enumerate}
% \item способ передачи (через регистры, через стек, смешанный);
% \item порядок размещения аргументов (Pascal "--- первый аргумент помещается в~стек первым, C "--- последним);
% \item кто очищает стек и~сохраняет/восстанавливает регистры (и~какие);
% \item инструкции вызова и возврата;
% \item как передаётся указатель this (для ООП).
% \end{enumerate}
% 
% Возвращаемое значение:
% \vspace{-1\parskip}
% \begin{enumerate}
% \item целое или указатель "--- \lstinline!%eax! (long long "--- \lstinline!%edx:%eax!);
% \item вещественное значение "--- регистр сопроцессора \lstinline!st(0)!.
% \end{enumerate}
% 
% \end{frame}
% 
% 
% 
% \subsection{Соглашения о~вызовах (32 бита)}
% \begin{frame}[fragile]{\insertsubsection}
% % \footnotesize
% \scriptsize
% \setlength{\parskip}{0.5\parskip}
% \setlength{\leftmargini}{0.5\leftmargini}
% 
% \renewcommand{\tabularxcolumn}[1]{m{#1}}
% \begin{tabularx}{\linewidth}{|M{3.5em}|M{5.5em}|M{3.5em}|L|%L|
% }
% \hline
% &\theadlong{Параметры в~регистрах}
% &\theadlong{Порядок}
% &\theadlong{Очистка стека}
% % &\theadlong{Дополнения}
% \\\hline
% \rowcolor{csMarker}cdecl&&
%  C&
%  вызывающая программа
%  %&
%  \\\hline
% pascal&&
%  Pascal&
%  функция
%  %&
% \\\hline
% winapi (stdcall)&&
%  C&
%  функция
%  %&
%  \\\hline
% \rowcolor{csMarker}Gnu&&
%  C&
% %  hybrid
% this "--- функция, \mbox{остальные "---  вызывающая программа}
% %  &
% % Стек иногда выравнивается на 16 бит
% \\\hline
% Gnu fastcall&
% ecx, edx
% &
%  C&
% функция
% \\\hline
% Gnu regparm (3)&
% eax, edx, ecx
% &
%  C&
% функция
% \\\hline
% Borland fastcall&
% ecx, edx
% &
% Pascal&
% функция
% \\\hline
%  Microsoft fastcall&
%  ecx, edx&
%  C&
%  функция
% %  &
% %  return pointer on stack if
% % not member function
% \\\hline
% % \\\hline
% \end{tabularx}
% 
% \tiny
% gcc.gnu.org/onlinedocs/gcc-3.4.5/gcc/Function-Attributes.html\\
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.
% 
% \end{frame}
% 
% 
% 
% \section{Вызов подпрограммы в~GAS}
% \begin{frame}[fragile]{\insertsection}
% 
% Соглашение о~вызове: Gnu %(cdecl)
% 
% Регистры, значение которых не~должно изменяться подпрограммой:
% \vspace{-1\parskip}
% % \section{Подпрограммы в~GAS}
% % \subsection{Регистры, значение которых не~должно изменяться подпрограммой}
% % \begin{frame}[fragile]{\insertsubsection}
% \begin{enumerate}
% \item\lstinline!%ebx!
% \item\lstinline!%esi!
% \item\lstinline!%edi!
% \item\lstinline!%ebp!
% \item Сегментные регистры \lstinline!%ds, %es! и~\lstinline!%ss!
% % \item Вершина стека \lstinline!%esp! нет
% % \item\lstinline!%r12—%r15! в~64-битном режиме
% \end{enumerate}
% % Прочие могут изменяться подпрограммами.
% \end{frame}
% % 
% % \subsection{Регистры, значение которых можно изменять}
% % \begin{frame}[fragile]{\insertsubsection}
% % \begin{enumerate}
% % \item\lstinline!%eax! "--- возвращаемое значение (целое до 4 байт или указатель)
% % \item\lstinline!%edx! "--- старшие 4 байта возвращаемого значения (long long)
% % \end{enumerate}
% % \end{frame}
% 
% 
% \subsection{Приветствие (GAS, stdlib)}
% 
% % \subsection{Приветствие (GAS, GNU/Linux)}
% \begin{frame}[fragile]{\insertsubsection}
% \lstset{basicstyle=\ttfamily\footnotesize}
% 
% \begin{lstlisting}
% .data
%     msg:
%     .string "Hello, world!\n"
% .global main // точка входа в программу
% main:
%     pushl $msg	// Адрес строки в стек
%     call printf
%     popl %eax	// Вычищаем параметр из стека
%   
%     movl $0,%eax
%     ret
% \end{lstlisting}
% 
% \vspace{-2\baselineskip}
% \lstset{xleftmargin=14em}
% \terminblue
% \begin{lstlisting}[numbers=none]
% int main(){
%     printf("Hello, world!\n");
%     return 0;
% }
% \end{lstlisting}
% \end{frame}
% 
% \subsection{Форматированный вывод (GAS, stdlib)}
% 
% % \subsection{Приветствие (GAS, GNU/Linux)}
% \begin{frame}[fragile]{\insertsubsection}
% \lstset{basicstyle=\ttfamily\footnotesize}
% 
% \begin{lstlisting}
% .data
% fmt: .string "Переменные: %d %d\n"
% foo: .int 13
% .global main // точка входа в программу
% main:
%   pushl foo	// Значение foo в стек
%   pushl $19	// Значение 19 в стек
%   pushl $fmt	// Адрес строки fmt в стек
%   call printf
%   addl $3*4, %esp // Три четырёхбайтовых числа из стека
%   movl $0,%eax
%   ret    
% \end{lstlisting}
% 
% \vspace{-2\baselineskip}
% \lstset{xleftmargin=12em}
% \terminblue
% \begin{lstlisting}[numbers=none]
% int foo = 13;
% int main(){
%   printf("Переменные: %d %d\n", 
%     19, foo);
%   return 0;
% }
% \end{lstlisting}
% \end{frame}
% 

% *****************************************************************************
\section{}
\begin{frame}{Вопросы}
\setlength{\leftmargini}{0ex}
\setlength{\parskip}{0.25\parskip}
\begin{enumerate}
\item Что включает инструкция на языке ассемблера?

\item Какие команды используются для вызова и~возврата из подпрограмм?

\item Какие вы знаете соглашения о~вызове?

\item Как передаются параметры в~функцию (соглашение cdecl)?

\item Как возвращается значение функции?

\item Какая команда используется для присваивания?

\item Какие команды используются для работы со стеком?

\item Какие команды используются для арифметических вычислений?


\end{enumerate}

\end{frame}

\makethanks
\end{document}
