\input{commonpres}


% \setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
% \setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}
% \setbeamerfont{frametitle}{size=\linespread{1.0}\large}

% \addtobeamertemplate{footnote}{}{\vspace{-30ex}}

% \title{Введение в~язык ассемблера}
% \title{Связь уровней ассемблера и~языка высокого уровня}
\title{Подпрограммы}
\graphicspath{{fig/}{fig/tanenbaum/}{fig/asm-intro/}{fig/model/}}


% \lstset{language={[x86masm]Assembler}}
% \lstset{commentline={\/}}
\lstset{xleftmargin=0mm}
% \lstset{language={[Motorola68k]Assembler}}
% alsolanguage=[
% h
% dialect
% i
% ]
% h
% language
% \lstset{language=C++, alsolanguage=[Motorola68k]Assembler}







\begin{document}
\maketitle



\section{Подпрограммы}
% \section{Вызов и~возврат из подпрограмм}

\subsection{Вызов подпрограммы}
\begin{frame}{\insertsubsection}
\begin{enumerate}
\item Передача параметров
\item {Сохранение адреса возврата}
\item {Передача управления вызываемой подпрограмме}
% \item Выполнение вызываемой подпрограммы
\item Подготовка возвращаемого значения
\item {Возвращение управления вызывающей программе}
\end{enumerate}
\end{frame}

\subsection{Требования}
\begin{frame}{\insertsubsection}
\begin{enumerate}
\item Передача управления на произвольный адрес
\item Возврат управления назад после завершения подпрограммы
\item Вложенные вызовы подпрограмм
\item Сохранение и~восстановление регистров вызывающей программы
\item Передача заданного количества аргументов
\item Передача и~возврат структур
\item Выделение и~освобождение памяти под локальные переменные подпрограмм
\end{enumerate}
\end{frame}


\subsection{Передача и~возврат управления}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{columns}
\lstset{numbers=none}

\begin{column}{0.65\linewidth}
Передача управления в~подпрограмму $label$:

\lstinline!call label!

указатель команд сохраняется в~стеке,
управление передаётся $label$
\end{column}
\begin{column}{0.34\linewidth}
\lstset{xleftmargin=0ex}
\begin{lstlisting}
push %ip
jmp label 
\end{lstlisting}
\end{column}
\end{columns}
\medskip

\begin{columns}
\lstset{numbers=none}

\begin{column}{0.68\linewidth}
Возврат из подпрограммы:

\lstinline!ret!

\lstinline!ret imm!

управление передаётся адресу, снятому со~стека (если указан аргумент $imm$, со~стека затем снимается ещё $imm$ байтов)
\end{column}
\begin{column}{0.31\linewidth}
\begin{lstlisting}
pop %ip
\end{lstlisting}
\end{column}
\end{columns}
\vspace{-1.5\parskip}

\hfill\includegraphics[width=\linewidth,height=0.3\slideheight,keepaspectratio,valign=t]{nested-call}
\centering

\end{frame}


\section{Соглашения о~вызовах}

\subsection{Параметры и~возвращаемое значение}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\setlength{\parskip}{0.25\parskip}
\setlength{\leftmargini}{0.5\leftmargini}

\termin{Соглашение о~вызовах} "--- протокол передачи аргументов:
\vspace{-1\parskip}
\begin{enumerate}
\item способ передачи (через регистры, через стек, смешанный);
\item порядок размещения аргументов (Pascal "--- первый аргумент помещается в~стек первым, C "--- последним);
\item кто очищает стек и~сохраняет/восстанавливает регистры (и~какие);
\item инструкции вызова и возврата (для функций \lstinline!call/ret!);
\item как передаётся указатель this (для ООП).
\end{enumerate}

Возвращаемое значение:
\vspace{-1\parskip}
\begin{enumerate}
\item целое или указатель "--- $A$ ($D:A$);
\item вещественное значение "---  $st(0)$, $xmm0/ymm0/zmm0$.
\end{enumerate}

\end{frame}




\subsection{Соглашения о~вызовах (32 бита)}
\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-1em}
% \footnotesize
\scriptsize
\setlength{\parskip}{0.5\parskip}
\setlength{\leftmargini}{0.5\leftmargini}
\renewcommand\theadfont{\bfseries\tiny}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{c}#1\end{tabular}}}}

% \scriptsize
% \footnotesize


\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|>{\theadfont\scriptsize}M{6em}|>{\footnotesize}l|l|L|%L|
}
\hline
\theadfont Соглашение &\tdhead{Параметры\\в~регистрах}	&\theadlong{Порядок}	&\theadlong{Очистка стека}	\\\hline
\rowcolor{clMarker}
cdecl		&	&	C	&	вызывающая программа	\\\hline
pascal		&	&	Pascal	&	функция			\\\hline
winapi (stdcall)&	&	C	&	функция			\\\hline
gnu		&	&	C	&	this "--- функция, \mbox{остальные "---  вызывающая программа}	\\\hline
gnu fastcall		&	$ecx, edx$	&	C	&	функция	\\\hline
gnu \mbox{regparm(3)}		&	$eax, edx, ecx$	&	C	&	функция	\\\hline
Borland fastcall	&	$ecx, edx$	&	Pascal	&	функция	\\\hline
Microsoft fastcall	&	$ecx, edx$	&	C	&	функция	\\\hline
\end{tabularx}


\footnotesize
\setlength{\parskip}{0.5\parskip}


Изменяемые регистры:
$eax, ecx, edx,$ сопроцессора $st(0){-}st(7),$
\mbox{расширений $xmm/ymm/zmm.$}

Неизменяемые "--- $ebx, ebp$ и~$esi, edi.$

\end{adjustwidth}


% \tiny
% gcc.gnu.org/onlinedocs/gcc-3.4.5/gcc/Function-Attributes.html\\
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.

\end{frame}

\subsection{Соглашения о~вызовах (64 бита)}

\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-1em}

\renewcommand\theadfont{\bfseries\tiny}
\newcommand{\tdhead}[1]{{\theadlong{\begin{tabular}{@{}l@{}}#1\end{tabular}}}}

% \footnotesize
\scriptsize

\renewcommand{\tabularxcolumn}[1]{m{#1}}
\noindent\begin{tabularx}{\linewidth}{|@{~}m{4.2em}@{\,}|L@{}|@{}c@{}|L@{}|L@{}|L@{}|
}
\hline
\theadlong{Соглашение} &\tdhead{Параметры\\в~регистрах}	&\tikz[baseline]\node[rotate=90] {\theadlong{Порядок}};	&\theadlong{Очистка стека}	
&\tdhead{Изменяемые\\регистры}	&	%\tdhead{Неприкосновенные\\регистры}
\tdhead{Неизменяемые\\регистры}
\\\hline
{\theadfont Microsoft Windows} %компиляторы MinGW, Microsoft, Intel	
&	
% $rcx/zmm0,$
% $rdx/zmm1,$
% $r8/zmm2,$
% $r9/zmm3$
\begin{tabular}{@{}>{$}c<{$}@{$/$}>{$}c<{$}@{}}
rcx&zmm0,\\
rdx&zmm1,\\
r8&zmm2,\\
r9&zmm3 \\
\end{tabular}
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$ $r8{-}r11,$ $st(0){-}st(7),$ 
$x/y/zmm,$
кроме младших частей $6{-}15$
&
$rbx, rbp,$ $rsi, rdi,$ $r12{-}r15,$ $xmm6{-}xmm15$
\\\hline
% Unix-подобные (
{\theadfont GNU/Linux, BSD, Mac~OS~X} %компиляторы GCC, Intel	
&	
% $rdi, rsi,$
% $rdx, rcx,$ 
% $r8, r9,$ 
\begin{tabular}{@{}>{$}c<{$}@{$~$}>{$}c<{$}@{}}
rdi,& rsi,\\
rdx,& rcx,\\
r8, & r9,\\
\end{tabular}
$zmm0{-}zmm7$
&	C	&	вызывающая программа	&
$rax, rcx, rdx,$  $rsi, rdi,$ $r8{-}r11,$ $st(0){-}st(7),$ $x/y/zmm$
&
$rbx, rbp,$ $r12{-}r15$ 
\\\hline
\end{tabularx}
\end{adjustwidth}
\end{frame}

% % \section{Вызов подпрограммы в~GAS}
% \subsection{Вызов подпрограммы в~GAS}
% % \begin{frame}[fragile]{\insertsection}
% \begin{frame}[fragile]{\insertsubsection}
% 
% Соглашение о~вызове: Gnu %(cdecl)
% 
% Регистры, значение которых не~должно изменяться подпрограммой:
% \vspace{-1\parskip}
% % \section{Подпрограммы в~GAS}
% % \subsection{Регистры, значение которых не~должно изменяться подпрограммой}
% % \begin{frame}[fragile]{\insertsubsection}
% \begin{enumerate}
% \item\lstinline!%ebx!
% \item\lstinline!%esi!
% \item\lstinline!%edi!
% \item\lstinline!%ebp!
% \item Сегментные регистры \lstinline!%ds, %es! и~\lstinline!%ss!
% % \item Вершина стека \lstinline!%esp! нет
% % \item\lstinline!%r12—%r15! в~64-битном режиме
% \end{enumerate}
% % Прочие могут изменяться подпрограммами.
% \end{frame}
% 
% \subsection{Регистры, значение которых можно изменять}
% \begin{frame}[fragile]{\insertsubsection}
% \begin{enumerate}
% \item\lstinline!%eax! "--- возвращаемое значение (целое до 4 байт или указатель)
% \item\lstinline!%edx! "--- старшие 4 байта возвращаемого значения (long long)
% \end{enumerate}
% \end{frame}



\section{Использование stdlib}


\subsection{Минимальная программа (GAS, stdlib, 32 бита, GNU/Linux)}
\begin{frame}[fragile]{\insertsubsection}
% \def\normalsize{\footnotesize}
\lstset{basicstyle=\ttfamily\footnotesize}
% \footnotesize
\small
\setlength{\parskip}{0.25\parskip}
% [caption=min.S]
\begin{lstlisting}
.globl main // точка входа (stdlib)
main:
     xorl %eax, %eax // A ^= A, то есть A = 0
     ret // return A
\end{lstlisting}
% Сборка (полученный файл a.out включает stdlib и~занимает 4.6 Кб)
% \begin{lstlisting}[language=Bash]
% $ g++ min.S
% \end{lstlisting}
% Сборка с~указанием имени выходного файла:
% \begin{lstlisting}[language=Bash]
% $ g++ -o min min.S
% \end{lstlisting}
% Файл a.out включает stdlib и~занимает 4.6 Кб

% gcc -o nsmin  nsmin.S  -nostdlib
% \begin{lstlisting}
% .globl _start
% _start: // точка входа 
%     movl $1, %eax // системный вызов № 1 — sys_exit
%     xorl %ebx, %ebx // выход с кодом 0
%     int $0x80 // вызов ядра
% \end{lstlisting}

Эквивалент на С++
\begin{lstlisting}
int main(int argc, char* argv[]){
    return 0;
}
\end{lstlisting}


\end{frame}

\subsection{Приветствие}

% \subsection{Приветствие (GAS, GNU/Linux)}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

\begin{lstlisting}
.data
    msg:
    .string "Hello, world!\n"
.global main // точка входа в программу
main:
    pushl $msg	// Адрес строки в стек
    call printf
    popl %eax	// Вычищаем параметр из стека
  
    xorl %eax, %eax
    ret
\end{lstlisting}

\vspace{-2\baselineskip}
\lstset{xleftmargin=14em}
\terminblue
\begin{lstlisting}[numbers=none]
int main(){
    printf("Hello, world!\n");
    return 0;
}
\end{lstlisting}
\end{frame}


\subsection{Форматированный вывод}

% \subsection{Приветствие (GAS, GNU/Linux)}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}

\begin{lstlisting}
.data
fmt: .string "Переменные: %d %d\n"
foo: .int 13
.global main // точка входа в программу
main:
  pushl foo	// Значение foo в стек
  pushl $19	// Значение 19 в стек
  pushl $fmt	// Адрес строки fmt в стек
  call printf
  addl $3*4, %esp // Три четырёхбайтовых числа из стека
  xorl %eax, %eax
  ret    
\end{lstlisting}

\vspace{-2\baselineskip}
\lstset{xleftmargin=12em}
\terminblue
\begin{lstlisting}[numbers=none]
int foo = 13;
int main(){
  printf("Переменные: %d %d\n", 
    19, foo);
  return 0;
}
\end{lstlisting}
\end{frame}



\subsection{Вызов C-функций из ассемблерного модуля}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{columns}
\begin{column}{0.49\linewidth}
unit.cpp
\begin{lstlisting}
/*@\colorbox{codestronghighlight}{extern "C"{}}@*/
int /*@\colorbox{codehighlight}{bar}@*/(int x)
{
    return 3*x+1;
};
\end{lstlisting}
\end{column}
\begin{column}{0.49\linewidth}
Фрагмент main.S (GNU/Linux, BSD)
\begin{lstlisting}
push $1
call /*@\colorbox{codehighlight}{bar}@*/
addl $4, %esp
\end{lstlisting}

% Фрагмент main.S (MS Windows)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{\_bar}@*/
% addl $4, %esp
% \end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\subsection{Описание C-функций на ассемблере}
\begin{frame}[fragile]{\insertsubsection}
\lstset{basicstyle=\ttfamily\footnotesize}
\footnotesize

\begin{columns}
\begin{column}{0.49\linewidth}
sqr.S (GNU/Linux, BSD)
\begin{lstlisting}
/*@\colorbox{codestronghighlight}{.globl sqr}@*/
/*@\colorbox{codehighlight}{sqr:}@*/
  movl 4(%esp), %eax
  imull %eax, %eax
  ret
\end{lstlisting}

% sqr.S \rlap{(... или MS Windows)}
% \begin{lstlisting}
% .globl sqr
% /*@\colorbox{codestronghighlight}{.globl \_sqr}@*/
% sqr:
% /*@\colorbox{codehighlight}{\_sqr:}@*/
%   movl 4(%esp), %eax
%   imull %eax, %eax
%   ret
% \end{lstlisting}
% % \vspace{-4\parskip}

\end{column}
\begin{column}{0.49\linewidth}
main.cpp
\begin{lstlisting}
#include <iostream>

using namespace std;
/*@\colorbox{codestronghighlight}{extern "C"{} int sqr(int x);}@*/

int main()
{
  int x=2, y;
  y = /*@\colorbox{codehighlight}{sqr(x)}@*/;
  cout << y <<endl;
  return 0;
}
\end{lstlisting}
\end{column}
\end{columns}
\vspace{-2\parskip}
% \begin{lstlisting}
% 
% \end{lstlisting}
\end{frame}


\section{Компоновка}


\subsection{Сборка программы}
% \subsection{Декорирование}
\begin{frame}[fragile]{\insertsubsection}

\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=16ex,text badly centered, minimum height=3ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white]

% \node (cpp) {\includegraphics[width=\linewidth,height=\slideheight-1\baselineskip,keepaspectratio,valign=t]{halfcompilecpp}};
\node[file,on chain=cpp] (prog1_cpp) {prog1.cpp};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {Временный файл (stdout)};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {prog1.s};
\node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
\node[file,on chain=cpp] (prog1_o) {prog1.o};
\node[stage,on chain=cpp] (cpp_linker) {Компоновщик};
% \coordinate[on chain=cpp] (cpp_linker);

\node[file, right= of cpp_preprocess,text width=20ex] (cpp_headers) {Заголовочные файлы (\#include)};
\path[blockarrow] (cpp_headers) -- (cpp_preprocess);


% \node[right= of compiler] (mangling) {Декорирование};
\node[text width=18ex] at (compiler-|cpp_headers) (mangling) {Декорирование \lstinline!int foo(int x)! $\to$ \lstinline!_Z3fooi!};

\node[fit=(prog1_cpp) (cpp_headers), inner sep=0ex] (cpp_box) {};
\coordinate[right=0ex of cpp_box] (cpp_egde);


% \node[right= of cpp] (S) {\includegraphics[width=\linewidth,height=\slideheight-1\baselineskip,keepaspectratio,valign=t]{halfcompileS}};
\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {prog2.S};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {Временный файл (stdout)};
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {prog2.o};
\node[stage,on chain=S] (S_linker) {Компоновщик};
% \coordinate[on chain=S] (S_linker);

% \node[file, right= of S_preprocess,text width=20ex] (S_headers) {Заголовочные файлы (\#include)};
% \path[blockarrow] (S_headers) -- (S_preprocess);
\path[blockarrow] (cpp_headers) -- (S_preprocess);

% \path[blockarrow] (cpp_asm) -- (S_asm);

% \path (cpp_linker)
\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  
\node[file, right= of linker,text width=20ex] (obj_lib) {Объектные файлы библиотек};
\path[blockarrow] (obj_lib) -- (linker);

\node[file,below= of linker] (prog) {prog};
\path[blockarrow] (linker) -- (prog);

\node[below= of prog-|cpp_linker]  {extern};

\node[below= of prog-|S_linker]  {.globl};


% \coordinate[above=6ex of cpp.south] (linking_start);

\begin{pgfonlayer}{background}
% %   \coordinate[left=0ex of cpp.south west] (cpp_egde);
% %   \coordinate[right=0ex of S.south east] (S_egde);
%   \node[rectangle,fit=(cpp.south west) (S.south east) (linking_start), inner sep=0ex, minimum height=11.8mm,fill=yellow] (linking) {};
\node[rectangle,fit=(compiler) (mangling), fill=blue!20!white]  {};

\end{pgfonlayer} 

\end{tikzpicture}
}
\centering

\end{frame}


% \subsection{Префиксы и~суффиксы при~отключённом декорировании (\mbox{extern "C"{}})}
% \begin{frame}{\insertsubsection}
% 
% % \includegraphics[width=\linewidth,height=\slideheight-1\baselineskip,keepaspectratio,valign=t]{func-prefix-nomangle}
% % \centering
% \begin{adjustwidth}{-1.8em}{-1.9em}
% 
% \includegraphics[width=0.499\linewidth,height=\slideheight-1\baselineskip,keepaspectratio,valign=t]{func-prefix-nomangle}
% \hfill
% \includegraphics[width=0.499\linewidth,height=\slideheight-1\baselineskip,keepaspectratio,valign=t]{func-suffix-nomangle}
% % \centering
% \end{adjustwidth}
% 
% % \tiny
% Agner Fog.
% Calling conventions
% for different C++ compilers and operating systems.
% 
% \end{frame}


\newcommand{\foocompile}[4]
{
\resizebox{\linewidth}{!}{
\tikzstyle{blockarrow}	= [-latex',thick,draw=blue]
\footnotesize
\begin{tikzpicture}[start chain=cpp going below,start chain=S going below,
every on chain/.style=join,every join/.style=blockarrow,
node distance=2ex and 4ex
]
\tikzstyle{block}	= [text width=22ex,text badly centered, minimum height=4ex, draw=black]
\tikzstyle{file}	= [block,  fill=yellow!40!white]
\tikzstyle{stage}	= [block, fill=blue,text=white, minimum height=3ex]

\node[file,on chain=cpp] (prog1_cpp) {extern "C"\ int foo()};
\node[stage,on chain=cpp] (cpp_preprocess) {Препроцессор};
\node[file, on chain=cpp] (prog1_pp) {extern "C"\ int foo()};
\node[stage,on chain=cpp] (compiler) {Компилятор};
\node[file,on chain=cpp] (prog1_s) {#1};
  
  \ifthenelse{\isempty{#4}}{}{  
  \node[stage,on chain=cpp] (cpp_asm) {Ассемблер};
  \node[file,on chain=cpp] (prog1_o) {#1};
  \node[stage,on chain=cpp] (cpp_linker) {Компоновщик};

  \node[fit=(prog1_cpp), inner sep=0ex] (cpp_box) {};
  \coordinate[right=0ex of cpp_box] (cpp_egde);
  }


\node[file,right= of prog1_cpp-|cpp_egde,on chain=S] (prog2_S) {#2};
\node[stage,on chain=S] (S_preprocess) {Препроцессор};
\node[file, on chain=S] (prog2_pp) {#3};
  \ifthenelse{\isempty{#4}}{}{  
\node[stage,on chain=S,right= of cpp_asm-|cpp_egde]  (S_asm) {Ассемблер};
\node[file,on chain=S] (prog2_o) {#3};
\node[stage,on chain=S] (S_linker) {Компоновщик};

\node[stage,fit=(cpp_linker) (S_linker), inner sep=0ex,align=center] (linker) {\strut

  \vspace{-0.5\baselineskip}Компоновщик};
  

\node[file,below= of linker] (prog) {#4};
\path[blockarrow] (linker) -- (prog);
}
\end{tikzpicture}
}
}


\subsection{Искажение имён компилятором}
% \subsection{Декорирование}
\begin{frame}[fragile]{\insertsubsection}

\begin{adjustwidth}{-1em}{-1em}
\begin{tabularx}{\linewidth}{@{}CC@{}}
GNU/Linux, BSD& Microsoft Windows 32 и~некоторые версии 64\\
\foocompile{foo}{foo}{foo}{Исполняемый файл}
&
\foocompile{\_foo}{foo}{foo}{Ошибка компоновки}
\end{tabularx}
\end{adjustwidth}
\end{frame}



\subsection{Компенсация искажения имён вручную}
% \subsection{Декорирование}
\begin{frame}[fragile]{\insertsubsection}

\footnotesize
\begin{lstlisting}
#ifdef _WIN32
#define FUNC_NAME(s) _##s
#else
#define FUNC_NAME(s) s
#endif 
\end{lstlisting}
\vspace{-1.5\baselineskip}

\begin{adjustwidth}{-1em}{-1em}
\begin{tabularx}{\linewidth}{@{}CC@{}}
GNU/Linux, BSD& Microsoft Windows 32\\
\foocompile{foo}{FUNC\_NAME(foo)}{foo}{}
&
\foocompile{\_foo}{FUNC\_NAME(foo)}{\_foo}{}
\end{tabularx}
\end{adjustwidth}
\end{frame}


% \subsection{Импорт в~C++}
% 
% \subsection{Импорт в~Asm}
% \begin{frame}[fragile]{\insertsubsection}
% \lstset{basicstyle=\ttfamily\footnotesize}
% \footnotesize
% 
% \begin{columns}
% \begin{column}{0.49\linewidth}
% unit.cpp
% \begin{lstlisting}
% /*@\colorbox{codestronghighlight}{extern "C"{}}@*/
% __attribute__((__cdecl__)) 
% int /*@\colorbox{codehighlight}{bar}@*/(int x)
% {
%     return 3*x+1;
% };
% \end{lstlisting}
% \end{column}
% \begin{column}{0.49\linewidth}
% Фрагмент main.S (GNU/Linux, BSD)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{bar}@*/
% addl $4, %esp
% \end{lstlisting}
% 
% Фрагмент main.S (MS Windows)
% \begin{lstlisting}
% push $1
% call /*@\colorbox{codehighlight}{\_bar}@*/
% addl $4, %esp
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}



% *****************************************************************************
\section{}
% \begin{frame}{Вопросы}
% \printquestions
% \end{frame}

\begin{frame}{Вопросы}
% \setlength{\leftmargini}{0ex}
\setlength{\parskip}{0.25\parskip}
\begin{enumerate}

\item Какие команды используются для вызова и~возврата из подпрограмм?

\item Какие вы знаете соглашения о~вызове?

\item Как передаются параметры в~функцию (соглашение cdecl)?
\item Как передаются параметры в~функцию (64-разрядные соглашения)?

\item Как возвращается значение функции?

% \item Каким ключевым словом открывается ассемблерная вставка?
% 
% \item Как из ассемблерной вставки обратиться к~локальным переменным?

% \item Какие вы знаете ограничения на размещение параметров ассемблерных вставок?

\end{enumerate}

\end{frame}

\makethanks
\end{document}
