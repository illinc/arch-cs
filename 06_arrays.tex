\input{commonpres}


% \setbeamertemplate{itemize/enumerate body begin}{\footnotesize}
% \setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}
% \setbeamerfont{frametitle}{size=\linespread{1.0}\large}

% \addtobeamertemplate{footnote}{}{\vspace{-30ex}}

\title{Массивы и~структуры}
\graphicspath{{fig/}}



\begin{document}
\maketitle


\begin{frame}{FPU: вычитание и~деление}
\begin{adjustwidth}{-1em}{-1em}

\def\normalsize{\footnotesize}
\def\theadfont{\scriptsize\bfseries}
\normalsize

\begin{tabularx}{\linewidth}{|l|L|}
% {|K{5em}|L|}
\hline
\thead{Команда} & \thead{Действие}  %& \thead{Флаги} 
\\\hline
add
&	

Сложение (Intel\&GAS)
\hfill $dest := dest + src$
\\\hline
sub
&	
Вычитание
\hfill \onlyIntel{$dest := dest - src$}

% \strut\hfill \onlyGas{$dest :=  src - dest$}
% не всегда

\strut\hfill \onlyGas{Если $src$ и~$dest$ "--- %оба 
регистры, то $dest :=  st(0) - st(i)$}
% 
% Intel\&GAS: 
% 
% если $src$ в~памяти, то $dest$ "--- обязательно $st(0)$: \hfill$st(0) :=  st(0) - src$
\\\hline
subr
&	
Обратное вычитание, уменьшаемое и вычитаемое меняются местами
% 
\strut\hfill \onlyIntel{$dest := src - dest$}

% не всегда
% \strut\hfill \onlyGas{$dest :=  dest -src$}
\strut\hfill \onlyGas{Если $src$ и~$dest$ "--- регистры, то $dest :=  st(i) - st(0)$}
% 
% Intel\&GAS: 
% 
% если $src$ в~памяти, то $dest$ "--- обязательно $st(0)$: \hfill$st(0) :=  src - st(0)$
\\\hline
mul
&	
Умножение (Intel\&GAS)
\hfill $dest := dest \cdot src$
\\\hline
div
&	
Деление
\hfill \onlyIntel{$dest := dest / src$}

% не всегда
% \hfill \onlyGas{$dest := src / dest$}
\strut\hfill \onlyGas{Если $src$ и~$dest$ "--- регистры, то $dest :=  st(0) / st(i)$}
% 
% Intel\&GAS: 
% 
%  если $src$ в~памяти, то $dest$ "--- обязательно $st(0)$: \hfill$st(0) :=  st(0) / src$
\\\hline
divr
&
Обратное деление, делимое и делитель меняются местами

\strut\hfill \onlyIntel{$dest := src / dest$}

% не всегда
% \strut\hfill \onlyGas{$dest := dest / src$}
\strut\hfill \onlyGas{Если $src$ и~$dest$ "--- регистры, то $dest :=  st(i) / st(0)$}
% 
% Intel\&GAS: 
% 
%  если $src$ в~памяти, то $dest$ "--- обязательно $st(0)$: \hfill$st(0) :=  src / st(0)$
\\\hline

\end{tabularx}
\end{adjustwidth}
\end{frame}



\section{Адресация}



\subsection{Формирование адреса}
\begin{frame}{\insertsubsection}
% Виртуальная память "--- плоское адресное пространство "--- адреса линейно возрастают от~0 до~максимального значения.

Адрес в~общем случае 
формируется из четырёх компонент
$$
\text{Адрес} = \text{баз%овый регистр
а} + \alpha \cdot \text{индекс} + \beta
$$
где  база и~индекс "--- регистры, $\alpha$ и~$\beta$ "--- числа, $\alpha = 2^{A}$ (не более $8$)

% \lstinline![base_reg + displacement + offset_reg*scalar_multiplier]! Intel
% \lstinline!displacement(base_reg, offset_reg, scalar_multiplier)!  At&T
GNU Assembler:
$
\beta(\text{баз%овый регистр
а}, \text{индекс}, \alpha)
$
\end{frame}


\section{Обращение к~элементу структуры}

\subsection{Адрес элемента структуры}
\begin{frame}{\insertsubsection}

Адрес элемента структур \lstinline!M[i]!
включает две компоненты: адрес структуры  и~смещение поля
$$
{\&(M[i])} = \&M + \beta
$$
В~GNU Assembler:
$$
\beta(\&M)
$$

\end{frame}
% \definecolor{codestronghighlight}{RGB}{255, 255,120}
% \definecolor{codehighlight}{RGB}{180, 255,180}

\subsection{Обращение к~элементу структуры}
\begin{frame}[fragile]{\insertsubsection}
% \footnotesize
\small
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
struct TSomeStruct
{
    char Tag;
    int  Val;
} s;
asm
(
"movb $'a', (%[S])\n"
"movl $13, 4(%[S])\n"
:
:[S]"r"(&s)
: "memory"
);
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
cout << s.Tag << " " << s.Val << endl;
\end{lstlisting}
\vspace{2em}

\terminblue
Вывод программы
\begin{lstlisting}[numbers=none]
a 13
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\subsection{Выравнивание}
\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-2em}
\footnotesize
\scriptsize
% \tiny

% \hfill
% \parbox{0.5\linewidth}{
% \begin{lstlisting}[numbers=none,xleftmargin=24em]
% 
% 
% 0 4
% 
% 
% 0 1
% 
% 
% 0 4
% \end{lstlisting}
% \vspace{-10\baselineskip}
% 
% \begin{lstlisting}[numbers=none,xleftmargin=-1em]
% struct TSomeStruct{
%     char Tag;    int  Val;
% } s1;
% #pragma pack (push, 1)
% struct TSqueezedStruct{
%     char Tag;    int  Val;
% } s2;
% #pragma pack (pop)
% struct TAnotherStruct{
%     char Tag;    int  Val;
% } s3;
% 
% cout << reinterpret_cast<char *>(&s1.Tag) - reinterpret_cast<char *>(&s1) << " ";
% cout << reinterpret_cast<char *>(&s1.Val) - reinterpret_cast<char *>(&s1) << endl;
% 
% cout << reinterpret_cast<char *>(&s2.Tag) - reinterpret_cast<char *>(&s2) << " ";
% cout << reinterpret_cast<char *>(&s2.Val) - reinterpret_cast<char *>(&s2) << endl;
% 
% cout << reinterpret_cast<char *>(&s3.Tag) - reinterpret_cast<char *>(&s3) << " ";
% cout << reinterpret_cast<char *>(&s3.Val) - reinterpret_cast<char *>(&s3) << endl;
% \end{lstlisting}
\lstset{language=C++}

\begin{lstlisting}
const int N = 10;
struct TSomeStruct{
    char Tag;    int  Val;
} s1, a1[N];
#pragma pack (push, 1)
struct TSqueezedStruct{
    char Tag;    int  Val;
} s2, a2[N];
#pragma pack (pop)
struct TAnotherStruct{
    char Tag;    int  Val;
} s3, a3[N];
TSqueezedStruct s20, a20[N];

#define PRINT(I) cout << reinterpret_cast<char *>(&s##I.Tag) - reinterpret_cast<char *>(&s##I) << " " \
 << reinterpret_cast<char *>(&s##I.Val) - reinterpret_cast<char *>(&s##I) \
 << " "<< sizeof(s##I) << " " << sizeof(a##I) << endl;
\end{lstlisting}
\vspace{-13\baselineskip}
\begin{lstlisting}[firstnumber=last,xleftmargin=24em]
PRINT(1)	// 0 4 8 80
PRINT(2)	// 0 1 5 50
PRINT(3)	// 0 4 8 80
PRINT(20)	// 0 1 5 50
\end{lstlisting}
\vspace{+8\baselineskip}
% \vfill
% 
% \strut

\end{adjustwidth}
\end{frame}


\subsection{Модификаторы параметров}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize

% \begin{tabularx}{1\linewidth}{lL}
z "--- Печать суффикса команда для размера операнда \\
c "--- Печать константы без префикса \lstinline!$! \\
b "--- Печать имени младшего байта регистра\\ (\lstinline!%al! для регистра $a$) \\
h "--- Печать имени старшего байта младшего слова регистра\\ (\lstinline!%ah! для регистра $a$) \\
w "--- Печать имени младшего слова регистра \\(\lstinline!%ax! для регистра $a$) \\
k "--- Печать имени младшего двойного слова регистра \\(\lstinline!%eax! для регистра $a$) \\
q "--- Печать 64-битного варианта имени регистра \\(\lstinline!%rax! для регистра $a$)
% \end{tabularx}

% Modifier 	Description 	Operand 	masm=att 	masm=intel
% z 	Print the opcode suffix for the size of the current integer operand (one of b/w/l/q). 	%z0 	l 	
% b 	Print the QImode name of the register. 	%b0 	%al 	al
% h 	Print the QImode name for a “high” register. 	%h0 	%ah 	ah
% w 	Print the HImode name of the register. 	%w0 	%ax 	ax
% k 	Print the SImode name of the register. 	%k0 	%eax 	eax
% q 	Print the DImode name of the register. 	%q0 	%rax 	rax
% l 	Print the label name with no punctuation. 	%l2 	.L2 	.L2
% c 	Require a constant operand and print the constant expression with no punctuation. 	%c1 	2 	
\end{frame}

\subsection{Обращение к~элементу структуры (переносимый код)}
\begin{frame}[fragile]{\insertsubsection}
\begin{adjustwidth}{-1em}{-2em}
\footnotesize
\scriptsize
% \begin{columns}
% \begin{column}{0.50\linewidth}
\begin{lstlisting}
struct TSomeStruct
{
    char Tag;
    int  Val;
} s;
asm
(
"movb $'a', %c[tag_disp](%[S])\n"
"movl $13,  %c[val_disp](%[S])\n"
:
:[S]"r"(&s),
 [tag_disp]"i"(reinterpret_cast<char *>(&s.Tag) 
    - reinterpret_cast<char *>(&s)),
 [val_disp]"i"(reinterpret_cast<char *>(&s.Val) 
    - reinterpret_cast<char *>(&s))
: "memory"
);
\end{lstlisting}
\end{adjustwidth}
% \end{column}
% \begin{column}{0.499\linewidth}
% \begin{lstlisting}[firstnumber=last]
% cout << s.Tag << " " << s.Val << endl;
% \end{lstlisting}
% \vspace{2em}
% 
% \terminblue
% Вывод программы
% \begin{lstlisting}[numbers=none]
% a 13
% \end{lstlisting}
% \end{column}
% \end{columns}
\end{frame}

% \subsection{Обращение к~элементу структуры (переносимый код)}
% \begin{frame}[fragile]{\insertsubsection}
% \begin{adjustwidth}{-1em}{-2em}
% \scriptsize
% 
% \begin{lstlisting}
% struct TSomeStruct
% {
%     char Tag;
%     int  Val;
% } s;
% asm
% (
% "movb $'a', %c[tag_disp](%[S])\n"
% "movl $13,  %c[val_disp](%[S])\n"
% :
% :[S]"r"(&s),
%  [tag_disp]"i"(reinterpret_cast<char *>(&s.Tag) - reinterpret_cast<char *>(&s)),
%  [val_disp]"i"(reinterpret_cast<char *>(&s.Val) - reinterpret_cast<char *>(&s))
% : "memory"
% );
% \end{lstlisting}
% \end{adjustwidth}
% \end{frame}


\section{Обращение к~элементу массива}

\subsection{Адрес элемента массива}
\begin{frame}{\insertsubsection}
\small

Адрес элемента массива \lstinline!M[i]!
включает три компоненты, одна из которых "--- постоянный размер элемента \rlap{$sizeof(M[0])$.}
$$
{\&(M[i])} = \&M + sizeof(M[0]) \cdot i
$$
% то есть 
адрес начала массива "---  база, индекс элемента "--- смещение.

Если размер элемента 1, 2, 4 или 8 байт
% , можно рассчитать адрес элемента непосредственно при обращении, как 
$$
(\&M, i, sizeof(M[0]))
$$

\end{frame}

\subsection{Элемент размера 1 байт}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
int i, x;
char M[N];
asm
(
  "movb $'a', %b[X]\n"
  "xorl %[I], %[I]\n"
"begin_iteration:\n"
  "cmpl %[M_len], %[I]\n"
  "jge end_loop\n"
  "movb %b[X], (%[M],%[I])\n"
  "incb %b[X]\n"
  "incl %[I]\n"
  "jmp begin_iteration\n"
"end_loop:\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[I]"=&r"(i), [X]"=&q"(x)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\begin{lstlisting}[numbers=none]
a b c d e f g h 
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\subsection{Элемент размера 1, 2, 4 или 8 байт}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
int M[N], i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"cmpl %[M_len], %[I]\n"
"jge end_loop\n"
"movl $0, (%[M],%[I],4)\n"
"incl %[I]\n"
"jmp begin_iteration\n"
"end_loop:\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M)
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\begin{lstlisting}[numbers=none]
0 0 0 0 0 0 0 0 
\end{lstlisting}

\end{column}
\end{columns}
\end{frame}

\subsection{Элемент размера 1, 2, 4 или 8 байт (изменяемый)}
\begin{frame}[fragile]{\insertsubsection}
\footnotesize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
short M[N];
int i;
asm
(
"xorl %[I], %[I]\n"
"begin_iteration:\n"
"cmpl %[M_len], %[I]\n"
"jge end_loop\n"
"mov%z[el_type] $0, (%[M],%[I],%c[el_size])\n"
"incl %[I]\n"
"jmp begin_iteration\n"
"end_loop:\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[I]"=&r"(i)
:[M_len]"i"(N), [M]"r"(M), 
[el_size]"i"(sizeof(M[0])), 
[el_type]"m"(M[0])
: "cc","memory"
);
for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\begin{lstlisting}[numbers=none]
0 0 0 0 0 0 0 0 
\end{lstlisting}

\end{column}
\end{columns}
\end{frame}

% const int N = 8;
% int i;
% double M[N];
% asm
% (
% "xorl %[I], %[I]\n"
% "begin_iteration:\n"
% "cmpl %[M_len], %[I]\n"
% "jge end_loop\n"
% "movl $0, (%[M],%[I],%c[el_size])\n"
% "movl $0, 4(%[M],%[I],%c[el_size])\n"
% "incl %[I]\n"
% "jmp begin_iteration\n"
% "end_loop:\n"
% :[I]"=r"(i)
% :[M_len]"i"(N), [M]"r"(M), "[I]"(i), [el_size]"i"(sizeof(M[0]))
% : "cc","memory"
% );
  
\subsection{Элемент произвольного размера}
\begin{frame}[fragile]{\insertsubsection}
% \footnotesize
\scriptsize
\begin{columns}
\begin{column}{0.50\linewidth}
\begin{lstlisting}
const int N = 8;
int i;
long double M[N], *p;
asm
(
"movl %[M_len], %[rev_idx]\n"
"movl %[M],     %[el_addr]\n"
"begin_iteration:\n"
"fldpi\n"
"fstpt (%[el_addr])\n"
"addl %[el_size], %[el_addr]\n"
"decl %[rev_idx]\n"
"jnz begin_iteration\n"
\end{lstlisting}
\end{column}
\begin{column}{0.499\linewidth}
\begin{lstlisting}[firstnumber=last]
:[rev_idx]"=&r"(i), [el_addr]"=&r"(p)
:[M_len]"i"(N), [M]"r"(M), [el_size]"i"(sizeof(M[0]))
: "cc","memory"
);

for(i = 0; i < N; ++i)
{
    cout << M[i] << " ";
}
cout << endl;
\end{lstlisting}

\scriptsize
\begin{lstlisting}[numbers=none]
3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 3.14159 
\end{lstlisting}

\end{column}
\end{columns}

\end{frame}
  \section{}
\begin{frame}{Вопросы}
\begin{enumerate}

\item Из каких компонент формируется эффективный адрес в~x86?

\item Как расположены в памяти элементы структуры?
\item Что такое выравнивание?
\item Какие вы знаете модификаторы параметров в~GAS?

\item Как расположены в памяти элементы массива?

\end{enumerate}

\end{frame}  
\makethanks
\end{document}
